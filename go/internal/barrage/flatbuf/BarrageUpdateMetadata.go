// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package flatbuf

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// A data header describing the shared memory layout of a "record" or "row"
/// batch for a ticking barrage table.
type BarrageUpdateMetadata struct {
	_tab flatbuffers.Table
}

func GetRootAsBarrageUpdateMetadata(buf []byte, offset flatbuffers.UOffsetT) *BarrageUpdateMetadata {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &BarrageUpdateMetadata{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *BarrageUpdateMetadata) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *BarrageUpdateMetadata) Table() flatbuffers.Table {
	return rcv._tab
}

/// The number of record batches that describe rows added (may be zero).
func (rcv *BarrageUpdateMetadata) NumAddBatches() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// The number of record batches that describe rows added (may be zero).
func (rcv *BarrageUpdateMetadata) MutateNumAddBatches(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

/// The number of record batches that describe rows modified (may be zero).
func (rcv *BarrageUpdateMetadata) NumModBatches() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// The number of record batches that describe rows modified (may be zero).
func (rcv *BarrageUpdateMetadata) MutateNumModBatches(n int64) bool {
	return rcv._tab.MutateInt64Slot(6, n)
}

/// This batch is generated from an upstream table that ticks independently of the stream. If
/// multiple events are coalesced into one update, the server may communicate that here for
/// informational purposes.
func (rcv *BarrageUpdateMetadata) FirstSeq() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

/// This batch is generated from an upstream table that ticks independently of the stream. If
/// multiple events are coalesced into one update, the server may communicate that here for
/// informational purposes.
func (rcv *BarrageUpdateMetadata) MutateFirstSeq(n int64) bool {
	return rcv._tab.MutateInt64Slot(8, n)
}

func (rcv *BarrageUpdateMetadata) LastSeq() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *BarrageUpdateMetadata) MutateLastSeq(n int64) bool {
	return rcv._tab.MutateInt64Slot(10, n)
}

/// Indicates if this message was sent due to upstream ticks or due to a subscription change.
func (rcv *BarrageUpdateMetadata) IsSnapshot() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// Indicates if this message was sent due to upstream ticks or due to a subscription change.
func (rcv *BarrageUpdateMetadata) MutateIsSnapshot(n bool) bool {
	return rcv._tab.MutateBoolSlot(12, n)
}

/// If this is a snapshot and the subscription is a viewport, then the effectively subscribed viewport
/// will be included in the payload. It is an encoded and compressed RowSet.
func (rcv *BarrageUpdateMetadata) EffectiveViewport(j int) int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *BarrageUpdateMetadata) EffectiveViewportLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// If this is a snapshot and the subscription is a viewport, then the effectively subscribed viewport
/// will be included in the payload. It is an encoded and compressed RowSet.
func (rcv *BarrageUpdateMetadata) MutateEffectiveViewport(j int, n int8) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt8(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

/// If this is a snapshot, then the effectively subscribed column set will be included in the payload.
func (rcv *BarrageUpdateMetadata) EffectiveColumnSet(j int) int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *BarrageUpdateMetadata) EffectiveColumnSetLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// If this is a snapshot, then the effectively subscribed column set will be included in the payload.
func (rcv *BarrageUpdateMetadata) MutateEffectiveColumnSet(j int, n int8) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt8(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

/// This is an encoded and compressed RowSet that was added in this update.
func (rcv *BarrageUpdateMetadata) AddedRows(j int) int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *BarrageUpdateMetadata) AddedRowsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// This is an encoded and compressed RowSet that was added in this update.
func (rcv *BarrageUpdateMetadata) MutateAddedRows(j int, n int8) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt8(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

/// This is an encoded and compressed RowSet that was removed in this update.
func (rcv *BarrageUpdateMetadata) RemovedRows(j int) int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *BarrageUpdateMetadata) RemovedRowsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// This is an encoded and compressed RowSet that was removed in this update.
func (rcv *BarrageUpdateMetadata) MutateRemovedRows(j int, n int8) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt8(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

/// This is an encoded and compressed RowSetShiftData describing how the keyspace of unmodified rows changed.
func (rcv *BarrageUpdateMetadata) ShiftData(j int) int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *BarrageUpdateMetadata) ShiftDataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// This is an encoded and compressed RowSetShiftData describing how the keyspace of unmodified rows changed.
func (rcv *BarrageUpdateMetadata) MutateShiftData(j int, n int8) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt8(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

/// This is an encoded and compressed RowSet that was included with this update.
/// (the server may include rows not in addedRows if this is a viewport subscription to refresh
///  unmodified rows that were scoped into view)
func (rcv *BarrageUpdateMetadata) AddedRowsIncluded(j int) int8 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetInt8(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *BarrageUpdateMetadata) AddedRowsIncludedLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// This is an encoded and compressed RowSet that was included with this update.
/// (the server may include rows not in addedRows if this is a viewport subscription to refresh
///  unmodified rows that were scoped into view)
func (rcv *BarrageUpdateMetadata) MutateAddedRowsIncluded(j int, n int8) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateInt8(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

/// The list of modified column data are in the same order as the field nodes on the schema.
func (rcv *BarrageUpdateMetadata) ModColumnNodes(obj *BarrageModColumnMetadata, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *BarrageUpdateMetadata) ModColumnNodesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// The list of modified column data are in the same order as the field nodes on the schema.
/// When this is set the viewport RowSet will be inverted against the length of the table. That is to say
/// every position value is converted from `i` to `n - i - 1` if the table has `n` rows.
func (rcv *BarrageUpdateMetadata) EffectiveReverseViewport() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// When this is set the viewport RowSet will be inverted against the length of the table. That is to say
/// every position value is converted from `i` to `n - i - 1` if the table has `n` rows.
func (rcv *BarrageUpdateMetadata) MutateEffectiveReverseViewport(n bool) bool {
	return rcv._tab.MutateBoolSlot(28, n)
}

func BarrageUpdateMetadataStart(builder *flatbuffers.Builder) {
	builder.StartObject(13)
}
func BarrageUpdateMetadataAddNumAddBatches(builder *flatbuffers.Builder, numAddBatches int64) {
	builder.PrependInt64Slot(0, numAddBatches, 0)
}
func BarrageUpdateMetadataAddNumModBatches(builder *flatbuffers.Builder, numModBatches int64) {
	builder.PrependInt64Slot(1, numModBatches, 0)
}
func BarrageUpdateMetadataAddFirstSeq(builder *flatbuffers.Builder, firstSeq int64) {
	builder.PrependInt64Slot(2, firstSeq, 0)
}
func BarrageUpdateMetadataAddLastSeq(builder *flatbuffers.Builder, lastSeq int64) {
	builder.PrependInt64Slot(3, lastSeq, 0)
}
func BarrageUpdateMetadataAddIsSnapshot(builder *flatbuffers.Builder, isSnapshot bool) {
	builder.PrependBoolSlot(4, isSnapshot, false)
}
func BarrageUpdateMetadataAddEffectiveViewport(builder *flatbuffers.Builder, effectiveViewport flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(effectiveViewport), 0)
}
func BarrageUpdateMetadataStartEffectiveViewportVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func BarrageUpdateMetadataAddEffectiveColumnSet(builder *flatbuffers.Builder, effectiveColumnSet flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(effectiveColumnSet), 0)
}
func BarrageUpdateMetadataStartEffectiveColumnSetVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func BarrageUpdateMetadataAddAddedRows(builder *flatbuffers.Builder, addedRows flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(addedRows), 0)
}
func BarrageUpdateMetadataStartAddedRowsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func BarrageUpdateMetadataAddRemovedRows(builder *flatbuffers.Builder, removedRows flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(removedRows), 0)
}
func BarrageUpdateMetadataStartRemovedRowsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func BarrageUpdateMetadataAddShiftData(builder *flatbuffers.Builder, shiftData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(shiftData), 0)
}
func BarrageUpdateMetadataStartShiftDataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func BarrageUpdateMetadataAddAddedRowsIncluded(builder *flatbuffers.Builder, addedRowsIncluded flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(addedRowsIncluded), 0)
}
func BarrageUpdateMetadataStartAddedRowsIncludedVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func BarrageUpdateMetadataAddModColumnNodes(builder *flatbuffers.Builder, modColumnNodes flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(11, flatbuffers.UOffsetT(modColumnNodes), 0)
}
func BarrageUpdateMetadataStartModColumnNodesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func BarrageUpdateMetadataAddEffectiveReverseViewport(builder *flatbuffers.Builder, effectiveReverseViewport bool) {
	builder.PrependBoolSlot(12, effectiveReverseViewport, false)
}
func BarrageUpdateMetadataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
