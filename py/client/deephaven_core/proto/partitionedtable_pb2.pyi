"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file

Copyright (c) 2016-2021 Deephaven Data Labs and Patent Pending
"""

import builtins
import collections.abc
import deephaven_core.proto.ticket_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class PartitionByRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TABLE_ID_FIELD_NUMBER: builtins.int
    RESULT_ID_FIELD_NUMBER: builtins.int
    KEY_COLUMN_NAMES_FIELD_NUMBER: builtins.int
    DROP_KEYS_FIELD_NUMBER: builtins.int
    drop_keys: builtins.bool
    @property
    def table_id(self) -> deephaven_core.proto.ticket_pb2.Ticket: ...
    @property
    def result_id(self) -> deephaven_core.proto.ticket_pb2.Ticket: ...
    @property
    def key_column_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]: ...
    def __init__(
        self,
        *,
        table_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        result_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        key_column_names: collections.abc.Iterable[builtins.str] | None = ...,
        drop_keys: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["result_id", b"result_id", "table_id", b"table_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["drop_keys", b"drop_keys", "key_column_names", b"key_column_names", "result_id", b"result_id", "table_id", b"table_id"]) -> None: ...

global___PartitionByRequest = PartitionByRequest

@typing.final
class PartitionByResponse(google.protobuf.message.Message):
    """Deliberately empty response, use /ObjectService/FetchObject to read the object by ticket."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___PartitionByResponse = PartitionByResponse

@typing.final
class MergeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    PARTITIONED_TABLE_FIELD_NUMBER: builtins.int
    RESULT_ID_FIELD_NUMBER: builtins.int
    @property
    def partitioned_table(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """The ticket for the PartitionedTable object to merge."""

    @property
    def result_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """The ticket to use to hold the results of the merge operation."""

    def __init__(
        self,
        *,
        partitioned_table: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        result_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["partitioned_table", b"partitioned_table", "result_id", b"result_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["partitioned_table", b"partitioned_table", "result_id", b"result_id"]) -> None: ...

global___MergeRequest = MergeRequest

@typing.final
class GetTableRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _UniqueBehavior:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _UniqueBehaviorEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[GetTableRequest._UniqueBehavior.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        NOT_SET_UNIQUE_BEHAVIOR: GetTableRequest._UniqueBehavior.ValueType  # 0
        """The behavior is unset, in which case we default to requiring unique results."""
        REQUIRE_UNIQUE_RESULTS_STATIC_SINGLE_KEY: GetTableRequest._UniqueBehavior.ValueType  # 1
        """Only one key is permitted, the key table is snapshot if not static, and the resulting partitioned table must have exactly one key."""
        PERMIT_MULTIPLE_KEYS: GetTableRequest._UniqueBehavior.ValueType  # 2
        """Merge results from multiple (or zero keys)."""

    class UniqueBehavior(_UniqueBehavior, metaclass=_UniqueBehaviorEnumTypeWrapper): ...
    NOT_SET_UNIQUE_BEHAVIOR: GetTableRequest.UniqueBehavior.ValueType  # 0
    """The behavior is unset, in which case we default to requiring unique results."""
    REQUIRE_UNIQUE_RESULTS_STATIC_SINGLE_KEY: GetTableRequest.UniqueBehavior.ValueType  # 1
    """Only one key is permitted, the key table is snapshot if not static, and the resulting partitioned table must have exactly one key."""
    PERMIT_MULTIPLE_KEYS: GetTableRequest.UniqueBehavior.ValueType  # 2
    """Merge results from multiple (or zero keys)."""

    PARTITIONED_TABLE_FIELD_NUMBER: builtins.int
    KEY_TABLE_TICKET_FIELD_NUMBER: builtins.int
    RESULT_ID_FIELD_NUMBER: builtins.int
    UNIQUE_BEHAVIOR_FIELD_NUMBER: builtins.int
    unique_behavior: global___GetTableRequest.UniqueBehavior.ValueType
    """The behavior for handling result Tables that do not have a unique result."""
    @property
    def partitioned_table(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """The ticket for the PartitionedTable object to query."""

    @property
    def key_table_ticket(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """The ticket for the table containing the key to fetch from the partitioned table."""

    @property
    def result_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """The ticket to use to hold the newly returned table."""

    def __init__(
        self,
        *,
        partitioned_table: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        key_table_ticket: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        result_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        unique_behavior: global___GetTableRequest.UniqueBehavior.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["key_table_ticket", b"key_table_ticket", "partitioned_table", b"partitioned_table", "result_id", b"result_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["key_table_ticket", b"key_table_ticket", "partitioned_table", b"partitioned_table", "result_id", b"result_id", "unique_behavior", b"unique_behavior"]) -> None: ...

global___GetTableRequest = GetTableRequest

@typing.final
class PartitionedTableDescriptor(google.protobuf.message.Message):
    """
    A message that describes a partitioned table, able to be sent as a plugin object to a client.
    This object will also come with a ticket to the underlying table that can be used to get the
    constituent tables by key.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_COLUMN_NAMES_FIELD_NUMBER: builtins.int
    CONSTITUENT_COLUMN_NAME_FIELD_NUMBER: builtins.int
    UNIQUE_KEYS_FIELD_NUMBER: builtins.int
    CONSTITUENT_DEFINITION_SCHEMA_FIELD_NUMBER: builtins.int
    CONSTITUENT_CHANGES_PERMITTED_FIELD_NUMBER: builtins.int
    constituent_column_name: builtins.str
    """The name of the column in the underlying table that contains the table represented by that row."""
    unique_keys: builtins.bool
    """True if the keys will be unique, so any set of known keys can be queried using GetTable."""
    constituent_definition_schema: builtins.bytes
    """Returns a flight Messsage wrapping a Schema that will describe every table contained in this
    PartitionedTable.
    """
    constituent_changes_permitted: builtins.bool
    """True if the underlying table may tick with updates. See PartitionedTable.constituentChangesPermitted()
    for more details.
    """
    @property
    def key_column_names(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The names of the key columns. The underlying table will contain these columns - a client can
        subscribe to these columns to see what keys are present.
        """

    def __init__(
        self,
        *,
        key_column_names: collections.abc.Iterable[builtins.str] | None = ...,
        constituent_column_name: builtins.str = ...,
        unique_keys: builtins.bool = ...,
        constituent_definition_schema: builtins.bytes = ...,
        constituent_changes_permitted: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["constituent_changes_permitted", b"constituent_changes_permitted", "constituent_column_name", b"constituent_column_name", "constituent_definition_schema", b"constituent_definition_schema", "key_column_names", b"key_column_names", "unique_keys", b"unique_keys"]) -> None: ...

global___PartitionedTableDescriptor = PartitionedTableDescriptor
