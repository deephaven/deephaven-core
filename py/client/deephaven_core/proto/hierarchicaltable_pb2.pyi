"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file

Copyright (c) 2016-2021 Deephaven Data Labs and Patent Pending
"""

import builtins
import collections.abc
import deephaven_core.proto.table_pb2
import deephaven_core.proto.ticket_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _RollupNodeType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _RollupNodeTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RollupNodeType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    TYPE_NOT_SPECIFIED: _RollupNodeType.ValueType  # 0
    AGGREGATED: _RollupNodeType.ValueType  # 1
    CONSTITUENT: _RollupNodeType.ValueType  # 2

class RollupNodeType(_RollupNodeType, metaclass=_RollupNodeTypeEnumTypeWrapper): ...

TYPE_NOT_SPECIFIED: RollupNodeType.ValueType  # 0
AGGREGATED: RollupNodeType.ValueType  # 1
CONSTITUENT: RollupNodeType.ValueType  # 2
global___RollupNodeType = RollupNodeType

@typing.final
class RollupRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESULT_ROLLUP_TABLE_ID_FIELD_NUMBER: builtins.int
    SOURCE_TABLE_ID_FIELD_NUMBER: builtins.int
    AGGREGATIONS_FIELD_NUMBER: builtins.int
    INCLUDE_CONSTITUENTS_FIELD_NUMBER: builtins.int
    GROUP_BY_COLUMNS_FIELD_NUMBER: builtins.int
    include_constituents: builtins.bool
    """Whether to include the leaf-level constituents in the result"""
    @property
    def result_rollup_table_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """Ticket to use to hold the result RollupTable from the rollup operation"""

    @property
    def source_table_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """Ticket for the source Table to rollup"""

    @property
    def aggregations(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[deephaven_core.proto.table_pb2.Aggregation]:
        """The aggregations that should be applied at each level of the rollup"""

    @property
    def group_by_columns(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """The names of the columns to rollup by"""

    def __init__(
        self,
        *,
        result_rollup_table_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        source_table_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        aggregations: collections.abc.Iterable[deephaven_core.proto.table_pb2.Aggregation] | None = ...,
        include_constituents: builtins.bool = ...,
        group_by_columns: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["result_rollup_table_id", b"result_rollup_table_id", "source_table_id", b"source_table_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregations", b"aggregations", "group_by_columns", b"group_by_columns", "include_constituents", b"include_constituents", "result_rollup_table_id", b"result_rollup_table_id", "source_table_id", b"source_table_id"]) -> None: ...

global___RollupRequest = RollupRequest

@typing.final
class RollupResponse(google.protobuf.message.Message):
    """Deliberately empty response, use /ObjectService/FetchObject to access the result_rollup_table_id ticket as
    a HierarchicalTableDescriptor. See HierarchicalTableDescriptor documentation for details.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___RollupResponse = RollupResponse

@typing.final
class TreeRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESULT_TREE_TABLE_ID_FIELD_NUMBER: builtins.int
    SOURCE_TABLE_ID_FIELD_NUMBER: builtins.int
    IDENTIFIER_COLUMN_FIELD_NUMBER: builtins.int
    PARENT_IDENTIFIER_COLUMN_FIELD_NUMBER: builtins.int
    PROMOTE_ORPHANS_FIELD_NUMBER: builtins.int
    identifier_column: builtins.str
    """The name of the column containing the unique identifier for each row in the source table"""
    parent_identifier_column: builtins.str
    """The name of the column containing the parent row's unique identifier for each row in the source table"""
    promote_orphans: builtins.bool
    """Whether to promote "orphaned" nodes to be children of the root node. Orphans are nodes whose parent identifiers do
    not occur as identifiers for any row in the source Table.
    """
    @property
    def result_tree_table_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """Ticket to use to hold the result TreeTable from the tree operation"""

    @property
    def source_table_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """Ticket for the source Table to tree"""

    def __init__(
        self,
        *,
        result_tree_table_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        source_table_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        identifier_column: builtins.str = ...,
        parent_identifier_column: builtins.str = ...,
        promote_orphans: builtins.bool = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["result_tree_table_id", b"result_tree_table_id", "source_table_id", b"source_table_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["identifier_column", b"identifier_column", "parent_identifier_column", b"parent_identifier_column", "promote_orphans", b"promote_orphans", "result_tree_table_id", b"result_tree_table_id", "source_table_id", b"source_table_id"]) -> None: ...

global___TreeRequest = TreeRequest

@typing.final
class TreeResponse(google.protobuf.message.Message):
    """Deliberately empty response, use /ObjectService/FetchObject to access the result_tree_table_id ticket as
    a HierarchicalTableDescriptor. See HierarchicalTableDescriptor documentation for details.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___TreeResponse = TreeResponse

@typing.final
class UpdateViewRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COLUMN_SPEC_FIELD_NUMBER: builtins.int
    NODE_TYPE_FIELD_NUMBER: builtins.int
    node_type: global___RollupNodeType.ValueType
    """The node types that will have this update_view applied. Ignored for TreeTable."""
    @property
    def column_spec(self) -> deephaven_core.proto.table_pb2.Selectable: ...
    def __init__(
        self,
        *,
        column_spec: deephaven_core.proto.table_pb2.Selectable | None = ...,
        node_type: global___RollupNodeType.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["column_spec", b"column_spec"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["column_spec", b"column_spec", "node_type", b"node_type"]) -> None: ...

global___UpdateViewRequest = UpdateViewRequest

@typing.final
class HierarchicalTableApplyRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESULT_HIERARCHICAL_TABLE_ID_FIELD_NUMBER: builtins.int
    INPUT_HIERARCHICAL_TABLE_ID_FIELD_NUMBER: builtins.int
    FILTERS_FIELD_NUMBER: builtins.int
    SORTS_FIELD_NUMBER: builtins.int
    FORMAT_VIEWS_FIELD_NUMBER: builtins.int
    UPDATE_VIEWS_FIELD_NUMBER: builtins.int
    @property
    def result_hierarchical_table_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """Ticket to use to hold the result HierarchicalTable (RollupTable or TreeTable) from the applying the operations"""

    @property
    def input_hierarchical_table_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """Ticket for the input HierarchicalTable (RollupTable or TreeTable) to apply operations to"""

    @property
    def filters(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[deephaven_core.proto.table_pb2.Condition]:
        """Filters to apply to the input HierarchicalTable to produce the result HierarchicalTable. Never expressed against
        the "structural" columns included in the a HierarchicalTableDescriptor's snapshot_schema.
        For RollupTables, only the group-by columns may be filtered. The names are always expressed as they appear
        in aggregated node columns (and in the group-by columns). The filtering will result in a complete or partial
        new Table.rollup operation.
        For TreeTables, these may be variously applied to the source (resulting in a new Table.tree operation) or to the
        nodes (resulting in filtering at snapshot time).
        """

    @property
    def sorts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[deephaven_core.proto.table_pb2.SortDescriptor]:
        """Sorts to apply to the input HierarchicalTable to produce the result HierarchicalTable. Never expressed against
        the "structural" columns included in the a HierarchicalTableDescriptor's snapshot_schema.
        For TreeTables, these are simply applied to the nodes at snapshot time.
        For RollupTables, these are expressed against the aggregated, constituent or updateView node columns. The
        appropriate sorts are applied to the nodes at snapshot time.
        """

    @property
    def format_views(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___UpdateViewRequest]:
        """Format operations to apply to the nodes of the table.
        For RollupTables, the update is applied only to the specified node types.
        For TreeTables, the node type is ignored and the update is applied to all nodes.
        """

    @property
    def update_views(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___UpdateViewRequest]:
        """User-supplied update_view operations to apply to the nodes of the table.
        For RollupTables, the update is applied only to the specified node types.
        For TreeTables, the node type is ignored and the update is applied to all nodes.
        """

    def __init__(
        self,
        *,
        result_hierarchical_table_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        input_hierarchical_table_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        filters: collections.abc.Iterable[deephaven_core.proto.table_pb2.Condition] | None = ...,
        sorts: collections.abc.Iterable[deephaven_core.proto.table_pb2.SortDescriptor] | None = ...,
        format_views: collections.abc.Iterable[global___UpdateViewRequest] | None = ...,
        update_views: collections.abc.Iterable[global___UpdateViewRequest] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["input_hierarchical_table_id", b"input_hierarchical_table_id", "result_hierarchical_table_id", b"result_hierarchical_table_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["filters", b"filters", "format_views", b"format_views", "input_hierarchical_table_id", b"input_hierarchical_table_id", "result_hierarchical_table_id", b"result_hierarchical_table_id", "sorts", b"sorts", "update_views", b"update_views"]) -> None: ...

global___HierarchicalTableApplyRequest = HierarchicalTableApplyRequest

@typing.final
class HierarchicalTableApplyResponse(google.protobuf.message.Message):
    """Deliberately empty response, use /ObjectService/FetchObject to access the result_hierarchical_table_id ticket as
    a HierarchicalTableDescriptor. See HierarchicalTableDescriptor documentation for details.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___HierarchicalTableApplyResponse = HierarchicalTableApplyResponse

@typing.final
class HierarchicalTableDescriptor(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SNAPSHOT_SCHEMA_FIELD_NUMBER: builtins.int
    IS_STATIC_FIELD_NUMBER: builtins.int
    snapshot_schema: builtins.bytes
    """Schema to be used for snapshot or subscription requests as described in Arrow Message.fbs::Message.
    Field metadata is used to convey additional information about the structure of the HierarchicalTable, the
    special roles some columns play, and the relationships between columns.

    "hierarchicalTable.isStructuralColumn" is always "true" if set, and is set on columns that should be included on
    every snapshot or subscription request, but should not be directly user-visible.

    "hierarchicalTable.isExpandByColumn" is always "true" if set, and is set on all the columns that must be included
    in a HierarchicalTableViewRequest's key table, if a key table is specified. These columns are generally
    user-visible and displayed before other columns, unless they also have "hierarchicalTable.isStructuralColumn" set.

    "hierarchicalTable.isRowDepthColumn" is always "true" if set, and is set on a single column that specifies the
    depth of a row. That column will always have "hierarchicalTable.isExpandByColumn" set for RollupTables, but never
    for TreeTables.

    "hierarchicalTable.isRowExpandedColumn" is always "true" if set, and is set on a single nullable column of
    booleans that specifies whether a row is expandable or expanded. Values will be null for rows that are not
    expandable, true for expanded rows, false for rows that are not expanded (but expandable). Leaf rows have no
    children to expand, and hence will always have a null value for this column.

    "rollupTable.isAggregatedNodeColumn" is always "true" if set, and is set on all columns of a RollupTable that
    belong to the aggregated nodes.

    "rollupTable.isConstituentNodeColumn" is always "true" if set, and is set on all columns of a RollupTable that
    belong to the constituent nodes. No such columns will be present if constituents are not included in the
    RollupTable.

    "rollupTable.isGroupByColumn" is always "true" if set, and is set on all columns of a RollupTable that are
    "group-by columns", whether the node is aggregated or constituent. All nodes have the same names and types for
    columns labeled in this way. Such columns will always have "hierarchicalTable.isExpandByColumn" set if and only if
    they also have "rollupTable.isAggregatedNodeColumn" set.

    "rollupTable.aggregationInputColumnName" is set to the (string) name of the corresponding constituent column that
    was used as input to this aggregation node column. May have an empty value, because some aggregations take no
    input columns, for example "Count". This is only ever present on columns with "rollupTable.isAggregatedNodeColumn"
    set.

    "treeTable.isNodeColumn" is always "true" if set, and is set on all columns of a TreeTable that nodes inherit from
    the source Table.

    "treeTable.isIdentifierColumn" is always "true" if set, and is set on the single column that uniquely identifies a
    TreeTable row and links it to its children. Such columns will always have "hierarchicalTable.isExpandByColumn"
    set.

    "treeTable.isParentIdentifierColumn" is always "true" if set, and is set on the single column that links a
    TreeTable row to its parent row.
    """
    is_static: builtins.bool
    """Whether or not this table might change."""
    def __init__(
        self,
        *,
        snapshot_schema: builtins.bytes = ...,
        is_static: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["is_static", b"is_static", "snapshot_schema", b"snapshot_schema"]) -> None: ...

global___HierarchicalTableDescriptor = HierarchicalTableDescriptor

@typing.final
class HierarchicalTableViewRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESULT_VIEW_ID_FIELD_NUMBER: builtins.int
    HIERARCHICAL_TABLE_ID_FIELD_NUMBER: builtins.int
    EXISTING_VIEW_ID_FIELD_NUMBER: builtins.int
    EXPANSIONS_FIELD_NUMBER: builtins.int
    @property
    def result_view_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """Ticket to use to hold the result HierarchicalTableView"""

    @property
    def hierarchical_table_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """Ticket for the HierarchicalTable (RollupTable or TreeTable) to expand"""

    @property
    def existing_view_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """Ticket for an existing HierarchicalTableView. The result view will inherit the HierarchicalTable from the
        existing view. The two views will share state used for caching snapshot data, but the server implementation may
        limit parallelism when performing snapshots for either view.
        Use this field when you intend to stop using the existing view and instead begin to use the result view.
        """

    @property
    def expansions(self) -> global___HierarchicalTableViewKeyTableDescriptor:
        """Description for the expansions that define this view of the HierarchicalTable. If not present, the result will
        have default expansions, For RollupTables this will be the root (single row, top-level aggregation) and the next
        level if one exists (that is, if there are one or more group-by columns, or constituents are included). For
        TreeTables, this will be the root (one row for each child of the "null" parent identifier).
        """

    def __init__(
        self,
        *,
        result_view_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        hierarchical_table_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        existing_view_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        expansions: global___HierarchicalTableViewKeyTableDescriptor | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["existing_view_id", b"existing_view_id", "expansions", b"expansions", "hierarchical_table_id", b"hierarchical_table_id", "result_view_id", b"result_view_id", "target", b"target"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["existing_view_id", b"existing_view_id", "expansions", b"expansions", "hierarchical_table_id", b"hierarchical_table_id", "result_view_id", b"result_view_id", "target", b"target"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["target", b"target"]) -> typing.Literal["hierarchical_table_id", "existing_view_id"] | None: ...

global___HierarchicalTableViewRequest = HierarchicalTableViewRequest

@typing.final
class HierarchicalTableViewKeyTableDescriptor(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_TABLE_ID_FIELD_NUMBER: builtins.int
    KEY_TABLE_ACTION_COLUMN_FIELD_NUMBER: builtins.int
    key_table_action_column: builtins.str
    """The name of a column of bytes found in the key table that specifies the action desired for the node selected by
    the other columns for each row. Takes on the value 1 for nodes that should be expanded, 3 for nodes that should be
    expanded along with their descendants, and 4 for nodes that should be contracted.
    If this column name is not present, all nodes in the key table will be expanded without their descendants.
    """
    @property
    def key_table_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """Ticket that represents a Table of expanded or contracted keys from a HierarchicalTable (RollupTable or TreeTable).
        The format for the key Table is dictated by the schema from the corresponding HierarchicalTableDescriptor. It is
        expected to have one column for each "expand-by column", including the "row depth column" for RollupTables only,
        and (optionally) an "action" column whose name is specified in the key_table_action_column field.
        If the Table is empty the result will have only default nodes expanded.
        """

    def __init__(
        self,
        *,
        key_table_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        key_table_action_column: builtins.str | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_key_table_action_column", b"_key_table_action_column", "key_table_action_column", b"key_table_action_column", "key_table_id", b"key_table_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_key_table_action_column", b"_key_table_action_column", "key_table_action_column", b"key_table_action_column", "key_table_id", b"key_table_id"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_key_table_action_column", b"_key_table_action_column"]) -> typing.Literal["key_table_action_column"] | None: ...

global___HierarchicalTableViewKeyTableDescriptor = HierarchicalTableViewKeyTableDescriptor

@typing.final
class HierarchicalTableViewResponse(google.protobuf.message.Message):
    """Deliberately empty response, use /FlightService/DoExchange to snapshot or subscribe to snapshots from the result
    result_view_id
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

global___HierarchicalTableViewResponse = HierarchicalTableViewResponse

@typing.final
class HierarchicalTableSourceExportRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESULT_TABLE_ID_FIELD_NUMBER: builtins.int
    HIERARCHICAL_TABLE_ID_FIELD_NUMBER: builtins.int
    @property
    def result_table_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """Ticket to use to hold an export of the HierarchicalTable's source Table"""

    @property
    def hierarchical_table_id(self) -> deephaven_core.proto.ticket_pb2.Ticket:
        """Ticket for the (existing) HierarchicalTable (RollupTable or TreeTable) to export the source Table for"""

    def __init__(
        self,
        *,
        result_table_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        hierarchical_table_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["hierarchical_table_id", b"hierarchical_table_id", "result_table_id", b"result_table_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["hierarchical_table_id", b"hierarchical_table_id", "result_table_id", b"result_table_id"]) -> None: ...

global___HierarchicalTableSourceExportRequest = HierarchicalTableSourceExportRequest
