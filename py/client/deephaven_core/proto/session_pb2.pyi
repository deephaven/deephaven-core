"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file

Copyright (c) 2016-2022 Deephaven Data Labs and Patent Pending
"""

import builtins
import collections.abc
import deephaven_core.proto.ticket_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class WrappedAuthenticationRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TYPE_FIELD_NUMBER: builtins.int
    PAYLOAD_FIELD_NUMBER: builtins.int
    type: builtins.str
    """
    The type of the protobuf the auth payload protobuf.
    """
    payload: builtins.bytes
    """
    The serialized payload of the protobuf instance.
    """
    def __init__(
        self,
        *,
        type: builtins.str = ...,
        payload: builtins.bytes = ...,
    ) -> None: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["payload", b"payload", "type", b"type"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___WrappedAuthenticationRequest: typing_extensions.TypeAlias = WrappedAuthenticationRequest

@typing.final
class HandshakeRequest(google.protobuf.message.Message):
    """
    The request that a client provides to a server on handshake.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AUTH_PROTOCOL_FIELD_NUMBER: builtins.int
    PAYLOAD_FIELD_NUMBER: builtins.int
    auth_protocol: builtins.int
    """
    A defined protocol version.

    Deephaven's OSS protocols are as follows:
    - protocol = 0: most recent HandshakeResponse payload
    - protocol = 1: payload is BasicAuth
    """
    payload: builtins.bytes
    """
    Arbitrary auth/handshake info.
    """
    def __init__(
        self,
        *,
        auth_protocol: builtins.int = ...,
        payload: builtins.bytes = ...,
    ) -> None: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["auth_protocol", b"auth_protocol", "payload", b"payload"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___HandshakeRequest: typing_extensions.TypeAlias = HandshakeRequest

@typing.final
class HandshakeResponse(google.protobuf.message.Message):
    """
    Servers respond with information needed to make subsequent requests tied to this session.
    The session token should be refreshed prior to the deadline, which is represented as milliseconds since the
    epoch. Clients are encouraged to use the expiration delay and cookie deadline to determine a good time to refresh.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    METADATA_HEADER_FIELD_NUMBER: builtins.int
    SESSION_TOKEN_FIELD_NUMBER: builtins.int
    TOKEN_DEADLINE_TIME_MILLIS_FIELD_NUMBER: builtins.int
    TOKEN_EXPIRATION_DELAY_MILLIS_FIELD_NUMBER: builtins.int
    metadata_header: builtins.bytes
    """
    The metadata header to identify the session. This value is static and defined via configuration.
    """
    session_token: builtins.bytes
    """
    Arbitrary session_token to assign to the value to the provided metadata header.
    """
    token_deadline_time_millis: builtins.int
    """
    When this session_token will be considered invalid by the server.
    """
    token_expiration_delay_millis: builtins.int
    """
    The length of time that this token was intended to live. Note that `refreshSessionToken` may return the
    existing token to reduce overhead and to prevent denial-of-service caused by refreshing too frequently.
    """
    def __init__(
        self,
        *,
        metadata_header: builtins.bytes = ...,
        session_token: builtins.bytes = ...,
        token_deadline_time_millis: builtins.int = ...,
        token_expiration_delay_millis: builtins.int = ...,
    ) -> None: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["metadata_header", b"metadata_header", "session_token", b"session_token", "token_deadline_time_millis", b"token_deadline_time_millis", "token_expiration_delay_millis", b"token_expiration_delay_millis"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___HandshakeResponse: typing_extensions.TypeAlias = HandshakeResponse

@typing.final
class CloseSessionResponse(google.protobuf.message.Message):
    """Intentionally empty and is here for backwards compatibility should this API change."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___CloseSessionResponse: typing_extensions.TypeAlias = CloseSessionResponse

@typing.final
class ReleaseRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> deephaven_core.proto.ticket_pb2.Ticket: ...
    def __init__(
        self,
        *,
        id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["id", b"id"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["id", b"id"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ReleaseRequest: typing_extensions.TypeAlias = ReleaseRequest

@typing.final
class ReleaseResponse(google.protobuf.message.Message):
    """Intentionally empty and is here for backwards compatibility should this API change."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___ReleaseResponse: typing_extensions.TypeAlias = ReleaseResponse

@typing.final
class ExportRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SOURCE_ID_FIELD_NUMBER: builtins.int
    RESULT_ID_FIELD_NUMBER: builtins.int
    @property
    def source_id(self) -> deephaven_core.proto.ticket_pb2.Ticket: ...
    @property
    def result_id(self) -> deephaven_core.proto.ticket_pb2.Ticket: ...
    def __init__(
        self,
        *,
        source_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        result_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["result_id", b"result_id", "source_id", b"source_id"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["result_id", b"result_id", "source_id", b"source_id"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ExportRequest: typing_extensions.TypeAlias = ExportRequest

@typing.final
class ExportResponse(google.protobuf.message.Message):
    """Intentionally empty and is here for backwards compatibility should this API change."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___ExportResponse: typing_extensions.TypeAlias = ExportResponse

@typing.final
class PublishRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SOURCE_ID_FIELD_NUMBER: builtins.int
    RESULT_ID_FIELD_NUMBER: builtins.int
    @property
    def source_id(self) -> deephaven_core.proto.ticket_pb2.Ticket: ...
    @property
    def result_id(self) -> deephaven_core.proto.ticket_pb2.Ticket: ...
    def __init__(
        self,
        *,
        source_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        result_id: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["result_id", b"result_id", "source_id", b"source_id"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["result_id", b"result_id", "source_id", b"source_id"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___PublishRequest: typing_extensions.TypeAlias = PublishRequest

@typing.final
class PublishResponse(google.protobuf.message.Message):
    """Intentionally empty and is here for backwards compatibility should this API change."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___PublishResponse: typing_extensions.TypeAlias = PublishResponse

@typing.final
class ExportNotificationRequest(google.protobuf.message.Message):
    """Intentionally empty and is here for backwards compatibility should this API change."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___ExportNotificationRequest: typing_extensions.TypeAlias = ExportNotificationRequest

@typing.final
class ExportNotification(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _State:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _StateEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ExportNotification._State.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UNKNOWN: ExportNotification._State.ValueType  # 0
        """This item is a dependency, but hasn't been registered yet."""
        PENDING: ExportNotification._State.ValueType  # 1
        """This item has pending dependencies."""
        PUBLISHING: ExportNotification._State.ValueType  # 2
        """This item is a client-supplied dependency with no guarantee on timing to EXPORT state."""
        QUEUED: ExportNotification._State.ValueType  # 3
        """This item is eligible for resolution and has been submitted to the executor."""
        RUNNING: ExportNotification._State.ValueType  # 4
        """This item is now executing."""
        EXPORTED: ExportNotification._State.ValueType  # 5
        """This item was successfully exported and is currently being retained."""
        RELEASED: ExportNotification._State.ValueType  # 6
        """This item was successfully released."""
        CANCELLED: ExportNotification._State.ValueType  # 7
        """ CANCELLED: The user cancelled the item before it exported."""
        FAILED: ExportNotification._State.ValueType  # 8
        """This item had a specific error."""
        DEPENDENCY_FAILED: ExportNotification._State.ValueType  # 9
        """One of this item's dependencies had an internal error before it exported."""
        DEPENDENCY_NEVER_FOUND: ExportNotification._State.ValueType  # 10
        """One of this item's dependencies was already released or never submitted within the out-of-order window."""
        DEPENDENCY_CANCELLED: ExportNotification._State.ValueType  # 11
        """Dependency was cancelled, causing a cascading cancel that applies to this export."""
        DEPENDENCY_RELEASED: ExportNotification._State.ValueType  # 12
        """Dependency was already released, causing a cascading failure that applies to this export."""

    class State(_State, metaclass=_StateEnumTypeWrapper): ...
    UNKNOWN: ExportNotification.State.ValueType  # 0
    """This item is a dependency, but hasn't been registered yet."""
    PENDING: ExportNotification.State.ValueType  # 1
    """This item has pending dependencies."""
    PUBLISHING: ExportNotification.State.ValueType  # 2
    """This item is a client-supplied dependency with no guarantee on timing to EXPORT state."""
    QUEUED: ExportNotification.State.ValueType  # 3
    """This item is eligible for resolution and has been submitted to the executor."""
    RUNNING: ExportNotification.State.ValueType  # 4
    """This item is now executing."""
    EXPORTED: ExportNotification.State.ValueType  # 5
    """This item was successfully exported and is currently being retained."""
    RELEASED: ExportNotification.State.ValueType  # 6
    """This item was successfully released."""
    CANCELLED: ExportNotification.State.ValueType  # 7
    """ CANCELLED: The user cancelled the item before it exported."""
    FAILED: ExportNotification.State.ValueType  # 8
    """This item had a specific error."""
    DEPENDENCY_FAILED: ExportNotification.State.ValueType  # 9
    """One of this item's dependencies had an internal error before it exported."""
    DEPENDENCY_NEVER_FOUND: ExportNotification.State.ValueType  # 10
    """One of this item's dependencies was already released or never submitted within the out-of-order window."""
    DEPENDENCY_CANCELLED: ExportNotification.State.ValueType  # 11
    """Dependency was cancelled, causing a cascading cancel that applies to this export."""
    DEPENDENCY_RELEASED: ExportNotification.State.ValueType  # 12
    """Dependency was already released, causing a cascading failure that applies to this export."""

    TICKET_FIELD_NUMBER: builtins.int
    EXPORT_STATE_FIELD_NUMBER: builtins.int
    CONTEXT_FIELD_NUMBER: builtins.int
    DEPENDENT_HANDLE_FIELD_NUMBER: builtins.int
    export_state: Global___ExportNotification.State.ValueType
    context: builtins.str
    """
    any errors will include an id that can be used to find details of the error in the logs
    """
    dependent_handle: builtins.str
    """
    will be set to an identifier of the dependency that cascaded the error if applicable
    """
    @property
    def ticket(self) -> deephaven_core.proto.ticket_pb2.Ticket: ...
    def __init__(
        self,
        *,
        ticket: deephaven_core.proto.ticket_pb2.Ticket | None = ...,
        export_state: Global___ExportNotification.State.ValueType = ...,
        context: builtins.str = ...,
        dependent_handle: builtins.str = ...,
    ) -> None: ...
    _HasFieldArgType: typing_extensions.TypeAlias = typing.Literal["ticket", b"ticket"]
    def HasField(self, field_name: _HasFieldArgType) -> builtins.bool: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["context", b"context", "dependent_handle", b"dependent_handle", "export_state", b"export_state", "ticket", b"ticket"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___ExportNotification: typing_extensions.TypeAlias = ExportNotification

@typing.final
class TerminationNotificationRequest(google.protobuf.message.Message):
    """Intentionally empty and is here for backwards compatibility should this API change."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    def __init__(
        self,
    ) -> None: ...

Global___TerminationNotificationRequest: typing_extensions.TypeAlias = TerminationNotificationRequest

@typing.final
class TerminationNotificationResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class StackTrace(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        TYPE_FIELD_NUMBER: builtins.int
        MESSAGE_FIELD_NUMBER: builtins.int
        ELEMENTS_FIELD_NUMBER: builtins.int
        type: builtins.str
        message: builtins.str
        @property
        def elements(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]: ...
        def __init__(
            self,
            *,
            type: builtins.str = ...,
            message: builtins.str = ...,
            elements: collections.abc.Iterable[builtins.str] | None = ...,
        ) -> None: ...
        _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["elements", b"elements", "message", b"message", "type", b"type"]
        def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

    ABNORMAL_TERMINATION_FIELD_NUMBER: builtins.int
    REASON_FIELD_NUMBER: builtins.int
    IS_FROM_UNCAUGHT_EXCEPTION_FIELD_NUMBER: builtins.int
    STACK_TRACES_FIELD_NUMBER: builtins.int
    abnormal_termination: builtins.bool
    """whether or not this termination is expected"""
    reason: builtins.str
    """if additional information is available then provide it in this field"""
    is_from_uncaught_exception: builtins.bool
    """if this is due to an exception, whether or not it was uncaught"""
    @property
    def stack_traces(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[Global___TerminationNotificationResponse.StackTrace]:
        """if applicable, the list of stack traces in reverse causal order"""

    def __init__(
        self,
        *,
        abnormal_termination: builtins.bool = ...,
        reason: builtins.str = ...,
        is_from_uncaught_exception: builtins.bool = ...,
        stack_traces: collections.abc.Iterable[Global___TerminationNotificationResponse.StackTrace] | None = ...,
    ) -> None: ...
    _ClearFieldArgType: typing_extensions.TypeAlias = typing.Literal["abnormal_termination", b"abnormal_termination", "is_from_uncaught_exception", b"is_from_uncaught_exception", "reason", b"reason", "stack_traces", b"stack_traces"]
    def ClearField(self, field_name: _ClearFieldArgType) -> None: ...

Global___TerminationNotificationResponse: typing_extensions.TypeAlias = TerminationNotificationResponse
