# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from pydeephaven.proto import object_pb2 as deephaven_dot_proto_dot_object__pb2


class ObjectServiceStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.FetchObject = channel.unary_unary(
                '/io.deephaven.proto.backplane.grpc.ObjectService/FetchObject',
                request_serializer=deephaven_dot_proto_dot_object__pb2.FetchObjectRequest.SerializeToString,
                response_deserializer=deephaven_dot_proto_dot_object__pb2.FetchObjectResponse.FromString,
                )
        self.MessageStream = channel.stream_stream(
                '/io.deephaven.proto.backplane.grpc.ObjectService/MessageStream',
                request_serializer=deephaven_dot_proto_dot_object__pb2.StreamRequest.SerializeToString,
                response_deserializer=deephaven_dot_proto_dot_object__pb2.StreamResponse.FromString,
                )
        self.OpenMessageStream = channel.unary_stream(
                '/io.deephaven.proto.backplane.grpc.ObjectService/OpenMessageStream',
                request_serializer=deephaven_dot_proto_dot_object__pb2.StreamRequest.SerializeToString,
                response_deserializer=deephaven_dot_proto_dot_object__pb2.StreamResponse.FromString,
                )
        self.NextMessageStream = channel.unary_unary(
                '/io.deephaven.proto.backplane.grpc.ObjectService/NextMessageStream',
                request_serializer=deephaven_dot_proto_dot_object__pb2.StreamRequest.SerializeToString,
                response_deserializer=deephaven_dot_proto_dot_object__pb2.BrowserNextResponse.FromString,
                )


class ObjectServiceServicer(object):
    """Missing associated documentation comment in .proto file."""

    def FetchObject(self, request, context):
        """
        Fetches a server-side object as a binary payload and assorted other tickets pointing at
        other server-side objects that may need to be read to properly use this payload. The binary
        format is implementation specific, but the implementation should be specified by the "type"
        identifier in the typed ticket.

        Deprecated in favor of MessageStream, which is able to handle the same content.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def MessageStream(self, request_iterator, context):
        """
        Provides a generic stream feature for Deephaven instances to use to add arbitrary functionality.
        This API lets a client open a stream to a particular object on the server, to be mediated by
        a server side plugin. In theory this could effectively be used to "tunnel" a custom gRPC call,
        but in practice there are a few deliberate shortcomings that still make this possible, but not
        trivial.

        The first message sent to the server is expected to have a ConnectRequest, indicating which
        export ticket to connect to. It is an error for the server to not have a plugin defined for that
        object type.

        Subsequent requests to the server, and all responses to the client, will be a payload of bytes
        and an arbitrary number of tickets, referring to server side objects that one side wishes to
        reference in its payload.

        Presently it is required that the server respond immediately, at least to acknowledge that the
        object was correctly contacted (as opposed to waiting for a pending ticket, or dealing with
        network lag, etc). This is a small (and possibly not required, but convenient) departure from
        a offering a gRPC stream (a server-streaming or bidi-streaming call need not send a message
        right away).

        Presently there is no explicit "close" message to send, but plugin implementations can devise
        their own "half-close" protocol if they so choose. For now, if one end closes the connection,
        the other is expected to follow suit by closing their end too.

        (address stream failures?)

        Finally, addressing a broader point of unsuitability for general gRPC-over-gRPC tunneling:
        there is a lot more to gRPC than just specifying a path and sending payloads to it, such as
        how to specify metadata. In theory, we could handle the metadata as another field (only sent
        in the first/last payloads), or as a separate plugin-defined type of payload (analogous to the
        grpc-websockets implementations), but we still run into issues where this user-defined gRPC
        service needs to coexist with the rest of the Deephaven platform, supporting at least authentication,
        and for browsers, our custom streaming implementation. The nested gRPC implementation would
        need to be at some level aware that it is already stateful to take advantage of this, rather
        than somehow redefine it.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def OpenMessageStream(self, request, context):
        """
        Half of the browser-based (browser's can't do bidirectional streams without websockets)
        implementation for MessageStream.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def NextMessageStream(self, request, context):
        """
        Other half of the browser-based implementation for MessageStream.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_ObjectServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'FetchObject': grpc.unary_unary_rpc_method_handler(
                    servicer.FetchObject,
                    request_deserializer=deephaven_dot_proto_dot_object__pb2.FetchObjectRequest.FromString,
                    response_serializer=deephaven_dot_proto_dot_object__pb2.FetchObjectResponse.SerializeToString,
            ),
            'MessageStream': grpc.stream_stream_rpc_method_handler(
                    servicer.MessageStream,
                    request_deserializer=deephaven_dot_proto_dot_object__pb2.StreamRequest.FromString,
                    response_serializer=deephaven_dot_proto_dot_object__pb2.StreamResponse.SerializeToString,
            ),
            'OpenMessageStream': grpc.unary_stream_rpc_method_handler(
                    servicer.OpenMessageStream,
                    request_deserializer=deephaven_dot_proto_dot_object__pb2.StreamRequest.FromString,
                    response_serializer=deephaven_dot_proto_dot_object__pb2.StreamResponse.SerializeToString,
            ),
            'NextMessageStream': grpc.unary_unary_rpc_method_handler(
                    servicer.NextMessageStream,
                    request_deserializer=deephaven_dot_proto_dot_object__pb2.StreamRequest.FromString,
                    response_serializer=deephaven_dot_proto_dot_object__pb2.BrowserNextResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'io.deephaven.proto.backplane.grpc.ObjectService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class ObjectService(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def FetchObject(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/io.deephaven.proto.backplane.grpc.ObjectService/FetchObject',
            deephaven_dot_proto_dot_object__pb2.FetchObjectRequest.SerializeToString,
            deephaven_dot_proto_dot_object__pb2.FetchObjectResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def MessageStream(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(request_iterator, target, '/io.deephaven.proto.backplane.grpc.ObjectService/MessageStream',
            deephaven_dot_proto_dot_object__pb2.StreamRequest.SerializeToString,
            deephaven_dot_proto_dot_object__pb2.StreamResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def OpenMessageStream(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/io.deephaven.proto.backplane.grpc.ObjectService/OpenMessageStream',
            deephaven_dot_proto_dot_object__pb2.StreamRequest.SerializeToString,
            deephaven_dot_proto_dot_object__pb2.StreamResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def NextMessageStream(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/io.deephaven.proto.backplane.grpc.ObjectService/NextMessageStream',
            deephaven_dot_proto_dot_object__pb2.StreamRequest.SerializeToString,
            deephaven_dot_proto_dot_object__pb2.BrowserNextResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
