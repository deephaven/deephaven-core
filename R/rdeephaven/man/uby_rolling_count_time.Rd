% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/update_by_ops_wrapper.R
\name{uby_rolling_count_time}
\alias{uby_rolling_count_time}
\title{Rolling count with time as the windowing unit}
\arguments{
\item{ts_col}{String denoting the column to use as the timestamp.}

\item{cols}{String or list of strings denoting the column(s) to operate on. Can be renaming expressions, i.e. “new_col = col”.
Default is to compute the rolling sum for all non-grouping columns.}

\item{rev_time}{ISO-8601-formatted string specifying the look-behind window size.}

\item{fwd_time}{ISO-8601-formatted string specifying the look-ahead window size. Default is 0 seconds.}
}
\value{
UpdateByOp to be used in \code{update_by()}.
}
\description{
Creates a rolling count UpdateByOp for each column in \code{cols}, using time as the windowing unit.
}
\details{
This uses ISO-8601 time strings as the reverse and forward window parameters.
Negative values are allowed and can be used to generate completely forward or completely reverse windows.
A row containing a null value in the timestamp column belongs to no window and will not be considered
in the windows of other rows; its output will be null.
Here are some examples of window values:
\itemize{
\item \verb{rev_time = "PT00:10:00", fwd_time = "PT00:10:00"} - contains rows from 10m before through 10m following
the current row timestamp (inclusive)
\item \verb{rev_time = "PT00:10:00", fwd_time = "-PT00:05:00"} - contains rows from 10m before through 5m before the
current row timestamp (inclusive), this is a purely backwards looking window
\item \verb{rev_time = "-PT00:05:00", fwd_time = "PT00:10:00"} - contains rows from 5m following through 10m
following the current row timestamp (inclusive), this is a purely forwards looking window
}

The aggregation groups that this function acts on are defined with the \code{by} parameter of the \code{update_by()} caller
function. The aggregation groups are defined by the unique combinations of values in the \code{by} columns. For example,
if \code{by = c("A", "B")}, then the aggregation groups are defined by the unique combinations of values in the
\code{A} and \code{B} columns.

This function, like the other Deephaven \verb{uby_*} functions, is a generator function. That is, its output is another
function that is intended to be used in a call to \code{update_by()}. This detail is typically hidden from the user by
\code{update_by()}, which calls the generated functions internally. However, it is important to understand this detail
for debugging purposes, as the output of a \verb{uby_*} function can otherwise seem unexpected.
}
\examples{
print("hello!")

}
