plugins {
    id 'base'
    id 'java'
    id 'io.deephaven.java-repository-conventions'
    id 'io.deephaven.java-classpath-conventions'
    id 'io.deephaven.java-license-conventions'
    id 'io.deephaven.java-header-conventions'
    id 'io.deephaven.java-toolchain-conventions'
    id 'io.deephaven.java-jar-conventions'
}

project.tasks.getByName('quick').dependsOn project.tasks.withType(JavaCompile)

configurations.all({ c ->
    // Make dynamic versions illegal.
    c.dependencies.all({
        Dependency dep ->
            if (dep.version && dep.version.endsWith('+')) {
                throw new GradleException("Dynamic versions not allowed ($dep found in $path)")
            }
    })
    c.resolutionStrategy {
        // by default, we don't use any changing modules.
        // however, if a developer is working on something where jars
        // are published to a local filesystem (like mavenLocal()),
        // they can use `api group: 'com.foo', name: 'blah', version: '1', changing: true`,
        // and gradle will happily recheck the filesystem for changes.
        cacheChangingModulesFor 0, 'seconds'
    }
})

tasks.named(LifecycleBasePlugin.CLEAN_TASK_NAME) {
    Delete d ->
        d.delete('out')
}
