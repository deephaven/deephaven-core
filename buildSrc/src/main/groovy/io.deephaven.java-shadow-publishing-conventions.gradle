import io.deephaven.project.util.PublishingTools
import com.github.jengelman.gradle.plugins.shadow.ShadowBasePlugin
import com.github.jengelman.gradle.plugins.shadow.ShadowJavaPlugin
import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import org.gradle.jvm.tasks.Jar

plugins {
  id 'java'
  id 'signing'
  id 'maven-publish'
  id 'com.gradleup.shadow'
  id 'io.deephaven.javadoc-conventions'
}

java {
  withJavadocJar()
  withSourcesJar()
}

tasks.withType(Javadoc).configureEach {
  // https://github.com/gradle/gradle/issues/19869
  options.addStringOption('sourcepath', sourceSets.main.allJava.getSourceDirectories().getAsPath())
}

def shadowPublication = project
        .extensions
        .getByType(PublishingExtension)
        .publications
        .create(PublishingTools.SHADOW_PUBLICATION_NAME, MavenPublication) {
          from(project.components.named(ShadowBasePlugin.COMPONENT_NAME).get())
          artifact(project.tasks.named('sourcesJar'))
          artifact(project.tasks.named('javadocJar'))
        }

def shadowJar = project.tasks.named(ShadowJavaPlugin.SHADOW_JAR_TASK_NAME, ShadowJar) {
  // We want the shadow jar to be the "default" jar, so we don't want it to have a classifier
  archiveClassifier = ''
}

project.tasks.named('jar', Jar) {
  // Note: this is forcing the output name of the plain jar task to be _different_ than the shadow jar, otherwise you
  // can end up with gradle thinking that the jar output is an implicit, unstated dependency of some shadow tasks, and
  // causes failures. (In addition to potential issues w/ tasks stomping on other tasks.)
  archiveClassifier = 'orig'
}

project.tasks.named('assemble') {
  it.dependsOn(shadowJar)
}

PublishingTools.setupRepositories(project)
PublishingTools.setupLicense(project, shadowPublication)
PublishingTools.setupMavenPublication(project, shadowPublication)
PublishingTools.setupSigning(project, shadowPublication)
// Projects will need to call PublishingTools.setupShadowName to setup appropriate shadow names
