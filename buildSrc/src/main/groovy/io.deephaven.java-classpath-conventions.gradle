plugins {
    id 'base'
    id 'java'
}

configurations {
    jdom
    math3
    jama.extendsFrom math3
    dxCompile
    dxRuntime.extendsFrom dxCompile
    junit

    fishBase
    fishIo.extendsFrom fishBase
    fishConfig.extendsFrom fishIo
    fishNumerics.extendsFrom fishBase
    fishBaseTest.extendsFrom junit
    fishIoTest.extendsFrom fishBaseTest

    dhNumerics.extendsFrom fishNumerics, jama
    dhUtil.extendsFrom fishConfig, fishIo, jdom
    dhPlot.extendsFrom dhUtil
    dhBenchmarkSupport
    dhIntegrations.extendsFrom math3
}

dependencies {

    // First, one-off configurations for stuff we need "here and there"
    jdom libs.jdom2
    math3 libs.commons.math3
    jama libs.jama

    junit libs.junit4
    junit libs.jmock.junit4
    junit libs.jmock.imposters

    // Now, all the various fish libs we depend on, with inherited dependencies matching
    // the actual dependencies used in fishlib... if we were strongly coupled, we could skip
    // having to maintain this...
    fishBase project(':Base'),
            libs.trove,
            libs.jetbrains.annotations,
            libs.commons.compress

    fishIo project(':IO')

    fishConfig project(':Configuration')
    fishConfig project(':DataStructures')

    fishBaseTest project(path: ':Base', configuration: 'tests')

    fishIoTest project(path: ':IO', configuration: 'tests')

    // https://mvnrepository.com/artifact/com.univocity/univocity-parsers
    dhBenchmarkSupport libs.univocity.parsers

    dhBenchmarkSupport platform(libs.jackson.bom)
    dhBenchmarkSupport libs.jackson.core
}
