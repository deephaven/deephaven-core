import groovy.json.JsonBuilder

plugins {
  id 'java'
}

def archivesBaseNamePrefix = 'deephaven-'

def compilerVersion = Integer.parseInt((String)project.findProperty('compilerVersion') ?: '11')

def languageLevel = Integer.parseInt((String)project.findProperty('languageLevel') ?: '11')
def runtimeVersion = Integer.parseInt((String)project.findProperty('runtimeVersion') ?: '11')

def testLanguageLevel = Integer.parseInt((String)project.findProperty('testLanguageLevel') ?: '11')
def testRuntimeVersion = Integer.parseInt((String)project.findProperty('testRuntimeVersion') ?: '11')

if (languageLevel > compilerVersion) {
  throw new IllegalArgumentException("languageLevel must be less than or equal to compileVersion")
}
if (languageLevel < 8) {
  throw new IllegalArgumentException("languageLevel must be greater than or equal to 8")
}
if (testLanguageLevel < 8) {
  throw new IllegalArgumentException("testLanguageLevel must be greater than or equal to 8")
}
if (runtimeVersion < languageLevel) {
  throw new IllegalArgumentException("runtimeVersion must be greater than or equal to languageLevel")
}
if (testRuntimeVersion < testLanguageLevel) {
  throw new IllegalArgumentException("testRuntimeVersion must be greater than or equal to testLanguageLevel")
}

archivesBaseName = "${archivesBaseNamePrefix}${project.name}"

java {
  toolchain {
    // Note: even though we are being explicit with our compilers / launchers via task type, we want to set up the
    // plugin with our compiler version.
    languageVersion = JavaLanguageVersion.of(compilerVersion)
  }
}

def compiler = javaToolchains.compilerFor {
  languageVersion = JavaLanguageVersion.of(compilerVersion)
} as Provider<JavaCompiler>

def runtimeLauncher = javaToolchains.launcherFor {
  languageVersion = JavaLanguageVersion.of(runtimeVersion)
} as Provider<JavaLauncher>

def testRuntimeLauncher = javaToolchains.launcherFor {
  languageVersion = JavaLanguageVersion.of(testRuntimeVersion)
} as Provider<JavaLauncher>

def groovyCompilerLauncher = javaToolchains.launcherFor {
  languageVersion = JavaLanguageVersion.of(compilerVersion)
} as Provider<JavaLauncher>

tasks.withType(JavaCompile).configureEach {
  javaCompiler.set compiler

  options.fork = true
  options.encoding = 'UTF-8'
  options.incremental = true
  options.compilerArgs << '-parameters'

  def isTestCompile = name == 'compileTestJava'
  if (isTestCompile) {
    if (compilerVersion != testLanguageLevel) {
      options.release.set testLanguageLevel
    }
  } else {
    if (compilerVersion != languageLevel) {
      options.release.set languageLevel
    }
  }
}

def tier4CompilationExcludes = [
  'io.deephaven.engine.table.impl.by.ssmpercentile.DoublePercentileTypeMedianHelper':['setResult'],
  'io.deephaven.engine.table.impl.by.ssmpercentile.FloatPercentileTypeMedianHelper':['setResult'],
  'io.deephaven.engine.table.impl.by.ssmpercentile.SsmChunkedPercentileOperator':['addChunk'],
  'io.deephaven.engine.table.impl.by.IncrementalChunkedOperatorAggregationStateManager':['buildTable'],
  'io.deephaven.engine.table.impl.RightIncrementalChunkedCrossJoinStateManager':['addToIndex', 'decorationProbe'],
  'io.deephaven.engine.table.impl.IncrementalChunkedNaturalJoinStateManager':['buildTable', 'decorationProbe'],
]
def createCompilerDirectives = tasks.register('createCompilerDirectives') {
  def c2ExcludesFile = project.layout.buildDirectory.file('c2-excludes.txt')
  it.outputs.file(c2ExcludesFile)

  doFirst {
    def excludesAsList = []
    tier4CompilationExcludes.forEach({type, methods ->
      methods.forEach {method ->
        excludesAsList += "${type}::${method}"
      }
    })
    def builder = new JsonBuilder()
    builder([{
              match excludesAsList
              c2 {
                Exclude true
              }
            }])
    c2ExcludesFile.get().asFile.text = builder.toPrettyString()
  }
}

def extraJvmArgs = { int runtimeJavaVersion, File c2ExcludesFile ->
  def args = [
          '-XX:Tier4CompileThreshold=1000',
//          '-XX:+PrintFlagsFinal',
//          '-XX:+PrintCompilation',
          '-XX:+UnlockDiagnosticVMOptions',
          "-XX:CompilerDirectivesFile=${c2ExcludesFile}",
  ]
  if (runtimeJavaVersion > 8) {
    // Allow reflection, disable broken jit
    args += [
            '--add-opens', 'java.base/java.lang=ALL-UNNAMED',
    ]
  }
  return args
}

tasks.withType(JavaExec).configureEach {
  def c2ExcludesFile = createCompilerDirectives.get().outputs.files
  inputs.files c2ExcludesFile
  javaLauncher.set runtimeLauncher
  jvmArgs += extraJvmArgs(runtimeVersion, c2ExcludesFile.singleFile)
  // todo: configure create start scripts
}

tasks.withType(Test).configureEach {
  def c2ExcludesFile = createCompilerDirectives.get().outputs.files
  inputs.files c2ExcludesFile

  javaLauncher.set testRuntimeLauncher
  jvmArgs += extraJvmArgs(testRuntimeVersion, c2ExcludesFile.singleFile)
}

tasks.withType(GroovyCompile).configureEach {
  javaLauncher.set groovyCompilerLauncher
}

tasks.withType(Jar).configureEach {
  Jar jar ->
    jar.preserveFileTimestamps = false
    jar.reproducibleFileOrder = true
}

tasks.named(LifecycleBasePlugin.CLEAN_TASK_NAME) {
  Delete d ->
    d.delete('out')
}

jar {
  manifest {
    attributes 'Implementation-Title': 'Deephaven Database',
        'Implementation-Version': project.version,
        'Provider': 'gradle'
  }
}

configurations {
  testOutput.extendsFrom testRuntimeClasspath
}