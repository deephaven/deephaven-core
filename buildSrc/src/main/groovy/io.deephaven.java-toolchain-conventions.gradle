import groovy.json.JsonBuilder

plugins {
  id 'java'
}

def compilerVersion = Integer.parseInt((String)project.findProperty('compilerVersion') ?: '11')
def compilerVendor = project.hasProperty('compilerVendor') ?  JvmVendorSpec.matching((String)project.property('compilerVendor')): null

def languageLevel = Integer.parseInt((String)project.findProperty('languageLevel') ?: '11')
def runtimeVersion = Integer.parseInt((String)project.findProperty('runtimeVersion') ?: '11')
def runtimeVendor = project.hasProperty('runtimeVendor') ?  JvmVendorSpec.matching((String)project.property('runtimeVendor')): null

def testLanguageLevel = Integer.parseInt((String)project.findProperty('testLanguageLevel') ?: '11')
def testRuntimeVersion = Integer.parseInt((String)project.findProperty('testRuntimeVersion') ?: '11')
def testRuntimeVendor = project.hasProperty('testRuntimeVendor') ?  JvmVendorSpec.matching((String)project.property('testRuntimeVendor')): null

if (languageLevel > compilerVersion) {
  throw new IllegalArgumentException("languageLevel must be less than or equal to compileVersion")
}
if (languageLevel < 8) {
  throw new IllegalArgumentException("languageLevel must be greater than or equal to 8")
}
if (testLanguageLevel < 8) {
  throw new IllegalArgumentException("testLanguageLevel must be greater than or equal to 8")
}
if (runtimeVersion < languageLevel) {
  throw new IllegalArgumentException("runtimeVersion must be greater than or equal to languageLevel")
}
if (testRuntimeVersion < testLanguageLevel) {
  throw new IllegalArgumentException("testRuntimeVersion must be greater than or equal to testLanguageLevel")
}

java {
  toolchain {
    // Note: even though we are being explicit with our compilers / launchers via task type, we want to set up the
    // plugin with our compiler version.
    languageVersion = JavaLanguageVersion.of(compilerVersion)
    if (compilerVendor != null) {
      vendor = compilerVendor
    }
  }
}

def compiler = javaToolchains.compilerFor {
  languageVersion = JavaLanguageVersion.of(compilerVersion)
  if (compilerVendor != null) {
    vendor = compilerVendor
  }
} as Provider<JavaCompiler>

def runtimeLauncher = javaToolchains.launcherFor {
  languageVersion = JavaLanguageVersion.of(runtimeVersion)
  if (runtimeVendor != null) {
    vendor = runtimeVendor
  }
} as Provider<JavaLauncher>

def testRuntimeLauncher = javaToolchains.launcherFor {
  languageVersion = JavaLanguageVersion.of(testRuntimeVersion)
  if (testRuntimeVendor != null) {
    vendor = testRuntimeVendor
  }
} as Provider<JavaLauncher>

def groovyCompilerLauncher = javaToolchains.launcherFor {
  languageVersion = JavaLanguageVersion.of(compilerVersion)
  if (compilerVendor != null) {
    vendor = compilerVendor
  }
} as Provider<JavaLauncher>

tasks.withType(JavaCompile).configureEach {
  javaCompiler.set compiler

  options.fork = true
  options.forkOptions.memoryMaximumSize = '2G'
  options.encoding = 'UTF-8'
  options.incremental = true
  options.compilerArgs << '-parameters'

  if (name == 'compileTestJava') {
    if (compilerVersion != testLanguageLevel) {
      options.release.set testLanguageLevel
    }
  } else {
    if (compilerVersion != languageLevel) {
      options.release.set languageLevel
    }
  }
}

def createCompilerDirectives = tasks.register('createCompilerDirectives') {
  def compilerDirectivesFile = project.layout.buildDirectory.file('dh-compiler-directives.txt')
  def compilerDirectivesText = new JsonBuilder([{
    match (['*.*'] as List)
    // Note: there seems to be a bug where this option doesn't actually get picked up
    // So using '-XX:DisableIntrinsic=_currentThread' explicitly
    // DisableIntrinsic('_currentThread')
  }]).toPrettyString()
  it.inputs.property('compilerDirectivesText', compilerDirectivesText)
  it.outputs.file(compilerDirectivesFile)
  doFirst {
    compilerDirectivesFile.get().asFile.text = compilerDirectivesText
  }
}

def compilerArgs = { String compilerDirectivesFile ->
  return [
          '-XX:+UnlockDiagnosticVMOptions',
          "-XX:CompilerDirectivesFile=${compilerDirectivesFile}",
          // (deephaven-core#2500): Remove DisableIntrinsic for currentThread
          '-XX:DisableIntrinsic=_currentThread',
          // '-XX:+CompilerDirectivesPrint',
          // '-XX:+LogCompilation',
  ]
}

def parseJvmArgumentsFromEnv = { String envName, List<String> orElse ->
  def s = System.getenv(envName)
  if (s == null) {
    return orElse
  }
  // Note: this logic could be improved to handle quotes and other cases, but hopefully this suffices for now.
  return s.split('\\s+').findAll { it -> !it.trim().isEmpty() } as List<String>
}

// Note: the gradle logic is explicitly reading the JAVA_OPTS and START_OPTS environment variables to provide
// developers a model that more closely matches with the native application script
// https://deephaven.io/core/docs/how-to-guides/configuration/native-application/#native-application-script.
//
// For example:
//
// ```
// START_OPTS="-Xmx1g -Dmy.system.property=123" ./gradlew server-jetty-app:run
// ```

// These are supposed to be generally applicable and recommended JVM options, but they aren't hard requirements.
// Overly specific options do *not* belong here. For example, we should _not_ be setting something like `-Xmx4g` here.
// If you are tempted to try and put system properties here (`-Dkey=value`), think again; there should be a more
// appropriate place to set those.
//
// From the perspective of our application distribution, these options will be used as defaults for JAVA_OPTS
// (if the user already has JAVA_OPTS set, these VM options will _not_ apply).
def JAVA_OPTS = parseJvmArgumentsFromEnv('JAVA_OPTS', [
  '-XX:+UseG1GC',
  '-XX:MaxGCPauseMillis=100',
  '-XX:+UseStringDeduplication',
])

// Utility to add jvm args to all executions, whether intellij or from a application script or gradle javaexec
def START_OPTS = parseJvmArgumentsFromEnv('START_OPTS', [
//  '-XX:Tier4CompileThreshold=1000', // this optional line makes it easier to trigger the c2 error on the above methods
//  '-XX:+PrintFlagsFinal',           // this optional line makes it easier to explore the final values for compiler args
//  '-XX:+PrintCompilation',          // this optional line shows jit operations as they happen
])

def createVmOptions = tasks.register('createVmOptions') {
  def vmOptionsFile = project.layout.buildDirectory.file('dh-default.vmoptions')
  def vmOptionsText = JAVA_OPTS.join('\n')
  it.inputs.property('vmOptionsText', vmOptionsText)
  it.outputs.file(vmOptionsFile)
  doFirst {
    vmOptionsFile.get().asFile.text = vmOptionsText
  }
}

tasks.withType(JavaExec).configureEach {
  def compilerDirectivesFile = createCompilerDirectives.get().outputs.files
  def vmOptionsFile = createVmOptions.get().outputs.files
  inputs.files compilerDirectivesFile
  inputs.files vmOptionsFile
  javaLauncher.set runtimeLauncher
  // Note: we _could_ have the vmOptionsFile constituents directly listed instead of using -XX:VMOptionsFile.
  // That said, the current approach used here more closely matches how the application start script is defined.
  jvmArgs += compilerArgs(compilerDirectivesFile.singleFile.path) + ["-XX:VMOptionsFile=${vmOptionsFile.singleFile.path}"] + START_OPTS
}

tasks.withType(Test).configureEach {
  def compilerDirectivesFile = createCompilerDirectives.get().outputs.files
  def vmOptionsFile = createVmOptions.get().outputs.files
  inputs.files compilerDirectivesFile
  inputs.files vmOptionsFile
  javaLauncher.set testRuntimeLauncher
  // Note: we _could_ have the vmOptionsFile constituents directly listed instead of using -XX:VMOptionsFile.
  // That said, the current approach used here more closely matches how the application start script is defined.
  jvmArgs += compilerArgs(compilerDirectivesFile.singleFile.path) + ["-XX:VMOptionsFile=${vmOptionsFile.singleFile.path}"] + START_OPTS
}

tasks.withType(GroovyCompile).configureEach {
  javaLauncher.set groovyCompilerLauncher
}

plugins.withType(ApplicationPlugin) {
  applicationDistribution.into('etc') {
    from(createCompilerDirectives.get().outputs.files)
    from(createVmOptions.get().outputs.files)
  }
}

tasks.withType(CreateStartScripts).configureEach {
  def unixStartScript = resources.text.fromUri(getClass().classLoader.getResource('unixStartScript.txt'))
  inputs.files unixStartScript
  unixStartScriptGenerator.template = unixStartScript
  // For now we only modify the *nix script, as the windows .bat file doesn't seem to work properly anyway,
  // and we don't yet have a requirement for it.
  windowsStartScriptGenerator.template = resources.text.fromString("echo Sorry, Windows .bat is not currently supported, please use WSL2\nexit 1")

//  def windowsStartScript = resources.text.fromUri(getClass().classLoader.getResource('windowsStartScript.txt'))
//  inputs.files windowsStartScript
//  windowsStartScriptGenerator.template = windowsStartScript

  // Note that we don't call compilerArgs() at this time, there is no way to template those strings.
  // Instead, we hard code the expected paths in the above templates to match the path etc/dh-compiler-directives.txt
//  defaultJvmOpts += compilerArgs(compilerDirectivesFile.singleFile.path)
}
