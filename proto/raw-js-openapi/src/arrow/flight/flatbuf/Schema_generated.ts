// automatically generated by the FlatBuffers compiler, do not modify

/**
 * @enum {number}
 */
export namespace org.apache.arrow.flatbuf{
export enum MetadataVersion{
  /**
   * 0.1.0 (October 2016).
   */
  V1= 0,

  /**
   * 0.2.0 (February 2017). Non-backwards compatible with V1.
   */
  V2= 1,

  /**
   * 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2.
   */
  V3= 2,

  /**
   * >= 0.8.0 (December 2017). Non-backwards compatible with V3.
   */
  V4= 3,

  /**
   * >= 1.0.0 (July 2020. Backwards compatible with V4 (V5 readers can read V4
   * metadata and IPC messages). Implementations are recommended to provide a
   * V4 compatibility mode with V5 format changes disabled.
   *
   * Incompatible changes between V4 and V5:
   * - Union buffer layout has changed. In V5, Unions don't have a validity
   *   bitmap buffer.
   */
  V5= 4
};
}

/**
 * Represents Arrow Features that might not have full support
 * within implementations. This is intended to be used in
 * two scenarios:
 *  1.  A mechanism for readers of Arrow Streams
 *      and files to understand that the stream or file makes
 *      use of a feature that isn't supported or unknown to
 *      the implementation (and therefore can meet the Arrow
 *      forward compatibility guarantees).
 *  2.  A means of negotiating between a client and server
 *      what features a stream is allowed to use. The enums
 *      values here are intented to represent higher level
 *      features, additional details maybe negotiated
 *      with key-value pairs specific to the protocol.
 *
 * Enums added to this list should be assigned power-of-two values
 * to facilitate exchanging and comparing bitmaps for supported
 * features.
 *
 * @enum {number}
 */
export namespace org.apache.arrow.flatbuf{
export enum Feature{
  /**
   * Needed to make flatbuffers happy.
   */
  UNUSED= 0,

  /**
   * The stream makes use of multiple full dictionaries with the
   * same ID and assumes clients implement dictionary replacement
   * correctly.
   */
  DICTIONARY_REPLACEMENT= 1,

  /**
   * The stream makes use of compressed bodies as described
   * in Message.fbs.
   */
  COMPRESSED_BODY= 2
};
}

/**
 * @enum {number}
 */
export namespace org.apache.arrow.flatbuf{
export enum UnionMode{
  Sparse= 0,
  Dense= 1
};
}

/**
 * @enum {number}
 */
export namespace org.apache.arrow.flatbuf{
export enum Precision{
  HALF= 0,
  SINGLE= 1,
  DOUBLE= 2
};
}

/**
 * @enum {number}
 */
export namespace org.apache.arrow.flatbuf{
export enum DateUnit{
  DAY= 0,
  MILLISECOND= 1
};
}

/**
 * @enum {number}
 */
export namespace org.apache.arrow.flatbuf{
export enum TimeUnit{
  SECOND= 0,
  MILLISECOND= 1,
  MICROSECOND= 2,
  NANOSECOND= 3
};
}

/**
 * @enum {number}
 */
export namespace org.apache.arrow.flatbuf{
export enum IntervalUnit{
  YEAR_MONTH= 0,
  DAY_TIME= 1
};
}

/**
 * ----------------------------------------------------------------------
 * Top-level Type value, enabling extensible type-specific metadata. We can
 * add new logical types to Type without breaking backwards compatibility
 *
 * @enum {number}
 */
export namespace org.apache.arrow.flatbuf{
export enum Type{
  NONE= 0,
  Null= 1,
  Int= 2,
  FloatingPoint= 3,
  Binary= 4,
  Utf8= 5,
  Bool= 6,
  Decimal= 7,
  Date= 8,
  Time= 9,
  Timestamp= 10,
  Interval= 11,
  List= 12,
  Struct_= 13,
  Union= 14,
  FixedSizeBinary= 15,
  FixedSizeList= 16,
  Map= 17,
  Duration= 18,
  LargeBinary= 19,
  LargeUtf8= 20,
  LargeList= 21
};

export function unionToType(
  type: Type,
  accessor: (obj:org.apache.arrow.flatbuf.Binary|org.apache.arrow.flatbuf.Bool|org.apache.arrow.flatbuf.Date|org.apache.arrow.flatbuf.Decimal|org.apache.arrow.flatbuf.Duration|org.apache.arrow.flatbuf.FixedSizeBinary|org.apache.arrow.flatbuf.FixedSizeList|org.apache.arrow.flatbuf.FloatingPoint|org.apache.arrow.flatbuf.Int|org.apache.arrow.flatbuf.Interval|org.apache.arrow.flatbuf.LargeBinary|org.apache.arrow.flatbuf.LargeList|org.apache.arrow.flatbuf.LargeUtf8|org.apache.arrow.flatbuf.List|org.apache.arrow.flatbuf.Map|org.apache.arrow.flatbuf.Null|org.apache.arrow.flatbuf.Struct_|org.apache.arrow.flatbuf.Time|org.apache.arrow.flatbuf.Timestamp|org.apache.arrow.flatbuf.Union|org.apache.arrow.flatbuf.Utf8) => org.apache.arrow.flatbuf.Binary|org.apache.arrow.flatbuf.Bool|org.apache.arrow.flatbuf.Date|org.apache.arrow.flatbuf.Decimal|org.apache.arrow.flatbuf.Duration|org.apache.arrow.flatbuf.FixedSizeBinary|org.apache.arrow.flatbuf.FixedSizeList|org.apache.arrow.flatbuf.FloatingPoint|org.apache.arrow.flatbuf.Int|org.apache.arrow.flatbuf.Interval|org.apache.arrow.flatbuf.LargeBinary|org.apache.arrow.flatbuf.LargeList|org.apache.arrow.flatbuf.LargeUtf8|org.apache.arrow.flatbuf.List|org.apache.arrow.flatbuf.Map|org.apache.arrow.flatbuf.Null|org.apache.arrow.flatbuf.Struct_|org.apache.arrow.flatbuf.Time|org.apache.arrow.flatbuf.Timestamp|org.apache.arrow.flatbuf.Union|org.apache.arrow.flatbuf.Utf8|null
): org.apache.arrow.flatbuf.Binary|org.apache.arrow.flatbuf.Bool|org.apache.arrow.flatbuf.Date|org.apache.arrow.flatbuf.Decimal|org.apache.arrow.flatbuf.Duration|org.apache.arrow.flatbuf.FixedSizeBinary|org.apache.arrow.flatbuf.FixedSizeList|org.apache.arrow.flatbuf.FloatingPoint|org.apache.arrow.flatbuf.Int|org.apache.arrow.flatbuf.Interval|org.apache.arrow.flatbuf.LargeBinary|org.apache.arrow.flatbuf.LargeList|org.apache.arrow.flatbuf.LargeUtf8|org.apache.arrow.flatbuf.List|org.apache.arrow.flatbuf.Map|org.apache.arrow.flatbuf.Null|org.apache.arrow.flatbuf.Struct_|org.apache.arrow.flatbuf.Time|org.apache.arrow.flatbuf.Timestamp|org.apache.arrow.flatbuf.Union|org.apache.arrow.flatbuf.Utf8|null {
  switch(org.apache.arrow.flatbuf.Type[type]) {
    case 'NONE': return null; 
    case 'Null': return accessor(new org.apache.arrow.flatbuf.Null())! as org.apache.arrow.flatbuf.Null;
    case 'Int': return accessor(new org.apache.arrow.flatbuf.Int())! as org.apache.arrow.flatbuf.Int;
    case 'FloatingPoint': return accessor(new org.apache.arrow.flatbuf.FloatingPoint())! as org.apache.arrow.flatbuf.FloatingPoint;
    case 'Binary': return accessor(new org.apache.arrow.flatbuf.Binary())! as org.apache.arrow.flatbuf.Binary;
    case 'Utf8': return accessor(new org.apache.arrow.flatbuf.Utf8())! as org.apache.arrow.flatbuf.Utf8;
    case 'Bool': return accessor(new org.apache.arrow.flatbuf.Bool())! as org.apache.arrow.flatbuf.Bool;
    case 'Decimal': return accessor(new org.apache.arrow.flatbuf.Decimal())! as org.apache.arrow.flatbuf.Decimal;
    case 'Date': return accessor(new org.apache.arrow.flatbuf.Date())! as org.apache.arrow.flatbuf.Date;
    case 'Time': return accessor(new org.apache.arrow.flatbuf.Time())! as org.apache.arrow.flatbuf.Time;
    case 'Timestamp': return accessor(new org.apache.arrow.flatbuf.Timestamp())! as org.apache.arrow.flatbuf.Timestamp;
    case 'Interval': return accessor(new org.apache.arrow.flatbuf.Interval())! as org.apache.arrow.flatbuf.Interval;
    case 'List': return accessor(new org.apache.arrow.flatbuf.List())! as org.apache.arrow.flatbuf.List;
    case 'Struct_': return accessor(new org.apache.arrow.flatbuf.Struct_())! as org.apache.arrow.flatbuf.Struct_;
    case 'Union': return accessor(new org.apache.arrow.flatbuf.Union())! as org.apache.arrow.flatbuf.Union;
    case 'FixedSizeBinary': return accessor(new org.apache.arrow.flatbuf.FixedSizeBinary())! as org.apache.arrow.flatbuf.FixedSizeBinary;
    case 'FixedSizeList': return accessor(new org.apache.arrow.flatbuf.FixedSizeList())! as org.apache.arrow.flatbuf.FixedSizeList;
    case 'Map': return accessor(new org.apache.arrow.flatbuf.Map())! as org.apache.arrow.flatbuf.Map;
    case 'Duration': return accessor(new org.apache.arrow.flatbuf.Duration())! as org.apache.arrow.flatbuf.Duration;
    case 'LargeBinary': return accessor(new org.apache.arrow.flatbuf.LargeBinary())! as org.apache.arrow.flatbuf.LargeBinary;
    case 'LargeUtf8': return accessor(new org.apache.arrow.flatbuf.LargeUtf8())! as org.apache.arrow.flatbuf.LargeUtf8;
    case 'LargeList': return accessor(new org.apache.arrow.flatbuf.LargeList())! as org.apache.arrow.flatbuf.LargeList;
    default: return null;
  }
}

export function unionListToType(
  type: Type, 
  accessor: (index: number, obj:org.apache.arrow.flatbuf.Binary|org.apache.arrow.flatbuf.Bool|org.apache.arrow.flatbuf.Date|org.apache.arrow.flatbuf.Decimal|org.apache.arrow.flatbuf.Duration|org.apache.arrow.flatbuf.FixedSizeBinary|org.apache.arrow.flatbuf.FixedSizeList|org.apache.arrow.flatbuf.FloatingPoint|org.apache.arrow.flatbuf.Int|org.apache.arrow.flatbuf.Interval|org.apache.arrow.flatbuf.LargeBinary|org.apache.arrow.flatbuf.LargeList|org.apache.arrow.flatbuf.LargeUtf8|org.apache.arrow.flatbuf.List|org.apache.arrow.flatbuf.Map|org.apache.arrow.flatbuf.Null|org.apache.arrow.flatbuf.Struct_|org.apache.arrow.flatbuf.Time|org.apache.arrow.flatbuf.Timestamp|org.apache.arrow.flatbuf.Union|org.apache.arrow.flatbuf.Utf8) => org.apache.arrow.flatbuf.Binary|org.apache.arrow.flatbuf.Bool|org.apache.arrow.flatbuf.Date|org.apache.arrow.flatbuf.Decimal|org.apache.arrow.flatbuf.Duration|org.apache.arrow.flatbuf.FixedSizeBinary|org.apache.arrow.flatbuf.FixedSizeList|org.apache.arrow.flatbuf.FloatingPoint|org.apache.arrow.flatbuf.Int|org.apache.arrow.flatbuf.Interval|org.apache.arrow.flatbuf.LargeBinary|org.apache.arrow.flatbuf.LargeList|org.apache.arrow.flatbuf.LargeUtf8|org.apache.arrow.flatbuf.List|org.apache.arrow.flatbuf.Map|org.apache.arrow.flatbuf.Null|org.apache.arrow.flatbuf.Struct_|org.apache.arrow.flatbuf.Time|org.apache.arrow.flatbuf.Timestamp|org.apache.arrow.flatbuf.Union|org.apache.arrow.flatbuf.Utf8|null, 
  index: number
): org.apache.arrow.flatbuf.Binary|org.apache.arrow.flatbuf.Bool|org.apache.arrow.flatbuf.Date|org.apache.arrow.flatbuf.Decimal|org.apache.arrow.flatbuf.Duration|org.apache.arrow.flatbuf.FixedSizeBinary|org.apache.arrow.flatbuf.FixedSizeList|org.apache.arrow.flatbuf.FloatingPoint|org.apache.arrow.flatbuf.Int|org.apache.arrow.flatbuf.Interval|org.apache.arrow.flatbuf.LargeBinary|org.apache.arrow.flatbuf.LargeList|org.apache.arrow.flatbuf.LargeUtf8|org.apache.arrow.flatbuf.List|org.apache.arrow.flatbuf.Map|org.apache.arrow.flatbuf.Null|org.apache.arrow.flatbuf.Struct_|org.apache.arrow.flatbuf.Time|org.apache.arrow.flatbuf.Timestamp|org.apache.arrow.flatbuf.Union|org.apache.arrow.flatbuf.Utf8|null {
  switch(org.apache.arrow.flatbuf.Type[type]) {
    case 'NONE': return null; 
    case 'Null': return accessor(index, new org.apache.arrow.flatbuf.Null())! as org.apache.arrow.flatbuf.Null;
    case 'Int': return accessor(index, new org.apache.arrow.flatbuf.Int())! as org.apache.arrow.flatbuf.Int;
    case 'FloatingPoint': return accessor(index, new org.apache.arrow.flatbuf.FloatingPoint())! as org.apache.arrow.flatbuf.FloatingPoint;
    case 'Binary': return accessor(index, new org.apache.arrow.flatbuf.Binary())! as org.apache.arrow.flatbuf.Binary;
    case 'Utf8': return accessor(index, new org.apache.arrow.flatbuf.Utf8())! as org.apache.arrow.flatbuf.Utf8;
    case 'Bool': return accessor(index, new org.apache.arrow.flatbuf.Bool())! as org.apache.arrow.flatbuf.Bool;
    case 'Decimal': return accessor(index, new org.apache.arrow.flatbuf.Decimal())! as org.apache.arrow.flatbuf.Decimal;
    case 'Date': return accessor(index, new org.apache.arrow.flatbuf.Date())! as org.apache.arrow.flatbuf.Date;
    case 'Time': return accessor(index, new org.apache.arrow.flatbuf.Time())! as org.apache.arrow.flatbuf.Time;
    case 'Timestamp': return accessor(index, new org.apache.arrow.flatbuf.Timestamp())! as org.apache.arrow.flatbuf.Timestamp;
    case 'Interval': return accessor(index, new org.apache.arrow.flatbuf.Interval())! as org.apache.arrow.flatbuf.Interval;
    case 'List': return accessor(index, new org.apache.arrow.flatbuf.List())! as org.apache.arrow.flatbuf.List;
    case 'Struct_': return accessor(index, new org.apache.arrow.flatbuf.Struct_())! as org.apache.arrow.flatbuf.Struct_;
    case 'Union': return accessor(index, new org.apache.arrow.flatbuf.Union())! as org.apache.arrow.flatbuf.Union;
    case 'FixedSizeBinary': return accessor(index, new org.apache.arrow.flatbuf.FixedSizeBinary())! as org.apache.arrow.flatbuf.FixedSizeBinary;
    case 'FixedSizeList': return accessor(index, new org.apache.arrow.flatbuf.FixedSizeList())! as org.apache.arrow.flatbuf.FixedSizeList;
    case 'Map': return accessor(index, new org.apache.arrow.flatbuf.Map())! as org.apache.arrow.flatbuf.Map;
    case 'Duration': return accessor(index, new org.apache.arrow.flatbuf.Duration())! as org.apache.arrow.flatbuf.Duration;
    case 'LargeBinary': return accessor(index, new org.apache.arrow.flatbuf.LargeBinary())! as org.apache.arrow.flatbuf.LargeBinary;
    case 'LargeUtf8': return accessor(index, new org.apache.arrow.flatbuf.LargeUtf8())! as org.apache.arrow.flatbuf.LargeUtf8;
    case 'LargeList': return accessor(index, new org.apache.arrow.flatbuf.LargeList())! as org.apache.arrow.flatbuf.LargeList;
    default: return null;
  }
}
}

/**
 * ----------------------------------------------------------------------
 * Dictionary encoding metadata
 * Maintained for forwards compatibility, in the future
 * Dictionaries might be explicit maps between integers and values
 * allowing for non-contiguous index values
 *
 * @enum {number}
 */
export namespace org.apache.arrow.flatbuf{
export enum DictionaryKind{
  DenseArray= 0
};
}

/**
 * ----------------------------------------------------------------------
 * Endianness of the platform producing the data
 *
 * @enum {number}
 */
export namespace org.apache.arrow.flatbuf{
export enum Endianness{
  Little= 0,
  Big= 1
};
}

/**
 * These are stored in the flatbuffer in the Type union below
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Null {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Null
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Null {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Null= obj
 * @returns Null
 */
static getRootAsNull(bb:flatbuffers.ByteBuffer, obj?:Null):Null {
  return (obj || new Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Null= obj
 * @returns Null
 */
static getSizePrefixedRootAsNull(bb:flatbuffers.ByteBuffer, obj?:Null):Null {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.Builder builder
 */
static startNull(builder:flatbuffers.Builder) {
  builder.startObject(0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endNull(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createNull(builder:flatbuffers.Builder):flatbuffers.Offset {
  Null.startNull(builder);
  return Null.endNull(builder);
}
}
}
/**
 * A Struct_ in the flatbuffer metadata is the same as an Arrow Struct
 * (according to the physical memory layout). We used Struct_ here as
 * Struct is a reserved word in Flatbuffers
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Struct_ {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Struct_
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Struct_ {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Struct_= obj
 * @returns Struct_
 */
static getRootAsStruct_(bb:flatbuffers.ByteBuffer, obj?:Struct_):Struct_ {
  return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Struct_= obj
 * @returns Struct_
 */
static getSizePrefixedRootAsStruct_(bb:flatbuffers.ByteBuffer, obj?:Struct_):Struct_ {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.Builder builder
 */
static startStruct_(builder:flatbuffers.Builder) {
  builder.startObject(0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endStruct_(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createStruct_(builder:flatbuffers.Builder):flatbuffers.Offset {
  Struct_.startStruct_(builder);
  return Struct_.endStruct_(builder);
}
}
}
/**
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class List {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns List
 */
__init(i:number, bb:flatbuffers.ByteBuffer):List {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param List= obj
 * @returns List
 */
static getRootAsList(bb:flatbuffers.ByteBuffer, obj?:List):List {
  return (obj || new List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param List= obj
 * @returns List
 */
static getSizePrefixedRootAsList(bb:flatbuffers.ByteBuffer, obj?:List):List {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.Builder builder
 */
static startList(builder:flatbuffers.Builder) {
  builder.startObject(0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endList(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createList(builder:flatbuffers.Builder):flatbuffers.Offset {
  List.startList(builder);
  return List.endList(builder);
}
}
}
/**
 * Same as List, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class LargeList {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns LargeList
 */
__init(i:number, bb:flatbuffers.ByteBuffer):LargeList {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param LargeList= obj
 * @returns LargeList
 */
static getRootAsLargeList(bb:flatbuffers.ByteBuffer, obj?:LargeList):LargeList {
  return (obj || new LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param LargeList= obj
 * @returns LargeList
 */
static getSizePrefixedRootAsLargeList(bb:flatbuffers.ByteBuffer, obj?:LargeList):LargeList {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.Builder builder
 */
static startLargeList(builder:flatbuffers.Builder) {
  builder.startObject(0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endLargeList(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createLargeList(builder:flatbuffers.Builder):flatbuffers.Offset {
  LargeList.startLargeList(builder);
  return LargeList.endLargeList(builder);
}
}
}
/**
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class FixedSizeList {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns FixedSizeList
 */
__init(i:number, bb:flatbuffers.ByteBuffer):FixedSizeList {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param FixedSizeList= obj
 * @returns FixedSizeList
 */
static getRootAsFixedSizeList(bb:flatbuffers.ByteBuffer, obj?:FixedSizeList):FixedSizeList {
  return (obj || new FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param FixedSizeList= obj
 * @returns FixedSizeList
 */
static getSizePrefixedRootAsFixedSizeList(bb:flatbuffers.ByteBuffer, obj?:FixedSizeList):FixedSizeList {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * Number of list items per value
 *
 * @returns number
 */
listSize():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startFixedSizeList(builder:flatbuffers.Builder) {
  builder.startObject(1);
};

/**
 * @param flatbuffers.Builder builder
 * @param number listSize
 */
static addListSize(builder:flatbuffers.Builder, listSize:number) {
  builder.addFieldInt32(0, listSize, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endFixedSizeList(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createFixedSizeList(builder:flatbuffers.Builder, listSize:number):flatbuffers.Offset {
  FixedSizeList.startFixedSizeList(builder);
  FixedSizeList.addListSize(builder, listSize);
  return FixedSizeList.endFixedSizeList(builder);
}
}
}
/**
 * A Map is a logical nested type that is represented as
 *
 * List<entries: Struct<key: K, value: V>>
 *
 * In this layout, the keys and values are each respectively contiguous. We do
 * not constrain the key and value types, so the application is responsible
 * for ensuring that the keys are hashable and unique. Whether the keys are sorted
 * may be set in the metadata for this field.
 *
 * In a field with Map type, the field has a child Struct field, which then
 * has two children: key type and the second the value type. The names of the
 * child fields may be respectively "entries", "key", and "value", but this is
 * not enforced.
 *
 * Map
 * ```text
 *   - child[0] entries: Struct
 *     - child[0] key: K
 *     - child[1] value: V
 * ```
 * Neither the "entries" field nor the "key" field may be nullable.
 *
 * The metadata is structured so that Arrow systems without special handling
 * for Map can make Map an alias for List. The "layout" attribute for the Map
 * field must have the same contents as a List.
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Map {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Map
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Map {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Map= obj
 * @returns Map
 */
static getRootAsMap(bb:flatbuffers.ByteBuffer, obj?:Map):Map {
  return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Map= obj
 * @returns Map
 */
static getSizePrefixedRootAsMap(bb:flatbuffers.ByteBuffer, obj?:Map):Map {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * Set to true if the keys within each value are sorted
 *
 * @returns boolean
 */
keysSorted():boolean {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
};

/**
 * @param flatbuffers.Builder builder
 */
static startMap(builder:flatbuffers.Builder) {
  builder.startObject(1);
};

/**
 * @param flatbuffers.Builder builder
 * @param boolean keysSorted
 */
static addKeysSorted(builder:flatbuffers.Builder, keysSorted:boolean) {
  builder.addFieldInt8(0, +keysSorted, +false);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endMap(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createMap(builder:flatbuffers.Builder, keysSorted:boolean):flatbuffers.Offset {
  Map.startMap(builder);
  Map.addKeysSorted(builder, keysSorted);
  return Map.endMap(builder);
}
}
}
/**
 * A union is a complex type with children in Field
 * By default ids in the type vector refer to the offsets in the children
 * optionally typeIds provides an indirection between the child offset and the type id
 * for each child `typeIds[offset]` is the id used in the type vector
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Union {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Union
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Union {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Union= obj
 * @returns Union
 */
static getRootAsUnion(bb:flatbuffers.ByteBuffer, obj?:Union):Union {
  return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Union= obj
 * @returns Union
 */
static getSizePrefixedRootAsUnion(bb:flatbuffers.ByteBuffer, obj?:Union):Union {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns org.apache.arrow.flatbuf.UnionMode
 */
mode():org.apache.arrow.flatbuf.UnionMode {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readInt16(this.bb_pos + offset)) : org.apache.arrow.flatbuf.UnionMode.Sparse;
};

/**
 * @param number index
 * @returns number
 */
typeIds(index: number):number|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
};

/**
 * @returns number
 */
typeIdsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @returns Int32Array
 */
typeIdsArray():Int32Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startUnion(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param org.apache.arrow.flatbuf.UnionMode mode
 */
static addMode(builder:flatbuffers.Builder, mode:org.apache.arrow.flatbuf.UnionMode) {
  builder.addFieldInt16(0, mode, org.apache.arrow.flatbuf.UnionMode.Sparse);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset typeIdsOffset
 */
static addTypeIds(builder:flatbuffers.Builder, typeIdsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, typeIdsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<number> data
 * @returns flatbuffers.Offset
 */
static createTypeIdsVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createTypeIdsVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createTypeIdsVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startTypeIdsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endUnion(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createUnion(builder:flatbuffers.Builder, mode:org.apache.arrow.flatbuf.UnionMode, typeIdsOffset:flatbuffers.Offset):flatbuffers.Offset {
  Union.startUnion(builder);
  Union.addMode(builder, mode);
  Union.addTypeIds(builder, typeIdsOffset);
  return Union.endUnion(builder);
}
}
}
/**
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Int {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Int
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Int {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Int= obj
 * @returns Int
 */
static getRootAsInt(bb:flatbuffers.ByteBuffer, obj?:Int):Int {
  return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Int= obj
 * @returns Int
 */
static getSizePrefixedRootAsInt(bb:flatbuffers.ByteBuffer, obj?:Int):Int {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns number
 */
bitWidth():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @returns boolean
 */
isSigned():boolean {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
};

/**
 * @param flatbuffers.Builder builder
 */
static startInt(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param number bitWidth
 */
static addBitWidth(builder:flatbuffers.Builder, bitWidth:number) {
  builder.addFieldInt32(0, bitWidth, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param boolean isSigned
 */
static addIsSigned(builder:flatbuffers.Builder, isSigned:boolean) {
  builder.addFieldInt8(1, +isSigned, +false);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endInt(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createInt(builder:flatbuffers.Builder, bitWidth:number, isSigned:boolean):flatbuffers.Offset {
  Int.startInt(builder);
  Int.addBitWidth(builder, bitWidth);
  Int.addIsSigned(builder, isSigned);
  return Int.endInt(builder);
}
}
}
/**
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class FloatingPoint {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns FloatingPoint
 */
__init(i:number, bb:flatbuffers.ByteBuffer):FloatingPoint {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param FloatingPoint= obj
 * @returns FloatingPoint
 */
static getRootAsFloatingPoint(bb:flatbuffers.ByteBuffer, obj?:FloatingPoint):FloatingPoint {
  return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param FloatingPoint= obj
 * @returns FloatingPoint
 */
static getSizePrefixedRootAsFloatingPoint(bb:flatbuffers.ByteBuffer, obj?:FloatingPoint):FloatingPoint {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns org.apache.arrow.flatbuf.Precision
 */
precision():org.apache.arrow.flatbuf.Precision {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readInt16(this.bb_pos + offset)) : org.apache.arrow.flatbuf.Precision.HALF;
};

/**
 * @param flatbuffers.Builder builder
 */
static startFloatingPoint(builder:flatbuffers.Builder) {
  builder.startObject(1);
};

/**
 * @param flatbuffers.Builder builder
 * @param org.apache.arrow.flatbuf.Precision precision
 */
static addPrecision(builder:flatbuffers.Builder, precision:org.apache.arrow.flatbuf.Precision) {
  builder.addFieldInt16(0, precision, org.apache.arrow.flatbuf.Precision.HALF);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endFloatingPoint(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createFloatingPoint(builder:flatbuffers.Builder, precision:org.apache.arrow.flatbuf.Precision):flatbuffers.Offset {
  FloatingPoint.startFloatingPoint(builder);
  FloatingPoint.addPrecision(builder, precision);
  return FloatingPoint.endFloatingPoint(builder);
}
}
}
/**
 * Unicode with UTF-8 encoding
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Utf8 {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Utf8
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Utf8 {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Utf8= obj
 * @returns Utf8
 */
static getRootAsUtf8(bb:flatbuffers.ByteBuffer, obj?:Utf8):Utf8 {
  return (obj || new Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Utf8= obj
 * @returns Utf8
 */
static getSizePrefixedRootAsUtf8(bb:flatbuffers.ByteBuffer, obj?:Utf8):Utf8 {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.Builder builder
 */
static startUtf8(builder:flatbuffers.Builder) {
  builder.startObject(0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endUtf8(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createUtf8(builder:flatbuffers.Builder):flatbuffers.Offset {
  Utf8.startUtf8(builder);
  return Utf8.endUtf8(builder);
}
}
}
/**
 * Opaque binary data
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Binary {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Binary
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Binary {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Binary= obj
 * @returns Binary
 */
static getRootAsBinary(bb:flatbuffers.ByteBuffer, obj?:Binary):Binary {
  return (obj || new Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Binary= obj
 * @returns Binary
 */
static getSizePrefixedRootAsBinary(bb:flatbuffers.ByteBuffer, obj?:Binary):Binary {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.Builder builder
 */
static startBinary(builder:flatbuffers.Builder) {
  builder.startObject(0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endBinary(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createBinary(builder:flatbuffers.Builder):flatbuffers.Offset {
  Binary.startBinary(builder);
  return Binary.endBinary(builder);
}
}
}
/**
 * Same as Utf8, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class LargeUtf8 {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns LargeUtf8
 */
__init(i:number, bb:flatbuffers.ByteBuffer):LargeUtf8 {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param LargeUtf8= obj
 * @returns LargeUtf8
 */
static getRootAsLargeUtf8(bb:flatbuffers.ByteBuffer, obj?:LargeUtf8):LargeUtf8 {
  return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param LargeUtf8= obj
 * @returns LargeUtf8
 */
static getSizePrefixedRootAsLargeUtf8(bb:flatbuffers.ByteBuffer, obj?:LargeUtf8):LargeUtf8 {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.Builder builder
 */
static startLargeUtf8(builder:flatbuffers.Builder) {
  builder.startObject(0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endLargeUtf8(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createLargeUtf8(builder:flatbuffers.Builder):flatbuffers.Offset {
  LargeUtf8.startLargeUtf8(builder);
  return LargeUtf8.endLargeUtf8(builder);
}
}
}
/**
 * Same as Binary, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class LargeBinary {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns LargeBinary
 */
__init(i:number, bb:flatbuffers.ByteBuffer):LargeBinary {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param LargeBinary= obj
 * @returns LargeBinary
 */
static getRootAsLargeBinary(bb:flatbuffers.ByteBuffer, obj?:LargeBinary):LargeBinary {
  return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param LargeBinary= obj
 * @returns LargeBinary
 */
static getSizePrefixedRootAsLargeBinary(bb:flatbuffers.ByteBuffer, obj?:LargeBinary):LargeBinary {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.Builder builder
 */
static startLargeBinary(builder:flatbuffers.Builder) {
  builder.startObject(0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endLargeBinary(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createLargeBinary(builder:flatbuffers.Builder):flatbuffers.Offset {
  LargeBinary.startLargeBinary(builder);
  return LargeBinary.endLargeBinary(builder);
}
}
}
/**
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class FixedSizeBinary {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns FixedSizeBinary
 */
__init(i:number, bb:flatbuffers.ByteBuffer):FixedSizeBinary {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param FixedSizeBinary= obj
 * @returns FixedSizeBinary
 */
static getRootAsFixedSizeBinary(bb:flatbuffers.ByteBuffer, obj?:FixedSizeBinary):FixedSizeBinary {
  return (obj || new FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param FixedSizeBinary= obj
 * @returns FixedSizeBinary
 */
static getSizePrefixedRootAsFixedSizeBinary(bb:flatbuffers.ByteBuffer, obj?:FixedSizeBinary):FixedSizeBinary {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * Number of bytes per value
 *
 * @returns number
 */
byteWidth():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startFixedSizeBinary(builder:flatbuffers.Builder) {
  builder.startObject(1);
};

/**
 * @param flatbuffers.Builder builder
 * @param number byteWidth
 */
static addByteWidth(builder:flatbuffers.Builder, byteWidth:number) {
  builder.addFieldInt32(0, byteWidth, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endFixedSizeBinary(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createFixedSizeBinary(builder:flatbuffers.Builder, byteWidth:number):flatbuffers.Offset {
  FixedSizeBinary.startFixedSizeBinary(builder);
  FixedSizeBinary.addByteWidth(builder, byteWidth);
  return FixedSizeBinary.endFixedSizeBinary(builder);
}
}
}
/**
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Bool {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Bool
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Bool {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Bool= obj
 * @returns Bool
 */
static getRootAsBool(bb:flatbuffers.ByteBuffer, obj?:Bool):Bool {
  return (obj || new Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Bool= obj
 * @returns Bool
 */
static getSizePrefixedRootAsBool(bb:flatbuffers.ByteBuffer, obj?:Bool):Bool {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.Builder builder
 */
static startBool(builder:flatbuffers.Builder) {
  builder.startObject(0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endBool(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createBool(builder:flatbuffers.Builder):flatbuffers.Offset {
  Bool.startBool(builder);
  return Bool.endBool(builder);
}
}
}
/**
 * Exact decimal value represented as an integer value in two's
 * complement. Currently only 128-bit (16-byte) and 256-bit (32-byte) integers
 * are used. The representation uses the endianness indicated
 * in the Schema.
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Decimal {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Decimal
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Decimal {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Decimal= obj
 * @returns Decimal
 */
static getRootAsDecimal(bb:flatbuffers.ByteBuffer, obj?:Decimal):Decimal {
  return (obj || new Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Decimal= obj
 * @returns Decimal
 */
static getSizePrefixedRootAsDecimal(bb:flatbuffers.ByteBuffer, obj?:Decimal):Decimal {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * Total number of decimal digits
 *
 * @returns number
 */
precision():number {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * Number of digits after the decimal point "."
 *
 * @returns number
 */
scale():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
};

/**
 * Number of bits per value. The only accepted widths are 128 and 256.
 * We use bitWidth for consistency with Int::bitWidth.
 *
 * @returns number
 */
bitWidth():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 128;
};

/**
 * @param flatbuffers.Builder builder
 */
static startDecimal(builder:flatbuffers.Builder) {
  builder.startObject(3);
};

/**
 * @param flatbuffers.Builder builder
 * @param number precision
 */
static addPrecision(builder:flatbuffers.Builder, precision:number) {
  builder.addFieldInt32(0, precision, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number scale
 */
static addScale(builder:flatbuffers.Builder, scale:number) {
  builder.addFieldInt32(1, scale, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param number bitWidth
 */
static addBitWidth(builder:flatbuffers.Builder, bitWidth:number) {
  builder.addFieldInt32(2, bitWidth, 128);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endDecimal(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createDecimal(builder:flatbuffers.Builder, precision:number, scale:number, bitWidth:number):flatbuffers.Offset {
  Decimal.startDecimal(builder);
  Decimal.addPrecision(builder, precision);
  Decimal.addScale(builder, scale);
  Decimal.addBitWidth(builder, bitWidth);
  return Decimal.endDecimal(builder);
}
}
}
/**
 * Date is either a 32-bit or 64-bit type representing elapsed time since UNIX
 * epoch (1970-01-01), stored in either of two units:
 *
 * * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no
 *   leap seconds), where the values are evenly divisible by 86400000
 * * Days (32 bits) since the UNIX epoch
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Date {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Date
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Date {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Date= obj
 * @returns Date
 */
static getRootAsDate(bb:flatbuffers.ByteBuffer, obj?:Date):Date {
  return (obj || new Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Date= obj
 * @returns Date
 */
static getSizePrefixedRootAsDate(bb:flatbuffers.ByteBuffer, obj?:Date):Date {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns org.apache.arrow.flatbuf.DateUnit
 */
unit():org.apache.arrow.flatbuf.DateUnit {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readInt16(this.bb_pos + offset)) : org.apache.arrow.flatbuf.DateUnit.MILLISECOND;
};

/**
 * @param flatbuffers.Builder builder
 */
static startDate(builder:flatbuffers.Builder) {
  builder.startObject(1);
};

/**
 * @param flatbuffers.Builder builder
 * @param org.apache.arrow.flatbuf.DateUnit unit
 */
static addUnit(builder:flatbuffers.Builder, unit:org.apache.arrow.flatbuf.DateUnit) {
  builder.addFieldInt16(0, unit, org.apache.arrow.flatbuf.DateUnit.MILLISECOND);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endDate(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createDate(builder:flatbuffers.Builder, unit:org.apache.arrow.flatbuf.DateUnit):flatbuffers.Offset {
  Date.startDate(builder);
  Date.addUnit(builder, unit);
  return Date.endDate(builder);
}
}
}
/**
 * Time type. The physical storage type depends on the unit
 * - SECOND and MILLISECOND: 32 bits
 * - MICROSECOND and NANOSECOND: 64 bits
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Time {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Time
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Time {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Time= obj
 * @returns Time
 */
static getRootAsTime(bb:flatbuffers.ByteBuffer, obj?:Time):Time {
  return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Time= obj
 * @returns Time
 */
static getSizePrefixedRootAsTime(bb:flatbuffers.ByteBuffer, obj?:Time):Time {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns org.apache.arrow.flatbuf.TimeUnit
 */
unit():org.apache.arrow.flatbuf.TimeUnit {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readInt16(this.bb_pos + offset)) : org.apache.arrow.flatbuf.TimeUnit.MILLISECOND;
};

/**
 * @returns number
 */
bitWidth():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 32;
};

/**
 * @param flatbuffers.Builder builder
 */
static startTime(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param org.apache.arrow.flatbuf.TimeUnit unit
 */
static addUnit(builder:flatbuffers.Builder, unit:org.apache.arrow.flatbuf.TimeUnit) {
  builder.addFieldInt16(0, unit, org.apache.arrow.flatbuf.TimeUnit.MILLISECOND);
};

/**
 * @param flatbuffers.Builder builder
 * @param number bitWidth
 */
static addBitWidth(builder:flatbuffers.Builder, bitWidth:number) {
  builder.addFieldInt32(1, bitWidth, 32);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endTime(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createTime(builder:flatbuffers.Builder, unit:org.apache.arrow.flatbuf.TimeUnit, bitWidth:number):flatbuffers.Offset {
  Time.startTime(builder);
  Time.addUnit(builder, unit);
  Time.addBitWidth(builder, bitWidth);
  return Time.endTime(builder);
}
}
}
/**
 * Time elapsed from the Unix epoch, 00:00:00.000 on 1 January 1970, excluding
 * leap seconds, as a 64-bit integer. Note that UNIX time does not include
 * leap seconds.
 *
 * Date & time libraries often have multiple different data types for temporal
 * data.  In order to ease interoperability between different implementations the
 * Arrow project has some recommendations for encoding these types into a Timestamp
 * column.
 *
 * An "instant" represents a single moment in time that has no meaningful time zone
 * or the time zone is unknown.  A column of instants can also contain values from
 * multiple time zones.  To encode an instant set the timezone string to "UTC".
 *
 * A "zoned date-time" represents a single moment in time that has a meaningful
 * reference time zone.  To encode a zoned date-time as a Timestamp set the timezone
 * string to the name of the timezone.  There is some ambiguity between an instant
 * and a zoned date-time with the UTC time zone.  Both of these are stored the same.
 * Typically, this distinction does not matter.  If it does, then an application should
 * use custom metadata or an extension type to distinguish between the two cases.
 *
 * An "offset date-time" represents a single moment in time combined with a meaningful
 * offset from UTC.  To encode an offset date-time as a Timestamp set the timezone string
 * to the numeric time zone offset string (e.g. "+03:00").
 *
 * A "local date-time" does not represent a single moment in time.  It represents a wall
 * clock time combined with a date.  Because of daylight savings time there may multiple
 * instants that correspond to a single local date-time in any given time zone.  A
 * local date-time is often stored as a struct or a Date32/Time64 pair.  However, it can
 * also be encoded into a Timestamp column.  To do so the value should be the the time
 * elapsed from the Unix epoch so that a wall clock in UTC would display the desired time.
 * The timezone string should be set to null or the empty string.
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Timestamp {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Timestamp
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Timestamp {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Timestamp= obj
 * @returns Timestamp
 */
static getRootAsTimestamp(bb:flatbuffers.ByteBuffer, obj?:Timestamp):Timestamp {
  return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Timestamp= obj
 * @returns Timestamp
 */
static getSizePrefixedRootAsTimestamp(bb:flatbuffers.ByteBuffer, obj?:Timestamp):Timestamp {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns org.apache.arrow.flatbuf.TimeUnit
 */
unit():org.apache.arrow.flatbuf.TimeUnit {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readInt16(this.bb_pos + offset)) : org.apache.arrow.flatbuf.TimeUnit.SECOND;
};

/**
 * The time zone is a string indicating the name of a time zone, one of:
 *
 * * As used in the Olson time zone database (the "tz database" or
 *   "tzdata"), such as "America/New_York"
 * * An absolute time zone offset of the form +XX:XX or -XX:XX, such as +07:30
 *
 * Whether a timezone string is present indicates different semantics about
 * the data:
 *
 * * If the time zone is null or an empty string, the data is a local date-time
 *   and does not represent a single moment in time.  Instead it represents a wall clock
 *   time and care should be taken to avoid interpreting it semantically as an instant.
 *
 * * If the time zone is set to a valid value, values can be displayed as
 *   "localized" to that time zone, even though the underlying 64-bit
 *   integers are identical to the same data stored in UTC. Converting
 *   between time zones is a metadata-only operation and does not change the
 *   underlying values
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
timezone():string|null
timezone(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
timezone(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startTimestamp(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param org.apache.arrow.flatbuf.TimeUnit unit
 */
static addUnit(builder:flatbuffers.Builder, unit:org.apache.arrow.flatbuf.TimeUnit) {
  builder.addFieldInt16(0, unit, org.apache.arrow.flatbuf.TimeUnit.SECOND);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset timezoneOffset
 */
static addTimezone(builder:flatbuffers.Builder, timezoneOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, timezoneOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endTimestamp(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createTimestamp(builder:flatbuffers.Builder, unit:org.apache.arrow.flatbuf.TimeUnit, timezoneOffset:flatbuffers.Offset):flatbuffers.Offset {
  Timestamp.startTimestamp(builder);
  Timestamp.addUnit(builder, unit);
  Timestamp.addTimezone(builder, timezoneOffset);
  return Timestamp.endTimestamp(builder);
}
}
}
/**
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Interval {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Interval
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Interval {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Interval= obj
 * @returns Interval
 */
static getRootAsInterval(bb:flatbuffers.ByteBuffer, obj?:Interval):Interval {
  return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Interval= obj
 * @returns Interval
 */
static getSizePrefixedRootAsInterval(bb:flatbuffers.ByteBuffer, obj?:Interval):Interval {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns org.apache.arrow.flatbuf.IntervalUnit
 */
unit():org.apache.arrow.flatbuf.IntervalUnit {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readInt16(this.bb_pos + offset)) : org.apache.arrow.flatbuf.IntervalUnit.YEAR_MONTH;
};

/**
 * @param flatbuffers.Builder builder
 */
static startInterval(builder:flatbuffers.Builder) {
  builder.startObject(1);
};

/**
 * @param flatbuffers.Builder builder
 * @param org.apache.arrow.flatbuf.IntervalUnit unit
 */
static addUnit(builder:flatbuffers.Builder, unit:org.apache.arrow.flatbuf.IntervalUnit) {
  builder.addFieldInt16(0, unit, org.apache.arrow.flatbuf.IntervalUnit.YEAR_MONTH);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endInterval(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createInterval(builder:flatbuffers.Builder, unit:org.apache.arrow.flatbuf.IntervalUnit):flatbuffers.Offset {
  Interval.startInterval(builder);
  Interval.addUnit(builder, unit);
  return Interval.endInterval(builder);
}
}
}
/**
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Duration {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Duration
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Duration {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Duration= obj
 * @returns Duration
 */
static getRootAsDuration(bb:flatbuffers.ByteBuffer, obj?:Duration):Duration {
  return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Duration= obj
 * @returns Duration
 */
static getSizePrefixedRootAsDuration(bb:flatbuffers.ByteBuffer, obj?:Duration):Duration {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @returns org.apache.arrow.flatbuf.TimeUnit
 */
unit():org.apache.arrow.flatbuf.TimeUnit {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readInt16(this.bb_pos + offset)) : org.apache.arrow.flatbuf.TimeUnit.MILLISECOND;
};

/**
 * @param flatbuffers.Builder builder
 */
static startDuration(builder:flatbuffers.Builder) {
  builder.startObject(1);
};

/**
 * @param flatbuffers.Builder builder
 * @param org.apache.arrow.flatbuf.TimeUnit unit
 */
static addUnit(builder:flatbuffers.Builder, unit:org.apache.arrow.flatbuf.TimeUnit) {
  builder.addFieldInt16(0, unit, org.apache.arrow.flatbuf.TimeUnit.MILLISECOND);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endDuration(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createDuration(builder:flatbuffers.Builder, unit:org.apache.arrow.flatbuf.TimeUnit):flatbuffers.Offset {
  Duration.startDuration(builder);
  Duration.addUnit(builder, unit);
  return Duration.endDuration(builder);
}
}
}
/**
 * ----------------------------------------------------------------------
 * user defined key value pairs to add custom metadata to arrow
 * key namespacing is the responsibility of the user
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class KeyValue {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns KeyValue
 */
__init(i:number, bb:flatbuffers.ByteBuffer):KeyValue {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param KeyValue= obj
 * @returns KeyValue
 */
static getRootAsKeyValue(bb:flatbuffers.ByteBuffer, obj?:KeyValue):KeyValue {
  return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param KeyValue= obj
 * @returns KeyValue
 */
static getSizePrefixedRootAsKeyValue(bb:flatbuffers.ByteBuffer, obj?:KeyValue):KeyValue {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
key():string|null
key(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
key(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
value():string|null
value(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
value(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * @param flatbuffers.Builder builder
 */
static startKeyValue(builder:flatbuffers.Builder) {
  builder.startObject(2);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset keyOffset
 */
static addKey(builder:flatbuffers.Builder, keyOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, keyOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset valueOffset
 */
static addValue(builder:flatbuffers.Builder, valueOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, valueOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endKeyValue(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

static createKeyValue(builder:flatbuffers.Builder, keyOffset:flatbuffers.Offset, valueOffset:flatbuffers.Offset):flatbuffers.Offset {
  KeyValue.startKeyValue(builder);
  KeyValue.addKey(builder, keyOffset);
  KeyValue.addValue(builder, valueOffset);
  return KeyValue.endKeyValue(builder);
}
}
}
/**
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class DictionaryEncoding {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns DictionaryEncoding
 */
__init(i:number, bb:flatbuffers.ByteBuffer):DictionaryEncoding {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param DictionaryEncoding= obj
 * @returns DictionaryEncoding
 */
static getRootAsDictionaryEncoding(bb:flatbuffers.ByteBuffer, obj?:DictionaryEncoding):DictionaryEncoding {
  return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param DictionaryEncoding= obj
 * @returns DictionaryEncoding
 */
static getSizePrefixedRootAsDictionaryEncoding(bb:flatbuffers.ByteBuffer, obj?:DictionaryEncoding):DictionaryEncoding {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * The known dictionary id in the application where this data is used. In
 * the file or streaming formats, the dictionary ids are found in the
 * DictionaryBatch messages
 *
 * @returns flatbuffers.Long
 */
id():flatbuffers.Long {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt64(this.bb_pos + offset) : this.bb!.createLong(0, 0);
};

/**
 * The dictionary indices are constrained to be non-negative integers. If
 * this field is null, the indices must be signed int32. To maximize
 * cross-language compatibility and performance, implementations are
 * recommended to prefer signed integer types over unsigned integer types
 * and to avoid uint64 indices unless they are required by an application.
 *
 * @param org.apache.arrow.flatbuf.Int= obj
 * @returns org.apache.arrow.flatbuf.Int|null
 */
indexType(obj?:org.apache.arrow.flatbuf.Int):org.apache.arrow.flatbuf.Int|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new org.apache.arrow.flatbuf.Int()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * By default, dictionaries are not ordered, or the order does not have
 * semantic meaning. In some statistical, applications, dictionary-encoding
 * is used to represent ordered categorical data, and we provide a way to
 * preserve that metadata here
 *
 * @returns boolean
 */
isOrdered():boolean {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
};

/**
 * @returns org.apache.arrow.flatbuf.DictionaryKind
 */
dictionaryKind():org.apache.arrow.flatbuf.DictionaryKind {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? /**  */ (this.bb!.readInt16(this.bb_pos + offset)) : org.apache.arrow.flatbuf.DictionaryKind.DenseArray;
};

/**
 * @param flatbuffers.Builder builder
 */
static startDictionaryEncoding(builder:flatbuffers.Builder) {
  builder.startObject(4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Long id
 */
static addId(builder:flatbuffers.Builder, id:flatbuffers.Long) {
  builder.addFieldInt64(0, id, builder.createLong(0, 0));
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset indexTypeOffset
 */
static addIndexType(builder:flatbuffers.Builder, indexTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, indexTypeOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param boolean isOrdered
 */
static addIsOrdered(builder:flatbuffers.Builder, isOrdered:boolean) {
  builder.addFieldInt8(2, +isOrdered, +false);
};

/**
 * @param flatbuffers.Builder builder
 * @param org.apache.arrow.flatbuf.DictionaryKind dictionaryKind
 */
static addDictionaryKind(builder:flatbuffers.Builder, dictionaryKind:org.apache.arrow.flatbuf.DictionaryKind) {
  builder.addFieldInt16(3, dictionaryKind, org.apache.arrow.flatbuf.DictionaryKind.DenseArray);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endDictionaryEncoding(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

}
}
/**
 * ----------------------------------------------------------------------
 * A field represents a named column in a record / row batch or child of a
 * nested type.
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Field {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Field
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Field {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Field= obj
 * @returns Field
 */
static getRootAsField(bb:flatbuffers.ByteBuffer, obj?:Field):Field {
  return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Field= obj
 * @returns Field
 */
static getSizePrefixedRootAsField(bb:flatbuffers.ByteBuffer, obj?:Field):Field {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * Name is not required, in i.e. a List
 *
 * @param flatbuffers.Encoding= optionalEncoding
 * @returns string|Uint8Array|null
 */
name():string|null
name(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
name(optionalEncoding?:any):string|Uint8Array|null {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
};

/**
 * Whether or not this field can contain nulls. Should be true in general.
 *
 * @returns boolean
 */
nullable():boolean {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
};

/**
 * @returns org.apache.arrow.flatbuf.Type
 */
typeType():org.apache.arrow.flatbuf.Type {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? /**  */ (this.bb!.readUint8(this.bb_pos + offset)) : org.apache.arrow.flatbuf.Type.NONE;
};

/**
 * This is the type of the decoded value if the field is dictionary encoded.
 *
 * @param flatbuffers.Table obj
 * @returns ?flatbuffers.Table
 */
type<T extends flatbuffers.Table>(obj:T):T|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
};

/**
 * Present only if the field is dictionary encoded.
 *
 * @param org.apache.arrow.flatbuf.DictionaryEncoding= obj
 * @returns org.apache.arrow.flatbuf.DictionaryEncoding|null
 */
dictionary(obj?:org.apache.arrow.flatbuf.DictionaryEncoding):org.apache.arrow.flatbuf.DictionaryEncoding|null {
  var offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new org.apache.arrow.flatbuf.DictionaryEncoding()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;
};

/**
 * children apply only to nested data types like Struct, List and Union. For
 * primitive types children will have length 0.
 *
 * @param number index
 * @param org.apache.arrow.flatbuf.Field= obj
 * @returns org.apache.arrow.flatbuf.Field
 */
children(index: number, obj?:org.apache.arrow.flatbuf.Field):org.apache.arrow.flatbuf.Field|null {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? (obj || new org.apache.arrow.flatbuf.Field()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
childrenLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * User-defined metadata
 *
 * @param number index
 * @param org.apache.arrow.flatbuf.KeyValue= obj
 * @returns org.apache.arrow.flatbuf.KeyValue
 */
customMetadata(index: number, obj?:org.apache.arrow.flatbuf.KeyValue):org.apache.arrow.flatbuf.KeyValue|null {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? (obj || new org.apache.arrow.flatbuf.KeyValue()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
customMetadataLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startField(builder:flatbuffers.Builder) {
  builder.startObject(7);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset nameOffset
 */
static addName(builder:flatbuffers.Builder, nameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, nameOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param boolean nullable
 */
static addNullable(builder:flatbuffers.Builder, nullable:boolean) {
  builder.addFieldInt8(1, +nullable, +false);
};

/**
 * @param flatbuffers.Builder builder
 * @param org.apache.arrow.flatbuf.Type typeType
 */
static addTypeType(builder:flatbuffers.Builder, typeType:org.apache.arrow.flatbuf.Type) {
  builder.addFieldInt8(2, typeType, org.apache.arrow.flatbuf.Type.NONE);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset typeOffset
 */
static addType(builder:flatbuffers.Builder, typeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, typeOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset dictionaryOffset
 */
static addDictionary(builder:flatbuffers.Builder, dictionaryOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, dictionaryOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset childrenOffset
 */
static addChildren(builder:flatbuffers.Builder, childrenOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, childrenOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createChildrenVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startChildrenVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset customMetadataOffset
 */
static addCustomMetadata(builder:flatbuffers.Builder, customMetadataOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, customMetadataOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createCustomMetadataVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startCustomMetadataVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endField(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

}
}
/**
 * ----------------------------------------------------------------------
 * A Buffer represents a single contiguous memory segment
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Buffer {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Buffer
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Buffer {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * The relative offset into the shared memory page where the bytes for this
 * buffer starts
 *
 * @returns flatbuffers.Long
 */
offset():flatbuffers.Long {
  return this.bb!.readInt64(this.bb_pos);
};

/**
 * The absolute length (in bytes) of the memory buffer. The memory is found
 * from offset (inclusive) to offset + length (non-inclusive). When building
 * messages using the encapsulated IPC message, padding bytes may be written
 * after a buffer, but such padding bytes do not need to be accounted for in
 * the size here.
 *
 * @returns flatbuffers.Long
 */
length():flatbuffers.Long {
  return this.bb!.readInt64(this.bb_pos + 8);
};

/**
 * @returns number
 */
static sizeOf():number {
  return 16;
}

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Long offset
 * @param flatbuffers.Long length
 * @returns flatbuffers.Offset
 */
static createBuffer(builder:flatbuffers.Builder, offset: flatbuffers.Long, length: flatbuffers.Long):flatbuffers.Offset {
  builder.prep(8, 16);
  builder.writeInt64(length);
  builder.writeInt64(offset);
  return builder.offset();
};

}
}
/**
 * ----------------------------------------------------------------------
 * A Schema describes the columns in a row batch
 *
 * @constructor
 */
export namespace org.apache.arrow.flatbuf{
export class Schema {
  bb: flatbuffers.ByteBuffer|null = null;

  bb_pos:number = 0;
/**
 * @param number i
 * @param flatbuffers.ByteBuffer bb
 * @returns Schema
 */
__init(i:number, bb:flatbuffers.ByteBuffer):Schema {
  this.bb_pos = i;
  this.bb = bb;
  return this;
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Schema= obj
 * @returns Schema
 */
static getRootAsSchema(bb:flatbuffers.ByteBuffer, obj?:Schema):Schema {
  return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * @param flatbuffers.ByteBuffer bb
 * @param Schema= obj
 * @returns Schema
 */
static getSizePrefixedRootAsSchema(bb:flatbuffers.ByteBuffer, obj?:Schema):Schema {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
};

/**
 * endianness of the buffer
 * it is Little Endian by default
 * if endianness doesn't match the underlying system then the vectors need to be converted
 *
 * @returns org.apache.arrow.flatbuf.Endianness
 */
endianness():org.apache.arrow.flatbuf.Endianness {
  var offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? /**  */ (this.bb!.readInt16(this.bb_pos + offset)) : org.apache.arrow.flatbuf.Endianness.Little;
};

/**
 * @param number index
 * @param org.apache.arrow.flatbuf.Field= obj
 * @returns org.apache.arrow.flatbuf.Field
 */
fields(index: number, obj?:org.apache.arrow.flatbuf.Field):org.apache.arrow.flatbuf.Field|null {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? (obj || new org.apache.arrow.flatbuf.Field()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
fieldsLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @param number index
 * @param org.apache.arrow.flatbuf.KeyValue= obj
 * @returns org.apache.arrow.flatbuf.KeyValue
 */
customMetadata(index: number, obj?:org.apache.arrow.flatbuf.KeyValue):org.apache.arrow.flatbuf.KeyValue|null {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? (obj || new org.apache.arrow.flatbuf.KeyValue()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
};

/**
 * @returns number
 */
customMetadataLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * Features used in the stream/file.
 *
 * @param number index
 * @returns flatbuffers.Long
 */
features(index: number):flatbuffers.Long|null {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? /**  */ (this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8)) : this.bb!.createLong(0, 0);
};

/**
 * @returns number
 */
featuresLength():number {
  var offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
};

/**
 * @param flatbuffers.Builder builder
 */
static startSchema(builder:flatbuffers.Builder) {
  builder.startObject(4);
};

/**
 * @param flatbuffers.Builder builder
 * @param org.apache.arrow.flatbuf.Endianness endianness
 */
static addEndianness(builder:flatbuffers.Builder, endianness:org.apache.arrow.flatbuf.Endianness) {
  builder.addFieldInt16(0, endianness, org.apache.arrow.flatbuf.Endianness.Little);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset fieldsOffset
 */
static addFields(builder:flatbuffers.Builder, fieldsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, fieldsOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createFieldsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startFieldsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset customMetadataOffset
 */
static addCustomMetadata(builder:flatbuffers.Builder, customMetadataOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, customMetadataOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Offset> data
 * @returns flatbuffers.Offset
 */
static createCustomMetadataVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startCustomMetadataVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset featuresOffset
 */
static addFeatures(builder:flatbuffers.Builder, featuresOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, featuresOffset, 0);
};

/**
 * @param flatbuffers.Builder builder
 * @param Array.<flatbuffers.Long> data
 * @returns flatbuffers.Offset
 */
static createFeaturesVector(builder:flatbuffers.Builder, data:flatbuffers.Long[]):flatbuffers.Offset {
  builder.startVector(8, data.length, 8);
  for (var i = data.length - 1; i >= 0; i--) {
    builder.addInt64(data[i]);
  }
  return builder.endVector();
};

/**
 * @param flatbuffers.Builder builder
 * @param number numElems
 */
static startFeaturesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(8, numElems, 8);
};

/**
 * @param flatbuffers.Builder builder
 * @returns flatbuffers.Offset
 */
static endSchema(builder:flatbuffers.Builder):flatbuffers.Offset {
  var offset = builder.endObject();
  return offset;
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset offset
 */
static finishSchemaBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset);
};

/**
 * @param flatbuffers.Builder builder
 * @param flatbuffers.Offset offset
 */
static finishSizePrefixedSchemaBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, undefined, true);
};

static createSchema(builder:flatbuffers.Builder, endianness:org.apache.arrow.flatbuf.Endianness, fieldsOffset:flatbuffers.Offset, customMetadataOffset:flatbuffers.Offset, featuresOffset:flatbuffers.Offset):flatbuffers.Offset {
  Schema.startSchema(builder);
  Schema.addEndianness(builder, endianness);
  Schema.addFields(builder, fieldsOffset);
  Schema.addCustomMetadata(builder, customMetadataOffset);
  Schema.addFeatures(builder, featuresOffset);
  return Schema.endSchema(builder);
}
}
}
