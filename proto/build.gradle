// keep this in sync w/ shadowed/proto/shadow-proto.gradle
def grpcVersion = '1.38.0'
def protobufVersion = '3.17.3'
def protocVersion = protobufVersion
def boringSslVersion = '2.0.34.Final'

// by convention, all subprojects have junit testing
subprojects {
  configurations {
    testCompile.extendsFrom junit
  }
}

// by convention, all subprojects that start with "proto-" will have the default protobuf settings applied
configure(subprojects.findAll{ it.name.startsWith('proto-') }) { p ->
  dependencies {
    compile "com.google.protobuf:protobuf-java:${protobufVersion}"

    compile "io.grpc:grpc-protobuf:${grpcVersion}"
    compile "io.grpc:grpc-stub:${grpcVersion}"
    compile "io.grpc:grpc-services:${grpcVersion}"

    compile "io.grpc:grpc-testing:${grpcVersion}"

    compile "io.grpc:grpc-netty:${grpcVersion}"

    runtimeOnly "io.netty:netty-tcnative-boringssl-static:${boringSslVersion}"
  }
}

// when running `./gradlew fixIj`, we need to run proto generators, for non-delegate-to-gradle builds.
def fixIj = tasks.maybeCreate('fixIj')
// by convention, all subprojects that end with "-grpc" will have the default grpc settings applied
configure(subprojects.findAll{ it.name.endsWith('-grpc') }) {
  dependencies {
    compileOnly "javax.annotation:javax.annotation-api:1.3.1"
  }
}

// let's make this project a lifecycle orchestrator for its children
// ie
// `./gradlew proto:build`
// will build all the children
clean.dependsOn(subprojects.collect { it.tasks.named('clean') })
check.dependsOn(subprojects.collect { it.tasks.named('check') })
assemble.dependsOn(subprojects.collect { it.tasks.named('assemble') })
build.dependsOn(subprojects.collect { it.tasks.named('build') })


// This code is just to keep old stuff compiling, even though we shouldn't need it for OSS
// TODO: delete when appropriate

configure(subprojects.findAll{ it.name.startsWith('proto-') && it.name != 'proto-backplane-grpc' }) { p ->
  apply plugin: 'com.google.protobuf'

  sourceSets {
    main {
      java {
        srcDirs "${protobuf.generatedFilesBaseDir}/main/java"
      }
    }
    test {
      java {
        srcDirs "${protobuf.generatedFilesBaseDir}/test/java"
      }
    }
  }

  protobuf {
    protoc { artifact = "com.google.protobuf:protoc:${protocVersion}" }
    plugins {
      grpc { artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}" }
    }
    generateProtoTasks {
      all().each {
        generateProtoTask ->
          // https://github.com/google/protobuf-gradle-plugin/issues/180 suggests that the following
          // might be necessary. I haven't found that to be the case (yet), but if we are running
          // into situations where generateProto is not getting invoked, this would workaround it.
          //generateProtoTask.outputs.upToDateWhen { false }

          // The generateProto task does not seem to properly clean its previously generated outputs.
          // See IDS-5480 for reproducibility.
          // See https://github.com/google/protobuf-gradle-plugin/issues/332
          // See https://github.com/google/protobuf-gradle-plugin/issues/331
          generateProtoTask.doFirst {
            delete generateProtoTask.outputs
          }
      }
    }
  }
}

configure(subprojects.findAll{ it.name.endsWith('-grpc') && it.name != 'proto-backplane-grpc' }) {
  sourceSets {
    main {
      java {
        srcDirs "${protobuf.generatedFilesBaseDir}/main/grpc"
      }
    }
    test {
      java {
        srcDirs "${protobuf.generatedFilesBaseDir}/test/grpc"
      }
    }
  }

  protobuf {
    plugins {
      grpc { artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}" }
    }
    generateProtoTasks {
      all().each {
        generateProtoTask ->
          generateProtoTask.plugins {
            grpc {}
          }
          fixIj.dependsOn generateProtoTask
      }
    }
  }
}