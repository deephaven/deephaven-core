plugins {
    id 'java'
    id 'application'
    id 'io.quarkus'
    id 'io.deephaven.project.register'
}

application {
    mainClassName = 'io.deephaven.demo.control.DhDemoServer'
}

run {
    environment("IS_CONTROLLER", System.getenv("IS_CONTROLLER") ?: "true")
    environment("COOKIE_DOMAIN", "localhost")
    environment("ALLOW_ADDRESS_LOOKUP", "false")
}

// we use withType(JavaExec) to catch intellij-created run configurations
tasks.withType(JavaExec).configureEach {
    JavaExec exe ->
        // see https://vertx.io/docs/vertx-web/java/
        // setting this here ensures local gradle runs won't cache things,
        // but running in a production container (not a gradle JavaExec), we let it cache
        exe.systemProperty("vertxweb.environment", "dev")
        exe.systemProperty("dh-helm-root", new File(projectDir, "helm").absolutePath)
        exe.systemProperty("dh-helm-mode", "generate")
        exe.systemProperty("dh-helm-target", new File(buildDir, "helm").absolutePath)
        exe.environment("IS_CONTROLLER", System.getenv("IS_CONTROLLER") ?: "true")
}

dependencies {
    implementation project(':demo-gcloud')

    String quarkusGroup = findProperty('quarkusPlatformGroupId')
    String quarkusArtifact = findProperty('quarkusPlatformArtifactId')
    String quarkusVersion = findProperty('quarkusPlatformVersion')
    implementation enforcedPlatform("${quarkusGroup}:${quarkusArtifact}:${quarkusVersion}")
    implementation enforcedPlatform("${quarkusGroup}:quarkus-google-cloud-services-bom:${quarkusVersion}")

    // The tools we will use to build our controller
    implementation 'io.quarkus:quarkus-vertx-http'
   // implementation 'io.quarkus:quarkus-resteasy-reactive-jackson'
    implementation 'io.smallrye.reactive:smallrye-mutiny-vertx-web-client'

    implementation 'io.quarkus:quarkus-container-image-docker'

    implementation 'com.squareup.okhttp3:okhttp'
    implementation 'com.google.guava:guava'
    implementation 'commons-io:commons-io'

    runtime "io.netty:netty-transport-native-epoll:$quarkusVersion:linux-x86_64"
    runtime "io.netty:netty-transport-native-kqueue:$quarkusVersion:osx-x86_64"

    testImplementation 'io.quarkus:quarkus-junit5'
    testImplementation 'io.rest-assured:rest-assured'
    testImplementation "junit:junit:4.13.2'"
}

test {
    useJUnit()
    // uncomment below to leave test machine alive to play with
    // systemProperty("noClean", "true") // WIP: must comment whole line to merge
}

String launchScript = 'launchScript'
tasks.register(launchScript).configure{
    Task t ->
        final String startScript = """#!/bin/bash
test -f /certs/deephaven-svc-act.json && gcloud auth activate-service-account --key-file=/certs/deephaven-svc-act.json
gcloud config set core/disable_usage_reporting true
gcloud config set component_manager/disable_update_check true
gcloud config set project deephaven-oss
export JAVA_OPTIONS="-Dquarkus.log.level=DEBUG -Dquarkus.http.host=0.0.0.0 -Dquarkus.http.port=7117 -Djava.util.logging.manager=org.jboss.logmanager.LogManager"
cd /deployments
./run-java.sh --debug
"""
        File protoOut = new File(buildDir, launchScript)
        t.outputs.dir(protoOut)
        t.inputs.property("startScript", startScript)
        t.doLast {
            protoOut.mkdirs()
            File demoStart = new File(protoOut, 'demo-start.sh')
            demoStart.text = startScript
            demoStart.setExecutable(true, false)
        }
}

String protoSyncName = 'protoSync'
tasks.register(protoSyncName, Sync).configure{
    Sync t ->
        File protoOut = new File(buildDir, protoSyncName)
        t.destinationDir(protoOut)
        gradle.rootProject.allprojects*.projectDir.forEach {
            File f ->
                File protos = new File(f, 'src/main/proto')
                protos.directory && t.from(protos)
        }
}

// TODO: forcibly test that a few toolchains can compile + run our code...
quarkusBuild {
    // don't realize the task just to put this dependsOn in place
    dependsOn "$project.path:$protoSyncName", "$project.path:$launchScript"
    inputs.property('machineVersion', project.ext.machineVersion)

    nativeArgs {
        containerBuild = true
        buildImage = "quay.io/quarkus/ubi-quarkus-native-image:21.1.0-java11"
    }
    finalizedBy {
        // check for error state,
        if (state.failure) {
            logger.quiet("This task can fail if you have not recently authorized docker with gcloud")
            logger.quiet("To do so:\n" +
                    "ZONE=us-central1\n" +
                    "REPO_ROOT=\"\${ZONE}-docker.pkg.dev\"\n" +
                    "gcloud auth configure-docker \"\$REPO_ROOT\"")
        }
    }
}
