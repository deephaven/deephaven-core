import com.bmuschko.gradle.docker.tasks.image.DockerPushImage
import com.bmuschko.gradle.docker.tasks.image.DockerRemoveImage
import com.bmuschko.gradle.docker.tasks.image.DockerTagImage
import org.gradle.internal.jvm.Jvm
static boolean getCanQuarkus() { Jvm.current().javaVersion.isJava11Compatible() }

plugins {
    id 'java'
    id 'application'
    id 'io.quarkus' apply false
    id 'com.bmuschko.docker-remote-api'
}

if (canQuarkus) {
    plugins.apply 'io.quarkus'
}

evaluationDependsOn ':demo-grpc-api'
evaluationDependsOn ':demo-web'
evaluationDependsOn ':demo-envoy'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(11)
    }
}

application {
    mainClassName = 'io.deephaven.demo.DhDemoServer'

}

// we use withType(JavaExec) to catch intellij-created run configurations
tasks.withType(JavaExec).configureEach {
    JavaExec exe ->
        // see https://vertx.io/docs/vertx-web/java/
        // setting this here ensures local gradle runs won't cache things,
        // but running in a production container (not a gradle JavaExec), we let it cache
        exe.systemProperty("vertxweb.environment", "dev")
        exe.systemProperty("dh-helm-root", new File(projectDir, "helm").absolutePath)
        exe.systemProperty("dh-helm-mode", "generate")
        exe.systemProperty("dh-helm-target", new File(buildDir, "helm").absolutePath)
        exe.doFirst {
            exe.args("generate")
        }
}


repositories {
    mavenCentral()
    mavenLocal()
}

dependencies {
    if (canQuarkus) {

        String quarkusGroup = findProperty('quarkusPlatformGroupId')
        String quarkusArtifact = findProperty('quarkusPlatformArtifactId')
        String quarkusVersion = findProperty('quarkusPlatformVersion')
        implementation enforcedPlatform("${quarkusGroup}:${quarkusArtifact}:${quarkusVersion}")
        implementation enforcedPlatform("${quarkusGroup}:quarkus-google-cloud-services-bom:${quarkusVersion}")

        // The tools we will use to build our controller
        implementation 'io.quarkus:quarkus-vertx-http'
       // implementation 'io.quarkus:quarkus-resteasy-reactive-jackson'
        implementation 'io.smallrye.reactive:smallrye-mutiny-vertx-web-client'

        runtime "io.netty:netty-transport-native-epoll:$quarkusVersion:linux-x86_64"
        runtime "io.netty:netty-transport-native-kqueue:$quarkusVersion:osx-x86_64"

        implementation 'io.quarkus:quarkus-kubernetes-client'
        implementation 'io.quarkus:quarkus-minikube'

        // not using yet... starts a grpc server
//        implementation 'io.quarkus:quarkus-grpc'

        // likely need this for image building
        implementation 'io.quarkus:quarkus-container-image-docker'

        // don't really need these yet, we maintain our own helm chart
    //
    //    implementation 'io.quarkus:quarkus-kubernetes-service-binding'
    //    implementation 'io.quarkus:quarkus-kubernetes-config'
    //    implementation 'io.quarkus:quarkus-kubernetes'

        // try this out once using quarkus docker image
        implementation 'io.quarkiverse.googlecloudservices:quarkus-google-cloud-secret-manager'

        // extras that looked interesting
    //
    //    implementation 'io.quarkus:quarkus-arc'
    //    implementation 'io.quarkus:quarkus-jgit'
    //    implementation 'io.quarkus:quarkus-kafka-client'
    //    implementation 'io.quarkus:quarkus-kafka-streams'

        testImplementation 'io.quarkus:quarkus-junit5'
        testImplementation 'io.rest-assured:rest-assured'
    } else {
        // java version < 11 == no quarkus, use raw dependencies (not io.quarkus: group)
        // (quarkus is an expensive one-time download that doesn't work on java 8,
        // but it can compile most of the java app to statically linked native code):
        implementation 'io.vertx:vertx-web:4.1.1'
        implementation 'io.kubernetes:client-java:10.0.0'
    }
    // dependencies added w/o adequate replacements in quarkus (afaik)
    implementation 'io.kubernetes:client-java-extended:13.0.0'
    testImplementation "junit:junit:4.13.2'"
}

test {
    useJUnit()
    // uncomment below to leave test machine alive to play with
    systemProperty("noClean", "true") // WIP: must comment whole line to merge
}

String launchScript = 'launchScript'
tasks.register(launchScript).configure{
    Task t ->
        final String startScript = """#!/bin/bash
test -f /certs/deephaven-svc-act.json && gcloud auth activate-service-account --key-file=/certs/deephaven-svc-act.json
gcloud config set core/disable_usage_reporting true
gcloud config set component_manager/disable_update_check true
gcloud config set project deephaven-oss
# cp /etc/ssl/certs/ca-certificates.crt /etc/pki/tls/certs/ca-bundle.crt
export JAVA_OPTIONS="-Dquarkus.log.level=DEBUG -Dquarkus.http.host=0.0.0.0 -Dquarkus.http.port=7117 -Djava.util.logging.manager=org.jboss.logmanager.LogManager"
cd /deployments
cat /deployments/run-java.sh
./run-java.sh --debug
"""
        File protoOut = new File(buildDir, launchScript)
        t.outputs.dir(protoOut)
        t.inputs.property("startScript", startScript)
        t.doLast {
            protoOut.mkdirs()
            File demoStart = new File(protoOut, 'demo-start.sh')
            demoStart.text = startScript
            demoStart.setExecutable(true, false)
        }

}

String protoSyncName = 'protoSync'
tasks.register(protoSyncName, Sync).configure{
    Sync t ->
        File protoOut = new File(buildDir, protoSyncName)
        t.destinationDir(protoOut)
        gradle.rootProject.allprojects*.projectDir.forEach {
            File f ->
                File protos = new File(f, 'src/main/proto')
                protos.directory && t.from(protos)
        }
}
gradle.projectsEvaluated {
    println tasks.names
}
// TODO: forcibly test that a few toolchains can compile + run our code...

if (canQuarkus) {

    quarkusBuild {
        // don't realize the task just to put this dependsOn in place
        dependsOn "$project.path:$protoSyncName", "$project.path:$launchScript"
        nativeArgs {
            containerBuild = true
            buildImage = "quay.io/quarkus/ubi-quarkus-native-image:21.1.0-java11"
        }
    }
}

def dockerPath = project.findProperty('dockerPath') ?: 'deephaven'
def dockerVersion = project.findProperty('dockerVersion') ?: 'local-build'

String grpcApiRepository = project.property('grpcApiRepository')
String grpcApiTag = project.version

String webRepository = project.property('webRepository')
String webTag = project.version

String envoyRepository = project.property('envoyRepository')
String envoyTag = project.version

def tagGrpcApiTask = tasks.register('tagGrpcApi', DockerTagImage) {
    DockerTagImage t ->
        def demoGrpcApi = project(':demo-grpc-api')
        t.imageId.set demoGrpcApi.property('image') as String
        t.repository.set grpcApiRepository
        t.tag.set grpcApiTag
        t.force.set true
        t.dependsOn demoGrpcApi.tasks.findByName('buildImage')
}

def tagWebTask = tasks.register('tagWeb', DockerTagImage) {
    DockerTagImage t ->
        def demoWeb = project(':demo-web')
        t.imageId.set demoWeb.property('image') as String
        t.repository.set webRepository
        t.tag.set webTag
        t.force.set true
        t.dependsOn demoWeb.tasks.findByName('buildImage')
}

def tagEnvoy = tasks.register('tagEnvoy', DockerTagImage) {
    DockerTagImage t ->
        def demoEnvoy = project(':demo-envoy')
        t.imageId.set demoEnvoy.property('image') as String
        t.repository.set envoyRepository
        t.tag.set envoyTag
        t.force.set true
        t.dependsOn demoEnvoy.tasks.findByName('buildImage')
}

def tagAll = tasks.register('tagAll') {
    it.dependsOn tagGrpcApiTask, tagWebTask, tagEnvoy
}

def untagGrpcApi = tasks.register('untagGrpcApi', DockerRemoveImage) {
    it.imageId.set "${grpcApiRepository}:${grpcApiTag}"
    it.onError { exception ->
        if (!exception.message.contains('No such image'))
            throw exception
    }
}

def untagWeb = tasks.register('untagWeb', DockerRemoveImage) {
    it.imageId.set "${webRepository}:${webTag}"
    it.onError { exception ->
        if (!exception.message.contains('No such image'))
            throw exception
    }
}

def untagEnvoy = tasks.register('untagEnvoy', DockerRemoveImage) {
    it.imageId.set "${envoyRepository}:${envoyTag}"
    it.onError { exception ->
        if (!exception.message.contains('No such image'))
            throw exception
    }
}

tasks.register('cleanDocker') {
    it.dependsOn untagGrpcApi, untagWeb, untagEnvoy
}

tasks.register('pushAll', DockerPushImage) {
    DockerPushImage p ->
        p.images = [ "${grpcApiRepository}:${grpcApiTag}", "${webRepository}:${webTag}", "${envoyRepository}:${envoyTag}" ]
        p.dependsOn tagAll
}