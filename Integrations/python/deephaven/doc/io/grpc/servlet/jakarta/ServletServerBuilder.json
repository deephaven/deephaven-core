{
 "className": "io.grpc.servlet.jakarta.ServletServerBuilder",
 "methods": {
  "build": "Builds a gRPC server that can run as a servlet.\n\n \n The returned server will not be started or bound to a port.\n\n \n Users should not call this method directly. Instead users should call buildServletAdapter() which\n internally will call build() and start() appropriately.\n\n:return: io.grpc.Server",
  "buildServletAdapter": "Creates a ServletAdapter.\n\n:return: io.grpc.servlet.jakarta.ServletAdapter",
  "maxInboundMessageSize": ":param bytes: int\n:return: io.grpc.servlet.jakarta.ServletServerBuilder",
  "scheduledExecutorService": "Provides a custom scheduled executor service to the server builder.\n\n:param scheduler: java.util.concurrent.ScheduledExecutorService\n:return: (io.grpc.servlet.jakarta.ServletServerBuilder) this",
  "useTransportSecurity": "Throws UnsupportedOperationException. TLS should be configured by the servlet container.\n\n:param certChain: java.io.File\n:param privateKey: java.io.File\n:return: io.grpc.servlet.jakarta.ServletServerBuilder"
 },
 "path": "io.grpc.servlet.jakarta.ServletServerBuilder",
 "text": "Builder to build a gRPC server that can run as a servlet. This is for advanced custom settings. Normally, users\n should consider extending the out-of-box GrpcServlet directly instead.\n\n \n The API is experimental. The authors would like to know more about the real usecases. Users are welcome to provide\n feedback by commenting on the tracking issue.",
 "typeName": "class"
}