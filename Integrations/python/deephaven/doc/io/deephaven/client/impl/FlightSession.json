{
 "className": "io.deephaven.client.impl.FlightSession",
 "methods": {
  "addToInputTable": "Add source to the input table destination.\n\n*Overload 1*  \n  :param destination: (io.deephaven.client.impl.HasTicketId) - the destination input table\n  :param source: (org.apache.arrow.flight.FlightStream) - the source\n  :return: (java.util.concurrent.CompletableFuture<java.lang.Void>) the future\n  \n*Overload 2*  \n  :param destination: (io.deephaven.client.impl.HasTicketId) - the destination input table\n  :param source: (io.deephaven.qst.table.NewTable) - the source\n  :param allocator: org.apache.arrow.memory.BufferAllocator\n  :return: (java.util.concurrent.CompletableFuture<java.lang.Void>) the future",
  "deleteFromInputTable": "Delete source from the input table destination.\n\n*Overload 1*  \n  :param destination: (io.deephaven.client.impl.HasTicketId) - the destination input table\n  :param source: (org.apache.arrow.flight.FlightStream) - the source\n  :return: (java.util.concurrent.CompletableFuture<java.lang.Void>) the future\n  \n*Overload 2*  \n  :param destination: (io.deephaven.client.impl.HasTicketId) - the destination input table\n  :param source: (io.deephaven.qst.table.NewTable) - the source\n  :param allocator: org.apache.arrow.memory.BufferAllocator\n  :return: (java.util.concurrent.CompletableFuture<java.lang.Void>) the future",
  "list": "List the flights.\n\n:return: (java.lang.Iterable<org.apache.arrow.flight.FlightInfo>) the flights",
  "of": ":param session: io.deephaven.client.impl.SessionImpl\n:param incomingAllocator: org.apache.arrow.memory.BufferAllocator\n:param channel: io.grpc.ManagedChannel\n:return: io.deephaven.client.impl.FlightSession",
  "put": "**Incompatible overloads text - text from the first overload:**\n\nPerforms a DoPut against the pathId with a FlightStream payload.\n\n*Overload 1*  \n  :param pathId: (io.deephaven.client.impl.HasPathId) - the path ID\n  :param input: (org.apache.arrow.flight.FlightStream) - the input\n  \n*Overload 2*  \n  :param pathId: (io.deephaven.client.impl.HasPathId) - the path ID\n  :param table: (io.deephaven.qst.table.NewTable) - the table\n  :param allocator: (org.apache.arrow.memory.BufferAllocator) - the allocator",
  "putExport": "**Incompatible overloads text - text from the first overload:**\n\nCreates a new server side exported table backed by the server semantics of DoPut with a FlightStream\n payload.\n\n \n For more advanced use cases, callers may use putExportManual(FlightStream).\n\n*Overload 1*  \n  :param table: (io.deephaven.qst.table.NewTable) - the table\n  :param allocator: (org.apache.arrow.memory.BufferAllocator) - the allocator\n  :return: (io.deephaven.client.impl.TableHandle) the table handle\n  \n*Overload 2*  \n  :param input: (org.apache.arrow.flight.FlightStream) - the input\n  :return: (io.deephaven.client.impl.TableHandle) the table handle",
  "putExportManual": "**Incompatible overloads text - text from the first overload:**\n\nCreates a new server side export table backed by the server semantics for DoPut with a FlightStream\n payload. Callers are responsible for calling release(ExportId).\n\n \n This method may be more efficient, depending on how the ticket is going to be used. If it will simply be bound to\n a ticket table, callers should prefer putExport(FlightStream).\n\n*Overload 1*  \n  :param table: (io.deephaven.qst.table.NewTable) - the table\n  :param allocator: (org.apache.arrow.memory.BufferAllocator) - the allocator\n  :return: (io.deephaven.client.impl.ExportId) the ticket\n  \n*Overload 2*  \n  :param input: (org.apache.arrow.flight.FlightStream) - the input\n  :return: (io.deephaven.client.impl.ExportId) the export ID",
  "release": "Releases the exportId.\n\n \n Note: this should only be called in combination with export IDs returned from\n putExportManual(NewTable, BufferAllocator) or putExportManual(FlightStream).\n\n:param exportId: (io.deephaven.client.impl.ExportId) - the export ID\n:return: (java.util.concurrent.CompletableFuture<java.lang.Void>) the future",
  "schema": "**Incompatible overloads text - text from the first overload:**\n\nCreate a schema from the existing handle's response.\n\n \n Equivalent to SchemaHelper.schema(handle.response()).\n\n*Overload 1*  \n  :param handle: (io.deephaven.client.impl.TableHandle) - the handle\n  :return: (org.apache.arrow.vector.types.pojo.Schema) the schema\n  \n*Overload 2*  \n  :param pathId: (io.deephaven.client.impl.HasPathId) - the path ID\n  :return: (org.apache.arrow.vector.types.pojo.Schema) the schema",
  "session": "The session.\n\n:return: (io.deephaven.client.impl.Session) the session",
  "stream": "Perform a DoGet to fetch the data.\n\n:param ticketId: (io.deephaven.client.impl.HasTicketId) - the ticket\n:return: (org.apache.arrow.flight.FlightStream) the stream"
 },
 "path": "io.deephaven.client.impl.FlightSession",
 "typeName": "class"
}