{
 "className": "io.deephaven.util.files.FileHelper",
 "methods": {
  "deleteRecursivelyOnNFS": "**Incompatible overloads text - text from the first overload:**\n\nAugment FileUtils.deleteRecursivelyOnNFS(File) with an exclude pattern. Files matching the pattern will\n not be removed, nor will containing directories.\n\n*Overload 1*  \n  :param file: (java.io.File) - the file or folder to delete.\n  :param excludePattern: (java.lang.String) - don't delete files or folders matching this pattern.\n  :return: (boolean) true if any files were excluded (so caller will know if a directory is empty)\n  \n*Overload 2*  \n  :param file: (java.io.File) - the file or folder to delete.\n  :param excludePattern: (java.util.regex.Pattern) - don't delete files or folders matching this pattern.\n  :return: (boolean) true if any files were excluded (so caller will know if a directory is empty)\n  \n*Overload 3*  \n  :param trashFile: (java.io.File) - Filename to move regular files to before deletion. .nfs files may be created in its parent\n          directory.\n  :param fileToBeDeleted: (java.io.File) - File or directory at which to begin recursive deletion.\n  :param excludePattern: (java.util.regex.Pattern) - don't delete files or folders matching this pattern.\n  :return: (boolean) true if any files were excluded (so caller will know if a directory is empty)",
  "getCanonicalForm": "Get the canonical path for the given path string, converting IOExceptions to UncheckIOException.\n\n:param path: (java.lang.String) - The file (as String) for which to get the canonical form.\n:return: (java.lang.String) the canonical file string."
 },
 "path": "io.deephaven.util.files.FileHelper",
 "text": "Utility/helper methods for file operations.",
 "typeName": "class"
}