{
 "className": "io.deephaven.util.Utils",
 "methods": {
  "areFileLinesEqual": "Does a line by line comparison of two files to check if they are the same.  Can skip the first N lines.\n\n:param fileA: (java.nio.file.Path) - the first file\n:param fileB: (java.nio.file.Path) - the second file\n:param skipLines: (int) - how many lines to skip before comparing\n:return: (boolean) true if contents are equal, false otherwise",
  "castTo": "require (o instanceof type)\n\n*Overload 1*  \n  Note: Java generics information - <T>\n  \n  :param o: java.lang.Object\n  :param name: java.lang.String\n  :param type: java.lang.Class<T>\n  :param numCallsBelowRequirer: int\n  :return: T\n  \n*Overload 2*  \n  Note: Java generics information - <T>\n  \n  :param o: java.lang.Object\n  :param name: java.lang.String\n  :param type: java.lang.Class<T>\n  :return: T",
  "changeFileExtension": "Changes if a file extension on a Path.  Assumes the current extension starts with a dot.\n\n:param path: (java.nio.file.Path) - the path to the file to change\n:param extension: (java.lang.String) - the extension\n:return: (java.nio.file.Path) a Path to a file with the new extension",
  "cleanRoom": ":return: java.net.URLClassLoader",
  "ensureClosed": "Close an AutoCloseable object and discard any exceptions.\n \n NB: Per AutoCloseable.close(), Note that unlike the close method of java.io.Closeable, this close\n method is not required to be idempotent. In other words, calling this close method more than once may have some\n visible side effect, unlike Closeable.close which is required to have no effect if called more than once.\n However, implementers of this interface are strongly encouraged to make their close methods idempotent.\n\n:param autoCloseable: (java.lang.AutoCloseable) - The resource to close.",
  "fileDeletePrivileged": "Delete a file in a privileged context\n\n:param file: (java.io.File) - The File to delete\n:return: (boolean) same as File.delete",
  "fileExistsPrivileged": "Perform a file existence check in a privileged context.\n\n:param file: (java.io.File) - The File to check\n:return: (boolean) same as File.exists",
  "fileGetAbsoluteFilePrivileged": "Get an absolute File in a privileged context.\n\n:param file: (java.io.File) - the File to check\n:return: (java.io.File) same as File.getAbsoluteFile",
  "fileGetAbsolutePathPrivileged": "Get an absolute path in a privileged context.\n\n:param file: (java.io.File) - the File to check\n:return: (java.lang.String) same as File.getAbsolutePath",
  "fileGetDirectoryStream": ":param dir: java.nio.file.Path\n:param filter: java.nio.file.DirectoryStream.Filter<? super java.nio.file.Path>\n:return: java.nio.file.DirectoryStream<java.nio.file.Path>",
  "fileIsDirectoryPrivileged": "Perform an IsDirectory check in a privileged context.\n\n*Overload 1*  \n  :param file: (java.io.File) - the File to check\n  :return: (boolean) same as File.isDirectory\n  \n*Overload 2*  \n  :param path: (java.nio.file.Path) - the File to check\n  :param options: java.nio.file.LinkOption...\n  :return: (boolean) same as File.isDirectory",
  "fileMkdirPrivileged": "Create the directory specified by this File, excluding parent directories, in a privileged context.\n\n:param file: (java.io.File) - The directory to create\n:return: (boolean) same as File.mkdir",
  "fileRenameToPrivileged": "Rename a file in a privileged context.\n\n:param file: (java.io.File) - the File to rename\n:param dest: (java.io.File) - the new name\n:return: (boolean) same as File.renameTo",
  "getLastModifiedTime": ":param f: java.io.File\n:return: java.time.LocalDateTime",
  "getMajorJavaVersion": "Get the major Java version (e.g. 8, 11). Throw an exception if it can't be determined, or if it isn't\n a Deephaven-supported version. Currently supported versions include:\n \n* 1.8 (returned as 8)\n* 11\n\n\n:return: (int) the major Java version",
  "getModifiedTimeComparator": "**Incompatible overloads text - text from the first overload:**\n\nGet a Comparator that treats its inputs as file names in the same directory basePath, and compares\n each file by its modified time\n\n*Overload 1*  \n  :param dir: (java.io.File) - The root path in which both files reside.\n  :param descending: boolean\n  :return: (java.util.Comparator<java.lang.String>) A new Comparator.\n  \n*Overload 2*  \n  :param descending: boolean\n  :return: (java.util.Comparator<java.io.File>) A new comparator.",
  "getSimpleNameFor": "**Incompatible overloads text - text from the first overload:**\n\nAnonymous inner classes return \"\" as simple name. In most cases, we want the SimpleName to reflect the\n class being overridden.\n\n*Overload 1*  \n  :param o: (java.lang.Object) - the object used to get the class for which to return the SimpleName\n  :return: (java.lang.String) The SimpleName of the object's class, or of its superclass\n  \n*Overload 2*  \n  :param objectClass: (java.lang.Class<?>) - the class for which to return the SimpleName\n  :return: (java.lang.String) The SimpleName of the class, or of its superclass",
  "isEmptyElement": "Checks if an Element is empty, ignoring the specified set of attributes.\n An empty element contains no content and no attributes aside from those indicated in\n ignoredAttrs\n\n:param elem: (org.jdom2.Element) - The element to check\n:param ignoredAttrs: (java.lang.String...) - A set of attributes that can be present while this element is still considered empty.\n:return: (boolean) true if the element contained no content or attributes excluding those indicated in ignoredAttrs",
  "makeReferentDescription": "Describe the object in a standardized format without accessing its fields or otherwise risking interacting with\n partially-initialized state.\n\n:param object: (java.lang.Object) - The object\n:return: (java.lang.String) The description",
  "reverseArraySubset": "Reverse a subset of an array.\n\nNote: Java generics information - <T>\n\n:param array: (T[]) - The array in question\n:param start: (int) - The starting index to reverse (inclusive)\n:param end: (int) - The ending index to reverse (inclusive)",
  "runWithoutInterruption": "Run something until it is successfully finished without an interrupted exception.\n\n:param log: io.deephaven.io.logger.Logger\n:param thing: (io.deephaven.base.Procedure.ThrowingNullary<java.lang.InterruptedException>) - the thing to run despite interruptions.\n:param name: (java.lang.String) - what to call the thing - for logging",
  "sleepIgnoringInterruptions": "Sleep, ignoring any interruptions\n\n:param millisToSleep: (long) - millis to sleep\n:return: (long) the number of millis slept",
  "sneakyThrow": ":param t: java.lang.Throwable\n:return: java.lang.RuntimeException",
  "unCheck": "Convert IOException to UncheckedIOException.\n\n*Overload 1*  \n  :param r: (io.deephaven.base.Procedure.ThrowingNullary<java.io.IOException>) - the stuff to run\n  \n*Overload 2*  \n  Note: Java generics information - <T>\n  \n  :param r: (io.deephaven.base.Function.ThrowingNullary<T,java.io.IOException>) - the stuff to run\n  :return: (T) the result of the stuff",
  "unNull": "syntactic sugar to use empty strings instead of null.\n\n:param s: (java.lang.String) - the string to check\n:return: (java.lang.String) the original string, or \"\" if it was null",
  "unwrapElement": "Get the single element that was wrapped by a previous call to wrapElement(String, Element)\n\n:param wrapperName: (java.lang.String) - The name of the wrapper\n:param parentElem: (org.jdom2.Element) - The element containing the wrapper\n:return: (org.jdom2.Element) The element that was rapped or null, if the wrapper was not found.",
  "wrapElement": "Wrap the specified element in a new one with the specified name\n\n:param wrapperName: (java.lang.String) - The name of the wrapper element to create\n:param wrapee: (org.jdom2.Element) - The element being wrapped.\n:return: (org.jdom2.Element) A new element with the specified name and element as it's content"
 },
 "path": "io.deephaven.util.Utils",
 "text": "Landing place for general purpose utility functions.",
 "typeName": "class"
}