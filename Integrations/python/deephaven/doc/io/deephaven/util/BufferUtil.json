{
 "className": "io.deephaven.util.BufferUtil",
 "methods": {
  "ensureSpace": "Return a buffer with at least requiredSize remaining capacity. The provided buffer will be copied to the new\n buffer, and might be the buffer returned.\n The new buffer's limit will be unchanged if the buffer is not reallocated, and equal to the new capacity if it is reallocated.\n The new buffer will be allocated with allocateDirect() if the original buffer is direct, else with allocate().\n\n:param dataBuffer: (java.nio.ByteBuffer) - a byte buffer in write mode\n:param requiredSize: (int) - additional capacity needed\n:return: (java.nio.ByteBuffer) a byte buffer in write mode with at least requiredSize remaining capacity",
  "reallocateBuffer": "Allocate a new ByteBuffer larger than the supplied buffer. This is generally used when dynamically resizing an\n output buffer.\n The resulting buffer's size will be a power-of-two at least double the supplied buffer's size and at least the\n specified minimum size, unless constrained by Integer.MAX_VALUE.\n The resulting buffer will be direct if and only if the supplied buffer was direct.\n The contents of the supplied buffer are copied into the result buffer as in ByteBuffer.put(ByteBuffer).\n  See also io.deephaven.tablelogger.AbstractBinaryStoreWriter#ensureSpace\n\n:param buffer: (java.nio.ByteBuffer) - The buffer to grow (and copy from)\n:param minimumSize: (int) - The minimum size for the result buffer\n:return: (java.nio.ByteBuffer) The new buffer, including contents of buffer",
  "writeUtf8": "Encode the given string as UTF_8 and write the size and data to the given buffer.\n The buffer might be reallocated using ensureSpace(java.nio.ByteBuffer, int) if necessary.\n\n:param dataBuffer: (java.nio.ByteBuffer) - Write to this ByteBuffer.\n:param value: (java.lang.String) - Encode this string.\n:return: (java.nio.ByteBuffer) The modified input ByteBuffer."
 },
 "path": "io.deephaven.util.BufferUtil",
 "text": "Utility methods for working with ByteBuffers.",
 "typeName": "class"
}