{
 "className": "io.deephaven.util.EncodingUtil",
 "methods": {
  "getBOMsForEncoding": "Get an array containing the possible byte order marks that could be present within a file\n of the specified encoding. This is intended for use with BOMInputStream\n\n:param encoding: (io.deephaven.base.string.EncodingInfo) - The encoding.\n:return: (org.apache.commons.io.ByteOrderMark[]) An array containing the possible BOMs for the encoding.",
  "getEncodingInfoForCharset": "**Incompatible overloads text - text from the first overload:**\n\nGet the EncodingInfo associated with a particular Charset\n\n*Overload 1*  \n  :param charSet: (java.nio.charset.Charset) - The charset\n  :return: (io.deephaven.base.string.EncodingInfo) the matching EncodingInfo\n  \n*Overload 2*  \n  :param charsetName: (java.lang.String) - the charset\n  :return: (io.deephaven.base.string.EncodingInfo) the matching EncodingInfo",
  "getUtf8String": "Extract a UTF-8 encoded string from the given buffer. The buffer must be positioned at the start of the encoding,\n which is an int length followed by the UTF-8 encoded bytes. The buffer is advanced to the end of the string.\n\n:param source: (java.nio.ByteBuffer) - a ByteBuffer positioned at the string encoded as length + UTF-8 encoded bytes.\n:return: (java.lang.String) a new String extracted from the buffer",
  "putUtf8String": "Encode the given string in UTF-8 format into the given ByteBuffer. The string is encoded as an int length\n followed by the encoded bytes.\n\n:param destination: (java.nio.ByteBuffer) - a ByteBuffer in which to encode the string. The buffer must be big enough for the encoded\n        string.\n:param value: (java.lang.String) - the String value to encode."
 },
 "path": "io.deephaven.util.EncodingUtil",
 "typeName": "class"
}