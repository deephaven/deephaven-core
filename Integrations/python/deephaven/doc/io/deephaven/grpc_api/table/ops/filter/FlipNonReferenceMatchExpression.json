{
 "className": "io.deephaven.grpc_api.table.ops.filter.FlipNonReferenceMatchExpression",
 "methods": {
  "exec": ":param filter: io.deephaven.proto.backplane.grpc.Condition\n:return: io.deephaven.proto.backplane.grpc.Condition",
  "onIn": ":param target: io.deephaven.proto.backplane.grpc.Value\n:param candidatesList: java.util.List<io.deephaven.proto.backplane.grpc.Value>\n:param caseSensitivity: io.deephaven.proto.backplane.grpc.CaseSensitivity\n:param matchType: io.deephaven.proto.backplane.grpc.MatchType\n:return: io.deephaven.proto.backplane.grpc.Condition"
 },
 "path": "io.deephaven.grpc_api.table.ops.filter.FlipNonReferenceMatchExpression",
 "text": "Enforces that all IN-type expressions have a reference on the left side and only literals\n on the right side. Any non-reference on the left or reference on the right will trigger\n the entire IN-type expression being replaced with an OR or AND, with a sub-IN for each\n expression on the right side.\n\n\n Examples:\n   o  ColumnA in 1, 2, 3 - left as-is\n   o  ColumnA in 1, 2, ColumnB - rewritten as (ColumnA in 1 OR ColumnA in 2 OR ColumnA in ColumnB)\n   o  1 in 3, 4, 5 - will be rewritten as (3 in 1 OR 4 in 1 OR 5 in 1). This is a silly case, but we're\n      not judging. At this step.\n   o  1 in ColumnA, 4, 5 - will be rewritten as (ColumnA in 1 OR 4 in 1 OR 5 in 1)\n   o  1 in ColumnA - will be rewritten as ColumnA in 1\n   o  ColumnA in ColumnB - will be rewritten as ColumnB in ColumnA. Note that like the second example,\n      this isn't productive on its own, but as a pair with a reference on the right, it will be noticed\n      by ConvertInvalidInExpressions.\n\n  It is assumed that some time after this step, related \"in\" expressions will be merged\n  together, and that these one-off expressions will get checked later.",
 "typeName": "class"
}