{
 "className": "io.deephaven.grpc_api.session.SessionState",
 "methods": {
  "addExportListener": ":param observer: io.grpc.stub.StreamObserver<io.deephaven.proto.backplane.grpc.ExportNotification>",
  "dropReference": "Drop a previously-retained reference to this referent.",
  "exportIdToTicket": "Convenience method to convert from export id to Ticket.\n\n:param exportId: (long) - the export id\n:return: (io.deephaven.proto.backplane.grpc.Ticket) a grpc Ticket wrapping the export id",
  "getAuthContext": ":return: (io.deephaven.util.auth.AuthContext) the auth context for this session",
  "getExpiration": ":return: (io.deephaven.grpc_api.session.SessionService.TokenExpiration) the current expiration token for this session",
  "getExport": "**Incompatible overloads text - text from the first overload:**\n\nGrab the ExportObject for the provided id.\n\n*Overload 1*  \n  Note: Java generics information - <T>\n  \n  :param ticket: (io.deephaven.proto.backplane.grpc.Ticket) - the export ticket\n  :return: (io.deephaven.grpc_api.session.SessionState.ExportObject<T>) a future-like object that represents this export\n  \n*Overload 2*  \n  Note: Java generics information - <T>\n  \n  :param exportId: (long) - the export handle id\n  :return: (io.deephaven.grpc_api.session.SessionState.ExportObject<T>) a future-like object that represents this export",
  "getWeakReference": "Get a WeakReference to this referent. This may be cached, or newly created.\n\n:return: (java.lang.ref.WeakReference<? extends io.deephaven.db.util.liveness.LivenessReferent>) A new or cached reference to this referent",
  "initializeTransientFieldsForLiveness": "Package-private for Serializable sub-classes to use in readObject only.\n Public to allow unit tests in another package to work around mock issues where the constructor is never invoked.\n\nNote: Java generics information - io.deephaven.util.annotations.@VisibleForTesting",
  "isExpired": ":return: (boolean) whether or not this session is expired",
  "isExportFailureState": "*Overload 1*  \n  :param state: io.deephaven.grpc_api.session.SessionState.ExportState\n  :return: (boolean) true iff the provided export state is a failure state\n  \n*Overload 2*  \n  :param state: io.deephaven.proto.backplane.grpc.ExportNotification.State\n  :return: (boolean) true iff the provided export state is a failure state",
  "isExportStateFinal": "*Overload 1*  \n  :param state: io.deephaven.grpc_api.session.SessionState.ExportState\n  :return: (boolean) true iff the provided export state is a terminal state\n  \n*Overload 2*  \n  :param state: io.deephaven.proto.backplane.grpc.ExportNotification.State\n  :return: (boolean) true iff the provided export state is a terminal state",
  "newExport": "Create an ExportBuilder to create the export after dependencies are satisfied.\n\n*Overload 1*  \n  Note: Java generics information - <T>\n  \n  :param ticket: io.deephaven.proto.backplane.grpc.Ticket\n  :return: (io.deephaven.grpc_api.session.SessionState.ExportBuilder<T>) an export builder\n  \n*Overload 2*  \n  Note: Java generics information - <T>\n  \n  :param exportId: long\n  :return: (io.deephaven.grpc_api.session.SessionState.ExportBuilder<T>) an export builder",
  "newServerSideExport": "Create and export a pre-computed element. This is typically used in scenarios where the number of exports is not\n known in advance by the requesting client.\n\nNote: Java generics information - <T>\n\n:param export: T\n:return: (io.deephaven.grpc_api.session.SessionState.ExportObject<T>) the ExportObject for this item for ease of access to the export",
  "nonExport": "Create an ExportBuilder to perform work after dependencies are satisfied that itself does not create any exports.\n\nNote: Java generics information - <T>\n\n:return: (io.deephaven.grpc_api.session.SessionState.ExportBuilder<T>) an export builder",
  "numExportListeners": "Note: Java generics information - io.deephaven.util.annotations.@VisibleForTesting\n\n:return: long",
  "onExpired": "Notes that this session has expired and exports should be released.",
  "removeExportListener": ":param observer: io.grpc.stub.StreamObserver<io.deephaven.proto.backplane.grpc.ExportNotification>",
  "ticketToExportId": "Convenience method to convert from Ticket to export id.\n\n:param ticket: (io.deephaven.proto.backplane.grpc.Ticket) - the grpc Ticket\n:return: (long) the export id that the Ticket wraps",
  "tryManage": "Attempt to add the specified referent to this manager.\n\n:param referent: io.deephaven.db.util.liveness.LivenessReferent\n:return: (boolean) Whether the referent was in fact added",
  "tryRetainReference": "If this referent is \"live\", behave as LivenessReferent.retainReference() and return true.\n Otherwise, returns false rather than throwing an exception.\n\n:return: (boolean) True if this referent was retained, false otherwise",
  "unmanageNonExport": "Some streaming response observers are liveness artifacts that have a life cycle as determined by grpc. We also\n manage them as part of the session state so that they are closed when the session is expired.\n\n:param nonExportReferent: (io.deephaven.db.util.liveness.LivenessReferent) - the referent that no longer needs management"
 },
 "path": "io.deephaven.grpc_api.session.SessionState",
 "text": "SessionState manages all exports for a single session.\n\n It manages exported LivenessReferent.\n It cascades failures to child dependencies.\n\n TODO:\n - cyclical dependency detection\n - out-of-order dependency timeout\n - wait ~30s and then remove a failed/cancelled/released export (this enables better out-of-order handling)\n\n Details Regarding Data Structure of ExportObjects:\n\n Together, exportMap, head, and tail, form a data structure not dissimilar to a linked hash set. We want to be\n able to synchronize a listener with the existing state of all exported objects and to continue to receive updates\n throughout the lifecycle of exports. The listener should receive a consistent stream of updates after the refresh\n until it is removed.\n\n - SessionState::exportMap's purpose is to map from the export id to the export object\n - SessionState::head is the head of the doubly linked list of outstanding exports\n - SessionState::tail is the tail of the doubly linked list of outstanding exports\n - ExportObject::prev is the previous export object node in the list; it is null for the head element\n - ExportObject::next is the successive export object node in the list; it is null for the tail element\n\n Listeners must be added to the list of listeners prior to starting their refresh, or else they may miss an update.\n Similarly, ExportObject's must be added to the list of ExportObjects prior to setting initial state. Changes to the\n head / tail are done while holding the exportMap's lock. Note that it is not necessary to grab this lock to read the\n head as long as the listener is added to the list before reading the head.\n\n Changes to ExportObject's prev/next must be synchronized on the ExportObject. Listeners can synchronize with all\n outstanding exports by following the linked list from head to tail via the next pointers. It will not receive updates\n or refreshes for exports that are already in terminal states when it receives its refresh.\n\n A listener will receive an export notification for export id NON_EXPORT_ID (a zero) to indicate that the refresh has\n completed.",
 "typeName": "class"
}