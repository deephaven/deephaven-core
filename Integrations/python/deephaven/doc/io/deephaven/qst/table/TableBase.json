{
 "className": "io.deephaven.qst.table.TableBase",
 "methods": {
  "absSumBy": "*Overload 1*  \n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "aggAllBy": "*Overload 1*  \n  :param spec: io.deephaven.api.agg.spec.AggSpec\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param spec: io.deephaven.api.agg.spec.AggSpec\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param spec: io.deephaven.api.agg.spec.AggSpec\n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param spec: io.deephaven.api.agg.spec.AggSpec\n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "aggBy": "*Overload 1*  \n  :param aggregation: io.deephaven.api.agg.Aggregation\n  :return: io.deephaven.qst.table.AggregationTable\n  \n*Overload 2*  \n  :param aggregation: io.deephaven.api.agg.Aggregation\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregationTable\n  \n*Overload 3*  \n  :param aggregation: io.deephaven.api.agg.Aggregation\n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.qst.table.AggregationTable\n  \n*Overload 4*  \n  :param aggregations: java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>\n  :return: io.deephaven.qst.table.AggregationTable\n  \n*Overload 5*  \n  :param aggregations: java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregationTable\n  \n*Overload 6*  \n  :param aggregations: java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>\n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.qst.table.AggregationTable",
  "aj": "**Incompatible overloads text - text from the first overload:**\n\nPerform an as-of join with the rightTable.\n\n \n Delegates to TableOperations.aj(Object, Collection, Collection, AsOfJoinRule).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :return: (io.deephaven.qst.table.AsOfJoinTable) a new table joined according to the specification in columnsToMatch\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the left side that need to be added to the right\n          side as a result of the match.\n  :return: (io.deephaven.qst.table.AsOfJoinTable) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (io.deephaven.qst.table.AsOfJoinTable) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :param asOfJoinRule: (io.deephaven.api.AsOfJoinRule) - The binary search operator for the last match pair.\n  :return: (io.deephaven.qst.table.AsOfJoinTable) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "avgBy": "*Overload 1*  \n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "countBy": "*Overload 1*  \n  :param countColumnName: java.lang.String\n  :return: io.deephaven.qst.table.CountByTable\n  \n*Overload 2*  \n  :param countColumnName: java.lang.String\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.CountByTable\n  \n*Overload 3*  \n  :param countColumnName: java.lang.String\n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.CountByTable\n  \n*Overload 4*  \n  :param countColumnName: java.lang.String\n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.CountByTable",
  "exactJoin": "**Incompatible overloads text - text from the first overload:**\n\nPerform an exact-join with the rightTable.\n\n \n Delegates to TableOperations.exactJoin(Object, Collection, Collection).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (io.deephaven.qst.table.ExactJoinTable) the exact-joined table\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (io.deephaven.qst.table.ExactJoinTable) the exact-joined table\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to be added to the left\n          side as a result of the match.\n  :return: (io.deephaven.qst.table.ExactJoinTable) the exact-joined table",
  "firstBy": "*Overload 1*  \n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "groupBy": "*Overload 1*  \n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "head": ":param size: long\n:return: io.deephaven.qst.table.HeadTable",
  "join": "**Incompatible overloads text - text from the first overload:**\n\nPerform a cross join with the rightTable.\n\n \n Delegates to TableOperations.join(Object, Collection, Collection, int).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (io.deephaven.qst.table.JoinTable) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :param reserveBits: (int) - The number of bits to reserve for rightTable groups.\n  :return: (io.deephaven.qst.table.JoinTable) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (io.deephaven.qst.table.JoinTable) a new table joined according to the specification in columnsToMatch and includes all non-key-columns from\n           the right table\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to be added to the left\n          side as a result of the match.\n  :return: (io.deephaven.qst.table.JoinTable) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "lastBy": "*Overload 1*  \n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "logic": ":return: io.deephaven.qst.TableCreationLogic",
  "maxBy": "*Overload 1*  \n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "medianBy": "*Overload 1*  \n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "minBy": "*Overload 1*  \n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "naturalJoin": "**Incompatible overloads text - text from the first overload:**\n\nPerform a natural-join with the rightTable.\n\n \n Delegates to TableOperations.naturalJoin(Object, Collection, Collection).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (io.deephaven.qst.table.NaturalJoinTable) the natural-joined table\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (io.deephaven.qst.table.NaturalJoinTable) the natural-joined table\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to be added to the left\n          side as a result of the match.\n  :return: (io.deephaven.qst.table.NaturalJoinTable) the natural-joined table",
  "raj": "**Incompatible overloads text - text from the first overload:**\n\nPerform a reverse-as-of join with the rightTable.\n\n \n Delegates to TableOperations.raj(Object, Collection, Collection, ReverseAsOfJoinRule).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :return: (io.deephaven.qst.table.ReverseAsOfJoinTable) a new table joined according to the specification in columnsToMatch\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the left side that need to be added to the right\n          side as a result of the match.\n  :return: (io.deephaven.qst.table.ReverseAsOfJoinTable) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (io.deephaven.qst.table.ReverseAsOfJoinTable) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :param reverseAsOfJoinRule: (io.deephaven.api.ReverseAsOfJoinRule) - The binary search operator for the last match pair.\n  :return: (io.deephaven.qst.table.ReverseAsOfJoinTable) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "reverse": ":return: io.deephaven.qst.table.ReverseTable",
  "select": "*Overload 1*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.qst.table.SelectTable\n  \n*Overload 2*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.qst.table.SelectTable",
  "selectDistinct": "*Overload 1*  \n  :return: io.deephaven.qst.table.SelectDistinctTable\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.SelectDistinctTable\n  \n*Overload 3*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.SelectDistinctTable\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.qst.table.SelectDistinctTable",
  "snapshot": "**Incompatible overloads text - text from the first overload:**\n\nSnapshot baseTable, triggered by this table, and return a new table as a result.\n\n \n Delegates to TableOperations.snapshot(Object, boolean, Collection).\n\n*Overload 1*  \n  :param baseTable: (io.deephaven.qst.table.TableSpec) - The table to be snapshotted\n  :param stampColumns: (java.lang.String...) - The columns forming the \"snapshot key\", i.e. some subset of this Table's columns to be\n          included in the result at snapshot time. As a special case, an empty stampColumns is taken to mean\n          \"include all columns\".\n  :return: (io.deephaven.qst.table.SnapshotTable) The result table\n  \n*Overload 2*  \n  :param baseTable: (io.deephaven.qst.table.TableSpec) - The table to be snapshotted\n  :param doInitialSnapshot: (boolean) - Take the first snapshot now (otherwise wait for a change event)\n  :param stampColumns: (java.lang.String...) - The columns forming the \"snapshot key\", i.e. some subset of this Table's columns to be\n          included in the result at snapshot time. As a special case, an empty stampColumns is taken to mean\n          \"include all columns\".\n  :return: (io.deephaven.qst.table.SnapshotTable) The result table\n  \n*Overload 3*  \n  :param baseTable: (io.deephaven.qst.table.TableSpec) - The table to be snapshotted\n  :param doInitialSnapshot: (boolean) - Take the first snapshot now (otherwise wait for a change event)\n  :param stampColumns: (java.util.Collection<io.deephaven.api.ColumnName>) - The columns forming the \"snapshot key\", i.e. some subset of this Table's columns to be\n          included in the result at snapshot time. As a special case, an empty stampColumns is taken to mean\n          \"include all columns\".\n  :return: (io.deephaven.qst.table.SnapshotTable) The result table",
  "sort": "*Overload 1*  \n  :param columnsToSortBy: java.lang.String...\n  :return: io.deephaven.qst.table.SortTable\n  \n*Overload 2*  \n  :param columnsToSortBy: java.util.Collection<io.deephaven.api.SortColumn>\n  :return: io.deephaven.qst.table.SortTable",
  "sortDescending": ":param columnsToSortBy: java.lang.String...\n:return: io.deephaven.qst.table.SortTable",
  "stdBy": "*Overload 1*  \n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "sumBy": "*Overload 1*  \n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "tail": ":param size: long\n:return: io.deephaven.qst.table.TailTable",
  "toString": ":return: java.lang.String",
  "update": "*Overload 1*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.qst.table.UpdateTable\n  \n*Overload 2*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.qst.table.UpdateTable",
  "updateView": "*Overload 1*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.qst.table.UpdateViewTable\n  \n*Overload 2*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.qst.table.UpdateViewTable",
  "varBy": "*Overload 1*  \n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "view": "*Overload 1*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.qst.table.ViewTable\n  \n*Overload 2*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.qst.table.ViewTable",
  "walk": "Note: Java generics information - <V extends io.deephaven.qst.table.TableSchema.Visitor>\n\n:param visitor: V\n:return: V",
  "wavgBy": "*Overload 1*  \n  :param weightColumn: java.lang.String\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param weightColumn: java.lang.String\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param weightColumn: java.lang.String\n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param weightColumn: java.lang.String\n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable",
  "where": "*Overload 1*  \n  :param filters: java.lang.String...\n  :return: io.deephaven.qst.table.WhereTable\n  \n*Overload 2*  \n  :param filters: java.util.Collection<? extendsio.deephaven.api.filter.Filter>\n  :return: io.deephaven.qst.table.WhereTable",
  "whereIn": "**Incompatible overloads text - text from the first overload:**\n\nFilters this table based on the set of values in the rightTable.\n\n \n Delegates to TableOperations.whereIn(Object, Collection).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - the filtering table.\n  :param columnsToMatch: (java.lang.String...) - the columns to match between the two tables\n  :return: (io.deephaven.qst.table.WhereInTable) a new table filtered on right table\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - the filtering table.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - the columns to match between the two tables\n  :return: (io.deephaven.qst.table.WhereInTable) a new table filtered on right table",
  "whereNotIn": "**Incompatible overloads text - text from the first overload:**\n\nFilters this table based on the set of values not in the rightTable.\n\n \n Delegates to TableOperations.whereNotIn(Object, Collection).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - the filtering table.\n  :param columnsToMatch: (java.lang.String...) - the columns to match between the two tables\n  :return: (io.deephaven.qst.table.WhereNotInTable) a new table filtered on right table\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.qst.table.TableSpec) - the filtering table.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - the columns to match between the two tables\n  :return: (io.deephaven.qst.table.WhereNotInTable) a new table filtered on right table",
  "wsumBy": "*Overload 1*  \n  :param weightColumn: java.lang.String\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 2*  \n  :param weightColumn: java.lang.String\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 3*  \n  :param weightColumn: java.lang.String\n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 4*  \n  :param weightColumn: java.lang.String\n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.qst.table.AggregateAllByTable"
 },
 "path": "io.deephaven.qst.table.TableBase",
 "typeName": "class"
}