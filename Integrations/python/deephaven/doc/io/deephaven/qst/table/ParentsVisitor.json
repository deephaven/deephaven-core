{
 "className": "io.deephaven.qst.table.ParentsVisitor",
 "methods": {
  "getOut": ":return: java.util.stream.Stream<io.deephaven.qst.table.TableSpec>",
  "getParents": "A traversal of the table's parents. Does not perform de-duplication.\n\n:param table: (io.deephaven.qst.table.TableSpec) - the table\n:return: (java.util.stream.Stream<io.deephaven.qst.table.TableSpec>) the parents stream",
  "postOrder": "Create a post-order set from tables.\n\n \n Post-order means that for any given table, the table's dependencies will come before the table itself. There may\n be multiple valid post-orderings; callers should not rely on a specific post-ordering.\n\n:param tables: (java.lang.Iterable<io.deephaven.qst.table.TableSpec>) - the tables\n:return: (java.util.Set<io.deephaven.qst.table.TableSpec>) the post-order set",
  "postOrderList": "Create a de-duplicated, post-order list from tables.\n\n \n Post-order means that for any given table, the table's dependencies will come before the table itself. There may\n be multiple valid post-orderings; callers should not rely on a specific post-ordering.\n\n:param tables: (java.lang.Iterable<io.deephaven.qst.table.TableSpec>) - the tables\n:return: (java.util.List<io.deephaven.qst.table.TableSpec>) the de-duplicated, post-order list",
  "postOrderWalk": "**Incompatible overloads text - text from the first overload:**\n\nInvoke the consumer for each table in the de-duplicated, post-order walk from tables.\n\n \n Post-order means that for any given table, the table's dependencies will come before the table itself. There may\n be multiple valid post-orderings; callers should not rely on a specific post-ordering.\n\n*Overload 1*  \n  :param tables: (java.lang.Iterable<io.deephaven.qst.table.TableSpec>) - the tables\n  :param consumer: (java.util.function.Consumer<io.deephaven.qst.table.TableSpec>) - the consumer\n  \n*Overload 2*  \n  :param tables: (java.lang.Iterable<io.deephaven.qst.table.TableSpec>) - the tables\n  :param visitor: (io.deephaven.qst.table.TableSpec.Visitor) - the visitor",
  "reachable": "Create a reachable set from tables, including tables. May be in any order.\n\n:param tables: (java.lang.Iterable<io.deephaven.qst.table.TableSpec>) - the tables\n:return: (java.util.Set<io.deephaven.qst.table.TableSpec>) the reachable set",
  "search": "Performs a search for a table that satisfies searchPredicate. Will follow the dependencies of\n initialInputs. Tables that match excludePaths will not be returned, and will not have its\n dependencies added to the search.\n\n \n Note: a dependency of a table that matches excludePaths will be returned if there is any path to that\n dependency that doesn't go through excludePaths.\n\n:param initialInputs: java.lang.Iterable<io.deephaven.qst.table.TableSpec>\n:param excludePaths: java.util.function.Predicate<io.deephaven.qst.table.TableSpec>\n:param searchPredicate: java.util.function.Predicate<io.deephaven.qst.table.TableSpec>\n:return: java.util.Optional<io.deephaven.qst.table.TableSpec>",
  "visit": "*Overload 1*  \n  :param emptyTable: io.deephaven.qst.table.EmptyTable\n  \n*Overload 2*  \n  :param newTable: io.deephaven.qst.table.NewTable\n  \n*Overload 3*  \n  :param timeTable: io.deephaven.qst.table.TimeTable\n  \n*Overload 4*  \n  :param mergeTable: io.deephaven.qst.table.MergeTable\n  \n*Overload 5*  \n  :param headTable: io.deephaven.qst.table.HeadTable\n  \n*Overload 6*  \n  :param tailTable: io.deephaven.qst.table.TailTable\n  \n*Overload 7*  \n  :param reverseTable: io.deephaven.qst.table.ReverseTable\n  \n*Overload 8*  \n  :param sortTable: io.deephaven.qst.table.SortTable\n  \n*Overload 9*  \n  :param snapshotTable: io.deephaven.qst.table.SnapshotTable\n  \n*Overload 10*  \n  :param whereTable: io.deephaven.qst.table.WhereTable\n  \n*Overload 11*  \n  :param whereInTable: io.deephaven.qst.table.WhereInTable\n  \n*Overload 12*  \n  :param whereNotInTable: io.deephaven.qst.table.WhereNotInTable\n  \n*Overload 13*  \n  :param naturalJoinTable: io.deephaven.qst.table.NaturalJoinTable\n  \n*Overload 14*  \n  :param exactJoinTable: io.deephaven.qst.table.ExactJoinTable\n  \n*Overload 15*  \n  :param joinTable: io.deephaven.qst.table.JoinTable\n  \n*Overload 16*  \n  :param aj: io.deephaven.qst.table.AsOfJoinTable\n  \n*Overload 17*  \n  :param raj: io.deephaven.qst.table.ReverseAsOfJoinTable\n  \n*Overload 18*  \n  :param viewTable: io.deephaven.qst.table.ViewTable\n  \n*Overload 19*  \n  :param selectTable: io.deephaven.qst.table.SelectTable\n  \n*Overload 20*  \n  :param updateViewTable: io.deephaven.qst.table.UpdateViewTable\n  \n*Overload 21*  \n  :param updateTable: io.deephaven.qst.table.UpdateTable\n  \n*Overload 22*  \n  :param aggAllByTable: io.deephaven.qst.table.AggregateAllByTable\n  \n*Overload 23*  \n  :param aggregationTable: io.deephaven.qst.table.AggregationTable\n  \n*Overload 24*  \n  :param ticketTable: io.deephaven.qst.table.TicketTable\n  \n*Overload 25*  \n  :param inputTable: io.deephaven.qst.table.InputTable\n  \n*Overload 26*  \n  :param selectDistinctTable: io.deephaven.qst.table.SelectDistinctTable\n  \n*Overload 27*  \n  :param countByTable: io.deephaven.qst.table.CountByTable"
 },
 "path": "io.deephaven.qst.table.ParentsVisitor",
 "text": "A visitor that returns the parent tables (if any) of the given table.",
 "typeName": "class"
}