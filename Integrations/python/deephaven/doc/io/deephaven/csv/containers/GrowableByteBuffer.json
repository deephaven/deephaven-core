{
 "className": "io.deephaven.csv.containers.GrowableByteBuffer",
 "methods": {
  "append": "Appends 'srcSize' characters from 'src', starting at 'srcOffset'.\n\n:param src: byte[]\n:param srcOffset: int\n:param srcSize: int",
  "clear": "Clear the buffer.",
  "data": "Access the underlying data array.\n\n:return: byte[]",
  "size": "The current size.\n\n:return: int"
 },
 "path": "io.deephaven.csv.containers.GrowableByteBuffer",
 "text": "This is like TByteArrayList except that you can get at the underlying data buffer and use it for your own purposes,\n assuming you know what you're doing. We exploit this ability to (temporarily) point our slices at the underlying\n array while we are processing slices. In terms of expected usage, this class is only used for holding the data for\n cells, and only when the cell has escaped characters (like escaped quotes) or the cell spans more than one input\n chunk (in which case we can no longer do the trick where we point a slice directly at the array that buffers our\n input). Therefore the max size of this data structure is equal to the size of the largest cell in the input (which\n likely to be in the 10s or 100s of bytes). Since it's expected to be modest in size, we don't worry too much about\n our growth strategy, which simply involves doubling when we run out of space. In fact, in practice for \"normal\"\n input, this object probably never reallocates.",
 "typeName": "class"
}