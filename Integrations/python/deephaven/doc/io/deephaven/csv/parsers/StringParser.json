{
 "className": "io.deephaven.csv.parsers.StringParser",
 "methods": {
  "makeParserContext": "Make a context object for the parser. Sample implementation: \n final MySink sink = new MySink();\n return new ParserContext<>(sink, null, new MyType[chunkSize]);\n \n\n Note that parsers other than {Byte,Short,Int,Long}Parser can leave the source field null, as in the above\n example.\n\n:param gctx: (io.deephaven.csv.parsers.Parser.GlobalContext) - The GlobalContext. Built-in parsers use this to access the SinkFactory so that they can make a Sink\n        of the right type. Custom parsers will probably not need this.\n:param chunkSize: (int) - The size of the chunk to create.\n:return: (io.deephaven.csv.parsers.Parser.ParserContext<java.lang.String[]>) The ParserContext.",
  "tryParse": "Tries to parse the data pointed to by IteratorHolder 'ih' into a Sink. The method parses as many values as it\n can. It stops when:\n \n* The range [destBegin,destEnd) is full, or\n* The iterator ih is exhausted, or\n* The code encounters a source value that it is unable to parse.\n\n\n:param gctx: (io.deephaven.csv.parsers.Parser.GlobalContext) - The Parser.GlobalContext holding various shared parameters for the parse. This will be shared among\n        parsers of different types as the type inference process proceeds.\n:param pctx: (io.deephaven.csv.parsers.Parser.ParserContext<java.lang.String[]>) - The Parser.ParserContext for this specific parser. It will be the object created by the call to\n        {Parser#makeContext}. If the caller calls Parser.tryParse(io.deephaven.csv.parsers.Parser.GlobalContext, io.deephaven.csv.parsers.Parser.ParserContext<TARRAY>, io.deephaven.csv.parsers.IteratorHolder, long, long, boolean) multiple times (for example during\n        two-phase parsing), it will pass the same Parser.ParserContext object each time.\n:param ih: (io.deephaven.csv.parsers.IteratorHolder) - An IteratorHolder pointing to the data. It is already pointing to the current element or the end (in\n        other words, it has had IteratorHolder.tryMoveNext() called on it at least once). The reason for\n        this invariant is because other code (controlling logic and other parsers) have needed to peek at the\n        current element before getting here in order to decide what to do.\n:param begin: (long) - The start of the range (inclusive) to write values to.\n:param end: (long) - The end of the range (exclusive) to write values to. This can also be a very large value like\n        Long.MAX_VALUE if the caller does not know how many values there are.\n:param appending: (boolean) - Whether the parser is being called in a mode where it is appending to the end of the\n        Sink or replacing previously-written pad values in the Sink. This value is simply passed\n        on to Sink.write(TARRAY, boolean[], long, long, boolean) which may use it as a hint to slightly simplify its logic.\n:return: (long) The end range (exclusive) of the values parsed. Returns begin if no values were parsed."
 },
 "path": "io.deephaven.csv.parsers.StringParser",
 "text": "The parser for the String type.",
 "typeName": "class"
}