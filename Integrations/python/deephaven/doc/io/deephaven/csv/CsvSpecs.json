{
 "className": "io.deephaven.csv.CsvSpecs",
 "methods": {
  "builder": "Creates a builder for CsvSpecs.\n\n:return: (io.deephaven.csv.CsvSpecs.Builder) the builder",
  "charset": "The character set.\n\n \n By default, is UTF-8.\n\n:return: (java.nio.charset.Charset) the character set.",
  "concurrent": "Should the CSVReader run its processing steps concurrently on multiple threads for better performance.\n\n:return: (boolean) the concurrent flag",
  "csv": "A comma-separated-value delimited format.\n\n \n Equivalent to builder().build().\n\n:return: (io.deephaven.csv.CsvSpecs) the spec",
  "delimiter": "The delimiter character.\n\n \n By default is ','.\n\n:return: (char) the delimiter character",
  "fromLegacyFormat": ":param format: java.lang.String\n:return: io.deephaven.csv.CsvSpecs",
  "hasHeaderRow": "The header row flag. If true, the column names of the output table will be inferred from the first row of\n the table. If false, the column names will be numbered numerically in the format \"Column%d\" with a\n 1-based index.\n\n \n Note: if header() is specified, it takes precedence over the column names that will be used.\n\n \n By default is true.\n\n:return: (boolean) the header row flag",
  "header": "A header, when specified, hints at the parser to use.\n\n \n To be even more explicit, callers may also use parserForName() or parserForIndex().\n\n:return: (java.util.Optional<io.deephaven.qst.table.TableHeader>) the table header.",
  "headerForIndex": "Header overrides, where the keys are 1-based column indices. Specifying a column header overrides the header that\n would otherwise be used for that specific column.\n\n:return: java.util.Map<java.lang.Integer,java.lang.String>",
  "headerless": "**Incompatible overloads text - text from the first overload:**\n\nA header-less, CSV format, with the user providing the header.\n\n \n Equivalent to builder().hasHeaderRow(false).header(header).build().\n\n*Overload 1*  \n  :return: (io.deephaven.csv.CsvSpecs) the spec\n  \n*Overload 2*  \n  :param header: (io.deephaven.qst.table.TableHeader) - the header to use\n  :return: (io.deephaven.csv.CsvSpecs) the spec",
  "headers": "A list of column header names that, when specified, overrides the column names that would otherwise be used.\n\n:return: java.util.List<java.lang.String>",
  "ignoreSurroundingSpaces": "The ignore surrounding spaces flag, whether to trim leading and trailing blanks from non-quoted values.\n\n \n By default is true\n\n:return: (boolean) the ignore surrounding spaces flag",
  "inference": "The inference specifications.\n\n \n By default, is InferenceSpecs.standard().\n\n:return: (io.deephaven.csv.InferenceSpecs) the inference specifications",
  "nullValueLiteral": "The null value literal that is used when it is not overridden for any particular column.\n\n:return: java.lang.String",
  "nullValueLiteralForIndex": "The null value literals, where the keys are 1-based column indices. Specifying a null value literal for a column\n overrides the default null value literal, which is the empty string.\n\n:return: (java.util.Map<java.lang.Integer,java.lang.String>) the null value literals",
  "nullValueLiteralForName": "The null value literals, where the keys are column names. Specifying a null value literal for a column overrides\n the default null value literal, which is the empty string.\n\n:return: (java.util.Map<java.lang.String,java.lang.String>) the null value literals",
  "parse": "**Incompatible overloads text - text from the first overload:**\n\nParses stream according to the specifications of this. The stream will be closed upon\n return.\n\n \n Note: this implementation will buffer the stream internally.\n\n*Overload 1*  \n  :param string: (java.lang.String) - the string\n  :return: (io.deephaven.engine.table.Table) the new table\n  \n*Overload 2*  \n  :param stream: (java.io.InputStream) - the stream\n  :return: (io.deephaven.engine.table.Table) the new table",
  "parserForIndex": "The parsers, where the keys are 1-based column indices. Specifying a parser for a column forgoes inference for\n that column.\n\n:return: (java.util.Map<java.lang.Integer,io.deephaven.csv.parsers.Parser<?>>) the parsers.",
  "parserForName": "The parsers, where the keys are column names. Specifying a parser for a column forgoes inference for that column.\n\n:return: (java.util.Map<java.lang.String,io.deephaven.csv.parsers.Parser<?>>) the parsers.",
  "quote": "The quote character.\n\n \n By default is '\"'.\n\n:return: (char) the quote character",
  "trim": "The trim flag, whether to trim leading and trailing blanks from inside quoted values.\n\n \n By default is false.\n\n:return: (boolean) the trim flag",
  "tsv": "A tab-separated-value delimited format.\n\n \n Equivalent to builder().delimiter('\\t').build().\n\n:return: (io.deephaven.csv.CsvSpecs) the spec"
 },
 "path": "io.deephaven.csv.CsvSpecs",
 "text": "A specification object for parsing a CSV, or CSV-like, structure into a NewTable.",
 "typeName": "class"
}