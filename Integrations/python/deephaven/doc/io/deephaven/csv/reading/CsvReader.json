{
 "className": "io.deephaven.csv.reading.CsvReader",
 "methods": {
  "addParsers": "Add parsers to the existing list of parsers participating in type inference.\n\n:param parsers: io.deephaven.csv.parsers.Parser<?>...\n:return: io.deephaven.csv.reading.CsvReader",
  "read": "Read the data.\n\n:param stream: (java.io.InputStream) - The input data, encoded in UTF-8.\n:param sinkFactory: (io.deephaven.csv.sinks.SinkFactory) - A factory that can provide Sink<T> of all appropriate types for the output data. Once\n        the CsvReader determines what the column type is, t will use the SinkFactory to create an appropriate\n        Sink<T> for the type. Note that the CsvReader might guess wrong, so it might create a Sink,\n        partially populate it, and then abandon it. The final set of fully-populated Sinks will be returned in in\n        the CsvReader.Result.\n:return: (io.deephaven.csv.reading.CsvReader.Result) A CsvReader.Result containing the column names, the number of columns, and the final set of\n         fully-populated Sinks.",
  "setConcurrent": "Whether the reader should run the file tokenizer and column parsing jobs concurrently, using multiple threads.\n This typically yields better performance.\n\n:param value: boolean\n:return: io.deephaven.csv.reading.CsvReader",
  "setCustomTimeZoneParser": "Specify a plugin to be used to parse custom time zones. This permits the caller to support custom time zones such\n as the \" NY\" that appears in \"2020-05-05 12:34:56 NY\". The first digit (here, space) must be something other than\n \"Z\".\n\n:param customTimeZoneParser: io.deephaven.csv.tokenization.Tokenizer.CustomTimeZoneParser\n:return: io.deephaven.csv.reading.CsvReader",
  "setFieldDelimiter": "Sets the field delimiter. Typically the comma or tab character.\n\n:param value: char\n:return: io.deephaven.csv.reading.CsvReader",
  "setHasHeaders": "Sets whether the first row of the input is column headers.\n\n:param value: boolean\n:return: io.deephaven.csv.reading.CsvReader",
  "setHeader": "Overrides a specific column header by index. Columns are numbered starting with 1.\n\n:param columnNumber: int\n:param header: java.lang.String\n:return: io.deephaven.csv.reading.CsvReader",
  "setHeaderLegalizer": ":param headerLegalizer: java.util.function.Function<java.lang.String[],java.lang.String[]>\n:return: io.deephaven.csv.reading.CsvReader",
  "setHeaderValidator": ":param headerValidator: java.util.function.Predicate<java.lang.String>\n:return: io.deephaven.csv.reading.CsvReader",
  "setHeaders": "Overrides (if hasHeaders is true) or provides (if hasHeaders is false) the column headers.\n\n*Overload 1*  \n  :param headers: java.util.Collection<java.lang.String>\n  :return: io.deephaven.csv.reading.CsvReader\n  \n*Overload 2*  \n  :param headers: java.lang.String...\n  :return: io.deephaven.csv.reading.CsvReader",
  "setIgnoreSurroundingSpaces": "Sets whether to trim leading and trailing blanks from non-quoted values. This really only matters for columns\n that are inferred to be of type String. Numeric columns ignore surrounding whitespace regardless of this setting.\n\n:param value: boolean\n:return: io.deephaven.csv.reading.CsvReader",
  "setNullParser": "Specify the parser to be used for columns that contain all nulls. (Unless that column has a parser specified by\n setParserFor(java.lang.String, io.deephaven.csv.parsers.Parser<?>).\n\n:param nullParser: io.deephaven.csv.parsers.Parser<?>\n:return: io.deephaven.csv.reading.CsvReader",
  "setNullValueLiteral": "Specify the default null value literal to be used if not overridden for a column.\n\n:param nullValueLiteral: java.lang.String\n:return: io.deephaven.csv.reading.CsvReader",
  "setNullValueLiteralFor": "**Incompatible overloads text - text from the first overload:**\n\nSpecify a parser for a given column number, rather than using inference to pick a type. The column numbers are\n 1-based.\n\n*Overload 1*  \n  :param name: java.lang.String\n  :param nullValueLiteral: java.lang.String\n  :return: io.deephaven.csv.reading.CsvReader\n  \n*Overload 2*  \n  :param columnNumber: int\n  :param nullValueLiteral: java.lang.String\n  :return: io.deephaven.csv.reading.CsvReader",
  "setParserFor": "**Incompatible overloads text - text from the first overload:**\n\nSpecify a parser for a given column name, rather than using inference to pick a type.\n\n*Overload 1*  \n  :param name: java.lang.String\n  :param parser: io.deephaven.csv.parsers.Parser<?>\n  :return: io.deephaven.csv.reading.CsvReader\n  \n*Overload 2*  \n  :param columnNumber: int\n  :param parser: io.deephaven.csv.parsers.Parser<?>\n  :return: io.deephaven.csv.reading.CsvReader",
  "setParsers": "Set the list of parsers participating in type inference.\n\n:param parsers: java.util.Collection<io.deephaven.csv.parsers.Parser<?>>\n:return: io.deephaven.csv.reading.CsvReader",
  "setTrim": "Sets whether to trim leading and trailing blanks from inside quoted values. This really only matters for columns\n that are inferred to be of type String. Numeric columns ignore surrounding whitespace regardless of this setting.\n\n:param value: boolean\n:return: io.deephaven.csv.reading.CsvReader",
  "setquoteChar": "Sets the quote character. Used by the input when it needs to escape special characters like field or line\n delimiters. A doubled quote character represents itself. Examples (assuming the quote character is set to '\"'):\n \n* \"Hello, there\": the string Hello, there\n* \"Hello\"\"there\": the string Hello\"there\n* \"\"\"\": the string \"\n\n\n:param value: char\n:return: io.deephaven.csv.reading.CsvReader"
 },
 "path": "io.deephaven.csv.reading.CsvReader",
 "text": "A class for reading CSV data. Typical usage is:\n \n* Construct a CsvReader.\n* Customize the CsvReader by calling the various setXXX methods.\n* Arrange for the input text to be in a Reader.\n* Prepare a SinkFactory which can in turn provide Sink<T> objects for the output data.\n* Call the read(java.io.InputStream, io.deephaven.csv.sinks.SinkFactory) method.\n\n Furthermore the setXXX methods can be used in a builder pattern. Example:\n \n \n final CsvReader csvr = new CsvReader()\n   .setQuoteChar('#')\n   .setAsync(false)\n   .setParserFor(\"Timestamp\", Parsers.DATETIME);\n final Reader r = ...;\n final SinkFactory f = ...;\n final CsvReader.Result res = csvr.read(r, f);",
 "typeName": "class"
}