{
 "className": "io.deephaven.db.tables.live.LiveTableMonitor",
 "methods": {
  "addNotification": "Enqueue a notification to be flushed according to its priority. Non-terminal notifications should only be\n enqueued during the updating phase of a cycle. That is, they should be enqueued from a\n LiveTable.refresh() or subsequent notification delivery.\n\n:param notification: (io.deephaven.db.tables.live.NotificationQueue.Notification) - The notification to enqueue",
  "addNotifications": "Enqueue a collection of notifications to be flushed.\n\n:param notifications: (java.util.Collection<io.deephaven.db.tables.live.NotificationQueue.Notification>) - The notification to enqueue",
  "addTable": "Add a table to the list of tables to refresh and mark it as refreshing\n if it was a DynamicNode.\n\n:param table: (io.deephaven.db.tables.live.LiveTable) - The table to be added to the refresh list",
  "append": ":param logOutput: io.deephaven.base.log.LogOutput\n:return: io.deephaven.base.log.LogOutput",
  "checkInitiateTableOperation": "If we are establishing a new table operation, on a refreshing table without the LiveTableMonitor lock; then\n we are likely committing a grievous error, but one that will only occasionally result in us getting the wrong\n answer or if we are lucky an assertion.  This method is called from various query operations that should not\n be established without the LTM lock.\nThe refresh thread pool threads are allowed to instantiate operations, even though that thread does not have\n the lock; because they are protected by the main refresh thread and dependency tracking.\nIf you are sure that you know what you are doing better than the query engine, you may call\n setCheckTableOperations(boolean) to set a thread local variable bypassing this check.",
  "completeCycleForUnitTests": "Do the second half of the update cycle, including flushing notifications, and completing the\n LogicalClock update cycle. Note that this happens on a simulated\n LTM refresh thread, rather than this thread.",
  "doUnchecked": "Execute the supplied code while table operations are unchecked.\n\n*Overload 1*  \n  Note: Java generics information - <T>\n  \n  :param supplier: (java.util.function.Supplier<T>) - the function to run\n  :return: (T) the result of supplier\n  \n*Overload 2*  \n  :param runnable: (java.lang.Runnable) - the function to run",
  "enableUnitTestMode": "Enable unit test mode.\nIn this mode calls to addTable(LiveTable) will only mark tables as\n refreshing.  Additionally start() may not be called.",
  "exclusiveLock": "Get the exclusive lock for this LiveTableMonitor.\n Using this lock will prevent refresh or read-only processing from proceeding concurrently.\n The exclusive lock implementation is expected to support reentrance.\n Note that using the exclusive lock while the shared lock is held by the current thread will result in\n exceptions, as lock upgrade is not supported.\n This lock does support Lock.newCondition().\n\n:return: (io.deephaven.util.locks.AwareFunctionalLock) The exclusive lock for this LiveTableMonitor",
  "flushAllNormalNotificationsForUnitTests": "**Incompatible overloads text - text from the first overload:**\n\nFlush all the normal notifications from the LTM queue, continuing until done returns true.\n Note that the flushing happens on a simulated LTM refresh thread, rather than this thread.\n\n*Overload 1*  \n  \n  \n*Overload 2*  \n  :param done: (java.util.function.BooleanSupplier) - Function to determine when we can stop waiting for new notifications\n  :param timeoutMillis: long\n  :return: (java.lang.Runnable) A Runnable that may be used to wait for the concurrent flush job to complete",
  "flushOneNotificationForUnitTests": "Flush a single notification from the LTM queue.\n Note that this happens on a simulated LTM refresh thread, rather than this thread.\n\n:return: (boolean) whether a notification was found in the queue",
  "flushOneNotificationForUnitTestsInternal": ":return: boolean",
  "getCheckTableOperations": "Should this thread check table operations?\n\n:return: (boolean) if we should check table operations.",
  "getTargetCycleTime": "Get the target period between refresh cycles.\n\n:return: (long) The current minimum cycle time",
  "getUpdateThreads": "Retrieve the number of update threads.\n\n The LiveTableMonitor has a configurable number of update processing threads.  The number of threads is exposed\n in your method to enable you to partition a query based on the number of threads.\n\n:return: (int) the number of update threads configured.",
  "getWatchDogMillis": "Get the current watchdog timeout value.\n\n:return: (int) The current timeout for the watchdog, 0 for disabled",
  "isRefreshThread": "Test if this thread is part of our refresh thread executor service.\n\n:return: (boolean) whether this is one of our refresh threads.",
  "logDependencies": ":return: io.deephaven.io.log.LogEntry",
  "maybeAddNotification": "Add a notification for this NotificationQueue to deliver (by invoking its run() method), iff the delivery step\n is the current step and the update cycle for that step is still in process.\n This is only supported for non-terminal notifications.\n\n:param notification: (io.deephaven.db.tables.live.NotificationQueue.Notification) - The notification to add\n:param deliveryStep: (long) - The step to deliver this notification on\n:return: boolean",
  "maybeRefreshTable": "Acquire the exclusive lock if necessary and do a refresh of liveTable on this thread if it is\n registered with this LTM.\n\n:param liveTable: (io.deephaven.db.tables.live.LiveTable) - The LiveTable that we would like to refresh\n:param onlyIfHaveLock: (boolean) - If true, check that the lock is held first and do nothing if it is not",
  "refreshLiveTableForUnitTests": "Refresh a LiveTable on a simulated LTM refresh thread, rather than this thread.\n\n:param liveTable: (io.deephaven.db.tables.live.LiveTable) - The LiveTable to refresh",
  "removeTable": "Remove a table from this registrar.\n\n:param liveTable: (io.deephaven.db.tables.live.LiveTable) - The table to remove",
  "removeTables": "Remove a collection of tables from the list of refreshing tables.\n\n:param tablesToRemove: (java.util.Collection<io.deephaven.db.tables.live.LiveTable>) - The tables to remove from the list of refreshing tables",
  "requestRefresh": "Request a refresh for a single live table, which must already be registered with this\n LiveTableMonitor.\nThe update will occur on the LTM thread, but will not necessarily wait for the next scheduled cycle.\n\n:param liveTable: (io.deephaven.db.tables.live.LiveTable) - The live table to refresh",
  "requestSignal": ":param liveTableMonitorCondition: java.util.concurrent.locks.Condition",
  "resetCycleTime": "Resets the refresh cycle time to the default target configured via the LiveTableMonitor.targetcycletime property.",
  "resetForUnitTests": "Clear all monitored tables and enqueued notifications to support unit-tests.\n\n*Overload 1*  \n  :param after: (boolean) - Whether this is *after* a unit test completed. If true, held locks should result in an exception and\n                the LivenessScopeStack will be cleared.\n  \n*Overload 2*  \n  :param after: (boolean) - Whether this is *after* a unit test completed. If true, held locks should result\n                                  in an exception and the LivenessScopeStack will be cleared.\n  :param randomizedNotifications: (boolean) - Whether the notification processor should randomize the order of delivery\n  :param seed: (int) - Seed for randomized notification delivery order and delays\n  :param maxRandomizedThreadCount: (int) - Maximum number of threads handling randomized notification delivery\n  :param notificationStartDelay: (int) - Maximum randomized notification start delay\n  :param notificationAdditionDelay: (int) - Maximum randomized notification addition delay",
  "runWithinUnitTestCycle": "Execute the given runnable wrapped with startCycleForUnitTests() and\n completeCycleForUnitTests(). Note that the runnable is run on the current thread.\n\nNote: Java generics information - <T extends java.lang.Exception>\n\n:param runnable: (io.deephaven.util.FunctionalInterfaces.ThrowingRunnable<T>) - the runnable to execute.",
  "satisfied": "Is this ancestor satisfied? Note that this method must be safe to call on any thread.\n\n:param step: (long) - The step for which we are testing satisfaction\n:return: (boolean) Whether the dependency is satisfied on step (and will not fire subsequent notifications)",
  "setCheckTableOperations": "If you know that the table operations you are performing are indeed safe, then call this method with false to\n disable table operation checking.  Conversely, if you want to enforce checking even if the configuration\n disagrees; call it with true.\n\n:param value: (boolean) - the new value of check table operations\n:return: (boolean) the old value of check table operations",
  "setTargetCycleTime": "Set the target clock time between refresh cycles.\nCan be reset to default via resetCycleTime()\n\n:param cycleTime: (long) - The target time between refreshes in milliseconds",
  "setWatchDogMillis": "Enable the loop watchdog with the specified timeout.  A value of 0 disables the watchdog.\n\n:param watchDogMillis: (int) - The time in milliseconds to set the watchdog, or 0 to disable.",
  "setWatchDogTimeoutProcedure": "Set the procedure to be called when the watchdog times out.\n\n:param procedure: (java.util.function.LongConsumer) - The procedure to call",
  "sharedLock": "Get the shared lock for this LiveTableMonitor.\n Using this lock will prevent refresh processing from proceeding concurrently, but will allow other read-only\n processing to proceed.\n The shared lock implementation is expected to support reentrance.\n This lock does not support Lock.newCondition(). Use the exclusive\n lock if you need to wait on events that are driven by refresh processing.\n\n:return: (io.deephaven.util.locks.AwareFunctionalLock) The shared lock for this LiveTableMonitor",
  "start": "Start the table refresh thread.",
  "startCycleForUnitTests": "Begin the next update cycle while in\n unit-test mode. Note that this happens on a simulated\n LTM refresh thread, rather than this thread.",
  "toString": ":return: java.lang.String",
  "valueOf": "Returns the enum constant of this type with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this type.  (Extraneous whitespace characters are \nnot permitted.)\n\n:param name: (java.lang.String) - the name of the enum constant to be returned.\n:return: (io.deephaven.db.tables.live.LiveTableMonitor) the enum constant with the specified name",
  "values": "Returns an array containing the constants of this enum type, in\nthe order they are declared.\n\n:return: (io.deephaven.db.tables.live.LiveTableMonitor[]) an array containing the constants of this enum type, in the order they are declared",
  "wakeRefreshThreadForUnitTests": "If the refresh thread is waiting in flushNormalNotificationsAndCompleteCycle() or\n flushAllNormalNotificationsForUnitTests(BooleanSupplier, long), wake it up."
 },
 "path": "io.deephaven.db.tables.live.LiveTableMonitor",
 "text": "This class contains a thread which periodically updates a set of monitored LiveTables\n at a specified target cycle time.  The target cycle time can be configured\n to reduce or increase the refresh rate of the monitored tables.\nThis class can be configured via the following Configuration property\n\n* LiveTableMonitor.targetcycletime (optional) - The default target cycle time in ms (1000 if not defined)",
 "typeName": "enum"
}