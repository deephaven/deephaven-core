{
 "className": "io.deephaven.db.tables.live.LiveTableMonitor",
 "methods": {
  "addNotification": "Enqueue a notification to be flushed according to its priority. Non-terminal notifications should only be\n enqueued during the updating phase of a cycle. That is, they should be enqueued from a\n LiveTable.refresh() or subsequent notification delivery.\n\n:param notification: io.deephaven.db.tables.live.NotificationQueue.Notification",
  "addNotifications": "Enqueue a collection of notifications to be flushed.\n\n:param notifications: (java.util.Collection<io.deephaven.db.tables.live.NotificationQueue.Notification>) - The notification to enqueue",
  "addTable": "Add a table to the list of tables to refresh and mark it as refreshing\n if it was a DynamicNode.\n\n:param table: io.deephaven.db.tables.live.LiveTable",
  "append": ":param logOutput: io.deephaven.base.log.LogOutput\n:return: io.deephaven.base.log.LogOutput",
  "checkInitiateTableOperation": "If we are establishing a new table operation, on a refreshing table without the LiveTableMonitor lock; then\n we are likely committing a grievous error, but one that will only occasionally result in us getting the wrong\n answer or if we are lucky an assertion.  This method is called from various query operations that should not\n be established without the LTM lock.\nThe refresh thread pool threads are allowed to instantiate operations, even though that thread does not have\n the lock; because they are protected by the main refresh thread and dependency tracking.\nIf you are sure that you know what you are doing better than the query engine, you may call\n LiveTableMonitor.setCheckTableOperations(boolean) to set a thread local variable bypassing this check.",
  "completeCycleForUnitTests": "Do the second half of the update cycle, including flushing notifications, and completing the\n LogicalClock update cycle. Note that this happens on a simulated\n LTM refresh thread, rather than this thread.\n\nNote: Java generics information - io.deephaven.util.annotations.@TestUseOnly",
  "computeLocked": "Deprecated. See LiveTableMonitor.exclusiveLock() and FunctionalLock.computeLocked(io.deephaven.util.FunctionalInterfaces.ThrowingSupplier)\n\nNote: Java generics information - <R>\n\n:param r: (io.deephaven.base.Function.Nullary<R>) - the function to run\n:return: (R) the return value of the function",
  "doLocked": "**Incompatible overloads text - text from the first overload:**\n\nDeprecated. See LiveTableMonitor.exclusiveLock() and FunctionalLock.computeLocked(io.deephaven.util.FunctionalInterfaces.ThrowingSupplier)\n\n*Overload 1*  \n  Note: Java generics information - <T>\n  \n  :param r: (java.util.function.Supplier<T>) - the stuff to run\n  :return: (T) the result of the stuff to run\n  \n*Overload 2*  \n  :param r: (io.deephaven.base.Procedure.Nullary) - the stuff to run",
  "doLockedInterruptible": "**Incompatible overloads text - text from the first overload:**\n\nDeprecated. See LiveTableMonitor.exclusiveLock() and\n FunctionalLock.computeLockedInterruptibly(io.deephaven.util.FunctionalInterfaces.ThrowingSupplier)\n\n*Overload 1*  \n  Note: Java generics information - <T>\n  \n  :param r: (java.util.function.Supplier<T>) - the stuff to run\n  :return: (T) the result of the stuff to run\n  \n*Overload 2*  \n  :param r: (io.deephaven.base.Procedure.Nullary) - the stuff to run",
  "doLockedThrowing": "Deprecated. See LiveTableMonitor.exclusiveLock() and\n FunctionalLock.doLocked(FunctionalInterfaces.ThrowingRunnable)\n\nNote: Java generics information - <T extends java.lang.Exception>\n\n:param r: (io.deephaven.base.Procedure.ThrowingNullary<T>) - the stuff to run",
  "doUnchecked": "Execute the supplied code while table operations are unchecked.\n\n*Overload 1*  \n  Note: Java generics information - <T>\n  \n  :param supplier: (java.util.function.Supplier<T>) - the function to run\n  :return: (T) the result of supplier\n  \n*Overload 2*  \n  :param runnable: (java.lang.Runnable) - the function to run",
  "enableUnitTestMode": "Enable unit test mode.\nIn this mode calls to LiveTableMonitor.addTable(LiveTable) will only mark tables as\n refreshing.  Additionally LiveTableMonitor.start() may not be called.",
  "exclusiveLock": "Get the exclusive lock for this LiveTableMonitor.\n Using this lock will prevent refresh or read-only processing from proceeding concurrently.\n The exclusive lock implementation is expected to support reentrance.\n Note that using the exclusive lock while the shared lock is held by the current thread will result in\n exceptions, as lock upgrade is not supported.\n This lock does support Lock.newCondition().\n\n:return: (io.deephaven.util.locks.AwareFunctionalLock) The exclusive lock for this LiveTableMonitor",
  "flushAllNormalNotificationsForUnitTests": "**Incompatible overloads text - text from the first overload:**\n\nFlush all the normal notifications from the LTM queue, continuing until done returns true.\n Note that the flushing happens on a simulated LTM refresh thread, rather than this thread.\n\n*Overload 1*  \n  Note: Java generics information - io.deephaven.util.annotations.@TestUseOnly\n  \n*Overload 2*  \n  Note: Java generics information - io.deephaven.util.annotations.@TestUseOnly\n  \n  :param done: (java.util.function.BooleanSupplier) - Function to determine when we can stop waiting for new notifications\n  :param timeoutMillis: long\n  :return: (java.lang.Runnable) A Runnable that may be used to wait for the concurrent flush job to complete",
  "flushOneNotificationForUnitTests": "Flush a single notification from the LTM queue.\n Note that this happens on a simulated LTM refresh thread, rather than this thread.\n\nNote: Java generics information - io.deephaven.util.annotations.@TestUseOnly\n\n:return: (boolean) whether a notification was found in the queue",
  "flushOneNotificationForUnitTestsInternal": "Note: Java generics information - io.deephaven.util.annotations.@TestUseOnly\n\n:return: boolean",
  "getCheckTableOperations": "Should this thread check table operations?\n\n:return: (boolean) if we should check table operations.",
  "getTargetCycleTime": "Get the target period between refresh cycles.\n\n:return: (long) The current minimum cycle time",
  "getUpdateThreads": "Retrieve the number of update threads.\n\n The LiveTableMonitor has a configurable number of update processing threads.  The number of threads is exposed\n in your method to enable you to partition a query based on the number of threads.\n\n:return: (int) the number of update threads configured.",
  "getWatchDogMillis": "Get the current watchdog timeout value.\n\n:return: (int) The current timeout for the watchdog, 0 for disabled",
  "isLockedByCurrentThread": "Deprecated. See LiveTableMonitor.exclusiveLock() and AwareLock.isHeldByCurrentThread()\n\n:return: (boolean) Whether the current thread holds the lock exclusively",
  "isRefreshThread": "Test if this thread is part of our refresh thread executor service.\n\n:return: (boolean) whether this is one of our refresh threads.",
  "lock": "Deprecated. Prefer {LiveTableMonitor.exclusiveLock()}.lock().",
  "lockInterruptibly": "Deprecated. Prefer {LiveTableMonitor.exclusiveLock()}.lockInterruptibly().",
  "logDependencies": ":return: io.deephaven.io.log.LogEntry",
  "maybeAddNotification": "Add a notification for this NotificationQueue to deliver (by invoking its run() method), iff the delivery step\n is the current step and the update cycle for that step is still in process.\n This is only supported for non-terminal notifications.\n\n:param notification: io.deephaven.db.tables.live.NotificationQueue.Notification\n:param deliveryStep: long\n:return: boolean",
  "maybeRefreshTable": "Acquire the exclusive lock if necessary and do a refresh of liveTable on this thread if it is\n registered with this LTM.\n\n:param liveTable: io.deephaven.db.tables.live.LiveTable\n:param onlyIfHaveLock: boolean",
  "newCondition": "Deprecated. Prefer {LiveTableMonitor.exclusiveLock()}.newCondition().\n\n:return: java.util.concurrent.locks.Condition",
  "refreshLiveTableForUnitTests": "Refresh a LiveTable on a simulated LTM refresh thread, rather than this thread.\n\nNote: Java generics information - io.deephaven.util.annotations.@TestUseOnly\n\n:param liveTable: (io.deephaven.db.tables.live.LiveTable) - The LiveTable to refresh",
  "removeTable": "Remove a table from this registrar.\n\n:param liveTable: io.deephaven.db.tables.live.LiveTable",
  "removeTables": "Remove a collection of tables from the list of refreshing tables.\n\n:param tablesToRemove: (java.util.Collection<io.deephaven.db.tables.live.LiveTable>) - The tables to remove from the list of refreshing tables",
  "requestRefresh": "Request a refresh for a single live table, which must already be registered with this\n LiveTableMonitor.\nThe update will occur on the LTM thread, but will not necessarily wait for the next scheduled cycle.\n\n:param liveTable: io.deephaven.db.tables.live.LiveTable",
  "requestSignal": ":param liveTableMonitorCondition: java.util.concurrent.locks.Condition",
  "resetCycleTime": "Resets the refresh cycle time to the default target configured via the LiveTableMonitor.targetcycletime property.",
  "resetForUnitTests": "Clear all monitored tables and enqueued notifications to support unit-tests.\n\n*Overload 1*  \n  Note: Java generics information - io.deephaven.util.annotations.@TestUseOnly\n  \n*Overload 2*  \n  :param randomizedNotifications: boolean\n  :param seed: int\n  :param maxRandomizedThreadCount: int\n  :param notificationStartDelay: int\n  :param notificationAdditionDelay: int",
  "runWithinUnitTestCycle": "Execute the given runnable wrapped with LiveTableMonitor.startCycleForUnitTests() and\n LiveTableMonitor.completeCycleForUnitTests(). Note that the runnable is run on the current thread.\n\nNote: Java generics information - <T extends java.lang.Exception>\n\n:param runnable: (io.deephaven.util.FunctionalInterfaces.ThrowingRunnable<T>) - the runnable to execute.",
  "satisfied": "Is this ancestor satisfied? Note that this method must be safe to call on any thread.\n\n:param step: long\n:return: (boolean) Whether the dependency is satisfied on step (and will not fire subsequent notifications)",
  "setCheckTableOperations": "If you know that the table operations you are performing are indeed safe, then call this method with false to\n disable table operation checking.  Conversely, if you want to enforce checking even if the configuration\n disagrees; call it with true.\n\n:param value: (boolean) - the new value of check table operations\n:return: (boolean) the old value of check table operations",
  "setTargetCycleTime": "Set the target clock time between refresh cycles.\nCan be reset to default via LiveTableMonitor.resetCycleTime()\n\n:param cycleTime: (long) - The target time between refreshes in milliseconds",
  "setWatchDogMillis": "Enable the loop watchdog with the specified timeout.  A value of 0 disables the watchdog.\n\n:param watchDogMillis: (int) - The time in milliseconds to set the watchdog, or 0 to disable.",
  "setWatchDogTimeoutProcedure": "Set the procedure to be called when the watchdog times out.\n\n:param procedure: (java.util.function.LongConsumer) - The procedure to call",
  "sharedLock": "Get the shared lock for this LiveTableMonitor.\n Using this lock will prevent refresh processing from proceeding concurrently, but will allow other read-only\n processing to proceed.\n The shared lock implementation is expected to support reentrance.\n This lock does not support Lock.newCondition(). Use the exclusive\n lock if you need to wait on events that are driven by refresh processing.\n\n:return: (io.deephaven.util.locks.AwareFunctionalLock) The shared lock for this LiveTableMonitor",
  "start": "Start the table refresh thread.",
  "startCycleForUnitTests": "Begin the next update cycle while in\n unit-test mode. Note that this happens on a simulated\n LTM refresh thread, rather than this thread.\n\nNote: Java generics information - io.deephaven.util.annotations.@TestUseOnly",
  "toString": ":return: java.lang.String",
  "tryLock": "Deprecated. Prefer {LiveTableMonitor.exclusiveLock()}.tryLock().\n\n*Overload 1*  \n  :return: boolean\n  \n*Overload 2*  \n  :param time: long\n  :param unit: java.util.concurrent.TimeUnit\n  :return: boolean",
  "unlock": "Deprecated. Prefer {LiveTableMonitor.exclusiveLock()}.unlock().",
  "valueOf": "Returns the enum constant of this type with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this type.  (Extraneous whitespace characters are \nnot permitted.)\n\n:param name: (java.lang.String) - the name of the enum constant to be returned.\n:return: (io.deephaven.db.tables.live.LiveTableMonitor) the enum constant with the specified name",
  "values": "Returns an array containing the constants of this enum type, in\nthe order they are declared.  This method may be used to iterate\nover the constants as follows:\n\nfor (LiveTableMonitor c : LiveTableMonitor.values())\n    System.out.println(c);\n\n\n:return: (io.deephaven.db.tables.live.LiveTableMonitor[]) an array containing the constants of this enum type, in the order they are declared",
  "wakeRefreshThreadForUnitTests": "If the refresh thread is waiting in LiveTableMonitor.flushNormalNotificationsAndCompleteCycle() or\n LiveTableMonitor.flushAllNormalNotificationsForUnitTests(BooleanSupplier, long), wake it up.\n\nNote: Java generics information - io.deephaven.util.annotations.@TestUseOnly"
 },
 "path": "io.deephaven.db.tables.live.LiveTableMonitor",
 "text": "This class contains a thread which periodically updates a set of monitored LiveTables\n at a specified target cycle time.  The target cycle time can be configured\n to reduce or increase the refresh rate of the monitored tables.\nThis class can be configured via the following Configuration property\n\n* LiveTableMonitor.targetcycletime (optional) - The default target cycle time in ms (1000 if not defined)",
 "typeName": "enum"
}