{
 "className": "io.deephaven.db.tables.Table",
 "methods": {
  "absSumBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the sum of the absolute values for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "addColumnGrouping": ":param columnName: java.lang.String",
  "aj": "**Incompatible overloads text - text from the first overload:**\n\nLooks up the columns in the rightTable that meet the match conditions in the columnsToMatch list.\n Matching is done exactly for the first n-1 columns and via a binary search for the last match pair.\n The columns of the original table are returned intact, together with all the columns from rightTable.\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (io.deephaven.db.tables.select.MatchPair[]) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n  :param columnsToAdd: (io.deephaven.db.tables.select.MatchPair[]) - A comma separated list with the columns from the left side that need to be added to the right\n                         side as a result of the match.\n  :param asOfMatchRule: io.deephaven.db.tables.Table.AsOfMatchRule\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (io.deephaven.db.tables.select.MatchPair[]) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n  :param columnsToAdd: (io.deephaven.db.tables.select.MatchPair[]) - A comma separated list with the columns from the left side that need to be added to the right\n                         side as a result of the match.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :param asOfJoinRule: (io.deephaven.api.AsOfJoinRule) - The binary search operator for the last match pair.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 5*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<java.lang.String>) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 6*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the left side that need to\n          be added to the right side as a result of the match.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 7*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch",
  "apply": "Applies a function to this table.\n \n This is useful if you have a reference to a table or a proxy and want to run a series of operations against the\n table without each individual operation resulting in an RMI.\n\nNote: Java generics information - <R>\n\n:param function: (io.deephaven.base.Function.Unary<R,io.deephaven.db.tables.Table>) - the function to run, its single argument will be this table\n:return: (R) the return value of function",
  "applyToAllBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups data according to groupByColumns and applies formulaColumn to each of columns not altered by the grouping\n operation.\n columnParamName is used as place-holder for the name of each column inside\n formulaColumn.\n\n*Overload 1*  \n  :param formulaColumn: (java.lang.String) - Formula applied to each column\n  :param columnParamName: (java.lang.String) - The parameter name used as a placeholder for each column\n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(SelectColumn[])\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param formulaColumn: (java.lang.String) - Formula applied to each column, uses parameter each to refer to each colum it being applied to\n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(SelectColumn...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param formulaColumn: (java.lang.String) - Formula applied to each column, uses parameter each to refer to each colum it being applied to\n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :param formulaColumn: java.lang.String\n  :param groupByColumn: java.lang.String\n  :return: io.deephaven.db.tables.Table",
  "avgBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the average for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "by": "*Overload 1*  \n  :param aggregationStateFactory: io.deephaven.db.v2.by.AggregationStateFactory\n  :param groupByColumns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param aggregationStateFactory: io.deephaven.db.v2.by.AggregationStateFactory\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param aggregationStateFactory: io.deephaven.db.v2.by.AggregationStateFactory\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :param groupByColumns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 5*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 6*  \n  :return: io.deephaven.db.tables.Table\n  \n*Overload 7*  \n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 8*  \n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :param aggregations: java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>\n  :return: io.deephaven.db.tables.Table",
  "byExternal": "Create a TableMap from this table, keyed by the specified columns.\n\n The returned TableMap contains each row in this table in exactly one of the tables within the map.  If you\n have exactly one key column the TableMap is keyed by the value in that column.  If you have zero key columns, then\n the TableMap is keyed by io.deephaven.datastructures.util.SmartKey.EMPTY (and will contain this table as the\n value).  If you have multiple key columns, then\n the TableMap is keyed by a io.deephaven.datastructures.util.SmartKey.  The SmartKey will have one value for\n each of your column values, in the order specified by keyColumnNames.\nFor example if you have a Table keyed by a String column named USym, and a DBDateTime column named Expiry; a\n value could be retrieved from the TableMap with\n tableMap.get(new SmartKey(\"SPY\";, DBTimeUtils.convertDateTime(\"2020-06-19T16:15:00 NY\"))).  For a table\n with an Integer column named Bucket, you simply use the desired value as in tableMap.get(1).\n\n*Overload 1*  \n  :param dropKeys: (boolean) - if true, drop key columns in the output Tables\n  :param keyColumnNames: (java.lang.String...) - the name of the key columns to use.\n  :return: (io.deephaven.db.v2.TableMap) a TableMap keyed by keyColumnNames\n  \n*Overload 2*  \n  :param keyColumnNames: (java.lang.String...) - the name of the key columns to use.\n  :return: (io.deephaven.db.v2.TableMap) a TableMap keyed by keyColumnNames",
  "byteColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.db.v2.iterators.ByteColumnIterator",
  "characterColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.db.v2.iterators.CharacterColumnIterator",
  "clearSortingRestrictions": "Clear all sorting restrictions that was applied to the current table.\nNote that this table operates on the table it was invoked on and does not\n    create a new table. So in the following code\n    T1 = baseTable.where(...)\n          T2 = T1.restrictSortTo(\"C1\")\n          T3 = T2.clearSortingRestrictions()\n    \n\n    T1 == T2 == T3 and the result has no restrictions on sorting.\n \n\n:return: (io.deephaven.db.tables.Table) The same table this was invoked on.",
  "close": "Release resources held by this table, possibly destructively. This may render the table unsuitable or unsafe for\n further use.",
  "coalesce": "Explicitly ensure that any work needed to make a table indexable, iterable, or queryable has been done, and\n return the coalesced child table if appropriate.\n\n:return: (io.deephaven.db.tables.Table) This table, or a fully-coalesced child",
  "columnIterator": "Note: Java generics information - <TYPE>\n\n:param columnName: java.lang.String\n:return: java.util.Iterator<TYPE>",
  "countBy": "*Overload 1*  \n  :param countColumnName: java.lang.String\n  :param groupByColumns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param countColumnName: java.lang.String\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param countColumnName: java.lang.String\n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :param countColumnName: java.lang.String\n  :return: io.deephaven.db.tables.Table",
  "dateTimeColumnAsNanos": "Produce a new table with the same columns as this table, but with a new column presenting the specified\n DBDateTime column as a Long column (with each DBDateTime represented instead as the corresponding number of\n nanos since the epoch).\n \n NOTE: This is a really just an updateView(), and behaves accordingly for column ordering and (re)placement.\n This doesn't work on data that has been brought fully into memory (e.g. via select()).  Use a view instead.\n\n*Overload 1*  \n  :param dateTimeColumnName: (java.lang.String) - \n  :param nanosColumnName: (java.lang.String) - \n  :return: (io.deephaven.db.tables.Table) The new table, constructed as explained above.\n  \n*Overload 2*  \n  :param columnName: (java.lang.String) - \n  :return: (io.deephaven.db.tables.Table) The result of dateTimeColumnAsNanos(columnName, columnName).",
  "doubleColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.db.v2.iterators.DoubleColumnIterator",
  "dropColumnFormats": ":return: io.deephaven.db.tables.Table",
  "dropColumns": "*Overload 1*  \n  :param columnNames: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param columnNames: java.util.Collection<java.lang.String>\n  :return: io.deephaven.db.tables.Table",
  "dropStream": "If this table is a stream table, i.e. it has STREAM_TABLE_ATTRIBUTE set to true, return a child\n without the attribute, restoring standard semantics for aggregation operations.\n\n:return: (io.deephaven.db.tables.Table) A non-stream child table, or this table if it is not a stream table",
  "exactJoin": "**Incompatible overloads text - text from the first overload:**\n\nPerform an exact-join with the rightTable.\n\n \n Delegates to TableOperations.exactJoin(Object, Collection, Collection).\n\n*Overload 1*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: io.deephaven.db.tables.select.MatchPair[]\n  :param columnsToAdd: io.deephaven.db.tables.select.MatchPair[]\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :return: (io.deephaven.db.tables.Table) the exact-joined table\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to\n          be added to the left side as a result of the match.\n  :return: (io.deephaven.db.tables.Table) the exact-joined table\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (io.deephaven.db.tables.Table) the exact-joined table",
  "firstBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and retrieves the first for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "flatten": "Creates a version of this table with a flat index (V2 only).\n\n:return: io.deephaven.db.tables.Table",
  "floatColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.db.v2.iterators.FloatColumnIterator",
  "formatColumnWhere": ":param columnName: java.lang.String\n:param condition: java.lang.String\n:param formula: java.lang.String\n:return: io.deephaven.db.tables.Table",
  "formatColumns": ":param columnFormats: java.lang.String...\n:return: io.deephaven.db.tables.Table",
  "formatRowWhere": ":param condition: java.lang.String\n:param formula: java.lang.String\n:return: io.deephaven.db.tables.Table",
  "getAttribute": "Get the value of the specified attribute.\n\n:param key: (java.lang.String) - the name of the attribute\n:return: (java.lang.Object) the value, or null if there was none.",
  "getAttributeNames": "Get a set of all the attributes that have values for this table.\n\n:return: (java.util.Set<java.lang.String>) a set of names",
  "getAttributes": "**Incompatible overloads text - text from the first overload:**\n\nGet all attributes from the desired table except the items that appear in excluded.\n\n*Overload 1*  \n  :return: (java.util.Map<java.lang.String,java.lang.Object>) A map containing all of the attributes.\n  \n*Overload 2*  \n  :param excluded: (java.util.Collection<java.lang.String>) - A set of attributes to exclude from the result\n  :return: (java.util.Map<java.lang.String,java.lang.Object>) All of the table's attributes except the ones present in excluded",
  "getColumn": "*Overload 1*  \n  :param columnIndex: int\n  :return: io.deephaven.db.tables.DataColumn\n  \n*Overload 2*  \n  :param columnName: java.lang.String\n  :return: io.deephaven.db.tables.DataColumn",
  "getColumnSource": "Retrieves a ColumnSource and casts is to to the target class clazz.\n\n*Overload 1*  \n  :param sourceName: java.lang.String\n  :return: io.deephaven.db.v2.sources.ColumnSource\n  \n*Overload 2*  \n  Note: Java generics information - <T>\n  \n  :param sourceName: (java.lang.String) - The name of the column.\n  :param extend: java.lang.Class<?\n  :return: (io.deephaven.db.v2.sources.ColumnSource<T>) The column source for sourceName, parameterized by T.",
  "getColumnSourceMap": ":return: java.util.Map<java.lang.String,? extends io.deephaven.db.v2.sources.ColumnSource>",
  "getColumnSources": ":return: java.util.Collection<? extends io.deephaven.db.v2.sources.ColumnSource>",
  "getColumns": ":return: io.deephaven.db.tables.DataColumn[]",
  "getDefinition": ":return: io.deephaven.db.tables.TableDefinition",
  "getDescription": ":return: java.lang.String",
  "getIndex": ":return: io.deephaven.db.v2.utils.Index",
  "getMeta": "Provides column metadata in Table form.\n Convenience method, behaves exactly the same as getDefinition().getColumnDefinitionsTable().\n\n:return: (io.deephaven.db.tables.Table) A Table of metadata about this Table's columns.",
  "getRecord": ":param rowNo: long\n:param columnNames: java.lang.String...\n:return: java.lang.Object[]",
  "getSubTable": ":param index: io.deephaven.db.v2.utils.Index\n:return: io.deephaven.db.tables.Table",
  "hasAttribute": "Check if the specified attribute exists in this table.\n\n:param name: (java.lang.String) - the name of the attribute\n:return: (boolean) true if the attribute exists",
  "hasColumns": "**Incompatible overloads text - text from the first overload:**\n\nDetermines whether this Table contains a column for each string in the specified array of columnNames.\n\n*Overload 1*  \n  :param columnNames: (java.lang.String...) - The array of column names to be checked for inclusion in this table. Must not be null.\n  :return: (boolean) true if this Table contains a column for each and every string in the columnNames array;\n   false if any element of columnNames is not the name of a column in this table\n  \n*Overload 2*  \n  :param columnNames: (java.util.Collection<java.lang.String>) - The collection of column names to be checked for inclusion in this table. Must not be null.\n  :return: (boolean) true if this Table contains a column for each and every string in the columnNames collection;\n   false if any element of columnNames is not the name of a column in this table",
  "head": ":param size: long\n:return: io.deephaven.db.tables.Table",
  "headBy": "*Overload 1*  \n  :param nRows: long\n  :param groupByColumns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param nRows: long\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param nRows: long\n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.db.tables.Table",
  "headPct": "Provides a head that selects a dynamic number of rows based on a percent.\n\n:param percent: (double) - the fraction of the table to return (0..1), the number of rows will be rounded up.  For example\n                if there are 3 rows, headPct(50) returns the first two rows.\n:return: io.deephaven.db.tables.Table",
  "integerColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.db.v2.iterators.IntegerColumnIterator",
  "isEmpty": "Returns true if this table has no rows (i.e. size() == 0).\n\n:return: (boolean) true if this table has no rows",
  "isFlat": "Return true if this table is guaranteed to be flat.\n The index of a flat table will be from 0...numRows-1.\n\n:return: boolean",
  "isLive": ":return: boolean",
  "join": "**Incompatible overloads text - text from the first overload:**\n\nPerform a cross join with the right table.\n \n Returns a table that is the cartesian product of left rows X right rows, with one column for each of the left\n table's columns, and one column corresponding to each of the right table's columns that are included in the\n columnsToAdd argument. The rows are ordered first by the left table then by the right table. If columnsToMatch\n is non-empty then the product is filtered by the supplied match conditions.\n \n To efficiently produce updates, the bits that represent a key for a given row are split into two. Unless specified,\n join reserves 16 bits to represent a right row. When there are too few bits to represent all of the right rows\n for a given aggregation group the table will shift a bit from the left side to the right side. The default of 16\n bits was carefully chosen because it results in an efficient implementation to process live updates.\n \n An OutOfKeySpaceException is thrown when the total number of bits needed\n to express the result table exceeds that needed to represent Long.MAX_VALUE. There are a few work arounds:\n - If the left table is sparse, consider flattening the left table.\n - If there are no key-columns and the right table is sparse, consider flattening the right table.\n - If the maximum size of a right table's group is small, you can reserve fewer bits by setting numRightBitsToReserve on initialization.\n \n Note: If you can prove that a given group has at most one right-row then you should prefer using naturalJoin(io.deephaven.db.tables.Table, io.deephaven.db.tables.select.MatchPair[], io.deephaven.db.tables.select.MatchPair[]).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification with zero key-columns and includes all right columns\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param numRightBitsToReserve: (int) - The number of bits to reserve for rightTable groups.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification with zero key-columns and includes all right columns\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and includes all\n           non-key-columns from the right table\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n  :param numRightBitsToReserve: (int) - The number of bits to reserve for rightTable groups.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and includes all non-key-columns from the right table\n  \n*Overload 5*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to\n          be added to the left side as a result of the match.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 6*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to be added to the left\n                         side as a result of the match.\n  :param numRightBitsToReserve: (int) - The number of bits to reserve for rightTable groups.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 7*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (io.deephaven.db.tables.select.MatchPair[]) - An array of match pair conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n  :param columnsToAdd: (io.deephaven.db.tables.select.MatchPair[]) - An array of the columns from the right side that need to be added to the left\n                         side as a result of the match.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 8*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (io.deephaven.db.tables.select.MatchPair[]) - An array of match pair conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n  :param columnsToAdd: (io.deephaven.db.tables.select.MatchPair[]) - An array of the columns from the right side that need to be added to the left\n                                side as a result of the match.\n  :param numRightBitsToReserve: (int) - The number of bits to reserve for rightTable groups.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 9*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 10*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :param numRightBitsToReserve: (int) - The number of bits to reserve for rightTable groups.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "lastBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and retrieves the last for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "layoutHints": "*Overload 1*  \n  :param hints: java.lang.String\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param builder: io.deephaven.db.tables.utils.LayoutHintBuilder\n  :return: io.deephaven.db.tables.Table",
  "lazyUpdate": "Compute column formulas on demand.\n\n Lazy update defers computation until required for a set of values, and caches the results for a set of input\n values.  This uses less RAM than an update statement when you have a smaller set of unique values.  Less\n computation than an updateView is needed, because the results are saved in a cache.\nIf you have many unique values, you should instead use an update statement, which will have more memory\n efficient structures.  Values are never removed from the lazyUpdate cache, so it should be used judiciously\n on a ticking table.\n\n*Overload 1*  \n  :param newColumns: (io.deephaven.db.v2.select.SelectColumn...) - the columns to add\n  :return: (io.deephaven.db.tables.Table) a new Table with the columns added; to be computed on demand\n  \n*Overload 2*  \n  :param newColumns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param newColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.db.tables.Table",
  "leftJoin": "**Incompatible overloads text - text from the first overload:**\n\nPerform a left-join with the rightTable.\n\n \n Delegates to TableOperations.leftJoin(Object, Collection, Collection).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.db.tables.Table) - input table\n  :param columnsToMatch: (io.deephaven.db.tables.select.MatchPair[]) - match criteria\n  :param columnsToAdd: (io.deephaven.db.tables.select.MatchPair[]) - columns to add\n  :return: (io.deephaven.db.tables.Table) a table that has one column for each original table's columns, and one column corresponding to each column\n   listed in columnsToAdd.  If columnsToAdd.length==0 one column corresponding to each column of\n   the input table (right table) columns whose names don't overlap with the name of a column from the source table is added.\n   The new columns (those corresponding to the input table) contain an aggregation of all values from the left side that\n   match the join criteria.\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :return: (io.deephaven.db.tables.Table) a table that has one column for each original table's columns, and one column\n           corresponding to each column listed in columnsToAdd. If\n           columnsToAdd.isEmpty() one column corresponding to each column of the input\n           table (right table) columns whose names don't overlap with the name of a column from\n           the source table is added. The new columns (those corresponding to the input table)\n           contain an aggregation of all values from the left side that match the join criteria.\n  \n*Overload 3*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: java.util.Collection<java.lang.String>\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to\n          be added to the left side as a result of the match.\n  :return: (io.deephaven.db.tables.Table) the left-joined table\n  \n*Overload 5*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (io.deephaven.db.tables.Table) the left-joined table\n  \n*Overload 6*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :return: io.deephaven.db.tables.Table",
  "longColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.db.v2.iterators.LongColumnIterator",
  "maxBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the max for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(String...) }\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...) }\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns by(String...) }\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "medianBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the median for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(String...) }\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...) }\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns by(String...) }\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "minBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the min for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "moveColumns": "Produce a new table with the specified columns moved to the specified index. Column indices begin at 0.\n Columns can be renamed with the usual syntax, i.e. \"NewColumnName=OldColumnName\").\n\n*Overload 1*  \n  :param index: (int) - The index to which the specified columns should be moved\n  :param columnsToMove: (java.lang.String...) - The columns to move to the specified index (and, optionally, to rename)\n  :return: (io.deephaven.db.tables.Table) The new table, with the columns rearranged as explained above\n  \n*Overload 2*  \n  :param index: int\n  :param moveToEnd: boolean\n  :param columnsToMove: java.lang.String...\n  :return: io.deephaven.db.tables.Table",
  "moveDownColumns": "Produce a new table with the specified columns moved to the rightmost position. Columns can be renamed with the\n usual syntax, i.e. \"NewColumnName=OldColumnName\").\n\n:param columnsToMove: (java.lang.String...) - The columns to move to the right (and, optionally, to rename)\n:return: (io.deephaven.db.tables.Table) The new table, with the columns rearranged as explained above\n moveColumns(int, String...)",
  "moveUpColumns": "Produce a new table with the specified columns moved to the leftmost position. Columns can be renamed with the\n usual syntax, i.e. \"NewColumnName=OldColumnName\").\n\n:param columnsToMove: (java.lang.String...) - The columns to move to the left (and, optionally, to rename)\n:return: (io.deephaven.db.tables.Table) The new table, with the columns rearranged as explained above\n moveColumns(int, String...)",
  "naturalJoin": "**Incompatible overloads text - text from the first overload:**\n\nPerform a natural-join with the rightTable.\n\n \n Delegates to TableOperations.naturalJoin(Object, Collection, Collection).\n\n*Overload 1*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: io.deephaven.db.tables.select.MatchPair[]\n  :param columnsToAdd: io.deephaven.db.tables.select.MatchPair[]\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :return: (io.deephaven.db.tables.Table) the natural-joined table\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to\n          be added to the left side as a result of the match.\n  :return: (io.deephaven.db.tables.Table) the natural-joined table\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (io.deephaven.db.tables.Table) the natural-joined table",
  "of": ":param table: io.deephaven.qst.table.TableSpec\n:return: io.deephaven.db.tables.Table",
  "raj": "**Incompatible overloads text - text from the first overload:**\n\nJust like .aj(), but the matching on the last column is in reverse order, so that you find the row after the\n given timestamp instead of the row before.\n \n Looks up the columns in the rightTable that meet the match conditions in the columnsToMatch list.\n Matching is done exactly for the first n-1 columns and via a binary search for the last match pair.\n The columns of the original table are returned intact, together with the all columns from rightTable.\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (io.deephaven.db.tables.select.MatchPair[]) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n  :param columnsToAdd: (io.deephaven.db.tables.select.MatchPair[]) - A comma separated list with the columns from the left side that need to be added to the right\n                         side as a result of the match.\n  :param asOfMatchRule: io.deephaven.db.tables.Table.AsOfMatchRule\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (io.deephaven.db.tables.select.MatchPair[]) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n  :param columnsToAdd: (io.deephaven.db.tables.select.MatchPair[]) - A comma separated list with the columns from the left side that need to be added to the right\n                         side as a result of the match.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :param reverseAsOfJoinRule: (io.deephaven.api.ReverseAsOfJoinRule) - The binary search operator for the last match pair.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 5*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<java.lang.String>) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 6*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the left side that need to be added to the right\n                         side as a result of the match.\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 7*  \n  :param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch",
  "releaseCachedResources": "Attempt to release cached resources held by this table. Unlike close(), this must not render the table\n unusable for subsequent read operations. Implementations should be sure to call\n super.releaseCachedResources().",
  "renameAllColumns": ":param renameFunction: io.deephaven.db.tables.Table.RenameFunction\n:return: io.deephaven.db.tables.Table",
  "renameColumns": "*Overload 1*  \n  :param pairs: io.deephaven.db.tables.select.MatchPair...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param columns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.db.tables.Table",
  "restrictSortTo": "Disallow sorting on all but the specified columns.\n\n:param allowedSortingColumns: (java.lang.String...) - The columns on which sorting is allowed.\n:return: (io.deephaven.db.tables.Table) The same table this was invoked on.",
  "reverse": ":return: io.deephaven.db.tables.Table",
  "rollup": "**Incompatible overloads text - text from the first overload:**\n\nCreate a rollup table.\n\n A rollup table aggregates all rows of the table.\n\n*Overload 1*  \n  :param comboAggregateFactory: (io.deephaven.db.v2.by.ComboAggregateFactory) - the ComboAggregateFactory describing the aggregation\n  :param columns: (java.util.Collection<java.lang.String>) - the columns to group by\n  :return: (io.deephaven.db.tables.Table) a hierarchical table with the rollup applied\n  \n*Overload 2*  \n  :param comboAggregateFactory: (io.deephaven.db.v2.by.ComboAggregateFactory) - the ComboAggregateFactory describing the aggregation\n  :param includeConstituents: (boolean) - set to true to include the constituent rows at the leaf level\n  :param columns: (java.util.Collection<java.lang.String>) - the columns to group by\n  :return: (io.deephaven.db.tables.Table) a hierarchical table with the rollup applied\n  \n*Overload 3*  \n  :param comboAggregateFactory: (io.deephaven.db.v2.by.ComboAggregateFactory) - the ComboAggregateFactory describing the aggregation\n  :param columns: (java.lang.String...) - the columns to group by\n  :return: (io.deephaven.db.tables.Table) a hierarchical table with the rollup applied\n  \n*Overload 4*  \n  :param comboAggregateFactory: (io.deephaven.db.v2.by.ComboAggregateFactory) - the ComboAggregateFactory describing the aggregation\n  :param includeConstituents: (boolean) - set to true to include the constituent rows at the leaf level\n  :param columns: (java.lang.String...) - the columns to group by\n  :return: (io.deephaven.db.tables.Table) a hierarchical table with the rollup applied\n  \n*Overload 5*  \n  :param comboAggregateFactory: (io.deephaven.db.v2.by.ComboAggregateFactory) - the ComboAggregateFactory describing the aggregation\n  :param columns: (io.deephaven.db.v2.select.SelectColumn...) - the columns to group by\n  :return: (io.deephaven.db.tables.Table) a hierarchical table with the rollup applied\n  \n*Overload 6*  \n  :param comboAggregateFactory: (io.deephaven.db.v2.by.ComboAggregateFactory) - the ComboAggregateFactory describing the aggregation\n  :return: (io.deephaven.db.tables.Table) a hierarchical table with the rollup applied\n  \n*Overload 7*  \n  :param comboAggregateFactory: (io.deephaven.db.v2.by.ComboAggregateFactory) - the ComboAggregateFactory describing the aggregation\n  :param includeConstituents: (boolean) - set to true to include the constituent rows at the leaf level\n  :return: (io.deephaven.db.tables.Table) a hierarchical table with the rollup applied\n  \n*Overload 8*  \n  :param comboAggregateFactory: io.deephaven.db.v2.by.ComboAggregateFactory\n  :param includeConstituents: boolean\n  :param columns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.Table",
  "select": "*Overload 1*  \n  :param columns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "selectDistinct": "*Overload 1*  \n  :param columns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param columns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "setAttribute": "Set the value of an attribute.\n\n:param key: (java.lang.String) - the name of the attribute\n:param object: (java.lang.Object) - the value",
  "setColumnRenderers": "Sets renderers for columns.\n\n:param builder: (io.deephaven.db.v2.ColumnRenderersBuilder) - a builder that creates the packed string for the attribute\n:return: (io.deephaven.db.tables.Table) The same table with the ColumnRenderes attribute set",
  "setTotalsTable": "Sets parameters for the default totals table display.\n\n:param builder: (io.deephaven.db.v2.TotalsTableBuilder) - a TotalsTableBuilder object\n:return: (io.deephaven.db.tables.Table) a table with the totals applied",
  "shortColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.db.v2.iterators.ShortColumnIterator",
  "sizeForInstrumentation": ":return: long",
  "slice": "Extracts a subset of a table by row position.\n\n If both firstPosition and lastPosition are positive, then the rows are counted from the beginning of the table.\n The firstPosition is inclusive, and the lastPosition is exclusive.  The head(long)(N) call is equivalent to\n slice(0, N).  The firstPosition must be less than or equal to the lastPosition.\n\n If firstPosition is positive and lastPosition is negative, then the firstRow is counted from the beginning of the\n table, inclusively.  The lastPosition is counted from the end of the table.  For example, slice(1, -1) includes\n all rows but the first and last.  If the lastPosition would be before the firstRow, the result is an emptyTable.\n\n If firstPosition is negative, and lastPosition is zero, then the firstRow is counted from the end of the table,\n and the end of the slice is the size of the table.  slice(-N, 0) is equivalent to tail(long)(N).\n\n If the firstPosition is nega tive and the lastPosition is negative, they are both counted from the end of the\n table. For example, slice(-2, -1) returns the second to last row of the table.\n\n:param firstPositionInclusive: (long) - the first position to include in the result\n:param lastPositionExclusive: (long) - the last position to include in the result\n:return: (io.deephaven.db.tables.Table) a new Table, which is the request subset of rows from the original table",
  "snapshot": "**Incompatible overloads text - text from the first overload:**\n\nSnapshot baseTable, triggered by this table, and return a new table as a\n result.\n\n \n Delegates to TableOperations.snapshot(Object, boolean, Collection).\n\n*Overload 1*  \n  :param baseTable: (io.deephaven.db.tables.Table) - The table to be snapshotted\n  :param doInitialSnapshot: (boolean) - Take the first snapshot now (otherwise wait for a change event)\n  :param stampColumns: (java.lang.String...) - The columns forming the \"snapshot key\", i.e. some subset of this Table's\n          columns to be included in the result at snapshot time. As a special case, an empty\n          stampColumns is taken to mean \"include all columns\".\n  :return: (io.deephaven.db.tables.Table) The result table\n  \n*Overload 2*  \n  :param baseTable: (io.deephaven.db.tables.Table) - The table to be snapshotted\n  :param stampColumns: (java.lang.String...) - The columns forming the \"snapshot key\", i.e. some subset of this Table's\n          columns to be included in the result at snapshot time. As a special case, an empty\n          stampColumns is taken to mean \"include all columns\".\n  :return: (io.deephaven.db.tables.Table) The result table\n  \n*Overload 3*  \n  :param baseTable: (io.deephaven.db.tables.Table) - The table to be snapshotted\n  :param doInitialSnapshot: (boolean) - Take the first snapshot now (otherwise wait for a change event)\n  :param stampColumns: (java.util.Collection<io.deephaven.api.ColumnName>) - The columns forming the \"snapshot key\", i.e. some subset of this Table's\n          columns to be included in the result at snapshot time. As a special case, an empty\n          stampColumns is taken to mean \"include all columns\".\n  :return: (io.deephaven.db.tables.Table) The result table",
  "snapshotHistory": ":param rightTable: io.deephaven.db.tables.Table\n:return: io.deephaven.db.tables.Table",
  "snapshotIncremental": "*Overload 1*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param doInitialSnapshot: boolean\n  :param stampColumns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param stampColumns: java.lang.String...\n  :return: io.deephaven.db.tables.Table",
  "sort": "*Overload 1*  \n  :param sortPairs: io.deephaven.db.tables.SortPair...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param columnsToSortBy: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param columnsToSortBy: java.util.Collection<io.deephaven.api.SortColumn>\n  :return: io.deephaven.db.tables.Table",
  "sortDescending": ":param columnsToSortBy: java.lang.String...\n:return: io.deephaven.db.tables.Table",
  "stdBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the standard deviation for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "sumBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the sum for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "tail": ":param size: long\n:return: io.deephaven.db.tables.Table",
  "tailBy": "*Overload 1*  \n  :param nRows: long\n  :param groupByColumns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param nRows: long\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param nRows: long\n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.db.tables.Table",
  "tailPct": ":param percent: double\n:return: io.deephaven.db.tables.Table",
  "treeTable": "Create a hierarchical tree table.\n\n The structure of the table is encoded by an \"id\" and a \"parent\" column.  The id column should represent a unique\n identifier for a given row, and the parent column indicates which row is the parent for a given row.  Rows that\n have a null parent, are shown in the main table.  It is possible for rows to be \"orphaned\", if their parent\n reference is non-null and does not exist in the table.\n\n:param idColumn: (java.lang.String) - the name of a column containing a unique identifier for a particular row in the table\n:param parentColumn: (java.lang.String) - the name of a column containing the parent's identifier, null for elements that are part of\n                     the root table\n:return: (io.deephaven.db.tables.Table) a hierarchical table grouped according to the parentColumn",
  "ungroup": "Ungroups a table by converting arrays into columns.\n\n*Overload 1*  \n  :param nullFill: (boolean) - indicates if the ungrouped table should allow disparate sized arrays filling shorter columns with\n                   null values.  If set to false, then all arrays should be the same length.\n  :param columnsToUngroup: (java.lang.String...) - the columns to ungroup\n  :return: (io.deephaven.db.tables.Table) the ungrouped table\n  \n*Overload 2*  \n  :param columnsToUngroup: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :param nullFill: boolean\n  :return: io.deephaven.db.tables.Table",
  "ungroupAllBut": ":param columnsNotToUngroup: java.lang.String...\n:return: io.deephaven.db.tables.Table",
  "update": "*Overload 1*  \n  :param newColumns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param newColumns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.db.tables.Table",
  "updateView": "*Overload 1*  \n  :param newColumns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param newColumns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.db.tables.Table",
  "validateSelect": "DO NOT USE -- this API is in flux and may change or disappear in the future.\n\n*Overload 1*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.db.tables.SelectValidationResult\n  \n*Overload 2*  \n  :param columns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.SelectValidationResult",
  "varBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the variance for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "view": "*Overload 1*  \n  :param columns: io.deephaven.db.v2.select.SelectColumn...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.db.tables.Table",
  "wavgBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the weighted average using\n weightColumn for the rest of the fields\n\n*Overload 1*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :return: io.deephaven.db.tables.Table",
  "where": "*Overload 1*  \n  :param filters: io.deephaven.db.v2.select.SelectFilter...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param filters: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param filters: java.util.Collection<? extendsio.deephaven.api.filter.Filter>\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :return: io.deephaven.db.tables.Table",
  "whereDynamic": "Use the whereIn method call instead.\n\n:param rightTable: io.deephaven.db.tables.Table\n:param inclusion: boolean\n:param columnsToMatch: io.deephaven.db.tables.select.MatchPair...\n:return: io.deephaven.db.tables.Table",
  "whereDynamicIn": "*Overload 1*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: io.deephaven.db.tables.select.MatchPair...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: java.lang.String...\n  :return: io.deephaven.db.tables.Table",
  "whereDynamicNotIn": "*Overload 1*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: io.deephaven.db.tables.select.MatchPair...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: java.lang.String...\n  :return: io.deephaven.db.tables.Table",
  "whereIn": "**Incompatible overloads text - text from the first overload:**\n\nFilters this table based on the set of values in the rightTable.\n\n \n Delegates to TableOperations.whereIn(Object, Collection).\n\n*Overload 1*  \n  :param groupStrategy: io.deephaven.db.tables.Table.GroupStrategy\n  :param rightTable: (io.deephaven.db.tables.Table) - the filtering table.\n  :param inclusion: (boolean) - whether things included in rightTable should be passed through (they are exluded if false)\n  :param columnsToMatch: (io.deephaven.db.tables.select.MatchPair...) - the columns to match between the two tables\n  :return: (io.deephaven.db.tables.Table) a new table filtered on right table\n  \n*Overload 2*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param inclusion: boolean\n  :param columnsToMatch: io.deephaven.db.tables.select.MatchPair...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param inclusion: boolean\n  :param columnsToMatch: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.db.tables.Table) - the filtering table.\n  :param columnsToMatch: (java.lang.String...) - the columns to match between the two tables\n  :return: (io.deephaven.db.tables.Table) a new table filtered on right table\n  \n*Overload 5*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: io.deephaven.db.tables.select.MatchPair...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 6*  \n  :param groupStrategy: io.deephaven.db.tables.Table.GroupStrategy\n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 7*  \n  :param groupStrategy: io.deephaven.db.tables.Table.GroupStrategy\n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: io.deephaven.db.tables.select.MatchPair...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 8*  \n  :param groupStrategy: io.deephaven.db.tables.Table.GroupStrategy\n  :param rightTable: io.deephaven.db.tables.Table\n  :param inclusion: boolean\n  :param columnsToMatch: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 9*  \n  :param rightTable: (io.deephaven.db.tables.Table) - the filtering table.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - the columns to match between the two tables\n  :return: (io.deephaven.db.tables.Table) a new table filtered on right table",
  "whereNotIn": "**Incompatible overloads text - text from the first overload:**\n\nFilters this table based on the set of values not in the rightTable.\n\n \n Delegates to TableOperations.whereNotIn(Object, Collection).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.db.tables.Table) - the filtering table.\n  :param columnsToMatch: (java.lang.String...) - the columns to match between the two tables\n  :return: (io.deephaven.db.tables.Table) a new table filtered on right table\n  \n*Overload 2*  \n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: io.deephaven.db.tables.select.MatchPair...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param groupStrategy: io.deephaven.db.tables.Table.GroupStrategy\n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :param groupStrategy: io.deephaven.db.tables.Table.GroupStrategy\n  :param rightTable: io.deephaven.db.tables.Table\n  :param columnsToMatch: io.deephaven.db.tables.select.MatchPair...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 5*  \n  :param rightTable: (io.deephaven.db.tables.Table) - the filtering table.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - the columns to match between the two tables\n  :return: (io.deephaven.db.tables.Table) a new table filtered on right table",
  "whereOneOf": "**Incompatible overloads text - text from the first overload:**\n\nApplies the provided filters to the table disjunctively.\n\n*Overload 1*  \n  :param filtersToApply: (java.util.Collection<io.deephaven.db.v2.select.SelectFilter>...) - each inner collection is a set of filters, all of must which match for the clause to\n                         be true.  If any one of the collections in the array evaluates to true, the row is part\n                         of the output table.\n  :return: (io.deephaven.db.tables.Table) a new table, with the filters applied.\n  \n*Overload 2*  \n  :param filtersToApplyStrings: (java.lang.String...) - an Array of filters to apply\n  :return: (io.deephaven.db.tables.Table) a new table, with the filters applied\n  \n*Overload 3*  \n  :return: io.deephaven.db.tables.Table",
  "withColumnDescription": "**Incompatible overloads text - text from the first overload:**\n\nAdd a description for a specific column.  You may use withColumnDescription(Map) to set several descriptions\n at once.\n\n*Overload 1*  \n  :param column: (java.lang.String) - the name of the column\n  :param description: (java.lang.String) - the column description\n  :return: (io.deephaven.db.tables.Table) a copy of the source table with the description applied\n  \n*Overload 2*  \n  :param descriptions: (java.util.Map<java.lang.String,java.lang.String>) - a map of Column name to Column description.\n  :return: (io.deephaven.db.tables.Table) a copy of the table with the descriptions applied.",
  "withKeys": "Set the table's key columns.\n\n:param columns: java.lang.String...\n:return: (io.deephaven.db.tables.Table) The same table this method was invoked on, with the keyColumns attribute set",
  "withTableDescription": ":param description: java.lang.String\n:return: io.deephaven.db.tables.Table",
  "withUniqueKeys": "Set the table's key columns and indicate that each key set will be unique.\n\n:param columns: java.lang.String...\n:return: (io.deephaven.db.tables.Table) The same table this method was invoked on, with the keyColumns\n         and unique attributes set",
  "wouldMatch": "A table operation that applies the supplied predicate to each row in the table and produces columns containing the\n pass/fail result of the predicate application. This is similar to where(String...) except that instead of\n selecting only rows that meet the criteria, new columns are added with the result of the comparison.\n\n*Overload 1*  \n  :param expressions: java.lang.String...\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param matchers: io.deephaven.db.tables.select.WouldMatchPair...\n  :return: (io.deephaven.db.tables.Table) a table with new columns containing the filter result for each row.",
  "wsumBy": "**Incompatible overloads text - text from the first overload:**\n\nComputes the weighted sum for all rows in the table using weightColumn for the rest of the fields\n\n If the weight column is a floating point type, all result columns will be doubles.  If the weight\n column is an integral type, all integral input columns will have long results and all floating point\n input columns will have double results.\n\n*Overload 1*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 2*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 3*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :param groupByColumns: (java.lang.String...) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table\n  \n*Overload 4*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns by(String...)\n  :return: io.deephaven.db.tables.Table"
 },
 "path": "io.deephaven.db.tables.Table",
 "text": "A Deephaven table.",
 "typeName": "interface"
}