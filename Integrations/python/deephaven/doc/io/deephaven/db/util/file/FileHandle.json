{
 "className": "io.deephaven.db.util.file.FileHandle",
 "methods": {
  "close": "Close this file handle and release underlying resources.\n \n See AbstractInterruptibleChannel.close().",
  "force": "Force updates (including metadata) to the underlying file to be written to *local* storage.\n \n See FileChannel.force(boolean).",
  "isOpen": "Tells whether this file handle is open.\n \n See AbstractInterruptibleChannel.isOpen().\n\n:return: (boolean) If the file handle is open",
  "position": "**Incompatible overloads text - text from the first overload:**\n\n\n Advance the position of this file handle to the specified new position.\n \n See FileChannel.position(long).\n\n*Overload 1*  \n  :return: (long) This file handle's position\n  \n*Overload 2*  \n  :param newPosition: (long) - The new position\n  :return: (io.deephaven.db.util.file.FileHandle) This file handle",
  "read": "**Incompatible overloads text - text from the first overload:**\n\n\n Attempt to read destination.remaining() bytes, beginning at the handle's current position and updating\n that position by the number of bytes read.\n \n See FileChannel.read(ByteBuffer).\n\n*Overload 1*  \n  :param destination: (java.nio.ByteBuffer) - The destination to read to\n  :param position: (long) - The position in the file to start reading from\n  :return: (int) The number of bytes read, or -1 if end of file is reached\n  \n*Overload 2*  \n  :param destination: (java.nio.ByteBuffer) - The destination to read to\n  :return: (int) The number of bytes read, or -1 of end of file is reached",
  "size": "Get the current size of the file.\n \n See FileChannel.size().\n\n:return: (long) The current size of the file",
  "truncate": "Truncate this file to the supplied size.\n \n See FileChannel.truncate(long).\n\n:param size: (long) - The new size\n:return: (io.deephaven.db.util.file.FileHandle) This handle",
  "write": "**Incompatible overloads text - text from the first overload:**\n\n\n Attempt to write source.remaining() bytes to this file handle, beginning at the handle's current position\n (which is first advanced to the end of the file, if the underlying FileChannel was opened with\n StandardOpenOption.APPEND), and updating that position by the number of bytes written.\n \n See FileChannel.write(ByteBuffer).\n\n*Overload 1*  \n  :param source: java.nio.ByteBuffer\n  :param position: long\n  :return: int\n  \n*Overload 2*  \n  :param source: (java.nio.ByteBuffer) - The source to write from\n  :return: (int) The number of bytes written"
 },
 "path": "io.deephaven.db.util.file.FileHandle",
 "text": "A representation of an open file. Designed to ensure predictable cleanup for open file descriptors.\n\n \n This class is basically just a wrapper around a FileChannel that only exposes some of its methods. It serves\n two purposes:\n \n* It creates an extra layer of indirection between the FileChannel and application code, to allow for\n reachability-sensitive cleanup.\n* It's a convenient place to add instrumentation and/or modified implementations when necessary.\n\n\n The current implementation adds a post-close procedure for integration with caches/trackers, and stats for all\n operations.\n\n \n Note that positional methods, e.g. position(), position(long), read(ByteBuffer), and\n write(ByteBuffer) may require external synchronization if used concurrently by more than one thread.",
 "typeName": "class"
}