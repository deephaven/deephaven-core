{
 "className": "io.deephaven.db.v2.select.AutoTuningIncrementalReleaseFilter",
 "methods": {
  "copy": "Create a copy of this SelectFilter.\n\n:return: (io.deephaven.db.v2.select.AutoTuningIncrementalReleaseFilter) an independent copy of this SelectFilter.",
  "dropReference": "Drop a previously-retained reference to this referent.",
  "getWeakReference": "Get a WeakReference to this referent. This may be cached, or newly created.\n\n:return: (java.lang.ref.WeakReference<? extends io.deephaven.db.util.liveness.LivenessReferent>) A new or cached reference to this referent",
  "initializeTransientFieldsForLiveness": "Package-private for Serializable sub-classes to use in readObject only.\n Public to allow unit tests in another package to work around mock issues where the constructor is never invoked.",
  "refresh": "Refresh this LiveTable.",
  "tryManage": "Attempt to add the specified referent to this manager.\n\n:param referent: (io.deephaven.db.util.liveness.LivenessReferent) - The referent to add\n:return: (boolean) Whether the referent was in fact added",
  "tryRetainReference": "If this referent is \"live\", behave as LivenessReferent.retainReference() and return true. Otherwise, returns false rather\n than throwing an exception.\n\n:return: (boolean) True if this referent was retained, false otherwise"
 },
 "path": "io.deephaven.db.v2.select.AutoTuningIncrementalReleaseFilter",
 "text": "Filter that releases the required number of rows from a table to saturate the LTM cycle.\n \n The table has an initial size, which can be thought of as the size during query initialization. There is an initial\n number of rows that are released, which is then used to tune the number of rows to release on the subsequent cycle.\n \n The targetFactor parameter is multiplied by the LTM's targetCycle. This allows you to determine how busy you want the\n LTM to be. For example a factor of 1, will attempt to hit the target cycle exactly. A target of 0.5 should result an\n LTM ratio of about 50%. A factor of 10 would mean that the system will extend beyond the target cycle time, coalesce\n updates accordingly and have a ratio that is nearly 100%.\n \n The time the rows are released is recorded, and a terminal notification is enqueued to record the end of the cycle.\n On each cycle, the number of rows per second is computed; and then the number of rows released is the LTM's target\n cycle multiplied by the rows per second multiplied by the target factor.\n\n\n \n The AutotuningIncrementalReleaseFilter can be used to benchmark how many rows of data a query can process. In its\n simplest form we can measure how many rows a lastBy statement can process. For example:\n \n\n import io.deephaven.db.v2.select.AutoTuningIncrementalReleaseFilter\n\n quotes = db.t(\"FeedOS\", \"EquityQuoteL1\").where(\"Date=lastBusinessDateNy()\")\n filter=new AutoTuningIncrementalReleaseFilter(10000, 10000, 1)\n quotesFiltered = quotes.where(filter)\n currentQuote = quotesFiltered.lastBy(\"LocalCodeStr\").update(\"Mid=(Bid + Ask)/2\")\n \n \n Produces a currentQuote table, and you can view the Log tab to determine how many rows per second were processed. The\n summary is sent to the WARN level:\n \n \n 12:55:49.985 WARN Completed release 6.97 seconds, rows=19630961, rows/second=2,817,053.86\n \n \n If verbose mode is enabled, progress is displayed for each cycle at the INFO level.\n \n\n \n You may specify a StreamLoggerImpl() to send the data to STDOUT, as follows:\n \n\n import io.deephaven.db.v2.select.AutoTuningIncrementalReleaseFilter\n\n quotes = db.t(\"FeedOS\", \"EquityQuoteL1\").where(\"Date=lastBusinessDateNy()\")\n logger = new io.deephaven.io.logger.StreamLoggerImpl()\n filterQuotes=new AutoTuningIncrementalReleaseFilter(logger, 10000, 10000, 1.0d, true)\n quotesFiltered = quotes.where(filterQuotes)\n currentQuote = quotesFiltered.lastBy(\"LocalCodeStr\").update(\"Mid=(Bid + Ask)/2\")\n \n\n The verbose information and the final report are easily visible on your console.\n \n\n The AutotuningIncrementalReleaseFilter is best suited for queries that have a single source table with arbitrary\n amounts of processing on that table. Multiple incremental release filters may be combined, and each filter will\n report the number of rows that were released per second, however the data is not synchronized between tables and it\n is not possible to differentiate which table is contributing more to the query's load without examining the\n performance tables. You may need to adjust the initial size parameters so that one table does not complete processing\n before another.\n \n \n import io.deephaven.db.v2.select.AutoTuningIncrementalReleaseFilter\n\n quotes = db.t(\"FeedOS\", \"EquityQuoteL1\").where(\"Date=lastBusinessDateNy()\")\n trades = db.t(\"FeedOS\", \"EquityTradeL1\").where(\"Date=lastBusinessDateNy()\")\n filterQuotes=new AutoTuningIncrementalReleaseFilter(10000, 10000, 1, true)\n quotesFiltered = quotes.where(filterQuotes)\n filterTrades=new AutoTuningIncrementalReleaseFilter(10000, 10000, 1, true)\n tradesFiltered = trades.where(filterTrades)\n\n decorated = tradesFiltered.aj(quotesFiltered, \"LocalCodeStr,MarketTimestamp\", \"QuoteTime=MarketTimestamp,Bid,BidSize,Ask,AskSize\")",
 "typeName": "class"
}