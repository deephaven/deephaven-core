{
 "className": "io.deephaven.db.v2.utils.IndexShiftData",
 "methods": {
  "append": "*Overload 1*  \n  :param logOutput: io.deephaven.base.log.LogOutput\n  :return: io.deephaven.base.log.LogOutput\n  \n*Overload 2*  \n  :param logOutput: io.deephaven.base.log.LogOutput\n  :param maxShifts: int\n  :return: io.deephaven.base.log.LogOutput",
  "apply": "**Incompatible overloads text - text from the first overload:**\n\nApply all shifts in a memmove-semantics-safe ordering through the provided shiftCallback.\n\n Use this to move from pre-shift keyspace to post-shift keyspace.\n\n*Overload 1*  \n  :param shiftCallback: (io.deephaven.db.v2.utils.IndexShiftData.Callback) - the callback that will process all shifts\n  \n*Overload 2*  \n  :param index: (io.deephaven.db.v2.utils.Index) - the index to shift",
  "applyIterator": ":return: io.deephaven.db.v2.utils.IndexShiftData.Iterator",
  "applyShift": "Apply a shift to the provided index. Moves index from pre-shift keyspace to post-shift keyspace.\n\n:param index: (io.deephaven.db.v2.utils.Index) - The index to apply the shift to\n:param beginRange: (long) - start of range (inclusive)\n:param endRange: (long) - end of range (inclusive)\n:param shiftDelta: (long) - amount range has moved by\n:return: (boolean) Whether there was any overlap found to shift",
  "empty": "Queries whether this IndexShiftData is empty (i.e. has no shifts).\n\n:return: (boolean) true if the size() of this is zero, false if the size is greater than zero",
  "equals": ":param obj: java.lang.Object\n:return: boolean",
  "extractParallelShiftedRowsFromPostShiftIndex": "This method creates two parallel Index structures that contain postShiftIndex keys affected by shifts. The two\n Indexes have the same size. An element at position k in the first index is the pre-shift key for the same row\n whose post-shift key is at position k in the second index.\n\n:param postShiftIndex: (io.deephaven.db.v2.utils.ReadOnlyIndex) - The index of keys that were shifted in post-shift keyspace. It should not contain rows that\n        did not exist prior to the shift.\n:return: (io.deephaven.util.SafeCloseablePair<io.deephaven.db.v2.utils.Index,io.deephaven.db.v2.utils.Index>) A SafeCloseablePair of preShiftedKeys and postShiftedKeys that intersect this IndexShiftData with\n         postShiftIndex.",
  "forAllInIndex": ":param filterIndex: io.deephaven.db.v2.utils.ReadOnlyIndex\n:param callback: io.deephaven.db.v2.utils.IndexShiftData.SingleElementShiftCallback",
  "getBeginRange": "Get the inclusive begin offset of the idxth shift.\n\n:param idx: (int) - which pair to get offset for\n:return: (long) the offset",
  "getEffectiveSize": "The number of keys affected by shift commands.\n\n:return: (long) number of keys affected by shifts",
  "getEffectiveSizeClamped": "The number of keys affected by shift commands.\n\n:param clamp: (long) - the maximum size to return\n:return: (long) number of keys affected by shifts",
  "getEndRange": "Get the inclusive end offset of the idxth shift.\n\n:param idx: (int) - which pair to get offset for\n:return: (long) the offset",
  "getShiftDelta": "Get the absolute shift of the idxth shift.\n\n:param idx: (int) - which pair to get shift for\n:return: (long) the shift",
  "intersect": "Intersects this IndexShiftData against the provided Index.\n\n:param index: (io.deephaven.db.v2.utils.Index) - the index to test for intersections (pre-shift keyspace)\n:return: (io.deephaven.db.v2.utils.IndexShiftData) an IndexShiftData containing only non-empty shifts",
  "nonempty": "Queries whether this IndexShiftData is non-empty (i.e. has at least one shift).\n\n:return: (boolean) true if the size() of this Index greater than zero, false if the size is zero",
  "size": "The number of shifts embedded in the payload.\n\n:return: (int) the number of shifts",
  "toString": ":return: java.lang.String",
  "unapply": "**Incompatible overloads text - text from the first overload:**\n\nApply all shifts in reverse in a memmove-semantics-safe ordering through the provided shiftCallback.\n\n Use this to move from post-shift keyspace to pre-shift keyspace.\n\n*Overload 1*  \n  :param shiftCallback: (io.deephaven.db.v2.utils.IndexShiftData.Callback) - the callback that will process all reverse shifts\n  \n*Overload 2*  \n  :param index: (io.deephaven.db.v2.utils.Index) - the index to shift\n  \n*Overload 3*  \n  :param index: (io.deephaven.db.v2.utils.Index) - the index to shift\n  :param offset: (long) - an additional offset to apply to all shifts (such as when applying to a wrapped table)",
  "unapplyShift": "Unapply a shift to the provided index. Moves index from post-shift keyspace to pre-shift keyspace.\n\n:param index: (io.deephaven.db.v2.utils.Index) - The index to apply the shift to\n:param beginRange: (long) - start of range (inclusive)\n:param endRange: (long) - end of range (inclusive)\n:param shiftDelta: (long) - amount range has moved by\n:return: (boolean) Whether there was any overlap found to shift",
  "validate": "Verify invariants of internal data structures hold."
 },
 "path": "io.deephaven.db.v2.utils.IndexShiftData",
 "text": "A set of sorted shifts. To apply shifts without losing data, use apply(Callback). The callback\n will be invoked with shifts in an order that will preserve data when applied immediately using memmove semantics.\n Internally the shifts are ordered by rangeStart. The IndexShiftData.Builder will verify that no two ranges\n overlap before or after shifting and assert that the constructed IndexShiftData will be valid.",
 "typeName": "class"
}