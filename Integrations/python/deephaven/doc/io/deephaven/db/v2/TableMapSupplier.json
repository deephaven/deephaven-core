{
 "className": "io.deephaven.db.v2.TableMapSupplier",
 "methods": {
  "addKeyListener": "Listen to changes in the map's keys.\n\n:param listener: io.deephaven.db.v2.TableMap.KeyListener",
  "addListener": "Add a new listener for changes to the map.\n\n:param listener: io.deephaven.db.v2.TableMap.Listener",
  "apply": "Applies a function to this tableMap.\n\n This is useful if you have a reference to a tableMap and want to run a series of operations against the table\n map without each individual operation resulting in a remote method invocation.\n\nNote: Java generics information - <R>\n\n:param function: io.deephaven.base.Function.Unary<R,io.deephaven.db.v2.TableMap>\n:return: (R) the return value of function",
  "asTable": "Create a Table out of this TableMap's values.\n\n Creates a proxy object that in many respects acts like a Table, you can perform many of the table operations\n on it, which are then applied using TableMap.transformTables(java.util.function.Function) or\n TableMap.transformTablesWithMap(TableMap, BiFunction) if the right hand side of an operation is another TableMap.\nThe returned table acts as if it were an uncoalesced table; when two of our Proxy objects are operated on\n together, e.g., by a Table.join(io.deephaven.db.tables.Table)) operation, then tables with identical keys are used.  If strictKeys\n is set, an error occurs if the two TableMaps do not have identical keySets.\nSupported operations include those which return a Table,\n LongSizedDataStructure.size(), Table.getDefinition() and operations to retrieve attributes. Operations which\n retrieve data (such as Table.getIndex()} or Table.getColumn(int) require a coalesce operation.\n If allowCoalesce is not set to true, then the coalescing operations will fail with an\n IllegalArgumentException.\n\n:param strictKeys: boolean\n:param allowCoalesce: boolean\n:param sanityCheckJoins: boolean\n:return: (io.deephaven.db.tables.Table) a Table object that performs operations by segment",
  "dropReference": "Drop a previously-retained reference to this referent.",
  "entrySet": "Gets the entries.\n\n:return: (java.util.Collection<java.util.Map.Entry<java.lang.Object,io.deephaven.db.tables.Table>>) the entries",
  "flatten": "Flattens all of the result tables within the tablemap.\n\n:return: io.deephaven.db.v2.TableMap",
  "get": "Gets a table with a given key.\n Note that this causes the current LivenessManager\n (see LivenessScopeStack) to manage the result if non-null.\n\n:param key: java.lang.Object\n:return: (io.deephaven.db.tables.Table) table associated with the key, or null if the key is not present.",
  "getKeySet": "Gets the keys.\n\n:return: (java.lang.Object[]) keys",
  "getWeakReference": "Get a WeakReference to this referent. This may be cached, or newly created.\n\n:return: (java.lang.ref.WeakReference<? extends io.deephaven.db.util.liveness.LivenessReferent>) A new or cached reference to this referent",
  "getWithTransform": "Gets a table with a given key, applying the specified transform before returning.\n\n:param key: java.lang.Object\n:param transform: java.util.function.Function<io.deephaven.db.tables.Table,io.deephaven.db.tables.Table>\n:return: (io.deephaven.db.tables.Table) table associated with the key, or null if the key is not present.",
  "merge": "Merges all of the component tables into a single Table.\n\n:return: (io.deephaven.db.tables.Table) all of our component tables merged into a single Table.",
  "populateKeys": "When creating the table map, some of the keys that we would like to be there eventually may not exist.  This\n call lets you pre-populate keys, so that at initialization time you can perform the appropriate joins, etc.,\n on empty tables that you expect to be populated in the future.\n\n:param keys: java.lang.Object...\n:return: (io.deephaven.db.v2.TableMap) this TableMap",
  "removeKeyListener": "Removes a key change listener.\n\n:param listener: io.deephaven.db.v2.TableMap.KeyListener",
  "removeListener": "Removes a map change listener.\n\n:param listener: io.deephaven.db.v2.TableMap.Listener",
  "size": "Number of tables in the map.\n\n:return: (int) number of tables in the map.",
  "transformTablesWithKey": "**Incompatible overloads text - text from the first overload:**\n\nApplies a transformation function on all tables in the TableMap, producing a new TableMap\n which will update as new keys are added.\n\n*Overload 1*  \n  :param function: java.util.function.BiFunction<java.lang.Object,io.deephaven.db.tables.Table,io.deephaven.db.tables.Table>\n  :return: (io.deephaven.db.v2.TableMap) a new TableMap where each table has had function applied\n  \n*Overload 2*  \n  :param returnDefinition: io.deephaven.db.tables.TableDefinition\n  :param function: java.util.function.BiFunction<java.lang.Object,io.deephaven.db.tables.Table,io.deephaven.db.tables.Table>\n  :return: (io.deephaven.db.v2.TableMap) a new TableMap where each table has had function applied",
  "transformTablesWithMap": "Applies a BiFunction function on all tables in this TableMap and otherMap that have matching keys, producing a\n new TableMap which will update as new keys are added.  Only applies the function to tables which exist in both\n maps.\n\n:param otherMap: io.deephaven.db.v2.TableMap\n:param function: java.util.function.BiFunction<io.deephaven.db.tables.Table,io.deephaven.db.tables.Table,io.deephaven.db.tables.Table>\n:return: (io.deephaven.db.v2.TableMap) a new TableMap where each table has had function applied",
  "tryManage": "Attempt to add the specified referent to this manager.\n\n:param referent: io.deephaven.db.util.liveness.LivenessReferent\n:return: (boolean) Whether the referent was in fact added",
  "tryRetainReference": "If this referent is \"live\", behave as LivenessReferent.retainReference() and return true.\n Otherwise, returns false rather than throwing an exception.\n\n:return: (boolean) True if this referent was retained, false otherwise",
  "values": "Gets the values.\n\n:return: (java.util.Collection<io.deephaven.db.tables.Table>) values"
 },
 "path": "io.deephaven.db.v2.TableMapSupplier",
 "text": "A TableMapSupplier uses a source TableMap and applies a set of operations in the get method.",
 "typeName": "class"
}