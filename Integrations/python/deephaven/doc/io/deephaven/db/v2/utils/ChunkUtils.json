{
 "className": "io.deephaven.db.v2.utils.ChunkUtils",
 "methods": {
  "canCopyForward": "Determines, when copying data from the source array to the dest array, whether the copying should proceed in the\n forward or reverse direction in order to be safe. The issue is that (like memmove), care needs to be taken when\n the arrays are the same and the ranges overlap. In some cases (like when the arrays are different), either\n direction will do; in those cases we will recommend copying in the forward direction for performance reasons.\n When srcArray and destArray refer to the array, one of these five cases applies:\n\n \n\n Case 1: Source starts to the left of dest, and does not overlap. Recommend copying in forward direction.\n SSSSS\n      DDDDD\n\n Case 2: Source starts to the left of dest, and partially overlaps. MUST copy in the REVERSE direction.\n SSSSS\n    DDDDD\n\n Case 3: Source is on top of dest. Recommend copying in forward direction (really, you should do nothing).\n SSSSS\n DDDDD\n\n Case 4: Source starts to the right of dest, and partially overlaps. MUST copy in the FORWARD direction.\n   SSSSS\n DDDDD\n\n Case 5: Source starts to the right of dest, and does not overlap. Recommend copying in the forward direction.\n      SSSSS\n DDDDD\n \n\n Note that case 2 is the only case where you need to copy backwards.\n\nNote: Java generics information - <TARRAY>\n\n:param srcArray: (TARRAY) - The source array\n:param srcOffset: (int) - The starting offset in the srcArray\n:param destArray: (TARRAY) - The destination array\n:param destOffset: (int) - The starting offset in the destination array\n:param length: (int) - The number of elements that will be copied\n:return: (boolean) true if the copy should proceed in the forward direction; false if it should proceed in the reverse\n         direction",
  "checkArrayArgs": ":param arrayLength: int\n:param offset: int\n:param capacity: int",
  "checkSliceArgs": ":param size: int\n:param offset: int\n:param capacity: int",
  "contains": "*Overload 1*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.CharChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :param value: char\n  :return: boolean\n  \n*Overload 2*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.ByteChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :param value: byte\n  :return: boolean\n  \n*Overload 3*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.ShortChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :param value: short\n  :return: boolean\n  \n*Overload 4*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.IntChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :param value: int\n  :return: boolean\n  \n*Overload 5*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :param value: long\n  :return: boolean\n  \n*Overload 6*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.FloatChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :param value: float\n  :return: boolean\n  \n*Overload 7*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.DoubleChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :param value: double\n  :return: boolean\n  \n*Overload 8*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.ObjectChunk<?,? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :param value: java.lang.Object\n  :return: boolean",
  "convertToOrderedKeyIndices": "Generates a LongChunk<Attributes.OrderedKeyIndices> from LongChunk<Attributes.OrderedKeyRanges> chunk.\n\n*Overload 1*  \n  :param chunk: (io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyRanges>) - the chunk to convert\n  :return: (io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyIndices>) the generated chunk\n  \n*Overload 2*  \n  :param srcOffset: (int) - the offset into chunk to begin including in the generated chunk\n  :param chunk: (io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyRanges>) - the chunk to convert\n  :return: (io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyIndices>) the generated chunk\n  \n*Overload 3*  \n  :param srcOffset: (int) - the offset into chunk to begin including in the generated chunk\n  :param chunk: (io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyRanges>) - the chunk to convert\n  :param dest: (io.deephaven.db.v2.sources.chunk.WritableLongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyIndices>) - the chunk to fill with indices\n  :param destOffset: int",
  "convertToOrderedKeyRanges": "**Incompatible overloads text - text from the first overload:**\n\nFills OrderedKeyRanges into dest from the provided chunk and specified source range.\n\n*Overload 1*  \n  :param chunk: (io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyIndices>) - the chunk to convert\n  :return: (io.deephaven.db.v2.sources.chunk.WritableLongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyRanges>) the generated chunk\n  \n*Overload 2*  \n  :param chunk: (io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyIndices>) - the chunk to convert\n  :param dest: (io.deephaven.db.v2.sources.chunk.WritableLongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyRanges>) - the chunk to fill with ranges",
  "copyData": "Copy data from sources to destinations for the provided source and destination keys.\n\n Sources and destinations must not overlap.\n\n*Overload 1*  \n  :param src: (io.deephaven.db.v2.sources.chunk.ChunkSource.WithPrev<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - The source of the data.\n  :param srcAllKeys: (io.deephaven.db.v2.utils.OrderedKeys) - The source keys.\n  :param dest: (io.deephaven.db.v2.sources.WritableSource<?>) - The destination of the data (dest != src).\n  :param destAllKeys: (io.deephaven.db.v2.utils.OrderedKeys) - The destination keys. It is ok for srcAllKeys == destAllKeys.\n  :param usePrev: (boolean) - Should we read previous values from src\n  \n*Overload 2*  \n  :param sources: (io.deephaven.db.v2.sources.chunk.ChunkSource.WithPrev<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>[]) - The sources of the data, parallel with destinations\n  :param srcAllKeys: (io.deephaven.db.v2.utils.OrderedKeys) - The source keys.\n  :param destinations: (io.deephaven.db.v2.sources.WritableSource<?>[]) - The destinations, parallel with sources, of the data (dest != src).\n  :param destAllKeys: (io.deephaven.db.v2.utils.OrderedKeys) - The destination keys. It is ok for srcAllKeys == destAllKeys.\n  :param usePrev: (boolean) - Should we read previous values from src",
  "dumpChunk": "*Overload 1*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :return: java.lang.String\n  \n*Overload 2*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.CharChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :return: java.lang.String\n  \n*Overload 3*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.ByteChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :return: java.lang.String\n  \n*Overload 4*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.ShortChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :return: java.lang.String\n  \n*Overload 5*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.IntChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :return: java.lang.String\n  \n*Overload 6*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :return: java.lang.String\n  \n*Overload 7*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.FloatChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :return: java.lang.String\n  \n*Overload 8*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.DoubleChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :return: java.lang.String\n  \n*Overload 9*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.ObjectChunk<?,? extendsio.deephaven.db.v2.sources.chunk.Attributes.Any>\n  :return: java.lang.String",
  "extractKeyStringFromChunk": "Produce a pretty key for error messages from an element within parallel chunks.\n\n*Overload 1*  \n  :param keyChunkType: io.deephaven.db.v2.sources.chunk.ChunkType\n  :param chunk: io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param chunkPosition: int\n  :return: java.lang.String\n  \n*Overload 2*  \n  :param chunk: io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param chunkPosition: int\n  :return: java.lang.String",
  "extractKeyStringFromChunks": "Produce a pretty key for error messages from an element within parallel chunks.\n\n:param keyChunkTypes: io.deephaven.db.v2.sources.chunk.ChunkType[]\n:param chunks: io.deephaven.db.v2.sources.chunk.Chunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>[]\n:param chunkPosition: int\n:return: java.lang.String",
  "fillInOrder": "Fill inOrderChunk with consecutive integers from 0..size() - 1.\n\n*Overload 1*  \n  Note: Java generics information - <T extends io.deephaven.db.v2.sources.chunk.Attributes.Any>\n  \n  :param inOrderChunk: (io.deephaven.db.v2.sources.chunk.WritableIntChunk<T>) - the chunk to fill\n  \n*Overload 2*  \n  Note: Java generics information - <T extends io.deephaven.db.v2.sources.chunk.Attributes.Any>\n  \n  :param inOrderChunk: (io.deephaven.db.v2.sources.chunk.WritableLongChunk<T>) - the chunk to fill",
  "fillWithNullValue": "Note: Java generics information - <T extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n\n:param dest: io.deephaven.db.v2.sources.WritableChunkSink<T>\n:param allKeys: io.deephaven.db.v2.utils.OrderedKeys",
  "makeInOrderIntChunk": "Make a chunk of integers in order.\n\nNote: Java generics information - <T extends io.deephaven.db.v2.sources.chunk.Attributes.Any>\n\n:param chunkSize: (int) - the size of the chunk to make\n:return: (io.deephaven.db.v2.sources.chunk.WritableIntChunk<T>) a chunk of integers from 0 to chunkSize - 1"
 },
 "path": "io.deephaven.db.v2.utils.ChunkUtils",
 "typeName": "class"
}