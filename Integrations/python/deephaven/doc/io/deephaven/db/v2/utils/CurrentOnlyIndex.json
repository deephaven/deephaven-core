{
 "className": "io.deephaven.db.v2.utils.CurrentOnlyIndex",
 "methods": {
  "append": ":param logOutput: io.deephaven.base.log.LogOutput\n:return: io.deephaven.base.log.LogOutput",
  "asIndex": "Get an Index representation of this OrderedKeys.\n\n:return: (io.deephaven.db.v2.utils.Index) An Index representation for the same keys in the same order",
  "clone": ":return: io.deephaven.db.v2.utils.CurrentOnlyIndex",
  "close": "Free any resources associated with this object.\n Using any OrderedKeys methods after close() is an error and may produce exceptions or\n undefined results.",
  "compact": "May reclaim some unused memory.",
  "containsRange": "Queries whether this index contains every element in the range provided.\n\n:param start: long\n:param end: long\n:return: (boolean) true if this index contains every element x in start <= x <= end.",
  "copyImmutableGroupings": ":param source: io.deephaven.db.v2.tuples.TupleSource\n:param dest: io.deephaven.db.v2.tuples.TupleSource",
  "empty": "Queries whether this index is empty (i.e. has no keys).\n\n:return: (boolean) true if the size() of this Index is zero, false if the size is greater than zero",
  "equals": ":param obj: java.lang.Object\n:return: boolean",
  "fillKeyIndicesChunk": "Fill the supplied WritableLongChunk with individual keys from this OrderedKeys.\n The chunk's capacity is assumed to be big enough.\n\n:param chunkToFill: io.deephaven.db.v2.sources.chunk.WritableLongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>",
  "fillKeyRangesChunk": "Fill the supplied WritableLongChunk with key ranges from this OrderedKeys.\n The chunk's capacity is assumed to be big enough.\n\n:param chunkToFill: io.deephaven.db.v2.sources.chunk.WritableLongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyRanges>",
  "find": "Returns the position in [0..(size-1)] where the key is found. If not found,\n then return (-(position it would be) - 1), a la Array.binarySearch.\n\n:param key: long\n:return: (long) a position from [0..(size-1)] if the key was found.  If the key was not found, then (-position - 1) as\n in Array.binarySearch.",
  "findMissing": "For the given keys Index, under the assertion that none of them are present in the current index, return the tentative\n insertion points in the current index with the count for each of them\n\n:param keys: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: (gnu.trove.list.array.TLongArrayList[]) two TLongArrayLists; [0] contains the positions, [1] contains the counts.",
  "findPrev": "Returns the position in [0..(size-1)] where the key is found in the previous index. If not found, then return\n (-(position it would be) - 1), as in Array.binarySearch.\n\n:param key: long\n:return: (long) a position from [0..(size-1)] if the key was found.  If the key was not found, then (-position - 1) as\n in Array.binarySearch.",
  "firstKey": "Get the first key in this Index.\n\n:return: (long) The first key, or ReadOnlyIndex.NULL_KEY if there is none.",
  "firstKeyPrev": ":return: long",
  "forEachLong": "Provide each value contained in this index, in increased sorted order to the consumer.\n If the consumer returns false for a key, stops after that key (does not provide any\n keys after that key).\n\n:param lc: io.deephaven.db.v2.utils.LongAbortableConsumer\n:return: (boolean) false if the consumer returned false at some point, true if the consumer always\n returned true and all values in the index were consumed.",
  "forEachLongRange": "For as long as the consumer wants more ranges, call accept on the consumer with the individual key ranges\n in this OrderedKeys, in increasing order.\n\n:param larc: io.deephaven.db.v2.utils.LongRangeAbortableConsumer\n:return: (boolean) false if the consumer provided ever returned false, true otherwise.",
  "get": "Returns the key at the given rank position.\n\n:param pos: long\n:return: (long) the key at that rank.",
  "getAverageRunLengthEstimate": "Get an estimate of the average (mean) length of runs of adjacent keys in this OrderedKeys.\n Implementations should strive to keep this method efficient (O(1) preferred) at the expense of\n accuracy.\n Empty OrderedKeys should return an arbitrary valid value, usually 1.\n\n:return: (long) An estimate of the average run length in this OrderedKeys, in [1, size()]",
  "getGrouping": ":param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n:return: java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>",
  "getGroupingForKeySet": "Return a grouping that contains keys that match the values in keySet.\n\n:param keys: java.util.Set<java.lang.Object>\n:param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n:return: (java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>) an Map from keys to Indices, for each of the keys in keySet and this Index.",
  "getImpl": ":return: io.deephaven.db.v2.utils.TreeIndexImpl",
  "getKeysForPositions": "Returns the sequence of (increasing) keys corresponding to the positions\n provided as input.\n\n:param positions: java.util.PrimitiveIterator.OfLong\n:param outputKeys: java.util.function.LongConsumer",
  "getOrderedKeysByKeyRange": "Get an ordered subset of the keys in this OrderedKeys for a key range. The returned set will be the\n intersection of the keys in this  with the keys in the closed interval\n [startKeyInclusive, endKeyInclusive].\n\n The returned reference is owned by the caller, who should call close() when it is done with it.\n\n:param startKeyInclusive: long\n:param endKeyInclusive: long\n:return: (io.deephaven.db.v2.utils.OrderedKeys) The subset as an OrderedKeys, which may be this",
  "getOrderedKeysByPosition": "Get an ordered subset of the keys in this OrderedKeys for a position range.\n The result will contain the set of keys in this that lie at positions in the half-open range\n [startPositionInclusive, startPositionInclusive + length).\n\n The returned reference is owned by the caller, who should call close() when it is done with it.\n\n:param startPositionInclusive: long\n:param length: long\n:return: (io.deephaven.db.v2.utils.OrderedKeys) The subset as an OrderedKeys, which may be this",
  "getOrderedKeysIterator": "Get an OrderedKeys.Iterator over this OrderedKeys.\n\n:return: (io.deephaven.db.v2.utils.OrderedKeys.Iterator) A new iterator, positioned at the first key",
  "getPrev": ":param pos: long\n:return: long",
  "getPrevGrouping": ":param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n:return: java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>",
  "getPrevIndex": ":return: io.deephaven.db.v2.utils.Index",
  "getSubIndexForKeySet": "Return a subIndex that contains indices that match the values in keySet.\n\n:param keySet: java.util.Set<java.lang.Object>\n:param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n:return: (io.deephaven.db.v2.utils.Index) an Index containing only keys that match keySet.",
  "hasGrouping": ":param keyColumns: io.deephaven.db.v2.sources.ColumnSource...\n:return: boolean",
  "initializePreviousValue": "Initializes our previous value from the current value.\n\n This call is used by operations that manipulate an Index while constructing it, but need to set the state at the\n end of the initial operation to the current state.\n\n Calling this in other circumstances will yield undefined results.",
  "insert": "**Incompatible overloads text - text from the first overload:**\n\nAdd a single key to this index if it's not already present.\n\n*Overload 1*  \n  :param key: long\n  \n*Overload 2*  \n  :param keys: io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyIndices>\n  :param offset: int\n  :param length: int\n  \n*Overload 3*  \n  :param added: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "insertRange": "Add all keys in a closed range to this index if they are not already present.\n\n:param startKey: long\n:param endKey: long",
  "insertWithShift": "For each key in the provided index, shift it by shiftAmount and insert it in the current index.\n\n:param shiftAmount: long\n:param other: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "intersect": "Returns a new index representing the intersection of the current index with the input index\n\n:param range: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: io.deephaven.db.v2.utils.Index",
  "invert": "**Incompatible overloads text - text from the first overload:**\n\nReturns an Index with the positions of keys in this Index.\n\n This can be thought of as an iterative find() over the values in keys, but all keys must exist\n within this index, because an Index result can not represent negative values.\n\n*Overload 1*  \n  :param keys: io.deephaven.db.v2.utils.ReadOnlyIndex\n  :return: (io.deephaven.db.v2.utils.Index) a new Index containing the positions of the keys in this index\n  \n*Overload 2*  \n  :param keys: io.deephaven.db.v2.utils.ReadOnlyIndex\n  :param maximumPosition: long\n  :return: (io.deephaven.db.v2.utils.Index) a new Index containing the positions of the keys in this index",
  "isFlat": "Returns whether or not this index is flat.  Unlike a table, this is a mutable property; which may change from step to step.\n\n:return: (boolean) true if the index keys are continguous and start at zero.",
  "isSorted": ":return: boolean",
  "iterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.Iterator",
  "lastKey": "Get the last key in this OrderedKeys.\n\n:return: (long) The last key, or ReadOnlyIndex.NULL_KEY if there is none.",
  "lastKeyPrev": ":return: long",
  "minus": "Returns a new index representing the keys of the current set not present inside indexToRemove\n This operation is equivalent to set difference.  This index is not modified.\n\n:param indexToRemove: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: io.deephaven.db.v2.utils.Index",
  "overlapsRange": "Returns true if this index has any overlap with the provided range.\n\n:param start: long\n:param end: long\n:return: (boolean) true if any value x in start <= x <= end is contained in this index.",
  "rangeIterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.RangeIterator",
  "rangesCountUpperBound": ":return: long",
  "readExternal": ":param in: java.io.ObjectInput",
  "refCount": ":return: int",
  "remove": "**Incompatible overloads text - text from the first overload:**\n\nRemove a single key from this index if it's present.\n\n*Overload 1*  \n  :param key: long\n  \n*Overload 2*  \n  :param keys: io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyIndices>\n  :param offset: int\n  :param length: int\n  \n*Overload 3*  \n  :param removed: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "removeRange": "Remove all keys in a closed range from this index if they are present.\n\n:param start: long\n:param end: long",
  "retain": "Modifies the index by removing any keys not in the indexToIntersect argument.\n\n:param toIntersect: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "retainRange": "Modifies the index by keeping only keys in the interval [start, end]\n\n:param start: long\n:param end: long",
  "reverseIterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.SearchIterator",
  "searchIterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.SearchIterator",
  "shift": ":param shiftAmount: long\n:return: io.deephaven.db.v2.utils.Index",
  "shiftInPlace": ":param shiftAmount: long",
  "size": "How many keys are in this index.\n\n:return: (long) the number of keys in this index.",
  "sizePrev": ":return: long",
  "strid": "Override to improve index debug-tracing messages.\n\n:return: java.lang.String",
  "subindexByKey": "Get a subset of this index within this range of keys.\n\n:param startKey: long\n:param endKey: long\n:return: (io.deephaven.db.v2.utils.Index) A new index, containing only values >= startKey and <= endKey.",
  "subindexByPos": "Get a subset of this index within this range of positions\n\n:param startPos: long\n:param endPos: long\n:return: (io.deephaven.db.v2.utils.Index) A new index, containing only positions >= startPos and < endPos",
  "subsetOf": "Returns true if this index is a (possibly improper) subset of other.\n\n:param other: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: (boolean) true if every element of this exists within other",
  "toString": ":return: java.lang.String",
  "union": "Returns a new index representing the keys present in both this index and the argument index.\n\n:param indexToAdd: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: (io.deephaven.db.v2.utils.Index) a new index with the union of the keys in both this index and indexToAdd.",
  "update": "Simultaneously adds the keys from the first index and removes the keys from the second one.\n API assumption: the intersection of added and removed is empty.\n\n:param added: io.deephaven.db.v2.utils.ReadOnlyIndex\n:param removed: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "validate": ":param failMsg: java.lang.String",
  "writeExternal": ":param out: java.io.ObjectOutput"
 },
 "path": "io.deephaven.db.v2.utils.CurrentOnlyIndex",
 "typeName": "class"
}