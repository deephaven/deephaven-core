{
 "className": "io.deephaven.db.v2.by.FirstOrLastChunkedOperator",
 "methods": {
  "addChunk": "Aggregate a chunk of data into the result columns.\n\n*Overload 1*  \n  :param bucketedContext: io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext\n  :param values: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param inputIndices: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param destinations: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param startPositions: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>\n  :param length: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>\n  :param stateModified: io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  \n*Overload 2*  \n  :param singletonContext: io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext\n  :param chunkSize: int\n  :param values: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param inputIndices: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param destination: long\n  :return: (boolean) true if the state was modified, false otherwise",
  "addIndex": ":param context: io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext\n:param addIndex: io.deephaven.db.v2.utils.Index\n:param destination: long\n:return: boolean",
  "ensureCapacity": "Ensure that this operator can handle destinations up to tableSize - 1.\n\n:param tableSize: long",
  "getResultColumns": "Return a map of result columns produced by this operator.\n\n:return: (java.util.Map<java.lang.String,? extends io.deephaven.db.v2.sources.ColumnSource<?>>) a map of name to columns for the result table",
  "modifyChunk": "**Incompatible overloads text - text from the first overload:**\n\nModify a chunk of data previously aggregated into the result columns using a parallel chunk of new values.\n Never includes modifies that have been shifted if IterativeChunkedAggregationOperator.requiresIndices() returns true - those are handled in\n IterativeChunkedAggregationOperator.shiftChunk(BucketedContext, Chunk, Chunk, LongChunk, LongChunk, IntChunk, IntChunk, IntChunk, WritableBooleanChunk).\n\n*Overload 1*  \n  :param bucketedContext: io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext\n  :param previousValues: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param newValues: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param postShiftIndices: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param destinations: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param startPositions: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>\n  :param length: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>\n  :param stateModified: io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  \n*Overload 2*  \n  :param singletonContext: io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext\n  :param chunkSize: int\n  :param previousValues: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param newValues: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param postShiftIndices: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param destination: long\n  :return: (boolean) true if the state was modified, false otherwise",
  "modifyIndices": "Called with the modified indices when IterativeChunkedAggregationOperator.requiresIndices() returns true if our input columns have not\n changed (or we have none).\n\n*Overload 1*  \n  :param context: io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext\n  :param inputIndices: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param destinations: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param startPositions: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>\n  :param length: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>\n  :param stateModified: io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  \n*Overload 2*  \n  :param context: io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext\n  :param indices: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param destination: long\n  :return: (boolean) true if the result should be considered modified",
  "removeChunk": "Remove a chunk of data previously aggregated into the result columns.\n\n*Overload 1*  \n  :param bucketedContext: io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext\n  :param values: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param inputIndices: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param destinations: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param startPositions: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>\n  :param length: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>\n  :param stateModified: io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  \n*Overload 2*  \n  :param singletonContext: io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext\n  :param chunkSize: int\n  :param values: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param inputIndices: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param destination: long\n  :return: (boolean) true if the state was modified, false otherwise",
  "requiresIndices": "Whether the operator requires indices. This implies that the operator must process shifts\n (i.e. IterativeChunkedAggregationOperator.shiftChunk(io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext, io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>, io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>, io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>, io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>, io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>, io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>, io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>, io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>)), and must observe modifications even when its input columns (if any) are not modified\n (i.e. IterativeChunkedAggregationOperator.modifyIndices(io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext, io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>, io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>, io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>, io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>, io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>)).\n\n:return: (boolean) true if the operator requires indices, false otherwise",
  "shiftChunk": "**Incompatible overloads text - text from the first overload:**\n\nCalled with shifted indices when IterativeChunkedAggregationOperator.requiresIndices() returns true, including shifted same-slot modifies.\n\n*Overload 1*  \n  :param bucketedContext: io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext\n  :param previousValues: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param newValues: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param preShiftIndices: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param postShiftIndices: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param destinations: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param startPositions: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>\n  :param length: io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>\n  :param stateModified: io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  \n*Overload 2*  \n  :param singletonContext: io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext\n  :param previousValues: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param newValues: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n  :param preInputIndices: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param postInputIndices: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n  :param destination: long\n  :return: (boolean) true if the result should be considered modified",
  "startTrackingPrevValues": "Called after initialization; when the operator's result columns must have previous tracking enabled.",
  "unchunkedIndex": "Whether the operator can deal with an unchunked Index more efficiently than a chunked index.\n\n:return: (boolean) true if the operator can deal with unchunked indices, false otherwise"
 },
 "path": "io.deephaven.db.v2.by.FirstOrLastChunkedOperator",
 "typeName": "class"
}