{
 "className": "io.deephaven.db.v2.sources.chunk.page.Page",
 "methods": {
  "advanceToNextPage": "**Incompatible overloads text - text from the first overload:**\n\nAssuming orderedKeysIterator is position at its first index key on this page, consume all keys on this\n page.\n\n*Overload 1*  \n  :param orderedKeysIterator: (io.deephaven.db.v2.utils.OrderedKeys.Iterator) - The iterator to advance\n  \n*Overload 2*  \n  :param searchIterator: (io.deephaven.db.v2.utils.ReadOnlyIndex.SearchIterator) - The iterator to advance\n  :return: (boolean) The result of ReadOnlyIndex.SearchIterator.advance(long)",
  "advanceToNextPageAndGetPositionDistance": "Assuming orderedKeysIterator is position at its first index key on this page, consume all keys on this\n page and return the number of keys consumed.\n\n:param orderedKeysIterator: (io.deephaven.db.v2.utils.OrderedKeys.Iterator) - The iterator to advance\n:return: long",
  "firstRow": ":param row: (long) - Any row contained on this page.\n:return: (long) the first row of this page, located in the same way as row.",
  "firstRowOffset": ":return: (long) the first row of this page, after applying the PagingChunkSource.mask(), which refers to the first row of this\n page.",
  "getRowOffset": ":param row: long\n:return: (long) the offset for the given row in this page, in [0, maxRow(row)]."
 },
 "path": "io.deephaven.db.v2.sources.chunk.page.Page",
 "text": "This provides the ChunkSource interface to a contiguous block of data beginning at firstRowOffset()\n and continuing to some row less than or equal to firstRowOffset() + PagingChunkSource.maxRow(long).\n \n Non overlapping pages can be collected together in a PageStore, which provides the ChunkSource\n interface to the collection of all of its Pages.\n \n There are two distinct use cases/types of pages. The first use case are Pages which always have a\n length() > 0.  These store length() values, which can be assessed via the ChunkSource methods.\n Valid OrderedKeys passed to those methods will have their offset in the range\n [firstRowOffset(), firstRowOffset() + length()). Passing OrderKeys with offsets outside of this range will have\n undefined results.\n \n The second use case will always have length() == 0 and firstRowOffset() == 0. These represent \"Null\" regions\n which return a fixed value, typically a null value, for every OrderedKeys passed into the\n ChunkSource methods. In order to have this use case, override length and override lastRow\n as maxRow.\n \n Though the ChunkSource methods ignore the non-offset portion of the rows in the OrderedKeys,\n they can assume they are identical for all the passed in elements of the OrderedKeys.  For instance,\n they can use the simple difference between the complete row value to determine a length.",
 "typeName": "interface"
}