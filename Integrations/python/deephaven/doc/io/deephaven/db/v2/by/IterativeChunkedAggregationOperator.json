{
 "className": "io.deephaven.db.v2.by.IterativeChunkedAggregationOperator",
 "methods": {
  "addChunk": "Aggregate a chunk of data into the result columns.\n\n*Overload 1*  \n  :param context: (io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param values: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - a chunk of values to aggregate\n  :param inputIndices: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the input indices, in post-shift space\n  :param destinations: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the destinations in resultColumn to aggregate into, parallel with startPositions and length\n  :param startPositions: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param context: (io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param chunkSize: (int) - the size of the addition\n  :param values: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - the values to aggregate\n  :param inputIndices: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the input indices, in post-shift space\n  :param destination: (long) - the destination in the result columns\n  :return: (boolean) true if the state was modified, false otherwise",
  "addIndex": ":param context: io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext\n:param index: io.deephaven.db.v2.utils.Index\n:param destination: long\n:return: boolean",
  "ensureCapacity": "Ensure that this operator can handle destinations up to tableSize - 1.\n\n:param tableSize: (long) - the new size of the table",
  "getResultColumns": "Return a map of result columns produced by this operator.\n\n:return: (java.util.Map<java.lang.String,? extends io.deephaven.db.v2.sources.ColumnSource<?>>) a map of name to columns for the result table",
  "initializeRefreshing": "Initialize refreshing result support for this operator. As a side effect, make a factory method for converting\n upstream modified column sets to result modified column sets, to be invoked whenever this operator reports a\n modification in order to determine the operator's contribution to the final result modified column set.\n\n:param resultTable: (io.deephaven.db.v2.QueryTable) - The result QueryTable after initialization\n:param aggregationUpdateListener: (io.deephaven.db.util.liveness.LivenessReferent) - The aggregation update listener, which may be needed for referential integrity\n:return: (java.util.function.UnaryOperator<io.deephaven.db.v2.ModifiedColumnSet>) A factory that produces a result modified column set from the upstream modified column set",
  "makeBucketedContext": "Make a IterativeChunkedAggregationOperator.BucketedContext suitable for this operator if necessary.\n\n:param size: (int) - The maximum size of input chunks that will be used with the result context\n:return: (io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext) A new IterativeChunkedAggregationOperator.BucketedContext, or null if none is necessary",
  "makeSingletonContext": "Make a IterativeChunkedAggregationOperator.SingletonContext suitable for this operator if necessary.\n\n:param size: (int) - The maximum size of input chunks that will be used with the result context\n:return: (io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext) A new IterativeChunkedAggregationOperator.SingletonContext, or null if none is necessary",
  "modifyChunk": "**Incompatible overloads text - text from the first overload:**\n\nModify a chunk of data previously aggregated into the result columns using a parallel chunk of new values. Never\n includes modifies that have been shifted if requiresIndices() returns true - those are handled in\n shiftChunk(BucketedContext, Chunk, Chunk, LongChunk, LongChunk, IntChunk, IntChunk, IntChunk, WritableBooleanChunk).\n\n*Overload 1*  \n  :param context: (io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param previousValues: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - a chunk of values that have been previously aggregated\n  :param newValues: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - a chunk of values to aggregate\n  :param postShiftIndices: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the input indices, in post-shift space\n  :param destinations: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the destinations in resultColumn to remove the values from, parallel with startPositions and\n          length\n  :param startPositions: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param context: (io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param chunkSize: (int) - the size of the modification\n  :param previousValues: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - a chunk of values that have been previously aggregated.\n  :param newValues: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - a chunk of values to aggregate\n  :param postShiftIndices: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the input indices, in post-shift space\n  :param destination: long\n  :return: (boolean) true if the state was modified, false otherwise",
  "modifyIndices": "Called with the modified indices when requiresIndices() returns true if our input columns have not\n changed (or we have none).\n\n*Overload 1*  \n  :param context: (io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param inputIndices: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the input indices, in post-shift space\n  :param destinations: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the destinations in resultColumn to aggregate into, parallel with startPositions and length\n  :param startPositions: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param context: (io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param indices: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the modified indices for a given destination, in post-shift space\n  :param destination: (long) - the destination that was modified\n  :return: (boolean) true if the result should be considered modified",
  "propagateFailure": "Called on error to propagate listener failure to this operator.\n\n:param originalException: (java.lang.Throwable) - The error Throwable\n:param sourceEntry: (io.deephaven.db.v2.utils.UpdatePerformanceTracker.Entry) - The UpdatePerformanceTracker.Entry for the failed listener",
  "propagateInitialState": "Perform any internal state keeping needed for destinations that were added during initialization.\n\n:param resultTable: (io.deephaven.db.v2.QueryTable) - The result QueryTable after initialization",
  "propagateUpdates": "Perform any internal state keeping needed for destinations that were added (went from 0 keys to &gt 0), removed\n (went from &gt 0 keys to 0), or modified (keys added or removed, or keys modified) by this iteration. Note that\n the arguments to this method should not be mutated in any way.\n\n:param downstream: (io.deephaven.db.v2.ShiftAwareListener.Update) - The downstream ShiftAwareListener.Update (which does not have its\n        ModifiedColumnSet finalized yet)\n:param newDestinations: (io.deephaven.db.v2.utils.ReadOnlyIndex) - New destinations added on this update",
  "removeChunk": "Remove a chunk of data previously aggregated into the result columns.\n\n*Overload 1*  \n  :param context: (io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param values: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - a chunk of values that have been previously aggregated.\n  :param inputIndices: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the input indices, in pre-shift space\n  :param destinations: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the destinations in resultColumn to remove the values from, parallel with startPositions and\n          length\n  :param startPositions: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param context: (io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param chunkSize: (int) - the size of the removal\n  :param values: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - the values to remove from the aggregation\n  :param inputIndices: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the input indices, in pre-shift space\n  :param destination: (long) - the destination in the result columns\n  :return: (boolean) true if the state was modified, false otherwise",
  "requiresIndices": "Whether the operator requires indices. This implies that the operator must process shifts (i.e.\n shiftChunk(io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext, io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>, io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>, io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>, io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>, io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>, io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>, io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>, io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>)), and must observe modifications even when its input columns (if any) are not modified (i.e.\n modifyIndices(io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext, io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>, io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>, io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>, io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>, io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>)).\n\n:return: (boolean) true if the operator requires indices, false otherwise",
  "resetForStep": "Reset any per-step internal state. Note that the arguments to this method should not be mutated in any way.\n\n:param upstream: (io.deephaven.db.v2.ShiftAwareListener.Update) - The upstream ShiftAwareListener.Update",
  "shiftChunk": "**Incompatible overloads text - text from the first overload:**\n\nCalled with shifted indices when requiresIndices() returns true, including shifted same-slot modifies.\n\n*Overload 1*  \n  :param context: (io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param previousValues: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - a chunk of values that have been previously aggregated.\n  :param newValues: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - a chunk of values to aggregate\n  :param preShiftIndices: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the input indices, in pre-shift space\n  :param postShiftIndices: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the input indices, in post-shift space\n  :param destinations: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the destinations in resultColumn to aggregate into, parallel with startPositions and length\n  :param startPositions: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.db.v2.sources.chunk.IntChunk<io.deephaven.db.v2.sources.chunk.Attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.db.v2.sources.chunk.WritableBooleanChunk<io.deephaven.db.v2.sources.chunk.Attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param context: (io.deephaven.db.v2.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param previousValues: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - a chunk of values that have been previously aggregated.\n  :param newValues: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - a chunk of values to aggregate\n  :param preShiftIndices: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the input indices, in pre-shift space\n  :param postShiftIndices: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - the input indices, in post-shift space\n  :param destination: (long) - the destination in the result columns\n  :return: (boolean) true if the result should be considered modified",
  "startTrackingPrevValues": "Called after initialization; when the operator's result columns must have previous tracking enabled.",
  "unchunkedIndex": "Whether the operator can deal with an unchunked Index more efficiently than a chunked index.\n\n:return: (boolean) true if the operator can deal with unchunked indices, false otherwise"
 },
 "path": "io.deephaven.db.v2.by.IterativeChunkedAggregationOperator",
 "text": "A chunked, iterative operator that processes indices and/or data from one input column to produce one or more output\n columns.",
 "typeName": "interface"
}