{
 "className": "io.deephaven.db.v2.remote.ConstructSnapshot$StaticSnapshotControl",
 "methods": {
  "snapshotConsistent": "Determine (from within a snapshot function) if the snapshot appears to still be consistent.\n \n This should be no more restrictive than the associated ConstructSnapshot.SnapshotCompletedConsistently.\n \n Can assume as a precondition that the clock step has not been observed to change since the last time the\n associated ConstructSnapshot.UsePreviousValues.usePreviousValues(long) was invoked, and that the clock state has not\n been observed to change if previous values were used. See ConstructSnapshot.clockConsistent(long, long, boolean).\n\n:param currentClockValue: (long) - The current clock value\n:param usingPreviousValues: (boolean) - Whether the snapshot function is using previous values\n:return: (boolean) True if we can no longer expect that the snapshot function's result will be consistent",
  "usePreviousValues": "Determine if previous values should be used in table data access for the given clock\n value.\n \n Expected to never request previous values during the idle phase of a cycle.\n \n Must never request previous values for a source that has already been updated on the current cycle, unless it\n can be proven that that source was not instantiated on the current cycle.\n \n Must be safe to call more than once, exactly once per snapshot attempt.\n\n:param beforeClockValue: (long) - The current clock value before the snapshot function will be invoked\n:return: (java.lang.Boolean) A Boolean with the following meaning:\n         \n* true if previous values should be used\n* false if they should not\n* null if a clock discrepancy was detected and we must retry with a new\n         beforeClockValue"
 },
 "path": "io.deephaven.db.v2.remote.ConstructSnapshot.StaticSnapshotControl",
 "text": "An implementation of ConstructSnapshot.SnapshotControl for sources that cannot update.",
 "typeName": "class"
}