{
 "className": "io.deephaven.db.v2.sources.chunk.page.PagingChunkSource",
 "methods": {
  "fillChunkAppend": "Similar to ChunkSource.fillChunk(FillContext, WritableChunk, OrderedKeys), except that the values from the\n ChunkSource are appended to destination, rather than placed at the beginning.\n \n\n The values to fill into destination are specified by orderedKeysIterator, whose\n OrderedKeys.firstKey() must exist, and must be represented by this PagingChunkSource\n (modulo {#link @mask}), otherwise results are undefined.\n \n\n No more than the elements in orderedKeysIterator, which are on the same page as\n OrderedKeys.firstKey(), have their values appended to destination, and consumed from\n orderedKeysIterator. Keys are on the same page when the bits outside of mask() are identical.\n\n:param context: (io.deephaven.db.v2.sources.chunk.ChunkSource.FillContext) - A context containing all mutable/state related data used in retrieving the Chunk. In particular,\n        the Context may be used to provide a Chunk data pool\n:param destination: (io.deephaven.db.v2.sources.chunk.WritableChunk<? superPagingChunkSource.ATTR>) - The chunk to append the results to.\n:param orderedKeysIterator: (io.deephaven.db.v2.utils.OrderedKeys.Iterator) - The iterator to the ordered keys, which contain at least the keys to extract from this\n        ChunkSource. The keys to extract will be at the beginning of iteration order.",
  "mask": "This mask is applied to OrderedKeys which are passed into\n ChunkSource.getChunk(ChunkSource.GetContext, OrderedKeys) and\n ChunkSource.fillChunk(ChunkSource.FillContext, WritableChunk, OrderedKeys). This allows the PagingChunkSources to be cached, and reused even if they are properly relocated in key space.\n\n:return: (long) the mask for this page, which must be a bitmask representing the some number of lower order bits of a\n         long.",
  "maxRow": "The maxRow is the greatest possible row which may reference this ChunkSource. This method is used by\n fillChunkAppend(FillContext, WritableChunk, OrderedKeys.Iterator) to determine which of its\n OrderedKeys are referencing this PagingChunkSource.\n \n\n The default implementation assumes that only one PagingChunkSource exits for each page reference. That\n is, there is only one PagingChunkSource for OrderedKeys with the same bits outside of\n mask().\n \n\n It is also possible to pack multiple, non-overlapping PagingChunkSources into the same page reference. In\n this case, one typically will want to override maxRow. An example such implementation is\n ChunkPage.\n\n:param row: (long) - Any row contained on this page.\n:return: (long) the maximum last row of this page, located in the same way as row."
 },
 "path": "io.deephaven.db.v2.sources.chunk.page.PagingChunkSource",
 "text": "In order to be able to cache and reuse ChunkSources across multiple Tables (or other references),\n PagingChunkSource adds a mask to the ChunkSource, and supports some additional fillChunk methods.\n\n The mask is a bitmask of the lower order bits of the keys in an OrderKeys, which specifies the bits from the\n OrderedKeys which will be used to uniquely specify the offsets into the ChunkSource elements on calls to\n ChunkSource.fillChunk(FillContext, WritableChunk, OrderedKeys),\n ChunkSource.getChunk(GetContext, OrderedKeys), ChunkSource.getChunk(GetContext, long, long).\n\n Also, a new method fillChunkAppend(FillContext, WritableChunk, OrderedKeys.Iterator) is\n added, which supports doing a fillChunk incrementally across a series of pages.",
 "typeName": "interface"
}