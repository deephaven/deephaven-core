{
 "className": "io.deephaven.db.v2.utils.rsp.RspArray",
 "methods": {
  "andEqualsUnsafeNoWriteCheck": "Intersects this RspArray with the argument, leaving the result on this RspArray. The argument won't be modified.\n\n:param other: (io.deephaven.db.v2.utils.rsp.RspArray) - an RspArray.",
  "andNotEqualsUnsafeNoWriteCheck": "Remove every element from argument from this RspArray. Argument won't be modified.\n\n:param other: (io.deephaven.db.v2.utils.rsp.RspArray) - the elements to remove.",
  "appendContainer": ":param k: long\n:param c: io.deephaven.db.v2.utils.rsp.container.Container",
  "appendFullBlockSpan": ":param k: long\n:param slen: long",
  "appendSingletonSpan": ":param v: long",
  "applyKeyOffset": ":param offset: long",
  "asOrderedKeys": ":return: io.deephaven.db.v2.utils.rsp.RspOrderedKeys",
  "binarySearchKeys": ":param fromIndex: int\n:param toIndex: int\n:param comp: io.deephaven.db.v2.utils.IndexUtilities.Comparator\n:return: int",
  "containerOverhead": ":return: double",
  "containsRange": ":param start: long\n:param end: long\n:return: boolean",
  "distanceInBlocks": "blockKeyEnd is exclusive. Assumption on entry: blockKeyStart <= blockKeyEnd\n\n:param blockKeyStart: (long) - inclusive start block key (only high 48 bits set).\n:param blockKeyEnd: (long) - exclusive end block key (only high 48 bits set).\n:return: (long) distance in blocks between blockKeyStart and blockKeyEnd",
  "divBlockSize": ":param v: long\n:return: long",
  "find": ":param val: long\n:return: long",
  "firstValue": ":return: long",
  "firstValueAtIndex": ":param i: int\n:return: long",
  "forEachLong": ":param lc: io.deephaven.db.v2.utils.LongAbortableConsumer\n:return: boolean",
  "forEachLongRange": ":param lrac: io.deephaven.db.v2.utils.LongRangeAbortableConsumer\n:return: boolean",
  "forEachLongRangeInSpanWithOffsetAndMaxCardinality": ":param i: int\n:param offset: long\n:param maxCardinality: long\n:param larc: io.deephaven.db.v2.utils.LongRangeAbortableConsumer\n:return: boolean",
  "get": ":param pos: long\n:return: long",
  "getAverageRunLengthEstimate": "*Overload 1*  \n  :return: long\n  \n*Overload 2*  \n  :param startIdx: int\n  :param endIdx: int\n  :return: long",
  "getCardinality": ":return: long",
  "getFullBlockSpanLen": ":param spanInfo: long\n:param span: java.lang.Object\n:return: long",
  "getIterator": ":return: io.deephaven.db.v2.utils.rsp.RspIterator",
  "getKeysForPositions": ":param inputPositions: java.util.PrimitiveIterator.OfLong\n:param outputKeys: java.util.function.LongConsumer",
  "getOrderedKeysByKeyRange": ":param startValueInclusive: long\n:param endValueInclusive: long\n:return: io.deephaven.db.v2.utils.OrderedKeys",
  "getOrderedKeysByPosition": ":param startPositionInclusive: long\n:param length: long\n:return: io.deephaven.db.v2.utils.OrderedKeys",
  "getOrderedKeysIterator": ":return: io.deephaven.db.v2.utils.OrderedKeys.Iterator",
  "getPackedInfoLowBits": ":param ac: io.deephaven.db.v2.utils.rsp.container.ArrayContainer\n:return: long",
  "getRangeBatchIterator": ":param initialSeek: long\n:param maxCount: long\n:return: io.deephaven.db.v2.utils.rsp.RspRangeBatchIterator",
  "getRangeIterator": ":return: io.deephaven.db.v2.utils.rsp.RspRangeIterator",
  "getReverseIterator": ":return: io.deephaven.db.v2.utils.rsp.RspReverseIterator",
  "getSpanCardinalityAtIndex": "*Overload 1*  \n  :param i: int\n  :return: long\n  \n*Overload 2*  \n  :param i: int\n  :param optimizeContainers: boolean\n  :return: long",
  "getSpanCardinalityAtIndexMaybeAcc": ":param i: int\n:return: long",
  "getSpanIndex": "*Overload 1*  \n  :param key: long\n  :return: (int) if the key is included in some existing span, returns the index of that span. if the key is not included\n           in any existing span, returns -(p - 1) where p is the position a span for the key would be inserted.\n  \n           Note that, since a span's covered interval may include multiple blocks, a key contained by a span may be\n           different than its first key (if the span includes more than one block).\n  \n*Overload 2*  \n  :param fromIndex: int\n  :param key: long\n  :return: int\n  \n*Overload 3*  \n  :param fromIndex: int\n  :param endIndexExclusive: int\n  :param key: long\n  :return: int",
  "highBits": ":param val: long\n:return: long",
  "insertContainerAtIndex": "Insert a container at position i with key k, pushing the existing elements to the right. The caller should ensure\n that the key order is preserved by this operation.\n\n:param i: (int) - position in which to insert\n:param key: (long) - key for the span to be inserted\n:param c: (io.deephaven.db.v2.utils.rsp.container.Container) - the container to be inserted",
  "insertFullBlockSpanAtIndex": "Insert a full block span at position i with key k, pushing the existing elements to the right. The caller should\n ensure that the key order is preserved by this operation.\n\n:param i: (int) - position in which to insert\n:param key: (long) - key for the span to be inserted\n:param flen: (long) - the full block len for the span inserted.",
  "insertSingletonAtIndex": "Insert a new singleton span at position i with key k, pushing the existing elements to the right. The caller\n should ensure that the key order is preserved by this operation.\n\n:param i: (int) - position in which to insert\n:param value: (long) - the singleton value for the span to be inserted",
  "isContainer": ":param s: java.lang.Object\n:return: boolean",
  "isEmpty": ":return: boolean",
  "isFullBlockSpan": ":param s: java.lang.Object\n:return: boolean",
  "keyForFirstBlock": ":return: long",
  "keyForLastBlock": ":return: long",
  "keySearch": "*Overload 1*  \n  :param startPos: int\n  :param key: long\n  :return: int\n  \n*Overload 2*  \n  :param startPos: int\n  :param endPosExclusive: int\n  :param key: long\n  :return: int",
  "lastValue": ":return: long",
  "lowBits": ":param val: long\n:return: short",
  "lowBitsAsInt": ":param val: long\n:return: int",
  "modBlockSize": ":param v: long\n:return: int",
  "nextKey": ":param key: long\n:return: long",
  "orEqualsShiftedUnsafeNoWriteCheck": "For every element in other, add (element + shiftAmount) to this RspArray. Note shiftAmount is assumed to be a\n multiple of BLOCK_SIZE. The argument won't be modified (with the possible exclusion of sharing some of its\n containers Copy On Write).\n\n:param shiftAmount: (long) - the amount to add to each key in other before insertion\n:param other: (io.deephaven.db.v2.utils.rsp.RspArray) - the base keys to add in the (key + shiftAmount) formula for insertion.",
  "orEqualsUnsafeNoWriteCheck": "For every element in other, add element to this RspArray. The argument won't be modified (with the possible\n exclusion of sharing some of its containers Copy On Write).\n\n:param other: (io.deephaven.db.v2.utils.rsp.RspArray) - the RspArray to add to this.",
  "overlaps": ":param other: io.deephaven.db.v2.utils.rsp.RspArray\n:return: boolean",
  "overlapsRange": "Returns true if any value in this RspArray is contained inside the range [first, last], false otherwise.\n\n*Overload 1*  \n  :param first: (long) - First value in the range to check\n  :param last: (long) - Last value in the range to check\n  :return: boolean\n  \n*Overload 2*  \n  :param iStart: int\n  :param start: long\n  :param end: long\n  :return: int",
  "paste": ":param highBits: long\n:param lowBits: short\n:return: long",
  "rangesCountUpperBound": "*Overload 1*  \n  :return: long\n  \n*Overload 2*  \n  :param startIdx: int\n  :param endIdx: int\n  :return: long",
  "removeRangeUnsafeNoWriteCheck": ":param start: long\n:param end: long",
  "removeRangesUnsafeNoWriteCheck": ":param rit: io.deephaven.db.v2.utils.ReadOnlyIndex.RangeIterator",
  "removeSpanAtIndex": ":param i: int",
  "replaceSpanAtIndex": "Replace the span at index i with the keys and spans from buf,\n\n:param i: int\n:param buf: io.deephaven.db.v2.utils.rsp.RspArray.ArraysBuf",
  "sampleMetrics": ":param rspParallelArraysSizeUsed: java.util.function.LongConsumer\n:param rspParallelArraysSizeUnused: java.util.function.LongConsumer\n:param arrayContainersBytesAllocated: java.util.function.LongConsumer\n:param arrayContainersBytesUnused: java.util.function.LongConsumer\n:param arrayContainersCardinality: java.util.function.LongConsumer\n:param arrayContainersCount: java.util.function.LongConsumer\n:param bitmapContainersBytesAllocated: java.util.function.LongConsumer\n:param bitmapContainersBytesUnused: java.util.function.LongConsumer\n:param bitmapContainersCardinality: java.util.function.LongConsumer\n:param bitmapContainersCount: java.util.function.LongConsumer\n:param runContainersBytesAllocated: java.util.function.LongConsumer\n:param runContainersBytesUnused: java.util.function.LongConsumer\n:param runContainersCardinality: java.util.function.LongConsumer\n:param runContainersCount: java.util.function.LongConsumer\n:param runContainersRunsCount: java.util.function.LongConsumer\n:param singleRangeContainersCount: java.util.function.LongConsumer\n:param singleRangeContainerCardinality: java.util.function.LongConsumer\n:param singletonContainersCount: java.util.function.LongConsumer\n:param twoValuesContainerCount: java.util.function.LongConsumer",
  "searchSpanIndex": ":param startPos: int\n:param comp: io.deephaven.db.v2.utils.IndexUtilities.Comparator\n:return: int",
  "setLastFullBlockSpan": ":param k: long\n:param slen: long",
  "setOrInsertFullBlockSpanAtIndex": ":param newSpanIdx: (int) - an index, as returned by getSpanAtIndex(k). Note this can be negative, in which case this is an\n        insertion (existing elements pushed to the right as necessary).\n:param newSpanKey: (long) - the key.\n:param newSpanFlen: (long) - the number of 2^16 intervals.\n:param madeNullSpansMu: org.apache.commons.lang3.mutable.MutableObject<io.deephaven.db.v2.utils.sortedranges.SortedRanges>\n:return: (int) the (positive) index where the span was actually inserted.",
  "size": ":return: int",
  "subsetOf": ":param other: io.deephaven.db.v2.utils.rsp.RspArray\n:return: boolean",
  "toString": ":return: java.lang.String",
  "tryCompact": ":param compactFactor: int",
  "tryCompactUnsafe": ":param compactFactor: (int) - if k == 0, compact if count < capacity. k > 0, compact if (capacity - count > (capacity >>\n        k).",
  "uGreater": ":param k1: long\n:param k2: long\n:return: boolean",
  "uGreaterOrEqual": ":param k1: long\n:param k2: long\n:return: boolean",
  "uLess": ":param k1: long\n:param k2: long\n:return: boolean",
  "uLessOrEqual": ":param k1: long\n:param k2: long\n:return: boolean",
  "uMax": ":param k1: long\n:param k2: long\n:return: long",
  "uMin": ":param k1: long\n:param k2: long\n:return: long",
  "unsignedShortToInt": ":param x: short\n:return: int",
  "unsignedShortToLong": ":param x: short\n:return: long",
  "valuesToString": ":return: java.lang.String"
 },
 "path": "io.deephaven.db.v2.utils.rsp.RspArray",
 "text": "A set representation for long values using Regular Space Partitioning (RSP) of the long space in \"blocks\" of (2^16)\n elements.\n \n\n Modeled heavily after roaringbitmap.RoaringArray (keeping API method names and semantics as much as possible), with\n modifications for:\n \n\n* Full \"unsigned long\" 64 bit range (as opposed to 32 bit in RoaringArray).\n* Spans of all bits set (\"AllSet\") that can be arbitrarily big (ie, not constrained to 2^16 = RB Container\n size).\n\n\n The handling of unsigned values follows RB; ie, key values are compared/sorted as unsigned longs.\n \n\n Definitions:\n \n\n* A \"block\" is a particular interval [n*2^16, (n+1)*2^16 - 1] of the long domain.\n* A \"span\" is a partition of the domain consisting of one or more consecutive blocks; a span is a subset of\n the domain represented by an interval [n*2^16, (n+m)*2^16 - 1], m >= 1.\n * Full blocks are blocks whose domain are fully contained in the set, ie, the set contains every possible value in\n the block's interval (as a bitmap, it would be \"all ones\").\n* Spans of full blocks are represented by a single \"full blocks span\" object (just a Long) which knows how many\n 2^16 ranges it has (it's \"full blocks span len\" (\"flen\") is the number of full blocks in the span).\n* Individual blocks that are not completely full are stored in an RB Container; their \"full blocks span len\" is\n zero.\n\n\n Our internal representation uses two parallel arrays:\n \n\n* a long[] spanInfos array that contains the information for the offset to the values in the span,\n which we call the span's \"key\". For instance, a full block span that represents all the long values in [65536,\n 196607] has as its key the value 65536.\n* an Object[] spans array that contains the actual spans. At the most basic level, a span can be\n either a full block span or a container of values (but there is nuance in exactly how to represent them, see\n below).\n\n\n We use several optimizations to reduce memory utilization for sparse sets. Details follow.\n \n\n The long[] spanInfos and Object[] spans data members of this class are used, combined, to\n represent the offset (key) and span values in the set, against that offset. The two arrays are used, together, as\n parallel arrays and the information for a given conceptual span is contained in both of them for the same\n corresponding index i.\n \n\n There are two basic cases for a span: it is either a full blocks span, containing a >=1 number of full blocks, or it\n is a container, containing individual values in the particular 2^16 block corresponding to the span's key.\n \n\n There are four ways total that these two cases can be represented between the long in the `spanInfos` array and the\n Object in the `spans` array. Given a span at position `i`:\n \n\n* If the corresponding Object spans[i] is of type Long, then the long spanInfos[i] value\n is the key for the span (with its lower 16 bits as zero), and the Long value represents how many full blocks are\n present. Example, the set [ 0, 2^50 - 1 ] is represented as spanInfo==0 and span==Long(2^34).\n* As an optimization to conserve memory, if the Object spans[i] is the Object reference with value\n FULL_BLOCK_SPAN_MARKER (a singleton and final marker Object defined statically in this file). then the\n upper 48 bits of the long spanInfo[i] value represent the key for the span, and the lower 16 bits of the\n long spanInfo[i] value represent the full block span length. Example, the set [ 65536, 196607 ] is\n represented by spanInfo==65538 and span==FULL_BLOCK_SPAN_MARKER (note\n 196607 == 65536*3 - 1, so the set is 2 full blocks, and 65538 == 65536 | 2.\n* If the corresponding Object spans[i] is null, then the long spanInfos[i] represents the\n single value present in the span (note in this case, its upper 16 bits still corresponds to its key). Example, the\n set { 65537 } is represented by spanInfo==65537 and span==null.\n* If the corresponding Object spans[i] is of type short[] or of type\n Container, then it represents a container of multiple values in a single block (but not all of the\n possible values in the block, since in that case it would be a full block span as above). In this case the higher 48\n bits of its corresponding spanInfo represent the key for the span. Depending on the actual type of span there are two\n subcases:\n\n \n* If spans[i] is of type Container, then the values in the roaringbitmaps container\n object are part of the set, considered against its key offset. The key is represented in the higher 48 bits of its\n corresponding spaninfo. The lower 16 bits of spanInfo are zero in this case. Example, the set [ 100,000-100,010,\n 100,020-100,030 ] is represented by spaInfo==65536,\n span==RunContainer({34464-34474, 34484-34494})\n* If spans[i] is of type short[], then an ArrayContainer with the\n short[] contents needs to be reconstructed. The lower 16 bits of the spanInfo value are used to\n represent the other data members of ArrayContainer. This case exists as an optimization to reduce memory utilization\n for sparse blocks. For details of this reconstruction please see the code for the definition of the SpanView class\n below.\n\n\n\n\n Notes:\n \n\n* Our version of RB Container supports a \"shared\" boolean flag that is used to implement copy-on-write (COW)\n semantics and allow operation results to share containers in COW fashion.\n* We extended the Container class hierarchy to include specializations for empty, single value, single range, and\n two values containers. These are immutable; empty is used only as a way to return empty results, and are never actual\n stored in the spans array. For details, please see the Container class definition and derived class hierarchy.",
 "typeName": "class"
}