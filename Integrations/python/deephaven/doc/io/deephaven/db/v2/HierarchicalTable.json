{
 "className": "io.deephaven.db.v2.HierarchicalTable",
 "methods": {
  "absSumBy": "Groups the data column according to groupByColumns and computes the sum of the absolute values for the rest of the fields\n\n:param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns Table.by(String...)\n:return: io.deephaven.db.tables.Table",
  "addColumnGrouping": ":param columnName: java.lang.String",
  "aj": "Looks up the columns in the rightTable that meet the match conditions in the columnsToMatch list.\n Matching is done exactly for the first n-1 columns and via a binary search for the last match pair.\n The columns of the original table are returned intact, together with the columns from rightTable defined in\n a comma separated list \"columnsToAdd\"\n\n:param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n:param columnsToMatch: (io.deephaven.db.tables.select.MatchPair[]) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n:param columnsToAdd: (io.deephaven.db.tables.select.MatchPair[]) - A comma separated list with the columns from the left side that need to be added to the right\n                       side as a result of the match.\n:param asOfMatchRule: io.deephaven.db.tables.Table.AsOfMatchRule\n:return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "applyToAllBy": "Groups data according to groupByColumns and applies formulaColumn to each of columns not altered by the grouping\n operation.\n columnParamName is used as place-holder for the name of each column inside\n formulaColumn.\n\n:param formulaColumn: (java.lang.String) - Formula applied to each column\n:param columnParamName: (java.lang.String) - The parameter name used as a placeholder for each column\n:param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns Table.by(SelectColumn[])\n:return: io.deephaven.db.tables.Table",
  "avgBy": "Groups the data column according to groupByColumns and computes the average for the rest of the fields\n\n:param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns Table.by(String...)\n:return: io.deephaven.db.tables.Table",
  "by": ":param aggregationStateFactory: io.deephaven.db.v2.by.AggregationStateFactory\n:param groupByColumns: io.deephaven.db.v2.select.SelectColumn...\n:return: io.deephaven.db.tables.Table",
  "byExternal": "Create a TableMap from this table, keyed by the specified columns.\n\n The returned TableMap contains each row in this table in exactly one of the tables within the map.  If you\n have exactly one key column the TableMap is keyed by the value in that column.  If you have zero key columns, then\n the TableMap is keyed by io.deephaven.datastructures.util.SmartKey.EMPTY (and will contain this table as the\n value).  If you have multiple key columns, then\n the TableMap is keyed by a io.deephaven.datastructures.util.SmartKey.  The SmartKey will have one value for\n each of your column values, in the order specified by keyColumnNames.\nFor example if you have a Table keyed by a String column named USym, and a DBDateTime column named Expiry; a\n value could be retrieved from the TableMap with\n tableMap.get(new SmartKey(\"SPY\";, DBTimeUtils.convertDateTime(\"2020-06-19T16:15:00 NY\"))).  For a table\n with an Integer column named Bucket, you simply use the desired value as in tableMap.get(1).\n\n:param dropKeys: (boolean) - if true, drop key columns in the output Tables\n:param keyColumnNames: (java.lang.String...) - the name of the key columns to use.\n:return: (io.deephaven.db.v2.LocalTableMap) a TableMap keyed by keyColumnNames",
  "copy": ":param copyAttributes: boolean\n:return: io.deephaven.db.tables.Table",
  "countBy": ":param countColumnName: java.lang.String\n:param groupByColumns: io.deephaven.db.v2.select.SelectColumn...\n:return: io.deephaven.db.tables.Table",
  "dropColumns": ":param columnNames: java.lang.String...\n:return: io.deephaven.db.tables.Table",
  "dropReference": "Drop a previously-retained reference to this referent.",
  "exactJoin": ":param table: io.deephaven.db.tables.Table\n:param columnsToMatch: io.deephaven.db.tables.select.MatchPair[]\n:param columnsToAdd: io.deephaven.db.tables.select.MatchPair[]\n:return: io.deephaven.db.tables.Table",
  "firstBy": "Groups the data column according to groupByColumns and retrieves the first for the rest of the fields\n\n:param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns Table.by(String...)\n:return: io.deephaven.db.tables.Table",
  "flatten": "Creates a version of this table with a flat index (V2 only).\n\n:return: io.deephaven.db.tables.Table",
  "formatColumns": ":param columnFormats: java.lang.String...\n:return: io.deephaven.db.tables.Table",
  "getInfo": "Get the HierarchicalTableInfo associated with this table.\n\n:return: (io.deephaven.db.v2.HierarchicalTableInfo) the info for this table",
  "getRawRootTable": "Get the table that is the root of the hierarchy\n\n:return: (io.deephaven.db.tables.Table) the root of the hierarchy",
  "getSourceTable": "Get the table on which this hierarchical table was created from.\n\n:return: (io.deephaven.db.tables.Table) the source table",
  "getSubTable": ":param index: io.deephaven.db.v2.utils.Index\n:return: io.deephaven.db.v2.QueryTable",
  "getWeakReference": "Get a WeakReference to this referent. This may be cached, or newly created.\n\n:return: (java.lang.ref.WeakReference<? extends io.deephaven.db.util.liveness.LivenessReferent>) A new or cached reference to this referent",
  "head": ":param size: long\n:return: io.deephaven.db.tables.Table",
  "headBy": ":param nRows: long\n:param groupByColumns: java.lang.String...\n:return: io.deephaven.db.tables.Table",
  "headPct": "Provides a head that selects a dynamic number of rows based on a percent.\n\n:param percent: (double) - the fraction of the table to return (0..1), the number of rows will be rounded up.  For example\n                if there are 3 rows, headPct(50) returns the first two rows.\n:return: io.deephaven.db.tables.Table",
  "initializeTransientFieldsForLiveness": "Package-private for Serializable sub-classes to use in readObject only.\n Public to allow unit tests in another package to work around mock issues where the constructor is never invoked.",
  "join": "Perform a cross join with the right table.\n \n Returns a table that is the cartesian product of left rows X right rows, with one column for each of the left\n table's columns, and one column corresponding to each of the right table's columns that are included in the\n columnsToAdd argument. The rows are ordered first by the left table then by the right table. If columnsToMatch\n is non-empty then the product is filtered by the supplied match conditions.\n \n To efficiently produce updates, the bits that represent a key for a given row are split into two. Unless specified,\n join reserves 16 bits to represent a right row. When there are too few bits to represent all of the right rows\n for a given aggregation group the table will shift a bit from the left side to the right side. The default of 16\n bits was carefully chosen because it results in an efficient implementation to process live updates.\n \n An OutOfKeySpaceException is thrown when the total number of bits needed\n to express the result table exceeds that needed to represent Long.MAX_VALUE. There are a few work arounds:\n - If the left table is sparse, consider flattening the left table.\n - If there are no key-columns and the right table is sparse, consider flattening the right table.\n - If the maximum size of a right table's group is small, you can reserve fewer bits by setting numRightBitsToReserve on initialization.\n \n Note: If you can prove that a given group has at most one right-row then you should prefer using Table.naturalJoin(io.deephaven.db.tables.Table, io.deephaven.db.tables.select.MatchPair[], io.deephaven.db.tables.select.MatchPair[]).\n\n:param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n:param columnsToMatch: (io.deephaven.db.tables.select.MatchPair[]) - An array of match pair conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n:param columnsToAdd: (io.deephaven.db.tables.select.MatchPair[]) - An array of the columns from the right side that need to be added to the left\n                              side as a result of the match.\n:param numRightBitsToReserve: (int) - The number of bits to reserve for rightTable groups.\n:return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "lastBy": "Groups the data column according to groupByColumns and retrieves the last for the rest of the fields\n\n:param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns Table.by(String...)\n:return: io.deephaven.db.tables.Table",
  "lazyUpdate": "Compute column formulas on demand.\n\n Lazy update defers computation until required for a set of values, and caches the results for a set of input\n values.  This uses less RAM than an update statement when you have a smaller set of unique values.  Less\n computation than an updateView is needed, because the results are saved in a cache.\nIf you have many unique values, you should instead use an update statement, which will have more memory\n efficient structures.  Values are never removed from the lazyUpdate cache, so it should be used judiciously\n on a ticking table.\n\n:param columns: (io.deephaven.db.v2.select.SelectColumn...) - the columns to add\n:return: (io.deephaven.db.tables.Table) a new Table with the columns added; to be computed on demand",
  "leftJoin": "Returns a table that has one column for each original table's columns, and one column corresponding to each of\n the input table (right table) columns listed in the columns to add (or all the columns whose names don't overlap\n with the name of a column from the source table if the columnsToAdd is length zero).\n The new columns (those corresponding to the input table) contain an aggregation of all values from the left side that\n match the join criteria. Consequently the types of all right side columns not involved in a join criteria, is an\n array of the original column type.\n If the two tables have columns with matching names then the method will fail with an exception unless the columns with\n corresponding names are found in one of the matching criteria.\n \n\n NOTE: leftJoin operation does not involve an actual data copy, or an in-memory table creation. In order to produce\n an actual in memory table you need to apply a select call on the join result.\n\n:param table: (io.deephaven.db.tables.Table) - input table\n:param columnsToMatch: (io.deephaven.db.tables.select.MatchPair[]) - match criteria\n:param columnsToAdd: (io.deephaven.db.tables.select.MatchPair[]) - columns to add\n:return: (io.deephaven.db.tables.Table) a table that has one column for each original table's columns, and one column corresponding to each column\n listed in columnsToAdd.  If columnsToAdd.length==0 one column corresponding to each column of\n the input table (right table) columns whose names don't overlap with the name of a column from the source table is added.\n The new columns (those corresponding to the input table) contain an aggregation of all values from the left side that\n match the join criteria.",
  "maxBy": "Groups the data column according to groupByColumns and computes the max for the rest of the fields\n\n:param selectColumns: (io.deephaven.db.v2.select.SelectColumn[]) - The grouping columns Table.by(String...) }\n:return: io.deephaven.db.tables.Table",
  "medianBy": "Groups the data column according to groupByColumns and computes the median for the rest of the fields\n\n:param selectColumns: (io.deephaven.db.v2.select.SelectColumn[]) - The grouping columns Table.by(String...) }\n:return: io.deephaven.db.tables.Table",
  "minBy": "Groups the data column according to groupByColumns and computes the min for the rest of the fields\n\n:param selectColumns: (io.deephaven.db.v2.select.SelectColumn[]) - The grouping columns Table.by(String...)\n:return: io.deephaven.db.tables.Table",
  "naturalJoin": ":param rightTable: io.deephaven.db.tables.Table\n:param columnsToMatch: io.deephaven.db.tables.select.MatchPair[]\n:param columnsToAdd: io.deephaven.db.tables.select.MatchPair[]\n:return: io.deephaven.db.tables.Table",
  "raj": "Just like .aj(), but the matching on the last column is in reverse order, so that you find the row after the\n given timestamp instead of the row before.\n \n Looks up the columns in the rightTable that meet the match conditions in the columnsToMatch list.\n Matching is done exactly for the first n-1 columns and via a binary search for the last match pair.\n The columns of the original table are returned intact, together with the columns from rightTable defined in\n a comma separated list \"columnsToAdd\"\n\n:param rightTable: (io.deephaven.db.tables.Table) - The right side table on the join.\n:param columnsToMatch: (io.deephaven.db.tables.select.MatchPair[]) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n:param columnsToAdd: (io.deephaven.db.tables.select.MatchPair[]) - A comma separated list with the columns from the left side that need to be added to the right\n                       side as a result of the match.\n:param asOfMatchRule: io.deephaven.db.tables.Table.AsOfMatchRule\n:return: (io.deephaven.db.tables.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "renameColumns": ":param pairs: io.deephaven.db.tables.select.MatchPair...\n:return: io.deephaven.db.tables.Table",
  "reverse": "The reverse operation returns a new table that is the same as the original table, but the first row is last, and\n the last row is first.  This is an internal API to be used by .raj(), but is accessible for unit tests.\n\n:return: (io.deephaven.db.tables.Table) the reversed table",
  "rollup": "Create a rollup table.\n\n A rollup table aggregates by the specified columns, and then creates a hierarchical table which re-aggregates\n using one less aggregation column on each level.  The column that is no longer part of the aggregation key is\n replaced with null on each level.\n\n:param comboAggregateFactory: (io.deephaven.db.v2.by.ComboAggregateFactory) - the ComboAggregateFactory describing the aggregation\n:param columns: (io.deephaven.db.v2.select.SelectColumn...) - the columns to group by\n:return: (io.deephaven.db.tables.Table) a hierarchical table with the rollup applied",
  "select": ":param selectColumns: io.deephaven.db.v2.select.SelectColumn...\n:return: io.deephaven.db.tables.Table",
  "selectDistinct": ":param columns: io.deephaven.db.v2.select.SelectColumn...\n:return: io.deephaven.db.tables.Table",
  "slice": "Extracts a subset of a table by row position.\n\n If both firstPosition and lastPosition are positive, then the rows are counted from the beginning of the table.\n The firstPosition is inclusive, and the lastPosition is exclusive.  The Table.head(long)(N) call is equivalent to\n slice(0, N).  The firstPosition must be less than or equal to the lastPosition.\n\n If firstPosition is positive and lastPosition is negative, then the firstRow is counted from the beginning of the\n table, inclusively.  The lastPosition is counted from the end of the table.  For example, slice(1, -1) includes\n all rows but the first and last.  If the lastPosition would be before the firstRow, the result is an emptyTable.\n\n If firstPosition is negative, and lastPosition is zero, then the firstRow is counted from the end of the table,\n and the end of the slice is the size of the table.  slice(-N, 0) is equivalent to Table.tail(long)(N).\n\n If the firstPosition is nega tive and the lastPosition is negative, they are both counted from the end of the\n table. For example, slice(-2, -1) returns the second to last row of the table.\n\n:param firstRowInclusive: (long) - the first position to include in the result\n:param lastRowExclusive: (long) - the last position to include in the result\n:return: (io.deephaven.db.tables.Table) a new Table, which is the request subset of rows from the original table",
  "snapshot": "Snapshot \"rightTable\", triggered by \"this\" Table, and return a new Table as a result.\n \"this\" Table is the triggering table, i.e. the table whose change events cause a new snapshot to be taken.\n The result table includes a \"snapshot key\" which is a subset (possibly all) of this Table's columns. The\n remaining columns in the result table come from \"rightTable\", the table being snapshotted.\n\n:param rightTable: (io.deephaven.db.tables.Table) - The table to be snapshotted\n:param doInitialSnapshot: (boolean) - Take the first snapshot now (otherwise wait for a change event)\n:param stampColumns: (java.lang.String...) - The columns forming the \"snapshot key\", i.e. some subset of this Table's columns\n                     to be included in the result at snapshot time. As a special case, an empty stampColumns\n                     is taken to mean \"include all columns\".\n:return: (io.deephaven.db.tables.Table) The result table",
  "snapshotHistory": ":param rightTable: io.deephaven.db.tables.Table\n:return: io.deephaven.db.tables.Table",
  "snapshotIncremental": ":param rightTable: io.deephaven.db.tables.Table\n:param doInitialSnapshot: boolean\n:param stampColumns: java.lang.String...\n:return: io.deephaven.db.tables.Table",
  "sort": ":param columnsToSortBy: io.deephaven.db.tables.SortPair...\n:return: io.deephaven.db.tables.Table",
  "stdBy": ":param groupByColumns: io.deephaven.db.v2.select.SelectColumn...\n:return: io.deephaven.db.tables.Table",
  "sumBy": "Groups the data column according to groupByColumns and computes the sum for the rest of the fields\n\n:param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns Table.by(String...)\n:return: io.deephaven.db.tables.Table",
  "tail": ":param size: long\n:return: io.deephaven.db.tables.Table",
  "tailBy": ":param nRows: long\n:param groupByColumns: java.lang.String...\n:return: io.deephaven.db.tables.Table",
  "tailPct": ":param percent: double\n:return: io.deephaven.db.tables.Table",
  "treeTable": "Create a hierarchical tree table.\n\n The structure of the table is encoded by an \"id\" and a \"parent\" column.  The id column should represent a unique\n identifier for a given row, and the parent column indicates which row is the parent for a given row.  Rows that\n have a null parent, are shown in the main table.  It is possible for rows to be \"orphaned\", if their parent\n reference is non-null and does not exist in the table.\n\n:param idColumn: (java.lang.String) - the name of a column containing a unique identifier for a particular row in the table\n:param parentColumn: (java.lang.String) - the name of a column containing the parent's identifier, null for elements that are part of\n                     the root table\n:return: (io.deephaven.db.tables.Table) a hierarchical table grouped according to the parentColumn",
  "tryManage": "Attempt to add the specified referent to this manager.\n\n:param referent: (io.deephaven.db.util.liveness.LivenessReferent) - The referent to add\n:return: (boolean) Whether the referent was in fact added",
  "tryRetainReference": "If this referent is \"live\", behave as LivenessReferent.retainReference() and return true.\n Otherwise, returns false rather than throwing an exception.\n\n:return: (boolean) True if this referent was retained, false otherwise",
  "ungroup": "Ungroups a table by converting arrays into columns.\n\n:param nullFill: (boolean) - indicates if the ungrouped table should allow disparate sized arrays filling shorter columns with\n                 null values.  If set to false, then all arrays should be the same length.\n:param columnsToUngroup: (java.lang.String...) - the columns to ungroup\n:return: (io.deephaven.db.tables.Table) the ungrouped table",
  "update": ":param columns: io.deephaven.db.v2.select.SelectColumn...\n:return: io.deephaven.db.tables.Table",
  "updateView": ":param columns: io.deephaven.db.v2.select.SelectColumn...\n:return: io.deephaven.db.tables.Table",
  "varBy": "Groups the data column according to groupByColumns and computes the variance for the rest of the fields\n\n:param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns Table.by(String...)\n:return: io.deephaven.db.tables.Table",
  "view": ":param columns: io.deephaven.db.v2.select.SelectColumn...\n:return: io.deephaven.db.tables.Table",
  "wavgBy": "Groups the data column according to groupByColumns and computes the weighted average using\n weightColumn for the rest of the fields\n\n:param weightColumn: (java.lang.String) - the column to use for the weight\n:param groupByColumns: (io.deephaven.db.v2.select.SelectColumn...) - The grouping columns Table.by(String...)\n:return: io.deephaven.db.tables.Table",
  "where": ":param filters: io.deephaven.db.v2.select.SelectFilter...\n:return: io.deephaven.db.tables.Table",
  "whereIn": "Filters this table based on the set of values in the rightTable.  Note that when the right table ticks, all of\n the rows in the left table are going to be re-evaluated, thus the intention is that the right table is fairly\n slow moving compared with the left table.\n\n:param groupStrategy: io.deephaven.db.tables.Table.GroupStrategy\n:param rightTable: io.deephaven.db.tables.Table\n:param inclusion: boolean\n:param columnsToMatch: io.deephaven.db.tables.select.MatchPair...\n:return: (io.deephaven.db.tables.Table) a new table filtered on right table"
 },
 "path": "io.deephaven.db.v2.HierarchicalTable",
 "text": "This class is an extension of QueryTable that overrides many methods from Table which are not valid to perform\n on Hierarchical tables (treeTables() and rollups()).",
 "typeName": "class"
}