{
 "className": "io.deephaven.db.v2.sources.ColumnSource",
 "methods": {
  "allowsReinterpret": "Test if a reinterpret call will succeed.\n\nNote: Java generics information - <ALTERNATE_DATA_TYPE>\n\n:param alternateDataType: (java.lang.Class<ALTERNATE_DATA_TYPE>) - The alternative type to consider\n:return: (boolean) If a reinterpret on this column source with the supplied alternateDataType will succeed.",
  "cast": "Returns this ColumnSource, parameterized by <TYPE>, if the data type of this column (as given by\n getType()) can be cast to clazz. This is analogous to casting the objects provided by this\n column source to clazz.\n \n For example, the following code will throw an exception if the \"MyString\" column does not actually contain\n String data:\n\n \n     ColumnSource<String> colSource = table.getColumnSource(\"MyString\").getParameterized(String.class)\n \n\n Due to the nature of type erasure, the JVM will still insert an additional cast to TYPE when elements are\n retrieved from the column source, such as with String myStr = colSource.get(0).\n\nNote: Java generics information - <TYPE>\n\n:param extend: java.lang.Class<?\n:return: (io.deephaven.db.v2.sources.ColumnSource<TYPE>) A ColumnSource parameterized by TYPE.",
  "createPreviousTuple": "Create a tuple for previous key column values at the supplied index key.\n\n:param indexKey: (long) - The index key\n:return: (ColumnSource.T) The resulting tuple",
  "createTuple": "Create a tuple for key column values at the supplied index key.\n\n:param indexKey: (long) - The index key\n:return: (ColumnSource.T) The resulting tuple",
  "createTupleFromValues": "Create a tuple for the supplied (boxed) values.\n\n:param values: (java.lang.Object...) - The values\n:return: (ColumnSource.T) The resulting tuple",
  "exportElement": "**Incompatible overloads text - text from the first overload:**\n\nExport a single element from the tuple, identified by its element index, to an Object\n \n \n For the empty tuple, this is unsupported.\n \n For singles, this will copy the sole element, possibly in boxed form.\n \n For doubles and longer, this will copy the specified element without any unnecessary boxing.\n\n*Overload 1*  \n  Note: Java generics information - <ELEMENT_TYPE>\n  \n  :param tuple: (ColumnSource.T) - The tuple to export an element from\n  :param elementIndex: (int) - The element index to export\n  :param writableSource: (io.deephaven.db.v2.sources.WritableSource<ELEMENT_TYPE>) - The destination\n  :param destinationIndexKey: (long) - The destination index key\n  \n*Overload 2*  \n  :param tuple: (ColumnSource.T) - The tuple to export an element from\n  :param elementIndex: (int) - The element index to export\n  :return: java.lang.Object",
  "exportToExternalKey": "Export this tuple's element list as a key suitable for the TableMaps resulting from\n Table.byExternal(boolean, java.lang.String...).\n \n For the empty tuple this is a unsupported.\n \n For singles, this is the (boxed) sole element itself.\n \n For doubles and longer, this is a newly-allocated \"SmartKey\".\n\n:param tuple: (ColumnSource.T) - The tuple to export all elements from\n:return: (java.lang.Object) The new smart key",
  "getChunkType": "Get the most suitable ChunkType for use with this ChunkSource.\n\n:return: (io.deephaven.db.v2.sources.chunk.ChunkType) The ChunkType",
  "getColumnSources": "Get the ColumnSources backing this tuple source.\n\n:return: (java.util.List<io.deephaven.db.v2.sources.ColumnSource>) The column sources",
  "getComponentType": ":return: java.lang.Class<?>",
  "getGroupToRange": "**Incompatible overloads text - text from the first overload:**\n\nCompute grouping information for (at least) all keys present in index.\n\n*Overload 1*  \n  :return: (java.util.Map<ColumnSource.T,io.deephaven.db.v2.utils.Index>) A map from distinct data values to an index that contains those values\n  \n*Overload 2*  \n  :param index: (io.deephaven.db.v2.utils.Index) - The index to consider\n  :return: (java.util.Map<ColumnSource.T,io.deephaven.db.v2.utils.Index>) A map from distinct data values to an index that contains those values",
  "getPrevSource": ":return: (io.deephaven.db.v2.sources.chunk.ChunkSource<io.deephaven.db.v2.sources.chunk.Attributes.Values>) a chunk source which accesses the previous values.",
  "getType": ":return: java.lang.Class<ColumnSource.T>",
  "getValuesMapping": ":param subRange: io.deephaven.db.v2.utils.Index\n:return: java.util.Map<ColumnSource.T,io.deephaven.db.v2.utils.Index>",
  "isImmutable": "Determine if this column source is immutable, meaning that the values at a given index key never change.\n\n:return: (boolean) true if the values at a given index of the column source never change, false otherwise",
  "match": ":param invertMatch: boolean\n:param usePrev: boolean\n:param caseInsensitive: boolean\n:param mapper: io.deephaven.db.v2.utils.Index\n:param keys: java.lang.Object...\n:return: io.deephaven.db.v2.utils.Index",
  "reinterpret": "Provide an alternative view into the data underlying this column source.\n\nNote: Java generics information - <ALTERNATE_DATA_TYPE>\n\n:param alternateDataType: (java.lang.Class<ALTERNATE_DATA_TYPE>) - The alternative type to expose\n:return: (io.deephaven.db.v2.sources.ColumnSource<ALTERNATE_DATA_TYPE>) A column source of the alternate data type, backed by the same underlying data.",
  "releaseCachedResources": "Release any resources held for caching purposes. Implementations need not guarantee that concurrent accesses are\n correct, as the purpose of this method is to ensure cleanup for column sources that will no longer be used.",
  "startTrackingPrevValues": "ColumnSource implementations that track previous values have the option to not actually start tracking previous\n values until this method is called. This is an option, not an obligation: some simple ColumnSource\n implementations (like TSingleValueSource for various T) always track previous values; other implementations (like\n PrevColumnSource) never do; some (like TArrayColumnSource) only start tracking once this method is called.\n\n An immutable column source can not have distinct prev values; therefore it is implemented as a no-op."
 },
 "path": "io.deephaven.db.v2.sources.ColumnSource",
 "text": "A \"source\" for column data - allows cell values to be looked up by (long) keys.\n\n \n Note for implementors: All ColumnSource implementations must map ReadOnlyIndex.NULL_KEY to a null value for\n all get and getPrev methods.",
 "typeName": "interface"
}