{
 "className": "io.deephaven.db.v2.utils.TreeIndex",
 "methods": {
  "add": ":param builder: io.deephaven.db.v2.utils.TreeIndexImpl.RandomBuilder\n:param idx: io.deephaven.db.v2.utils.TreeIndex",
  "append": ":param logOutput: io.deephaven.base.log.LogOutput\n:return: io.deephaven.base.log.LogOutput",
  "asIndex": "Get an Index representation of this OrderedKeys.\n\n:return: (io.deephaven.db.v2.utils.Index) An Index representation for the same keys in the same order",
  "clone": ":return: io.deephaven.db.v2.utils.Index",
  "close": "Free any resources associated with this object.\n Using any OrderedKeys methods after close() is an error and may produce exceptions or\n undefined results.",
  "compact": "May reclaim some unused memory.",
  "containsRange": "Queries whether this index contains every element in the range provided.\n\n:param start: long\n:param end: long\n:return: (boolean) true if this index contains every element x in start <= x <= end.",
  "empty": "Queries whether this index is empty (i.e. has no keys).\n\n:return: (boolean) true if the size() of this Index is zero, false if the size is greater than zero",
  "fillKeyIndicesChunk": "Fill the supplied WritableLongChunk with individual keys from this OrderedKeys.\n The chunk's capacity is assumed to be big enough.\n\n:param chunkToFill: io.deephaven.db.v2.sources.chunk.WritableLongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>",
  "fillKeyRangesChunk": "Fill the supplied WritableLongChunk with key ranges from this OrderedKeys.\n The chunk's capacity is assumed to be big enough.\n\n:param chunkToFill: io.deephaven.db.v2.sources.chunk.WritableLongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyRanges>",
  "find": "Returns the position in [0..(size-1)] where the key is found. If not found,\n then return (-(position it would be) - 1), a la Array.binarySearch.\n\n:param key: long\n:return: (long) a position from [0..(size-1)] if the key was found.  If the key was not found, then (-position - 1) as\n in Array.binarySearch.",
  "findPrev": "Returns the position in [0..(size-1)] where the key is found in the previous index. If not found, then return\n (-(position it would be) - 1), as in Array.binarySearch.\n\n:param key: long\n:return: (long) a position from [0..(size-1)] if the key was found.  If the key was not found, then (-position - 1) as\n in Array.binarySearch.",
  "firstKey": "Get the first key in this Index.\n\n:return: (long) The first key, or ReadOnlyIndex.NULL_KEY if there is none.",
  "firstKeyPrev": ":return: long",
  "forEachLong": "Provide each value contained in this index, in increased sorted order to the consumer.\n If the consumer returns false for a key, stops after that key (does not provide any\n keys after that key).\n\n:param lc: io.deephaven.db.v2.utils.LongAbortableConsumer\n:return: (boolean) false if the consumer returned false at some point, true if the consumer always\n returned true and all values in the index were consumed.",
  "forEachLongRange": "For as long as the consumer wants more ranges, call accept on the consumer with the individual key ranges\n in this OrderedKeys, in increasing order.\n\n:param lrac: io.deephaven.db.v2.utils.LongRangeAbortableConsumer\n:return: (boolean) false if the consumer provided ever returned false, true otherwise.",
  "get": "Returns the key at the given rank position.\n\n:param pos: long\n:return: (long) the key at that rank.",
  "getAverageRunLengthEstimate": "Get an estimate of the average (mean) length of runs of adjacent keys in this OrderedKeys.\n Implementations should strive to keep this method efficient (O(1) preferred) at the expense of\n accuracy.\n Empty OrderedKeys should return an arbitrary valid value, usually 1.\n\n:return: (long) An estimate of the average run length in this OrderedKeys, in [1, size()]",
  "getEmptyIndex": ":return: io.deephaven.db.v2.utils.SortedIndex",
  "getImpl": ":return: io.deephaven.db.v2.utils.TreeIndexImpl",
  "getKeysForPositions": "Returns the sequence of (increasing) keys corresponding to the positions\n provided as input.\n\n:param positions: java.util.PrimitiveIterator.OfLong\n:param outputKeys: java.util.function.LongConsumer",
  "getOrderedKeysByKeyRange": "Get an ordered subset of the keys in this OrderedKeys for a key range. The returned set will be the\n intersection of the keys in this  with the keys in the closed interval\n [startKeyInclusive, endKeyInclusive].\n\n The returned reference is owned by the caller, who should call close() when it is done with it.\n\n:param startKeyInclusive: long\n:param endKeyInclusive: long\n:return: (io.deephaven.db.v2.utils.OrderedKeys) The subset as an OrderedKeys, which may be this",
  "getOrderedKeysByPosition": "Get an ordered subset of the keys in this OrderedKeys for a position range.\n The result will contain the set of keys in this that lie at positions in the half-open range\n [startPositionInclusive, startPositionInclusive + length).\n\n The returned reference is owned by the caller, who should call close() when it is done with it.\n\n:param start: long\n:param len: long\n:return: (io.deephaven.db.v2.utils.OrderedKeys) The subset as an OrderedKeys, which may be this",
  "getOrderedKeysIterator": "Get an OrderedKeys.Iterator over this OrderedKeys.\n\n:return: (io.deephaven.db.v2.utils.OrderedKeys.Iterator) A new iterator, positioned at the first key",
  "getPrev": ":param pos: long\n:return: long",
  "getPrevIndex": ":return: io.deephaven.db.v2.utils.Index",
  "initializePreviousValue": "Initializes our previous value from the current value.\n\n This call is used by operations that manipulate an Index while constructing it, but need to set the state at the\n end of the initial operation to the current state.\n\n Calling this in other circumstances will yield undefined results.",
  "insert": "**Incompatible overloads text - text from the first overload:**\n\nAdd a single key to this index if it's not already present.\n\n*Overload 1*  \n  :param key: long\n  \n*Overload 2*  \n  :param keys: io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyIndices>\n  :param offset: int\n  :param length: int\n  \n*Overload 3*  \n  :param added: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "insertRange": "Add all keys in a closed range to this index if they are not already present.\n\n:param startKey: long\n:param endKey: long",
  "insertWithShift": "For each key in the provided index, shift it by shiftAmount and insert it in the current index.\n\n:param shiftAmount: long\n:param other: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "intersect": "Returns a new index representing the intersection of the current index with the input index\n\n:param range: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: io.deephaven.db.v2.utils.Index",
  "invert": "The only used implementation of invert is in the TreeIndex, really the guts of it are in BspNodeIndex.\n\n This version is inefficient as it simply performs O(keys) find operations; which is O(keys * lg size), because\n there is no memory about what you've already found.\n\n It serves as a reasonable reference for what the invert operation is \"meant\" to do.\n\n Note maximumPosition is inclusive.\n\n:param keys: io.deephaven.db.v2.utils.ReadOnlyIndex\n:param maximumPosition: long\n:return: (io.deephaven.db.v2.utils.Index) a new Index containing the positions of the keys in this index",
  "iterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.Iterator",
  "lastKey": "Get the last key in this OrderedKeys.\n\n:return: (long) The last key, or ReadOnlyIndex.NULL_KEY if there is none.",
  "lastKeyPrev": ":return: long",
  "makeCurrentRandomBuilder": ":return: io.deephaven.db.v2.utils.Index.RandomBuilder",
  "makeCurrentSequentialBuilder": ":return: io.deephaven.db.v2.utils.Index.SequentialBuilder",
  "makeEmptyRsp": ":return: io.deephaven.db.v2.utils.TreeIndex",
  "makeEmptySr": ":return: io.deephaven.db.v2.utils.TreeIndex",
  "makeRandomBuilder": ":return: io.deephaven.db.v2.utils.Index.RandomBuilder",
  "makeSequentialBuilder": ":return: io.deephaven.db.v2.utils.Index.SequentialBuilder",
  "makeSingleRange": ":param start: long\n:param end: long\n:return: io.deephaven.db.v2.utils.TreeIndex",
  "minus": "Returns a new index representing the keys of the current set not present inside indexToRemove\n This operation is equivalent to set difference.  This index is not modified.\n\n:param set: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: io.deephaven.db.v2.utils.Index",
  "overlaps": "Returns true if an index has any overlap.\n\n:param range: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: boolean",
  "overlapsRange": "Returns true if this index has any overlap with the provided range.\n\n:param start: long\n:param end: long\n:return: (boolean) true if any value x in start <= x <= end is contained in this index.",
  "rangeIterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.RangeIterator",
  "rangesCountUpperBound": ":return: long",
  "readExternal": ":param in: java.io.ObjectInput",
  "refCount": "Note: Java generics information - io.deephaven.util.annotations.@VisibleForTesting\n\n:return: int",
  "remove": "**Incompatible overloads text - text from the first overload:**\n\nRemove a single key from this index if it's present.\n\n*Overload 1*  \n  :param key: long\n  \n*Overload 2*  \n  :param keys: io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyIndices>\n  :param offset: int\n  :param length: int\n  \n*Overload 3*  \n  :param removed: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "removeRange": "Remove all keys in a closed range from this index if they are present.\n\n:param startKey: long\n:param endKey: long",
  "retain": "Modifies the index by removing any keys not in the indexToIntersect argument.\n\n:param toIntersect: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "retainRange": "Modifies the index by keeping only keys in the interval [start, end]\n\n:param startKey: long\n:param endKey: long",
  "reverseIterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.SearchIterator",
  "searchIterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.SearchIterator",
  "shift": ":param shiftAmount: long\n:return: io.deephaven.db.v2.utils.Index",
  "shiftInPlace": ":param shiftAmount: long",
  "size": "How many keys are in this index.\n\n:return: (long) the number of keys in this index.",
  "sizePrev": ":return: long",
  "strid": "Override to improve index debug-tracing messages.\n\n:return: java.lang.String",
  "subindexByKey": "Get a subset of this index within this range of keys.\n\n:param startKey: long\n:param endKey: long\n:return: (io.deephaven.db.v2.utils.Index) A new index, containing only values >= startKey and <= endKey.",
  "subindexByPos": "Get a subset of this index within this range of positions\n\n:param startPos: long\n:param endPos: long\n:return: (io.deephaven.db.v2.utils.Index) A new index, containing only positions >= startPos and < endPos",
  "subsetOf": "Returns true if this index is a (possibly improper) subset of other.\n\n:param range: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: (boolean) true if every element of this exists within other",
  "toString": "*Overload 1*  \n  :return: java.lang.String\n  \n*Overload 2*  \n  :param maxNodes: int\n  :return: java.lang.String",
  "trace": ":param msg: java.lang.String",
  "union": "Returns a new index representing the keys present in both this index and the argument index.\n\n:param set: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: (io.deephaven.db.v2.utils.Index) a new index with the union of the keys in both this index and indexToAdd.",
  "update": "Simultaneously adds the keys from the first index and removes the keys from the second one.\n API assumption: the intersection of added and removed is empty.\n\n:param added: io.deephaven.db.v2.utils.ReadOnlyIndex\n:param removed: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "validate": ":param failMsg: java.lang.String",
  "writeExternal": ":param out: java.io.ObjectOutput",
  "writeImpl": ":param out: java.io.ObjectOutput"
 },
 "path": "io.deephaven.db.v2.utils.TreeIndex",
 "typeName": "class"
}