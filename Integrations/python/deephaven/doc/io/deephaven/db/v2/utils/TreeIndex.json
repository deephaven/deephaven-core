{
 "className": "io.deephaven.db.v2.utils.TreeIndex",
 "methods": {
  "add": ":param builder: io.deephaven.db.v2.utils.TreeIndexImpl.RandomBuilder\n:param idx: io.deephaven.db.v2.utils.TreeIndex",
  "append": ":param logOutput: io.deephaven.base.log.LogOutput\n:return: io.deephaven.base.log.LogOutput",
  "asIndex": "Get an Index representation of this OrderedKeys.\n\n:return: (io.deephaven.db.v2.utils.Index) An Index representation for the same keys in the same order",
  "clone": ":return: io.deephaven.db.v2.utils.Index",
  "close": "Free any resources associated with this object.\n Using any OrderedKeys methods after close() is an error and may produce exceptions or\n undefined results.",
  "compact": "May reclaim some unused memory.",
  "containsRange": "Queries whether this index contains every element in the range provided.\n\n:param start: (long) - Start of the range, inclusive.\n:param end: (long) - End of the range, inclusive.\n:return: (boolean) true if this index contains every element x in start <= x <= end.",
  "empty": "Queries whether this index is empty (i.e. has no keys).\n\n:return: (boolean) true if the size() of this Index is zero, false if the size is greater than zero",
  "fillKeyIndicesChunk": "Fill the supplied WritableLongChunk with individual keys from this OrderedKeys.\n The chunk's capacity is assumed to be big enough.\n\n:param chunkToFill: (io.deephaven.db.v2.sources.chunk.WritableLongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - A chunk to fill with individual keys",
  "fillKeyRangesChunk": "Fill the supplied WritableLongChunk with key ranges from this OrderedKeys.\n The chunk's capacity is assumed to be big enough.\n\n:param chunkToFill: (io.deephaven.db.v2.sources.chunk.WritableLongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyRanges>) - A chunk to fill with key ranges",
  "find": "Returns the position in [0..(size-1)] where the key is found. If not found,\n then return (-(position it would be) - 1), a la Array.binarySearch.\n\n:param key: (long) - the key to search for\n:return: (long) a position from [0..(size-1)] if the key was found.  If the key was not found, then (-position - 1) as\n in Array.binarySearch.",
  "findPrev": "Returns the position in [0..(size-1)] where the key is found in the previous index. If not found, then return\n (-(position it would be) - 1), as in Array.binarySearch.\n\n:param key: (long) - the key to search for\n:return: (long) a position from [0..(size-1)] if the key was found.  If the key was not found, then (-position - 1) as\n in Array.binarySearch.",
  "firstKey": "Get the first key in this Index.\n\n:return: (long) The first key, or ReadOnlyIndex.NULL_KEY if there is none.",
  "firstKeyPrev": ":return: long",
  "forEachLong": "Provide each value contained in this index, in increased sorted order to the consumer.\n If the consumer returns false for a key, stops after that key (does not provide any\n keys after that key).\n\n:param lc: (io.deephaven.db.v2.utils.LongAbortableConsumer) - the consumer.\n:return: (boolean) false if the consumer returned false at some point, true if the consumer always\n returned true and all values in the index were consumed.",
  "forEachLongRange": "For as long as the consumer wants more ranges, call accept on the consumer with the individual key ranges\n in this OrderedKeys, in increasing order.\n\n:param lrac: (io.deephaven.db.v2.utils.LongRangeAbortableConsumer) - a consumer to feed the individual key values to.\n:return: (boolean) false if the consumer provided ever returned false, true otherwise.",
  "get": "Returns the key at the given rank position.\n\n:param pos: (long) - a position in this index between 0 and size() - 1\n:return: (long) the key at that rank.",
  "getAverageRunLengthEstimate": "Get an estimate of the average (mean) length of runs of adjacent keys in this OrderedKeys.\n Implementations should strive to keep this method efficient (O(1) preferred) at the expense of\n accuracy.\n Empty OrderedKeys should return an arbitrary valid value, usually 1.\n\n:return: (long) An estimate of the average run length in this OrderedKeys, in [1, size()]",
  "getEmptyIndex": ":return: io.deephaven.db.v2.utils.SortedIndex",
  "getImpl": ":return: io.deephaven.db.v2.utils.TreeIndexImpl",
  "getKeysForPositions": "Returns the sequence of (increasing) keys corresponding to the positions\n provided as input.\n\n:param positions: (java.util.PrimitiveIterator.OfLong) - an iterator providing index positions in increasing order.\n:param outputKeys: (java.util.function.LongConsumer) - a consumer of corresponding keys for the positions provided as input.",
  "getOrderedKeysByKeyRange": "Get an ordered subset of the keys in this OrderedKeys for a key range. The returned set will be the\n intersection of the keys in this  with the keys in the closed interval\n [startKeyInclusive, endKeyInclusive].\n\n The returned reference is owned by the caller, who should call close() when it is done with it.\n\n:param startKeyInclusive: (long) - The minimum key to include\n:param endKeyInclusive: (long) - The maximum key to include\n:return: (io.deephaven.db.v2.utils.OrderedKeys) The subset as an OrderedKeys, which may be this",
  "getOrderedKeysByPosition": "Get an ordered subset of the keys in this OrderedKeys for a position range.\n The result will contain the set of keys in this that lie at positions in the half-open range\n [startPositionInclusive, startPositionInclusive + length).\n\n The returned reference is owned by the caller, who should call close() when it is done with it.\n\n:param start: (long) - The position of the first key to include\n:param len: (long) - The number of keys to include\n:return: (io.deephaven.db.v2.utils.OrderedKeys) The subset as an OrderedKeys, which may be this",
  "getOrderedKeysIterator": "Get an OrderedKeys.Iterator over this OrderedKeys.\n\n:return: (io.deephaven.db.v2.utils.OrderedKeys.Iterator) A new iterator, positioned at the first key",
  "getPrev": ":param pos: long\n:return: long",
  "getPrevIndex": ":return: io.deephaven.db.v2.utils.Index",
  "initializePreviousValue": "Initializes our previous value from the current value.\n\n This call is used by operations that manipulate an Index while constructing it, but need to set the state at the\n end of the initial operation to the current state.\n\n Calling this in other circumstances will yield undefined results.",
  "insert": "**Incompatible overloads text - text from the first overload:**\n\nAdd a single key to this index if it's not already present.\n\n*Overload 1*  \n  :param key: (long) - The key to add\n  \n*Overload 2*  \n  :param keys: (io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyIndices>) - The LongChunk of Attributes.OrderedKeyIndices to insert\n  :param offset: (int) - The offset in keys to begin inserting keys from\n  :param length: (int) - The number of keys to insert\n  \n*Overload 3*  \n  :param added: (io.deephaven.db.v2.utils.ReadOnlyIndex) - The index to add",
  "insertRange": "Add all keys in a closed range to this index if they are not already present.\n\n:param startKey: (long) - The first key to add\n:param endKey: (long) - The last key to add (inclusive)",
  "insertWithShift": "For each key in the provided index, shift it by shiftAmount and insert it in the current index.\n\n:param shiftAmount: (long) - the amount to add to each key in the index argument before insertion.\n:param other: (io.deephaven.db.v2.utils.ReadOnlyIndex) - the index with the keys to shift and insert.",
  "intersect": "Returns a new index representing the intersection of the current index with the input index\n\n:param range: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: io.deephaven.db.v2.utils.Index",
  "invert": "The only used implementation of invert is in the TreeIndex, really the guts of it are in BspNodeIndex.\n\n This version is inefficient as it simply performs O(keys) find operations; which is O(keys * lg size), because\n there is no memory about what you've already found.\n\n It serves as a reasonable reference for what the invert operation is \"meant\" to do.\n\n Note maximumPosition is inclusive.\n\n:param keys: (io.deephaven.db.v2.utils.ReadOnlyIndex) - the keys to find positions for\n:param maximumPosition: (long) - the largest position for which we will find a key\n:return: (io.deephaven.db.v2.utils.Index) a new Index containing the positions of the keys in this index",
  "iterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.Iterator",
  "lastKey": "Get the last key in this OrderedKeys.\n\n:return: (long) The last key, or ReadOnlyIndex.NULL_KEY if there is none.",
  "lastKeyPrev": ":return: long",
  "makeCurrentRandomBuilder": ":return: io.deephaven.db.v2.utils.Index.RandomBuilder",
  "makeCurrentSequentialBuilder": ":return: io.deephaven.db.v2.utils.Index.SequentialBuilder",
  "makeEmptyRsp": ":return: io.deephaven.db.v2.utils.TreeIndex",
  "makeEmptySr": ":return: io.deephaven.db.v2.utils.TreeIndex",
  "makeRandomBuilder": ":return: io.deephaven.db.v2.utils.Index.RandomBuilder",
  "makeSequentialBuilder": ":return: io.deephaven.db.v2.utils.Index.SequentialBuilder",
  "makeSingleRange": ":param start: long\n:param end: long\n:return: io.deephaven.db.v2.utils.TreeIndex",
  "minus": "Returns a new index representing the keys of the current set not present inside indexToRemove\n This operation is equivalent to set difference.  This index is not modified.\n\n:param set: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: io.deephaven.db.v2.utils.Index",
  "overlaps": "Returns true if an index has any overlap.\n\n:param range: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: boolean",
  "overlapsRange": "Returns true if this index has any overlap with the provided range.\n\n:param start: (long) - Start of range, inclusive.\n:param end: (long) - End of range, inclusive.\n:return: (boolean) true if any value x in start <= x <= end is contained in this index.",
  "rangeIterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.RangeIterator",
  "rangesCountUpperBound": ":return: long",
  "readExternal": ":param in: java.io.ObjectInput",
  "refCount": ":return: int",
  "remove": "**Incompatible overloads text - text from the first overload:**\n\nRemove a single key from this index if it's present.\n\n*Overload 1*  \n  :param key: (long) - The key to remove\n  \n*Overload 2*  \n  :param keys: (io.deephaven.db.v2.sources.chunk.LongChunk<io.deephaven.db.v2.sources.chunk.Attributes.OrderedKeyIndices>) - The LongChunk of Attributes.OrderedKeyIndices to remove\n  :param offset: (int) - The offset in keys to begin removing keys from\n  :param length: (int) - The number of keys to remove\n  \n*Overload 3*  \n  :param removed: (io.deephaven.db.v2.utils.ReadOnlyIndex) - The index to remove",
  "removeRange": "Remove all keys in a closed range from this index if they are present.\n\n:param startKey: (long) - The first key to remove\n:param endKey: (long) - The last key to remove (inclusive)",
  "retain": "Modifies the index by removing any keys not in the indexToIntersect argument.\n\n:param toIntersect: (io.deephaven.db.v2.utils.ReadOnlyIndex) - an index with the keys to retain; any other keys not in indexToIntersect will be removed.",
  "retainRange": "Modifies the index by keeping only keys in the interval [start, end]\n\n:param startKey: (long) - beginning of interval of keys to keep.\n:param endKey: (long) - end of interval of keys to keep (inclusive).",
  "reverseIterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.SearchIterator",
  "searchIterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.SearchIterator",
  "shift": ":param shiftAmount: long\n:return: io.deephaven.db.v2.utils.Index",
  "shiftInPlace": ":param shiftAmount: long",
  "size": "How many keys are in this index.\n\n:return: (long) the number of keys in this index.",
  "sizePrev": ":return: long",
  "subindexByKey": "Get a subset of this index within this range of keys.\n\n:param startKey: (long) - The first key to include in the output.\n:param endKey: (long) - The last key (inclusive) to include in the output.\n:return: (io.deephaven.db.v2.utils.Index) A new index, containing only values >= startKey and <= endKey.",
  "subindexByPos": "Get a subset of this index within this range of positions\n\n:param startPos: (long) - The first position to included in the output (inclusive)\n:param endPos: (long) - The last position to included in the output (exclusive)\n:return: (io.deephaven.db.v2.utils.Index) A new index, containing only positions >= startPos and < endPos",
  "subsetOf": "Returns true if this index is a (possibly improper) subset of other.\n\n:param range: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: (boolean) true if every element of this exists within other",
  "toString": "*Overload 1*  \n  :return: java.lang.String\n  \n*Overload 2*  \n  :param maxNodes: int\n  :return: java.lang.String",
  "trace": ":param msg: java.lang.String",
  "union": "Returns a new index representing the keys present in both this index and the argument index.\n\n:param set: (io.deephaven.db.v2.utils.ReadOnlyIndex) - an index whose keys will be joined with our own to produce a new index.\n:return: (io.deephaven.db.v2.utils.Index) a new index with the union of the keys in both this index and indexToAdd.",
  "update": "Simultaneously adds the keys from the first index and removes the keys from the second one.\n API assumption: the intersection of added and removed is empty.\n\n:param added: io.deephaven.db.v2.utils.ReadOnlyIndex\n:param removed: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "validate": ":param failMsg: java.lang.String",
  "writeExternal": ":param out: java.io.ObjectOutput",
  "writeImpl": ":param out: java.io.ObjectOutput"
 },
 "path": "io.deephaven.db.v2.utils.TreeIndex",
 "typeName": "class"
}