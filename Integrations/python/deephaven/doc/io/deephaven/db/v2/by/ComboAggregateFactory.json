{
 "className": "io.deephaven.db.v2.by.ComboAggregateFactory",
 "methods": {
  "Agg": "Create an aggregation.\n\n*Overload 1*  \n  :param factory: (io.deephaven.db.v2.by.AggregationStateFactory) - aggregation factory.\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)\n  \n*Overload 2*  \n  :param factory: (io.deephaven.db.v2.by.AggregationStateFactory) - aggregation factory.\n  :param matchPairs: (io.deephaven.db.tables.select.MatchPair...) - the columns to apply the aggregation to.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)\n  \n*Overload 3*  \n  :param factoryType: (io.deephaven.db.v2.by.AggType) - aggregation factory type.\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)\n  \n*Overload 4*  \n  :param factoryType: (io.deephaven.db.v2.by.AggType) - aggregation factory type.\n  :param matchPairs: (io.deephaven.db.tables.select.MatchPair...) - the columns to apply the aggregation to.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggAbsSum": "Create an absolute sum aggregation, equivalent to Table.absSumBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggArray": "Create an array aggregation, equivalent to Table.by(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggAvg": "Create an average aggregation, equivalent to Table.avgBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggCombo": "Create a new ComboAggregateFactory suitable for passing to Table.by(AggregationStateFactory, String...).\n\n:param aggregations: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy...) - the aggregations to compute\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory) a new table with the specified aggregations.",
  "AggCount": "Create an count aggregation, equivalent to Table.countBy(String).\n\n:param resultColumn: (java.lang.String) - the name of the result column containing the count of each group\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggCountDistinct": "Create a distinct count aggregation.\n\n The output column contains the number of distinct values for the input column in that group.\n\n*Overload 1*  \n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...). Null values are not counted.\n  \n*Overload 2*  \n  :param countNulls: (boolean) - if true null values are counted as a distinct value, otherwise null values are ignored\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggDistinct": "Create a distinct aggregation.\n\n The output column contains a DbArrayBase with the distinct values for the\n input column within the group.\n\n*Overload 1*  \n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...). Null values are ignored.\n  \n*Overload 2*  \n  :param countNulls: (boolean) - if true, then null values are included in the result, otherwise null values are ignored\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggFirst": "Create a first aggregation, equivalent to Table.firstBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggFormula": "Create a formula aggregation.\n\n:param formula: (java.lang.String) - the formula to apply to each group\n:param formulaParam: (java.lang.String) - the parameter name within the formula\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggLast": "Create a last aggregation, equivalent to Table.lastBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggMax": "Create a maximum aggregation, equivalent to Table.maxBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggMed": "Create a median aggregation, equivalent to Table.medianBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggMin": "Create a minimum aggregation, equivalent to Table.minBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggPct": "Create a percentile aggregation.\n\n*Overload 1*  \n  :param percentile: (double) - the percentile to calculate\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)\n  \n*Overload 2*  \n  :param percentile: (double) - the percentile to calculate\n  :param averageMedian: (boolean) - if true, then when the upper values and lower values have an equal size; average the highest\n          lower value and lowest upper value to produce the median value for integers, longs, doubles, and floats\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggSortedFirst": "Create a sorted first aggregation, equivalent to SortedBy.sortedFirstBy(io.deephaven.db.tables.Table, java.lang.String).\n\n*Overload 1*  \n  :param sortColumn: (java.lang.String) - the column to sort by\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)\n  \n*Overload 2*  \n  :param sortColumns: (java.lang.String[]) - the column to sort by\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggSortedLast": "Create a sorted last aggregation, equivalent to SortedBy.sortedLastBy(io.deephaven.db.tables.Table, java.lang.String).\n\n*Overload 1*  \n  :param sortColumn: (java.lang.String) - the column to sort by\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)\n  \n*Overload 2*  \n  :param sortColumns: (java.lang.String[]) - the columns to sort by\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggStd": "Create a standard deviation aggregation, equivalent to Table.stdBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggSum": "Create a summation aggregation, equivalent to Table.sumBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggUnique": "Create a Unique aggregation.\n\n The output column contains a value of the same type as the input column which contains\n\n* The \"no key value\" - if there are no values present\n* The single unique value - if there is only a single value present\n* The \"non unique value\" - if there are more than 1 distinct values present\n\n*Overload 1*  \n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)\n  \n*Overload 2*  \n  :param countNulls: (boolean) - if true, then null values are included in the result, otherwise null values are ignored\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...). Output columns contain null if\n           there are no values present or there are more than 1 distinct values present.\n  \n*Overload 3*  \n  :param countNulls: (boolean) - if true, then null values are included in the result, otherwise null values are ignored\n  :param noKeyValue: (java.lang.Object) - the value to use if there are no values present\n  :param nonUniqueValue: (java.lang.Object) - the value to use if there are more than 1 values present\n  :param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n          the same name, then the column name can be specified.\n  :return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggVar": "Create a variance aggregation, equivalent to Table.varBy(String...).\n\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggWAvg": "Create a weighted average aggregation, equivalent to Table.wavgBy(String, String...).\n\n:param weight: (java.lang.String) - the name of the column to use as the weight for the average\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "AggWSum": "Create a weighted sum aggregation, equivalent to Table.wsumBy(String, String...).\n\n:param weight: (java.lang.String) - the name of the column to use as the weight for the sum\n:param matchPairs: (java.lang.String...) - the columns to apply the aggregation to in the form Output=Input, if the Output and Input have\n        the same name, then the column name can be specified.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory.ComboBy) a ComboBy object suitable for passing to AggCombo(ComboBy...)",
  "forRollup": ":param includeConstituents: boolean\n:return: io.deephaven.db.v2.by.ComboAggregateFactory",
  "getMatchPairs": ":return: java.util.List<io.deephaven.db.tables.select.MatchPair>",
  "getMemoKey": "Produces a MemoKey for this aggregation state factory.\n\n \n If two AggregationStateFactories have equal memoKeys, then Table.by(io.deephaven.db.v2.by.AggregationStateFactory, io.deephaven.db.v2.select.SelectColumn...) operations that have the same group\n by columns may be memoized. In that case instead of recomputing the result; the original result will be used.\n \n\n If null is returned, the operation will not be memoized.\n \n\n:return: (io.deephaven.db.v2.by.AggregationMemoKey) an AggregationMemoKey, null if this operation can not be memoized.",
  "makeAggregationContextFactory": ":return: io.deephaven.db.v2.by.AggregationContextFactory",
  "rollupFactory": "Create a factory for performing rollups.\n\n:return: io.deephaven.db.v2.by.ComboAggregateFactory",
  "toString": ":return: java.lang.String",
  "withNulls": "Create a new factory that will have columns with all null values.\n\n Used by rollup to empty out unused grouping columns.\n\n:param nullColumns: (java.util.Map<java.lang.String,java.lang.Class<?>>) - a map of column names to types.\n:return: (io.deephaven.db.v2.by.ComboAggregateFactory) a new ComboAggregateFactory that will produce null values for the given columns."
 },
 "path": "io.deephaven.db.v2.by.ComboAggregateFactory",
 "text": "The ComboAggregateFactory combines one or more aggregations into an operator for use with\n Table.by(AggregationStateFactory).\n\n \n The intended use of this class is to call the AggCombo(ComboBy...) method with a set of aggregations defined\n by:\n \n* AggMin(java.lang.String...)\n* AggMax(java.lang.String...)\n* AggSum(java.lang.String...)\n* AggAbsSum(java.lang.String...)\n* AggVar(java.lang.String...)\n* AggAvg(java.lang.String...)\n* AggWAvg(java.lang.String, java.lang.String...)\n* AggWSum(java.lang.String, java.lang.String...)\n* AggMed(java.lang.String...)\n* AggPct(double, java.lang.String...)\n* AggStd(java.lang.String...)\n* AggFirst(java.lang.String...)\n* AggLast(java.lang.String...)\n* AggCount(java.lang.String)\n* AggCountDistinct(java.lang.String...)\n* AggDistinct(java.lang.String...)\n* AggArray(java.lang.String...)\n* AggSortedFirst(java.lang.String, java.lang.String...)\n* AggSortedLast(java.lang.String, java.lang.String...)\n\n\n For example, to produce a table with several aggregations on the LastPrice of a Trades table:\n ohlc=trades.by(AggCombo(AggFirst(\"Open=LastPrice\"), AggLast(\"Close=LastPrice\"), AggMax(\"High=LastPrice\"), AggMin(\"Low=LastPrice\"), AggSum(\"Volume=Size\"), AggWAvg(\"Size\", \"VWAP=LastPrice\"), \"Symbol\")",
 "typeName": "class"
}