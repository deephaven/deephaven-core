{
 "className": "io.deephaven.db.v2.locations.TableLocation",
 "methods": {
  "append": ":param logOutput: io.deephaven.base.log.LogOutput\n:return: io.deephaven.base.log.LogOutput",
  "getColumnLocation": ":param name: (java.lang.CharSequence) - The column name\n:return: (TableLocation.CLT) The ColumnLocation for the defined column under this table location",
  "getFormat": "Get the format that was used to persist this table location.\n\n:return: (io.deephaven.db.v2.locations.TableLocation.Format) The format for this table location",
  "getTableKey": ":return: (io.deephaven.db.v2.locations.TableKey) A TableKey instance for the enclosing table",
  "refresh": "Initialize or refresh state information.",
  "subscribe": "Subscribe to pushed location updates. Subscribing more than once with the same listener without an\n intervening unsubscribe is an error, and may result in undefined behavior.\n This is a possibly asynchronous operation - listener will receive 1 or more handleUpdate callbacks,\n followed by 0 or 1 handleException callbacks during invocation and continuing after completion, on a thread\n determined by the implementation.  Don't hold a lock that prevents notification delivery while subscribing!\n This method only guarantees eventually consistent state.  To force a state update, use refresh() after\n subscription completes.\n\n:param listener: (io.deephaven.db.v2.locations.TableLocation.Listener) - A listener",
  "supportsSubscriptions": "Does this location support subscriptions? That is, can this location ever have ticking data?\n\n:return: (boolean) True if this location supports subscriptions",
  "toGenericString": "Format the table key without implementation specific bits.\n\n:return: (java.lang.String) a formatted string",
  "toStringDetailed": "Optional toString path with more implementation detail.\n\n:return: (java.lang.String) detailed conversion to string",
  "toStringHelper": ":return: java.lang.String",
  "unsubscribe": "Unsubscribe from pushed location updates.\n\n:param listener: (io.deephaven.db.v2.locations.TableLocation.Listener) - The listener to forget about"
 },
 "path": "io.deephaven.db.v2.locations.TableLocation",
 "text": "=====================================================================================================================\n\n Building block for Deephaven file-based tables, with helper methods for discovering locations and their sizes.\n\n ================================================= INTERFACE =========================================================\n\n A location specifies the column and size data location for a splayed table.  The location may be either:\n (1) the sole location of a stand-alone splayed table, or\n (2) a single location of a nested partitioned table, in which case it belongs to an internal partition and a column\n         partition.\n\n ================================================== LAYOUTS ==========================================================\n\n There are exactly two layouts in use for file-based tables:\n\n ---------------------------------------------------------------------------------------------------------------------\n Splayed: (stand-alone)\n ---------------------------------------------------------------------------------------------------------------------\n Such tables have exactly one location.\n\n The layout looks like:\n L0  ROOT (e.g. /db/<namespace type>/<namespace name>/Tables)\n L1  <table name>\n L2  COLUMN FILES [<column name>.[dat, ovr, bytes, sym, sym.bytes]], SIZE FILE [table.size]\n\n ---------------------------------------------------------------------------------------------------------------------\n Nested Partitioned:\n ---------------------------------------------------------------------------------------------------------------------\n Such tables are horizontally partitioned at two levels:\n  - The first (\"internal\") partitioning divides data into manageable fragments or distinct streams.\n  - The second (\"column\") partitioning specifies a String column (named by the table's definition, by convention\n        nearly-always \"Date\").\n The locations in use by such a table are identical to those used by a splayed table, except that they are contained\n     within a column partition, which is in turn contained within an internal partition.\n\n The layout looks like:\n  L0  ROOT (e.g. /db/<namespace type>/<namespace name>/Partitions)\n  L1  \"Internal\" Partitions (e.g. \"0\", \"1\", ...)\n  L2  \"Column\" Partitions (e.g. \"2011-10-13\", \"2011-10-14\", ...)\n  L3  <table name>\n  L4  COLUMN FILES [<column name>.[dat, ovr, bytes, sym, sym.bytes]], METADATA FILE [table.size]\n\n ================================================== COMMENTS =========================================================\n\n Future work may allow more fields from TableLocationKey or TableLocationState to be accessed as columns.\n\n =====================================================================================================================",
 "typeName": "interface"
}