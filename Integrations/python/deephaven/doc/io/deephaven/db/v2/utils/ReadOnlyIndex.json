{
 "className": "io.deephaven.db.v2.utils.ReadOnlyIndex",
 "methods": {
  "clone": ":return: io.deephaven.db.v2.utils.Index",
  "close": "Free any resources associated with this object.\n \n Using any OrderedKeys methods after close() is an error and may produce exceptions or undefined\n results.",
  "containsRange": "Queries whether this index contains every element in the range provided.\n\n:param start: (long) - Start of the range, inclusive.\n:param end: (long) - End of the range, inclusive.\n:return: (boolean) true if this index contains every element x in start <= x <= end.",
  "copyImmutableGroupings": ":param source: io.deephaven.db.v2.tuples.TupleSource\n:param dest: io.deephaven.db.v2.tuples.TupleSource",
  "empty": "Queries whether this index is empty (i.e. has no keys).\n\n:return: (boolean) true if the size() of this Index is zero, false if the size is greater than zero",
  "find": "Returns the position in [0..(size-1)] where the key is found. If not found, then return (-(position it would be)\n - 1), a la Array.binarySearch.\n\n:param key: (long) - the key to search for\n:return: (long) a position from [0..(size-1)] if the key was found. If the key was not found, then (-position - 1) as in\n         Array.binarySearch.",
  "findMissing": "For the given keys Index, under the assertion that none of them are present in the current index, return the\n tentative insertion points in the current index with the count for each of them\n\n:param keys: (io.deephaven.db.v2.utils.ReadOnlyIndex) - the keys to identify insertion locations\n:return: (gnu.trove.list.array.TLongArrayList[]) two TLongArrayLists; [0] contains the positions, [1] contains the counts.",
  "findPrev": "Returns the position in [0..(size-1)] where the key is found in the previous index. If not found, then return\n (-(position it would be) - 1), as in Array.binarySearch.\n\n:param key: (long) - the key to search for\n:return: (long) a position from [0..(size-1)] if the key was found. If the key was not found, then (-position - 1) as in\n         Array.binarySearch.",
  "firstKey": "Get the first key in this Index.\n\n:return: (long) The first key, or NULL_KEY if there is none.",
  "firstKeyPrev": ":return: long",
  "forAllLongs": ":param lc: java.util.function.LongConsumer",
  "forEachLong": "Provide each value contained in this index, in increased sorted order to the consumer. If the consumer returns\n false for a key, stops after that key (does not provide any keys after that key).\n\n:param lc: (io.deephaven.db.v2.utils.LongAbortableConsumer) - the consumer.\n:return: (boolean) false if the consumer returned false at some point, true if the consumer always returned true and all\n         values in the index were consumed.",
  "get": "Returns the key at the given rank position.\n\n:param pos: (long) - a position in this index between 0 and size() - 1\n:return: (long) the key at that rank.",
  "getGrouping": ":param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n:return: java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>",
  "getGroupingForKeySet": "Return a grouping that contains keys that match the values in keySet.\n\n:param keys: (java.util.Set<java.lang.Object>) - a set of values that keyColumns should match. For a single keyColumns, the values within the set are\n        the values that we would like to find. For multiple keyColumns, the values are SmartKeys.\n:param tupleSource: (io.deephaven.db.v2.tuples.TupleSource) - the tuple factory for the keyColumns\n:return: (java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>) an Map from keys to Indices, for each of the keys in keySet and this Index.",
  "getKeysForPositions": "Returns the sequence of (increasing) keys corresponding to the positions provided as input.\n\n:param inputPositions: (java.util.PrimitiveIterator.OfLong) - an iterator providing index positions in increasing order.\n:param outputKeys: (java.util.function.LongConsumer) - a consumer of corresponding keys for the positions provided as input.",
  "getPrev": ":param pos: long\n:return: long",
  "getPrevGrouping": ":param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n:return: java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>",
  "getPrevIndex": ":return: io.deephaven.db.v2.utils.Index",
  "getSubIndexForKeySet": "Return a subIndex that contains indices that match the values in keySet.\n\n:param keySet: (java.util.Set<java.lang.Object>) - a set of values that keyColumns should match. For a single keyColumns, the values within the set\n        are the values that we would like to find. For multiple keyColumns, the values are SmartKeys.\n:param tupleSource: (io.deephaven.db.v2.tuples.TupleSource) - the tuple factory for the keyColumn\n:return: (io.deephaven.db.v2.utils.Index) an Index containing only keys that match keySet.",
  "hasGrouping": ":param keyColumns: io.deephaven.db.v2.sources.ColumnSource...\n:return: boolean",
  "intersect": "Returns a new index representing the intersection of the current index with the input index\n\n:param range: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: io.deephaven.db.v2.utils.Index",
  "invert": "**Incompatible overloads text - text from the first overload:**\n\nReturns an Index with the positions of keys in this Index.\n\n This can be thought of as an iterative find() over the values in keys, but all keys must exist\n within this index, because an Index result can not represent negative values.\n\n*Overload 1*  \n  :param keys: (io.deephaven.db.v2.utils.ReadOnlyIndex) - the keys to find positions for\n  :return: (io.deephaven.db.v2.utils.Index) a new Index containing the positions of the keys in this index\n  \n*Overload 2*  \n  :param keys: (io.deephaven.db.v2.utils.ReadOnlyIndex) - the keys to find positions for\n  :param maximumPosition: (long) - the largest position for which we will find a key\n  :return: (io.deephaven.db.v2.utils.Index) a new Index containing the positions of the keys in this index",
  "isEmpty": "Queries whether this index is empty (i.e. has no keys).\n\n:return: (boolean) true if the size() of this Index is zero, false if the size is greater than zero",
  "isFlat": "Returns whether or not this index is flat. Unlike a table, this is a mutable property; which may change from step\n to step.\n\n:return: (boolean) true if the index keys are continguous and start at zero.",
  "isSorted": ":return: boolean",
  "iterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.Iterator",
  "lastKey": "Get the last key in this Index.\n\n:return: (long) The last key, or NULL_KEY if there is none.",
  "lastKeyPrev": ":return: long",
  "minus": "Returns a new index representing the keys of the current set not present inside indexToRemove This operation is\n equivalent to set difference. This index is not modified.\n\n:param indexToRemove: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: io.deephaven.db.v2.utils.Index",
  "nonempty": "Queries whether this index is non-empty (i.e. has at least one key).\n\n:return: (boolean) true if the size() of this Index greater than zero, false if the size is zero",
  "overlaps": "Returns true if an index has any overlap.\n\n:param index: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: boolean",
  "overlapsRange": "Returns true if this index has any overlap with the provided range.\n\n:param start: (long) - Start of range, inclusive.\n:param end: (long) - End of range, inclusive.\n:return: (boolean) true if any value x in start <= x <= end is contained in this index.",
  "rangeIterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.RangeIterator",
  "refCount": ":return: int",
  "reverseIterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.SearchIterator",
  "searchIterator": ":return: io.deephaven.db.v2.utils.ReadOnlyIndex.SearchIterator",
  "shift": ":param shiftAmount: long\n:return: io.deephaven.db.v2.utils.Index",
  "size": "How many keys are in this index.\n\n:return: (long) the number of keys in this index.",
  "sizePrev": ":return: long",
  "subindexByKey": "Get a subset of this index within this range of keys.\n\n:param startKey: (long) - The first key to include in the output.\n:param endKey: (long) - The last key (inclusive) to include in the output.\n:return: (io.deephaven.db.v2.utils.Index) A new index, containing only values >= startKey and <= endKey.",
  "subindexByPos": "**Incompatible overloads text - text from the first overload:**\n\nGet a subset of this index within these range of positions.\n\n*Overload 1*  \n  :param startPos: (long) - The first position to included in the output (inclusive)\n  :param endPos: (long) - The last position to included in the output (exclusive)\n  :return: (io.deephaven.db.v2.utils.Index) A new index, containing only positions >= startPos and < endPos\n  \n*Overload 2*  \n  :param posIndex: (io.deephaven.db.v2.utils.Index) - The index of position-based ranges to extract.\n  :return: (io.deephaven.db.v2.utils.Index) A new index, containing values at the locations in the provided index.",
  "subsetOf": "Returns true if this index is a (possibly improper) subset of other.\n\n:param other: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: (boolean) true if every element of this exists within other",
  "toLongArray": "*Overload 1*  \n  :param vs: long[]\n  \n*Overload 2*  \n  :param vs: long[]\n  :param offset: int",
  "union": "Returns a new index representing the keys present in both this index and the argument index.\n\n:param indexToAdd: (io.deephaven.db.v2.utils.ReadOnlyIndex) - an index whose keys will be joined with our own to produce a new index.\n:return: (io.deephaven.db.v2.utils.Index) a new index with the union of the keys in both this index and indexToAdd.",
  "validate": "*Overload 1*  \n  :param failMsg: java.lang.String\n  \n*Overload 2*"
 },
 "path": "io.deephaven.db.v2.utils.ReadOnlyIndex",
 "text": "Read-only subset of the Index interface.",
 "typeName": "interface"
}