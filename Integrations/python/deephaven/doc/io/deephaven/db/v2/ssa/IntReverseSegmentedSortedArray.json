{
 "className": "io.deephaven.db.v2.ssa.IntReverseSegmentedSortedArray",
 "methods": {
  "applyShift": ":param stampChunk: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Any>\n:param keyChunk: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n:param shiftDelta: long",
  "applyShiftReverse": ":param stampChunk: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Any>\n:param keyChunk: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n:param shiftDelta: long",
  "forAllKeys": "Call the longConsumer for each of the long index keys in this SegmentedSortedArray.\n\n:param longConsumer: java.util.function.LongConsumer",
  "getFirst": ":return: (long) the first index in this SSA, Index.NULL_KEY when empty.",
  "getLast": ":return: (long) the last index in this SSA, Index.NULL_KEY when empty.",
  "getNodeSize": ":return: int",
  "insert": "Insert new valuesToInsert into this SSA.  The valuesToInsert to insert must be sorted.\n\n:param valuesToInsert: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Any>\n:param indicesToInsert: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>",
  "insertAndGetNextValue": "Note: Java generics information - <T extends io.deephaven.db.v2.sources.chunk.Attributes.Any>\n\n:param valuesToInsert: io.deephaven.db.v2.sources.chunk.Chunk<T>\n:param indicesToInsert: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n:param nextValue: io.deephaven.db.v2.sources.chunk.WritableChunk<T>\n:return: int",
  "isReversed": ":return: boolean",
  "makeChecker": ":return: io.deephaven.db.v2.ssa.SsaChecker",
  "remove": "Remove valuesToRemove from this SSA.  The valuesToRemove to remove must be sorted.\n\n:param valuesToRemove: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Any>\n:param indicesToRemove: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>",
  "removeAndGetPrior": "Remove the values and indices referenced in stampChunk and indicesToRemove.  Fill priorRedirections with the\n redirection value immediately preceding the removed value.\n\n:param stampChunk: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Any>\n:param indicesToRemove: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>\n:param priorRedirections: io.deephaven.db.v2.sources.chunk.WritableLongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>",
  "size": "The size of this data structure.\n\n:return: (long) The size",
  "validate": "Note: Java generics information - io.deephaven.util.annotations.@VisibleForTesting"
 },
 "path": "io.deephaven.db.v2.ssa.IntReverseSegmentedSortedArray",
 "text": "For keeping track of incremental states of sorted values, we would ideally like to hold them in an Array or a Chunk;\n with parallel index keys.  However, if we just put them in an array we can not insert or remove values without\n unnecessarily shifting everything.\n\n The segmented array allows us to either insert or remove elements and only shift values in a \"leaf\" block and\n possibly a \"directory\" block.  It can be thought of as similar to a single-level b+ tree with only keys.\n\n We must be totally ordered, which is accomplished by sorting on the int values, and then on the corresponding\n index key.",
 "typeName": "class"
}