{
 "className": "io.deephaven.db.v2.sources.regioned.RegionedColumnSource",
 "methods": {
  "addRegion": "Add a region to this regioned column source.\n\n \n Elements in this region are ordered after elements in other regions added previously.\n\n:param columnDefinition: (io.deephaven.db.tables.ColumnDefinition<?>) - The column definition for this column source (potentially varies by region)\n:param columnLocation: (io.deephaven.db.v2.locations.ColumnLocation) - The column location for the region being added\n:return: (int) The index assigned to the added region",
  "getElementIndex": "Get the element index implied by a region index and a region offset.\n\n:param regionIndex: int\n:param regionOffset: long\n:return: (long) The element index for a particular region offset of a region index",
  "getFirstElementIndex": "Get the first element index for a region index.\n\n:param regionIndex: int\n:return: (long) The first element index for a region index",
  "getLastElementIndex": "Get the last element index for a region index.\n\n:param regionIndex: int\n:return: (long) The last element index for a region index"
 },
 "path": "io.deephaven.db.v2.sources.regioned.RegionedColumnSource",
 "text": "Regioned column source interface.\n\n \nsource tables can be thought of a tree of partitions with\n table locations at the leaf nodes. When building the\n Index for such a table, we statically\n partition the available element address space from [0, 9223372036854775807L (2^63-1)].\n\n \n We constrain the size at these leaf nodes in order to support a partitioning of the element address space into region\n index and sub-region element index. In order to make the calculations as inexpensive as possible, this is done by\n assigning some bits of each index key (element address) to the region index, and\n the remaining bits to the sub-region element index.\n\n \n This type of address space allocation allows very cheap O(1) element access. Denser alternatives tend to introduce\n more complication and/or O(log n) lookups.\n\n \n Currently, region indices use 20 and region offsets use\n 43, allowing tables to consist of 1048576 locations\n with 8796093022208L each.",
 "typeName": "interface"
}