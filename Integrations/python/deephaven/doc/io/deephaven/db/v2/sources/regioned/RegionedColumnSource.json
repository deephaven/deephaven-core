{
 "className": "io.deephaven.db.v2.sources.regioned.RegionedColumnSource",
 "methods": {
  "addRegion": "Add a region to this regioned column source.\n Elements in this region are ordered after elements in other regions added previously.\n\n:param columnDefinition: (io.deephaven.db.tables.ColumnDefinition<?>) - The column definition for this column source (potentially varies by region)\n:param columnLocation: (io.deephaven.db.v2.locations.ColumnLocation) - The column location for the region being added\n:return: (int) The index assigned to the added region"
 },
 "path": "io.deephaven.db.v2.sources.regioned.RegionedColumnSource",
 "text": "Regioned column source interface.\n\n \"V2\" SourceTables can be thought of a tree of partitions with\n TableLocations at the leaf nodes. When building the\n Index for such a Table, we statically\n partition the available element address space from [0, 9223372036854775807L (2^63-1)].\n\n We constrain the size at these leaf nodes in order to support a partitioning of the element address space into\n region index and sub-region element index. In order to make the calculations as inexpensive as possible, this is\n done by assigning X bits of each index key (element address) to the region index, and the remaining Y = 63 - X to the\n sub-region element index.\n\n This type of address space allocation allows very cheap O(1) element access. Denser alternatives tend to\n introduce more complication and/or O(log n) lookups.\n\n Currently, X is 23 and Y is 40, allowing tables to consist of more than 8 million locations with more than\n 1 trillion elements each.",
 "typeName": "interface"
}