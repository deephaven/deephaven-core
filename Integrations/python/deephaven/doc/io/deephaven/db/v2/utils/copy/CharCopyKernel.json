{
 "className": "io.deephaven.db.v2.utils.copy.CharCopyKernel",
 "methods": {
  "conditionalCopy": "Copy values from baseInput / overInput into output.\n \n Pseudo-implementation: output[i] = useOverInput.forBit(i) ? overInput[i] : baseInput[i];\n \n Note that useOverInput should cover the same data range as baseInput such that\n useOverInput.length == (overInput.length + 63) / 64 is true.\n\n*Overload 1*  \n  Note: Java generics information - <T extends io.deephaven.db.v2.sources.chunk.Attributes.Any>\n  \n  :param output: (io.deephaven.db.v2.sources.chunk.WritableCharChunk<T>) - the output chunk\n  :param baseInput: (char[]) - the input array to use when bit in useOverInput is zero (array)\n  :param overInput: (char[]) - the input array to use when bit in useOverInput is one (array)\n  :param useOverInput: (long[]) - the bitset array to indicate whether to use baseInput or overInput for each element\n  :param srcOffset: (int) - the offset in baseInput/overInput\n  :param dstOffset: (int) - the offset in output\n  :param length: (int) - the number of elements to copy\n  \n*Overload 2*  \n  Note: Java generics information - <T extends io.deephaven.db.v2.sources.chunk.Attributes.Any>\n  \n  :param output: io.deephaven.db.v2.sources.chunk.WritableChunk<T>\n  :param baseInput: java.lang.Object\n  :param overInput: java.lang.Object\n  :param useOverInput: long[]\n  :param srcOffset: int\n  :param dstOffset: int\n  :param length: int"
 },
 "path": "io.deephaven.db.v2.utils.copy.CharCopyKernel",
 "typeName": "class"
}