{
 "className": "io.deephaven.db.v2.locations.parquet.ColumnChunkPageStore",
 "methods": {
  "creator": "Note: Java generics information - <ATTR extends io.deephaven.db.v2.sources.chunk.Attributes.Any>\n\n:param columnChunkReader: io.deephaven.parquet.ColumnChunkReader\n:param toPageCreator: io.deephaven.db.v2.locations.parquet.ColumnChunkPageStore.ToPageCreator<ATTR>\n:param metaDataCreator: io.deephaven.db.v2.locations.parquet.ColumnChunkPageStore.MetaDataCreator\n:return: io.deephaven.db.v2.locations.parquet.ColumnChunkPageStore.Creator<ATTR>",
  "firstRowOffset": ":return: (long) the first row of this page, after applying the PagingChunkSource.mask(), which refers to the first row of this\n page.",
  "getChunkType": "Get the most suitable ChunkType for use with this ColumnSource.\n\n:return: (io.deephaven.db.v2.sources.chunk.ChunkType) The ChunkType",
  "getNativeType": ":return: java.lang.Class<?>",
  "getPageContaining": "These implementations don't use the FillContext parameter, so we're create a helper method to ignore it.\n\n:param row: long\n:return: io.deephaven.db.v2.sources.chunk.page.ChunkPage<ColumnChunkPageStore.ATTR>",
  "length": ":return: (long) the length of this page.",
  "mask": "This mask is applied to OrderedKeys which are passed into\n ChunkSource.getChunk(ChunkSource.GetContext, OrderedKeys) and\n ChunkSource.fillChunk(ChunkSource.FillContext, WritableChunk, OrderedKeys). This allows the\n PagingChunkSources to be cached, and reused even if they are properly relocated in key space.\n\n:return: (long) the mask for this page, which must be a bitmask representing the some number of lower order bits of a\n long."
 },
 "path": "io.deephaven.db.v2.locations.parquet.ColumnChunkPageStore",
 "typeName": "class"
}