{
 "className": "io.deephaven.db.v2.utils.SortedIndex",
 "methods": {
  "clone": ":return: io.deephaven.db.v2.utils.Index",
  "copyImmutableGroupings": ":param source: io.deephaven.db.v2.tuples.TupleSource\n:param dest: io.deephaven.db.v2.tuples.TupleSource",
  "equals": ":param obj: java.lang.Object\n:return: boolean",
  "findMissing": "For the given keys Index, under the assertion that none of them are present in the current index, return the tentative\n insertion points in the current index with the count for each of them\n\n:param keys: io.deephaven.db.v2.utils.ReadOnlyIndex\n:return: (gnu.trove.list.array.TLongArrayList[]) two TLongArrayLists; [0] contains the positions, [1] contains the counts.",
  "getGrouping": "*Overload 1*  \n  :param thisIndex: io.deephaven.db.v2.utils.Index\n  :param indexOp: java.util.function.UnaryOperator<io.deephaven.db.v2.utils.Index>\n  :param mappings: java.util.WeakHashMap<java.util.List<io.deephaven.db.v2.sources.ColumnSource>,io.deephaven.db.v2.utils.SortedIndex.MappingInfo>\n  :param ephemeralMappings: java.util.WeakHashMap<java.util.List<io.deephaven.db.v2.sources.ColumnSource>,io.deephaven.db.v2.utils.SortedIndex.MappingInfo>\n  :param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n  :return: java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>\n  \n*Overload 2*  \n  :param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n  :return: java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>",
  "getGroupingForKeySet": "Return a grouping that contains keys that match the values in keySet.\n\n:param keys: java.util.Set<java.lang.Object>\n:param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n:return: (java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>) an Map from keys to Indices, for each of the keys in keySet and this Index.",
  "getPrevGrouping": ":param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n:return: java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>",
  "getSubIndexForKeySet": "Return a subIndex that contains indices that match the values in keySet.\n\n:param keys: java.util.Set<java.lang.Object>\n:param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n:return: (io.deephaven.db.v2.utils.Index) an Index containing only keys that match keySet.",
  "hasGrouping": ":param keyColumns: io.deephaven.db.v2.sources.ColumnSource...\n:return: boolean",
  "insert": "Add all of the keys in added to this index if they are not already present.\n\n:param added: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "invert": "**Incompatible overloads text - text from the first overload:**\n\nReturns an Index with the positions of keys in this Index.\n\n This can be thought of as an iterative find() over the values in keys, but all keys must exist\n within this index, because an Index result can not represent negative values.\n\n*Overload 1*  \n  :param keys: io.deephaven.db.v2.utils.ReadOnlyIndex\n  :return: (io.deephaven.db.v2.utils.Index) a new Index containing the positions of the keys in this index\n  \n*Overload 2*  \n  :param keys: io.deephaven.db.v2.utils.ReadOnlyIndex\n  :param maximumPosition: long\n  :return: (io.deephaven.db.v2.utils.Index) a new Index containing the positions of the keys in this index",
  "isFlat": "Returns whether or not this index is flat.  Unlike a table, this is a mutable property; which may change from step to step.\n\n:return: (boolean) Whether this index is flat (that is, contiguous from 0 to size - 1)",
  "isSorted": ":return: boolean",
  "remove": "Remove all of the keys in removed that are present in this index.\n\n:param removed: io.deephaven.db.v2.utils.ReadOnlyIndex",
  "toString": ":return: java.lang.String"
 },
 "path": "io.deephaven.db.v2.utils.SortedIndex",
 "typeName": "class"
}