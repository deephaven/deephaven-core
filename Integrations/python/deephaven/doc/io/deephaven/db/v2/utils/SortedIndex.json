{
 "className": "io.deephaven.db.v2.utils.SortedIndex",
 "methods": {
  "clone": ":return: io.deephaven.db.v2.utils.Index",
  "copyImmutableGroupings": ":param source: io.deephaven.db.v2.tuples.TupleSource\n:param dest: io.deephaven.db.v2.tuples.TupleSource",
  "equals": ":param obj: java.lang.Object\n:return: boolean",
  "findMissing": "For the given keys Index, under the assertion that none of them are present in the current index, return the\n tentative insertion points in the current index with the count for each of them\n\n:param keys: (io.deephaven.db.v2.utils.ReadOnlyIndex) - the keys to identify insertion locations\n:return: (gnu.trove.list.array.TLongArrayList[]) two TLongArrayLists; [0] contains the positions, [1] contains the counts.",
  "getGrouping": "*Overload 1*  \n  :param thisIndex: io.deephaven.db.v2.utils.Index\n  :param indexOp: java.util.function.UnaryOperator<io.deephaven.db.v2.utils.Index>\n  :param mappings: java.util.WeakHashMap<java.util.List<io.deephaven.db.v2.sources.ColumnSource>,io.deephaven.db.v2.utils.SortedIndex.MappingInfo>\n  :param ephemeralMappings: java.util.WeakHashMap<java.util.List<io.deephaven.db.v2.sources.ColumnSource>,io.deephaven.db.v2.utils.SortedIndex.MappingInfo>\n  :param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n  :return: java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>\n  \n*Overload 2*  \n  :param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n  :return: java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>",
  "getGroupingForKeySet": "Return a grouping that contains keys that match the values in keySet.\n\n:param keys: (java.util.Set<java.lang.Object>) - a set of values that keyColumns should match. For a single keyColumns, the values within the set are\n        the values that we would like to find. For multiple keyColumns, the values are SmartKeys.\n:param tupleSource: (io.deephaven.db.v2.tuples.TupleSource) - the tuple factory for the keyColumns\n:return: (java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>) an Map from keys to Indices, for each of the keys in keySet and this Index.",
  "getPrevGrouping": ":param tupleSource: io.deephaven.db.v2.tuples.TupleSource\n:return: java.util.Map<java.lang.Object,io.deephaven.db.v2.utils.Index>",
  "getSubIndexForKeySet": "Return a subIndex that contains indices that match the values in keySet.\n\n:param keys: (java.util.Set<java.lang.Object>) - a set of values that keyColumns should match. For a single keyColumns, the values within the set\n        are the values that we would like to find. For multiple keyColumns, the values are SmartKeys.\n:param tupleSource: (io.deephaven.db.v2.tuples.TupleSource) - the tuple factory for the keyColumn\n:return: (io.deephaven.db.v2.utils.Index) an Index containing only keys that match keySet.",
  "hasGrouping": ":param keyColumns: io.deephaven.db.v2.sources.ColumnSource...\n:return: boolean",
  "insert": "Add all of the keys in added to this index if they are not already present.\n\n:param added: (io.deephaven.db.v2.utils.ReadOnlyIndex) - The index to add",
  "invert": "**Incompatible overloads text - text from the first overload:**\n\nReturns an Index with the positions of keys in this Index.\n\n This can be thought of as an iterative find() over the values in keys, but all keys must exist\n within this index, because an Index result can not represent negative values.\n\n*Overload 1*  \n  :param keys: (io.deephaven.db.v2.utils.ReadOnlyIndex) - the keys to find positions for\n  :return: (io.deephaven.db.v2.utils.Index) a new Index containing the positions of the keys in this index\n  \n*Overload 2*  \n  :param keys: (io.deephaven.db.v2.utils.ReadOnlyIndex) - the keys to find positions for\n  :param maximumPosition: (long) - the largest position for which we will find a key\n  :return: (io.deephaven.db.v2.utils.Index) a new Index containing the positions of the keys in this index",
  "isFlat": "Returns whether or not this index is flat. Unlike a table, this is a mutable property; which may change from step\n to step.\n\n:return: (boolean) Whether this index is flat (that is, contiguous from 0 to size - 1)",
  "isSorted": ":return: boolean",
  "remove": "Remove all of the keys in removed that are present in this index.\n\n:param removed: (io.deephaven.db.v2.utils.ReadOnlyIndex) - The index to remove",
  "toString": ":return: java.lang.String"
 },
 "path": "io.deephaven.db.v2.utils.SortedIndex",
 "typeName": "class"
}