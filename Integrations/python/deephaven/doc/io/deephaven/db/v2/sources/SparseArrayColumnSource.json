{
 "className": "io.deephaven.db.v2.sources.SparseArrayColumnSource",
 "methods": {
  "fillChunk": "Populates the given destination chunk with data corresponding to the keys from the given OrderedKeys.\n\n:param context: (io.deephaven.db.v2.sources.chunk.ChunkSource.FillContext) - A context containing all mutable/state related data used in retrieving the Chunk.\n:param dest: (io.deephaven.db.v2.sources.chunk.WritableChunk<? superio.deephaven.db.v2.sources.chunk.Attributes.Values>) - The chunk to be populated according to orderedKeys. No assumptions shall be made about\n        the size of the chunk shall be made. The chunk will be populated from position [0,orderedKeys.size()).\n:param orderedKeys: (io.deephaven.db.v2.utils.OrderedKeys) - An OrderedKeys representing the keys to be fetched",
  "fillChunkUnordered": "Populates a contiguous portion of the given destination chunk with data corresponding to the keys from the given\n LongChunk.\n\n:param context: (io.deephaven.db.v2.sources.chunk.ChunkSource.FillContext) - A context containing all mutable/state related data used in retrieving the Chunk.\n:param dest: (io.deephaven.db.v2.sources.chunk.WritableChunk<? superio.deephaven.db.v2.sources.chunk.Attributes.Values>) - The chunk to be populated according to keys\n:param keys: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - A chunk of individual, not assumed to be ordered keys to be fetched",
  "fillFromChunk": "Our default, inefficient, implementation. Inheritors who care should provide a better implementation.\n\n:param context: (io.deephaven.db.v2.sources.WritableChunkSink.FillFromContext) - A context containing all mutable/state related data used in writing the Chunk.\n:param src: (io.deephaven.db.v2.sources.chunk.Chunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.Values>) - The source of the data orderedKeys\n:param orderedKeys: (io.deephaven.db.v2.utils.OrderedKeys) - An OrderedKeys representing the keys to be written",
  "fillPrevChunkUnordered": "Populates a contiguous portion of the given destination chunk with prev data corresponding to the keys from the\n given LongChunk.\n\n:param context: (io.deephaven.db.v2.sources.chunk.ChunkSource.FillContext) - A context containing all mutable/state related data used in retrieving the Chunk.\n:param dest: (io.deephaven.db.v2.sources.chunk.WritableChunk<? superio.deephaven.db.v2.sources.chunk.Attributes.Values>) - The chunk to be populated according to keys\n:param keys: (io.deephaven.db.v2.sources.chunk.LongChunk<? extendsio.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>) - A chunk of individual, not assumed to be ordered keys to be fetched",
  "getDateTimeMemoryColumnSource": ":param data: long[]\n:return: io.deephaven.db.v2.sources.SparseArrayColumnSource<io.deephaven.db.tables.utils.DBDateTime>",
  "getPreferredChunkSize": "Using a preferred chunk size of BLOCK_SIZE gives us the opportunity to directly return chunks from our data\n structure rather than copying data.\n\n:return: int",
  "getSparseMemoryColumnSource": "*Overload 1*  \n  Note: Java generics information - <T>\n  \n  :param data: java.util.Collection<T>\n  :param type: java.lang.Class<T>\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<T>\n  \n*Overload 2*  \n  :param data: byte[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Byte>\n  \n*Overload 3*  \n  :param data: char[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Character>\n  \n*Overload 4*  \n  :param data: double[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Double>\n  \n*Overload 5*  \n  :param data: float[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Float>\n  \n*Overload 6*  \n  :param data: int[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Integer>\n  \n*Overload 7*  \n  :param data: long[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Long>\n  \n*Overload 8*  \n  :param data: short[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Short>\n  \n*Overload 9*  \n  Note: Java generics information - <T>\n  \n  :param type: java.lang.Class<T>\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<T>\n  \n*Overload 10*  \n  Note: Java generics information - <T>\n  \n  :param type: java.lang.Class<T>\n  :param componentType: java.lang.Class<?>\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<T>\n  \n*Overload 11*  \n  Note: Java generics information - <T>\n  \n  :param size: long\n  :param type: java.lang.Class<T>\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<T>\n  \n*Overload 12*  \n  Note: Java generics information - <T>\n  \n  :param size: long\n  :param type: java.lang.Class<T>\n  :param componentType: java.lang.Class<?>\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<T>\n  \n*Overload 13*  \n  :param dataArray: java.lang.Object\n  :return: io.deephaven.db.v2.sources.ColumnSource<?>",
  "isImmutable": "Determine if this column source is immutable, meaning that the values at a given index key never change.\n\n:return: (boolean) true if the values at a given index of the column source never change, false otherwise",
  "makeFillFromContext": "Provide a default, empty WritableChunkSink.FillFromContext for use with our default WritableSource.fillFromChunk(io.deephaven.db.v2.sources.WritableChunkSink.FillFromContext, io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>, io.deephaven.db.v2.utils.OrderedKeys).\n\n:param chunkCapacity: int\n:return: io.deephaven.db.v2.sources.WritableChunkSink.FillFromContext",
  "remove": ":param toRemove: io.deephaven.db.v2.utils.Index",
  "set": "*Overload 1*  \n  :param key: long\n  :param value: byte\n  \n*Overload 2*  \n  :param key: long\n  :param value: char\n  \n*Overload 3*  \n  :param key: long\n  :param value: double\n  \n*Overload 4*  \n  :param key: long\n  :param value: float\n  \n*Overload 5*  \n  :param key: long\n  :param value: int\n  \n*Overload 6*  \n  :param key: long\n  :param value: long\n  \n*Overload 7*  \n  :param key: long\n  :param value: short",
  "shift": ":param keysToShift: io.deephaven.db.v2.utils.Index\n:param shiftDelta: long"
 },
 "path": "io.deephaven.db.v2.sources.SparseArrayColumnSource",
 "text": "A column source backed by arrays that may not be filled in all blocks.\n\n \n To store the blocks, we use a multi-level page table like structure. Each entry that exists is complete, i.e. we\n never reallocate partial blocks, we always allocate the complete block. The index key is divided as follows:\n \n\n\nDescription\n Size\nBits\n\n\nBlock 0\n19\n62-44\n\n\nBlock 1\n18\n43-26\n\n\nBlock 2\n18\n25-8\n\n\nIndex Within Block\n8\n7-0\n\n\n\n Bit 63, the sign bit, is used to indicate null (that is, all negative numbers are defined to be null)\n \n\n Parallel structures are used for previous values and prevInUse. We recycle all levels of the previous blocks, so that\n the previous structure takes up memory only while it is in use.",
 "typeName": "class"
}