{
 "className": "io.deephaven.db.v2.sources.SparseArrayColumnSource",
 "methods": {
  "fillChunk": "Populates the given destination chunk with data corresponding to the keys from the given OrderedKeys.\n\n:param context: io.deephaven.db.v2.sources.chunk.ChunkSource.FillContext\n:param dest: io.deephaven.db.v2.sources.chunk.WritableChunk<? super io.deephaven.db.v2.sources.chunk.Attributes.Values>\n:param orderedKeys: io.deephaven.db.v2.utils.OrderedKeys",
  "fillChunkUnordered": "Populates a contiguous portion of the given destination chunk with data corresponding to the keys from the given LongChunk.\n\n:param context: io.deephaven.db.v2.sources.chunk.ChunkSource.FillContext\n:param dest: io.deephaven.db.v2.sources.chunk.WritableChunk<? super io.deephaven.db.v2.sources.chunk.Attributes.Values>\n:param keys: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>",
  "fillFromChunk": "Our default, inefficient, implementation. Inheritors who care should provide a better implementation.\n\n:param context: io.deephaven.db.v2.sources.WritableChunkSink.FillFromContext\n:param src: io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>\n:param orderedKeys: io.deephaven.db.v2.utils.OrderedKeys",
  "fillPrevChunkUnordered": "Populates a contiguous portion of the given destination chunk with prev data corresponding to the keys from the given LongChunk.\n\n:param context: io.deephaven.db.v2.sources.chunk.ChunkSource.FillContext\n:param dest: io.deephaven.db.v2.sources.chunk.WritableChunk<? super io.deephaven.db.v2.sources.chunk.Attributes.Values>\n:param keys: io.deephaven.db.v2.sources.chunk.LongChunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.KeyIndices>",
  "getDateTimeMemoryColumnSource": ":param data: long[]\n:return: io.deephaven.db.v2.sources.SparseArrayColumnSource<io.deephaven.db.tables.utils.DBDateTime>",
  "getPreferredChunkSize": "Using a preferred chunk size of BLOCK_SIZE gives us the opportunity to directly return chunks from our data\n structure rather than copying data.\n\n:return: int",
  "getSparseMemoryColumnSource": "*Overload 1*  \n  Note: Java generics information - <T>\n  \n  :param data: java.util.Collection<T>\n  :param type: java.lang.Class<T>\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<T>\n  \n*Overload 2*  \n  :param data: byte[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Byte>\n  \n*Overload 3*  \n  :param data: char[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Character>\n  \n*Overload 4*  \n  :param data: double[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Double>\n  \n*Overload 5*  \n  :param data: float[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Float>\n  \n*Overload 6*  \n  :param data: int[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Integer>\n  \n*Overload 7*  \n  :param data: long[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Long>\n  \n*Overload 8*  \n  :param data: short[]\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<java.lang.Short>\n  \n*Overload 9*  \n  Note: Java generics information - <T>\n  \n  :param type: java.lang.Class<T>\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<T>\n  \n*Overload 10*  \n  Note: Java generics information - <T>\n  \n  :param type: java.lang.Class<T>\n  :param componentType: java.lang.Class\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<T>\n  \n*Overload 11*  \n  Note: Java generics information - <T>\n  \n  :param size: long\n  :param type: java.lang.Class<T>\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<T>\n  \n*Overload 12*  \n  Note: Java generics information - <T>\n  \n  :param size: long\n  :param type: java.lang.Class<T>\n  :param componentType: java.lang.Class\n  :return: io.deephaven.db.v2.sources.SparseArrayColumnSource<T>\n  \n*Overload 13*  \n  :param dataArray: java.lang.Object\n  :return: io.deephaven.db.v2.sources.ColumnSource",
  "isImmutable": "Determine if this column source is immutable, meaning that the values at a given index key never change.\n\n:return: (boolean) true if the values at a given index of the column source never change, false otherwise",
  "makeFillFromContext": "Provide a default, empty WritableChunkSink.FillFromContext for use with our default WritableSource.fillFromChunk(io.deephaven.db.v2.sources.WritableChunkSink.FillFromContext, io.deephaven.db.v2.sources.chunk.Chunk<? extends io.deephaven.db.v2.sources.chunk.Attributes.Values>, io.deephaven.db.v2.utils.OrderedKeys).\n\n:param chunkCapacity: int\n:return: io.deephaven.db.v2.sources.WritableChunkSink.FillFromContext",
  "remove": ":param toRemove: io.deephaven.db.v2.utils.Index",
  "set": "*Overload 1*  \n  :param key: long\n  :param value: byte\n  \n*Overload 2*  \n  :param key: long\n  :param value: char\n  \n*Overload 3*  \n  :param key: long\n  :param value: double\n  \n*Overload 4*  \n  :param key: long\n  :param value: float\n  \n*Overload 5*  \n  :param key: long\n  :param value: int\n  \n*Overload 6*  \n  :param key: long\n  :param value: long\n  \n*Overload 7*  \n  :param key: long\n  :param value: short",
  "shift": ":param keysToShift: io.deephaven.db.v2.utils.Index\n:param shiftDelta: long"
 },
 "path": "io.deephaven.db.v2.sources.SparseArrayColumnSource",
 "text": "A column source backed by arrays that may not be filled in all blocks.\n\n To store the blocks, we use a multi-level page table like structure.  Each entry that exists is complete, i.e. we\n never reallocate partial blocks, we always allocate the complete block.  The index key is divided as follows:\n\nDescriptionSizeBits\nBlock 01962-44\nBlock 11843-26\nBlock 21825-8\nIndex Within Block87-0\n\nBit 63, the sign bit, is used to indicate null (that is, all negative numbers are defined to be null)\nParallel structures are used for previous values and prevInUse.  We recycle all levels of the previous blocks,\n so that the previous structure takes up memory only while it is in use.",
 "typeName": "class"
}