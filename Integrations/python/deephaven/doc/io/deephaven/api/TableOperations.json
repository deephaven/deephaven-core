{
 "className": "io.deephaven.api.TableOperations",
 "methods": {
  "aggAllBy": "*Overload 1*  \n  :param spec: io.deephaven.api.agg.spec.AggSpec\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param spec: io.deephaven.api.agg.spec.AggSpec\n  :param groupByColumns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 3*  \n  :param spec: io.deephaven.api.agg.spec.AggSpec\n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: TableOperations.TOPS\n  \n*Overload 4*  \n  :param spec: io.deephaven.api.agg.spec.AggSpec\n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: TableOperations.TOPS",
  "aggBy": "*Overload 1*  \n  :param aggregation: io.deephaven.api.agg.Aggregation\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param aggregation: io.deephaven.api.agg.Aggregation\n  :param groupByColumns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 3*  \n  :param aggregation: io.deephaven.api.agg.Aggregation\n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS\n  \n*Overload 4*  \n  :param aggregations: java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>\n  :return: TableOperations.TOPS\n  \n*Overload 5*  \n  :param aggregations: java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>\n  :param groupByColumns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 6*  \n  :param aggregations: java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>\n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS",
  "aj": "**Incompatible overloads text - text from the first overload:**\n\nPerform an as-of join with the rightTable.\n\n \n Delegates to aj(Object, Collection, Collection, AsOfJoinRule).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the left side that need to be added to the right\n          side as a result of the match.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 4*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :param asOfJoinRule: (io.deephaven.api.AsOfJoinRule) - The binary search operator for the last match pair.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "countBy": "*Overload 1*  \n  :param countColumnName: java.lang.String\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param countColumnName: java.lang.String\n  :param groupByColumns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 3*  \n  :param countColumnName: java.lang.String\n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: TableOperations.TOPS\n  \n*Overload 4*  \n  :param countColumnName: java.lang.String\n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: TableOperations.TOPS",
  "exactJoin": "**Incompatible overloads text - text from the first overload:**\n\nPerform an exact-join with the rightTable.\n\n \n Delegates to exactJoin(Object, Collection, Collection).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (TableOperations.TOPS) the exact-joined table\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to be added to the left\n          side as a result of the match.\n  :return: (TableOperations.TOPS) the exact-joined table\n  \n*Overload 3*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (TableOperations.TOPS) the exact-joined table",
  "groupBy": "*Overload 1*  \n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 3*  \n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS",
  "head": ":param size: long\n:return: TableOperations.TOPS",
  "join": "**Incompatible overloads text - text from the first overload:**\n\nPerform a cross join with the rightTable.\n\n \n Delegates to join(Object, Collection, Collection, int).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and includes all non-key-columns from\n           the right table\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to be added to the left\n          side as a result of the match.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 4*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :param reserveBits: (int) - The number of bits to reserve for rightTable groups.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "naturalJoin": "**Incompatible overloads text - text from the first overload:**\n\nPerform a natural-join with the rightTable.\n\n \n Delegates to naturalJoin(Object, Collection, Collection).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (TableOperations.TOPS) the natural-joined table\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to be added to the left\n          side as a result of the match.\n  :return: (TableOperations.TOPS) the natural-joined table\n  \n*Overload 3*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (TableOperations.TOPS) the natural-joined table",
  "raj": "**Incompatible overloads text - text from the first overload:**\n\nPerform a reverse-as-of join with the rightTable.\n\n \n Delegates to raj(Object, Collection, Collection, ReverseAsOfJoinRule).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the left side that need to be added to the right\n          side as a result of the match.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 4*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :param reverseAsOfJoinRule: (io.deephaven.api.ReverseAsOfJoinRule) - The binary search operator for the last match pair.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "reverse": ":return: TableOperations.TOPS",
  "select": "*Overload 1*  \n  :param columns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS",
  "selectDistinct": "*Overload 1*  \n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 3*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: TableOperations.TOPS\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS",
  "snapshot": "**Incompatible overloads text - text from the first overload:**\n\nSnapshot baseTable, triggered by this table, and return a new table as a result.\n\n \n Delegates to snapshot(Object, boolean, Collection).\n\n*Overload 1*  \n  :param baseTable: (TableOperations.TABLE) - The table to be snapshotted\n  :param stampColumns: (java.lang.String...) - The columns forming the \"snapshot key\", i.e. some subset of this Table's columns to be\n          included in the result at snapshot time. As a special case, an empty stampColumns is taken to mean\n          \"include all columns\".\n  :return: (TableOperations.TOPS) The result table\n  \n*Overload 2*  \n  :param baseTable: (TableOperations.TABLE) - The table to be snapshotted\n  :param doInitialSnapshot: (boolean) - Take the first snapshot now (otherwise wait for a change event)\n  :param stampColumns: (java.lang.String...) - The columns forming the \"snapshot key\", i.e. some subset of this Table's columns to be\n          included in the result at snapshot time. As a special case, an empty stampColumns is taken to mean\n          \"include all columns\".\n  :return: (TableOperations.TOPS) The result table\n  \n*Overload 3*  \n  :param baseTable: (TableOperations.TABLE) - The table to be snapshotted\n  :param doInitialSnapshot: (boolean) - Take the first snapshot now (otherwise wait for a change event)\n  :param stampColumns: (java.util.Collection<io.deephaven.api.ColumnName>) - The columns forming the \"snapshot key\", i.e. some subset of this Table's columns to be\n          included in the result at snapshot time. As a special case, an empty stampColumns is taken to mean\n          \"include all columns\".\n  :return: (TableOperations.TOPS) The result table",
  "sort": "*Overload 1*  \n  :param columnsToSortBy: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param columnsToSortBy: java.util.Collection<io.deephaven.api.SortColumn>\n  :return: TableOperations.TOPS",
  "sortDescending": ":param columnsToSortBy: java.lang.String...\n:return: TableOperations.TOPS",
  "tail": ":param size: long\n:return: TableOperations.TOPS",
  "update": "*Overload 1*  \n  :param columns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS",
  "updateView": "*Overload 1*  \n  :param columns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS",
  "view": "*Overload 1*  \n  :param columns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS",
  "where": "*Overload 1*  \n  :param filters: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param filters: java.util.Collection<? extendsio.deephaven.api.filter.Filter>\n  :return: TableOperations.TOPS",
  "whereIn": "**Incompatible overloads text - text from the first overload:**\n\nFilters this table based on the set of values in the rightTable.\n\n \n Delegates to whereIn(Object, Collection).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - the filtering table.\n  :param columnsToMatch: (java.lang.String...) - the columns to match between the two tables\n  :return: (TableOperations.TOPS) a new table filtered on right table\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - the filtering table.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - the columns to match between the two tables\n  :return: (TableOperations.TOPS) a new table filtered on right table",
  "whereNotIn": "**Incompatible overloads text - text from the first overload:**\n\nFilters this table based on the set of values not in the rightTable.\n\n \n Delegates to whereNotIn(Object, Collection).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - the filtering table.\n  :param columnsToMatch: (java.lang.String...) - the columns to match between the two tables\n  :return: (TableOperations.TOPS) a new table filtered on right table\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - the filtering table.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - the columns to match between the two tables\n  :return: (TableOperations.TOPS) a new table filtered on right table"
 },
 "path": "io.deephaven.api.TableOperations",
 "text": "Table operations is a user-accessible api for modifying tables or building up table operations.",
 "typeName": "interface"
}