{
 "className": "io.deephaven.api.TableOperations",
 "methods": {
  "aj": "**Incompatible overloads text - text from the first overload:**\n\nPerform an as-of join with the rightTable.\n\n \n Delegates to aj(Object, Collection, Collection, AsOfJoinRule).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the left side that need to\n          be added to the right side as a result of the match.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 4*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :param asOfJoinRule: (io.deephaven.api.AsOfJoinRule) - The binary search operator for the last match pair.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "by": "*Overload 1*  \n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 3*  \n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS\n  \n*Overload 4*  \n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :param aggregations: java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>\n  :return: TableOperations.TOPS",
  "exactJoin": "**Incompatible overloads text - text from the first overload:**\n\nPerform an exact-join with the rightTable.\n\n \n Delegates to exactJoin(Object, Collection, Collection).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (TableOperations.TOPS) the exact-joined table\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to\n          be added to the left side as a result of the match.\n  :return: (TableOperations.TOPS) the exact-joined table\n  \n*Overload 3*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :return: (TableOperations.TOPS) the exact-joined table",
  "head": ":param size: long\n:return: TableOperations.TOPS",
  "join": "**Incompatible overloads text - text from the first overload:**\n\nPerform a cross join with the rightTable.\n\n \n Delegates to join(Object, Collection, Collection, int).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and includes all\n           non-key-columns from the right table\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to\n          be added to the left side as a result of the match.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 4*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :param reserveBits: (int) - The number of bits to reserve for rightTable groups.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "leftJoin": "**Incompatible overloads text - text from the first overload:**\n\nPerform a left-join with the rightTable.\n\n \n Delegates to leftJoin(Object, Collection, Collection).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (TableOperations.TOPS) the left-joined table\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to\n          be added to the left side as a result of the match.\n  :return: (TableOperations.TOPS) the left-joined table\n  \n*Overload 3*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :return: (TableOperations.TOPS) a table that has one column for each original table's columns, and one column\n           corresponding to each column listed in columnsToAdd. If\n           columnsToAdd.isEmpty() one column corresponding to each column of the input\n           table (right table) columns whose names don't overlap with the name of a column from\n           the source table is added. The new columns (those corresponding to the input table)\n           contain an aggregation of all values from the left side that match the join criteria.",
  "naturalJoin": "**Incompatible overloads text - text from the first overload:**\n\nPerform a natural-join with the rightTable.\n\n \n Delegates to naturalJoin(Object, Collection, Collection).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (TableOperations.TOPS) the natural-joined table\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to\n          be added to the left side as a result of the match.\n  :return: (TableOperations.TOPS) the natural-joined table\n  \n*Overload 3*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :return: (TableOperations.TOPS) the natural-joined table",
  "raj": "**Incompatible overloads text - text from the first overload:**\n\nPerform a reverse-as-of join with the rightTable.\n\n \n Delegates to raj(Object, Collection, Collection, ReverseAsOfJoinRule).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the left side that need to\n          be added to the right side as a result of the match.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 4*  \n  :param rightTable: (TableOperations.TABLE) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as\n          a result of the match.\n  :param reverseAsOfJoinRule: (io.deephaven.api.ReverseAsOfJoinRule) - The binary search operator for the last match pair.\n  :return: (TableOperations.TOPS) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "reverse": ":return: TableOperations.TOPS",
  "select": "*Overload 1*  \n  :param columns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS",
  "snapshot": "**Incompatible overloads text - text from the first overload:**\n\nSnapshot baseTable, triggered by this table, and return a new table as a\n result.\n\n \n Delegates to snapshot(Object, boolean, Collection).\n\n*Overload 1*  \n  :param baseTable: (TableOperations.TABLE) - The table to be snapshotted\n  :param stampColumns: (java.lang.String...) - The columns forming the \"snapshot key\", i.e. some subset of this Table's\n          columns to be included in the result at snapshot time. As a special case, an empty\n          stampColumns is taken to mean \"include all columns\".\n  :return: (TableOperations.TOPS) The result table\n  \n*Overload 2*  \n  :param baseTable: (TableOperations.TABLE) - The table to be snapshotted\n  :param doInitialSnapshot: (boolean) - Take the first snapshot now (otherwise wait for a change event)\n  :param stampColumns: (java.lang.String...) - The columns forming the \"snapshot key\", i.e. some subset of this Table's\n          columns to be included in the result at snapshot time. As a special case, an empty\n          stampColumns is taken to mean \"include all columns\".\n  :return: (TableOperations.TOPS) The result table\n  \n*Overload 3*  \n  :param baseTable: (TableOperations.TABLE) - The table to be snapshotted\n  :param doInitialSnapshot: (boolean) - Take the first snapshot now (otherwise wait for a change event)\n  :param stampColumns: (java.util.Collection<io.deephaven.api.ColumnName>) - The columns forming the \"snapshot key\", i.e. some subset of this Table's\n          columns to be included in the result at snapshot time. As a special case, an empty\n          stampColumns is taken to mean \"include all columns\".\n  :return: (TableOperations.TOPS) The result table",
  "sort": "*Overload 1*  \n  :param columnsToSortBy: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param columnsToSortBy: java.util.Collection<io.deephaven.api.SortColumn>\n  :return: TableOperations.TOPS",
  "sortDescending": ":param columnsToSortBy: java.lang.String...\n:return: TableOperations.TOPS",
  "tail": ":param size: long\n:return: TableOperations.TOPS",
  "update": "*Overload 1*  \n  :param columns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS",
  "updateView": "*Overload 1*  \n  :param columns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS",
  "view": "*Overload 1*  \n  :param columns: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: TableOperations.TOPS",
  "where": "*Overload 1*  \n  :param filters: java.lang.String...\n  :return: TableOperations.TOPS\n  \n*Overload 2*  \n  :param filters: java.util.Collection<? extendsio.deephaven.api.filter.Filter>\n  :return: TableOperations.TOPS",
  "whereIn": "**Incompatible overloads text - text from the first overload:**\n\nFilters this table based on the set of values in the rightTable.\n\n \n Delegates to whereIn(Object, Collection).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - the filtering table.\n  :param columnsToMatch: (java.lang.String...) - the columns to match between the two tables\n  :return: (TableOperations.TOPS) a new table filtered on right table\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - the filtering table.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - the columns to match between the two tables\n  :return: (TableOperations.TOPS) a new table filtered on right table",
  "whereNotIn": "**Incompatible overloads text - text from the first overload:**\n\nFilters this table based on the set of values not in the rightTable.\n\n \n Delegates to whereNotIn(Object, Collection).\n\n*Overload 1*  \n  :param rightTable: (TableOperations.TABLE) - the filtering table.\n  :param columnsToMatch: (java.lang.String...) - the columns to match between the two tables\n  :return: (TableOperations.TOPS) a new table filtered on right table\n  \n*Overload 2*  \n  :param rightTable: (TableOperations.TABLE) - the filtering table.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - the columns to match between the two tables\n  :return: (TableOperations.TOPS) a new table filtered on right table"
 },
 "path": "io.deephaven.api.TableOperations",
 "text": "Table operations is a user-accessible api for modifying tables or building up table operations.",
 "typeName": "interface"
}