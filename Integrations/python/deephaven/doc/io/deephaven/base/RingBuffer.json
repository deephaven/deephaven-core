{
 "className": "io.deephaven.base.RingBuffer",
 "methods": {
  "add": ":param e: RingBuffer.E\n:return: boolean",
  "addFirst": ":param e: RingBuffer.E\n:return: boolean",
  "addOverwrite": ":param e: RingBuffer.E\n:return: RingBuffer.E",
  "back": ":return: RingBuffer.E",
  "capacity": ":return: int",
  "element": ":return: RingBuffer.E",
  "front": "*Overload 1*  \n  :return: RingBuffer.E\n  \n*Overload 2*  \n  :param offset: int\n  :return: RingBuffer.E",
  "isEmpty": ":return: boolean",
  "isFull": ":return: boolean",
  "iterator": ":return: io.deephaven.base.RingBuffer.Iterator",
  "offer": ":param e: RingBuffer.E\n:return: boolean",
  "offerFirst": ":param e: RingBuffer.E\n:return: boolean",
  "peek": "*Overload 1*  \n  :return: RingBuffer.E\n  \n*Overload 2*  \n  :param offset: int\n  :return: RingBuffer.E",
  "peekLast": "*Overload 1*  \n  :return: RingBuffer.E\n  \n*Overload 2*  \n  :param offset: int\n  :return: RingBuffer.E",
  "poll": ":return: RingBuffer.E",
  "remove": ":return: RingBuffer.E",
  "removeAtSwapLast": ":param offset: int\n:return: RingBuffer.E",
  "size": ":return: int"
 },
 "path": "io.deephaven.base.RingBuffer",
 "text": "A trivial circular buffer, like java.util.concurrent.ArrayBlockingQueue but without all the synchronization and\n collection cruft.",
 "typeName": "class"
}