{
 "className": "io.deephaven.compilertools.CompilerTools",
 "methods": {
  "compile": "Compile a class.\n\n*Overload 1*  \n  :param className: java.lang.String\n  :param classBody: java.lang.String\n  :param packageNameRoot: java.lang.String\n  :return: java.lang.Class<?>\n  \n*Overload 2*  \n  :param className: java.lang.String\n  :param classBody: java.lang.String\n  :param packageNameRoot: java.lang.String\n  :param parameterClasses: java.util.Map<java.lang.String,java.lang.Class<?>>\n  :return: java.lang.Class<?>\n  \n*Overload 3*  \n  :param className: java.lang.String\n  :param classBody: java.lang.String\n  :param packageNameRoot: java.lang.String\n  :param codeLog: java.lang.StringBuilder\n  :return: java.lang.Class<?>\n  \n*Overload 4*  \n  :param className: (java.lang.String) - Class name\n  :param classBody: (java.lang.String) - Class body, before update with \"$CLASS_NAME$\" replacement and package name prefixing\n  :param packageNameRoot: (java.lang.String) - Package name prefix\n  :param codeLog: (java.lang.StringBuilder) - Optional \"log\" for final class code\n  :param parameterClasses: (java.util.Map<java.lang.String,java.lang.Class<?>>) - Generic parameters, empty if none required\n  :return: (java.lang.Class<?>) The compiled class",
  "createEscapedJoinedString": "Transform a string into the corresponding Java source code that compiles into that string. This involves escaping\n special characters, surrounding it with quotes, and (if the string is larger than the max string length for Java\n literals), splitting it into substrings and constructing a call to String.join() that combines those substrings.\n\n*Overload 1*  \n  :param originalString: java.lang.String\n  :return: java.lang.String\n  \n*Overload 2*  \n  :param originalString: java.lang.String\n  :param maxStringLength: int\n  :return: java.lang.String",
  "doWithContext": "Note: Java generics information - <RETURN_TYPE>\n\n:param context: io.deephaven.compilertools.CompilerTools.Context\n:param action: java.util.function.Supplier<RETURN_TYPE>\n:return: RETURN_TYPE",
  "getContext": ":return: io.deephaven.compilertools.CompilerTools.Context",
  "getJavaClassPath": "Retrieve the java class path from our existing Java class path, and IntelliJ/TeamCity environment variables.\n\n:return: java.lang.String",
  "main": ":param args: java.lang.String[]",
  "setContext": ":param context: io.deephaven.compilertools.CompilerTools.Context",
  "setDefaultContext": "Sets the default context.\n\n:param context: (io.deephaven.compilertools.CompilerTools.Context) - the script session's compiler context",
  "setLogEnabled": "Enables or disables compilation logging.\n\n:param logEnabled: (boolean) - Whether or not logging should be enabled\n:return: (boolean) The value of logEnabled before calling this method.",
  "tryCompile": "Try to compile the set of files, returning a pair of success and compiler output.\n\n:param basePath: (java.io.File) - the base path for the java classes\n:param javaFiles: (java.util.Collection<java.io.File>) - the java source files\n:return: (io.deephaven.base.Pair<java.lang.Boolean,java.lang.String>) a Pair of success, and the compiler output",
  "writeClass": "*Overload 1*  \n  :param destinationDirectory: java.io.File\n  :param className: java.lang.String\n  :param data: byte[]\n  \n*Overload 2*  \n  :param destinationDirectory: java.io.File\n  :param className: java.lang.String\n  :param data: byte[]\n  :param message: java.lang.String"
 },
 "path": "io.deephaven.compilertools.CompilerTools",
 "typeName": "class"
}