{
 "className": "io.deephaven.io.streams.ByteBufferInputStream",
 "methods": {
  "available": ":return: int",
  "mark": ":param readlimit: int",
  "markSupported": ":return: boolean",
  "read": "*Overload 1*  \n  :return: int\n  \n*Overload 2*  \n  :param b: byte[]\n  :return: int\n  \n*Overload 3*  \n  :param b: byte[]\n  :param off: int\n  :param len: int\n  :return: int\n  \n*Overload 4*  \n  :param dest: java.nio.ByteBuffer\n  :param length: int",
  "readBoolean": ":return: boolean",
  "readByte": ":return: byte",
  "readChar": ":return: char",
  "readDouble": ":return: double",
  "readFloat": ":return: float",
  "readFully": "*Overload 1*  \n  :param b: byte[]\n  \n*Overload 2*  \n  :param b: byte[]\n  :param off: int\n  :param len: int",
  "readInt": ":return: int",
  "readLine": ":return: java.lang.String",
  "readLong": ":return: long",
  "readShort": ":return: short",
  "readUTF": "*Overload 1*  \n  :return: java.lang.String\n  \n*Overload 2*  \n  :param output: io.deephaven.base.string.cache.CharSequenceAdapterBuilder\n  :param cache: io.deephaven.base.string.cache.StringCache<java.lang.String>\n  :return: java.lang.String\n  \n*Overload 3*  \n  :param output: io.deephaven.base.string.cache.CharSequenceAdapterBuilder",
  "readUnsignedByte": ":return: int",
  "readUnsignedShort": ":return: int",
  "setBuffer": "Set the buffer to be used for future read operations.\n\n:param buf: java.nio.ByteBuffer",
  "skip": ":param n: long\n:return: long",
  "skipBytes": ":param n: int\n:return: int"
 },
 "path": "io.deephaven.io.streams.ByteBufferInputStream",
 "text": "This is an InputStream implementation which reads from a java.nio.ByteBuffer. If a read operation crosses the end of\n the buffer, the BufferUnderflowException is converted to an EOFException.\n\n The stream contains no state other than that in in the buffer itself, so the buffer can be exchanged at will with the\n setBuffer() method.",
 "typeName": "class"
}