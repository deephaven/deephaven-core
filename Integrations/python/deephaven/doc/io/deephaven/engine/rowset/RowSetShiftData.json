{
 "className": "io.deephaven.engine.rowset.RowSetShiftData",
 "methods": {
  "append": "*Overload 1*  \n  :param logOutput: io.deephaven.base.log.LogOutput\n  :return: io.deephaven.base.log.LogOutput\n  \n*Overload 2*  \n  :param logOutput: io.deephaven.base.log.LogOutput\n  :param maxShifts: int\n  :return: io.deephaven.base.log.LogOutput",
  "apply": "**Incompatible overloads text - text from the first overload:**\n\nApply all shifts in a memmove-semantics-safe ordering through the provided shiftCallback.\n \n Use this to move from pre-shift keyspace to post-shift keyspace.\n\n*Overload 1*  \n  :param shiftCallback: (io.deephaven.engine.rowset.RowSetShiftData.Callback) - the callback that will process all shifts\n  \n*Overload 2*  \n  :param rowSet: (io.deephaven.engine.rowset.WritableRowSet) - The WritableRowSet to shift\n  :return: (io.deephaven.engine.rowset.WritableRowSet) rowSet",
  "applyIterator": ":return: io.deephaven.engine.rowset.RowSetShiftData.Iterator",
  "applyShift": "Apply a shift to the provided rowSet. Moves rowSet from pre-shift keyspace to post-shift keyspace.\n\n:param rowSet: (io.deephaven.engine.rowset.WritableRowSet) - The rowSet to apply the shift to\n:param beginRange: (long) - start of range (inclusive)\n:param endRange: (long) - end of range (inclusive)\n:param shiftDelta: (long) - amount range has moved by\n:return: (boolean) Whether there was any overlap found to shift",
  "empty": "Queries whether this RowSetShiftData is empty (i.e. has no shifts).\n\n:return: (boolean) true if the size() of this is zero, false if the size is greater than zero",
  "equals": ":param obj: java.lang.Object\n:return: boolean",
  "extractParallelShiftedRowsFromPostShiftRowSet": "This method creates two parallel RowSet structures that contain postShiftRowSet keys affected by shifts. The two\n RowSets have the same size. An element at position k in the first RowSet is the pre-shift key for the same row\n whose post-shift key is at position k in the second RowSet.\n\n:param postShiftRowSet: (io.deephaven.engine.rowset.RowSet) - The RowSet of keys that were shifted in post-shift keyspace. It should not contain rows\n        that did not exist prior to the shift.\n:return: (io.deephaven.util.SafeCloseablePair<io.deephaven.engine.rowset.RowSet,io.deephaven.engine.rowset.RowSet>) A SafeCloseablePair of preShiftedKeys and postShiftedKeys that intersect this RowSetShiftData with\n         postShiftRowSet.",
  "forAllInRowSet": ":param filterRowSet: io.deephaven.engine.rowset.RowSet\n:param callback: io.deephaven.engine.rowset.RowSetShiftData.SingleElementShiftCallback",
  "getBeginRange": "Get the inclusive begin offset of the idxth shift.\n\n:param idx: (int) - which pair to get offset for\n:return: (long) the offset",
  "getEffectiveSize": "The number of keys affected by shift commands.\n\n:return: (long) number of keys affected by shifts",
  "getEffectiveSizeClamped": "The number of keys affected by shift commands.\n\n:param clamp: (long) - the maximum size to return\n:return: (long) number of keys affected by shifts",
  "getEndRange": "Get the inclusive end offset of the idxth shift.\n\n:param idx: (int) - which pair to get offset for\n:return: (long) the offset",
  "getShiftDelta": "Get the absolute shift of the idxth shift.\n\n:param idx: (int) - which pair to get shift for\n:return: (long) the shift",
  "intersect": "Intersects this RowSetShiftData against the provided RowSet.\n\n:param rowSet: (io.deephaven.engine.rowset.RowSet) - the rowSet to test for intersections (pre-shift keyspace)\n:return: (io.deephaven.engine.rowset.RowSetShiftData) a rowSetShiftData containing only non-empty shifts",
  "nonempty": "Queries whether this RowSetShiftData is non-empty (i.e. has at least one shift).\n\n:return: (boolean) true if the size() of this TrackingWritableRowSet greater than zero, false if the size is zero",
  "size": "The number of shifts embedded in the payload.\n\n:return: (int) the number of shifts",
  "toString": ":return: java.lang.String",
  "unapply": "**Incompatible overloads text - text from the first overload:**\n\nApply all shifts in reverse in a memmove-semantics-safe ordering through the provided shiftCallback.\n \n Use this to move from post-shift keyspace to pre-shift keyspace.\n\n*Overload 1*  \n  :param shiftCallback: (io.deephaven.engine.rowset.RowSetShiftData.Callback) - the callback that will process all reverse shifts\n  \n*Overload 2*  \n  :param rowSet: (io.deephaven.engine.rowset.WritableRowSet) - The WritableRowSet to shift\n  :return: (io.deephaven.engine.rowset.WritableRowSet) rowSet\n  \n*Overload 3*  \n  :param rowSet: (io.deephaven.engine.rowset.WritableRowSet) - The WritableRowSet to shift\n  :param offset: (long) - An additional offset to apply to all shifts (such as when applying to a wrapped table)\n  :return: (io.deephaven.engine.rowset.WritableRowSet) rowSet",
  "unapplyShift": "Unapply a shift to the provided rowSet. Moves rowSet from post-shift keyspace to pre-shift keyspace.\n\n:param rowSet: (io.deephaven.engine.rowset.WritableRowSet) - The rowSet to apply the shift to\n:param beginRange: (long) - start of range (inclusive)\n:param endRange: (long) - end of range (inclusive)\n:param shiftDelta: (long) - amount range has moved by\n:return: (boolean) Whether there was any overlap found to shift",
  "validate": "Verify invariants of internal data structures hold."
 },
 "path": "io.deephaven.engine.rowset.RowSetShiftData",
 "text": "A set of sorted shifts. To apply shifts without losing data, use apply(Callback). The\n callback will be invoked with shifts in an order that will preserve data when applied immediately using memmove\n semantics. Internally the shifts are ordered by rangeStart. The RowSetShiftData.Builder will verify that no\n two ranges overlap before or after shifting and assert that the constructed RowSetShiftData will be valid.",
 "typeName": "class"
}