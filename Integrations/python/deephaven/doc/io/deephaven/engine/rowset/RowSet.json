{
 "className": "io.deephaven.engine.rowset.RowSet",
 "methods": {
  "close": "Free any resources associated with this object.\n \n Using any RowSequence methods after close() is an error and may produce exceptions or undefined\n results.",
  "containsRange": "Queries whether this RowSet contains every element in the range provided.\n\n:param start: (long) - Start of the range, inclusive.\n:param end: (long) - End of the range, inclusive.\n:return: (boolean) true if this RowSet contains every element x in start <= x <= end.",
  "copy": "Make a new WritableRowSet with the same row keys as this that is safe for further mutation. As in\n other operations that return a WritableRowSet, the result must be closed by the caller\n when it is no longer needed. The result will never be a TrackingRowSet; use\n WritableRowSet.toTracking() on the result as needed.\n\n:return: (io.deephaven.engine.rowset.WritableRowSet) The copied WritableRowSet",
  "find": "Returns the position in [0..(size-1)] where the key is found. If not found, then return (-(position it would be)\n - 1), a la Array.binarySearch.\n\n:param key: (long) - the key to search for\n:return: (long) a position from [0..(size-1)] if the key was found. If the key was not found, then (-position - 1) as in\n         Array.binarySearch.",
  "findMissing": "For the given keys RowSet, under the assertion that none of them are present in the current RowSet, return the\n tentative insertion points in the current RowSet with the count for each of them\n\n:param keys: (io.deephaven.engine.rowset.RowSet) - the keys to identify insertion locations\n:return: (gnu.trove.list.array.TLongArrayList[]) two TLongArrayLists; [0] contains the positions, [1] contains the counts.",
  "firstRowKey": "Get the first row key in this RowSet.\n\n:return: (long) The first row key, or RowSequence.NULL_ROW_KEY if there is none.",
  "forAllRowKeys": ":param lc: java.util.function.LongConsumer",
  "forEachRowKey": "Provide each value contained in this RowSet, in increased sorted order to the consumer. If the consumer returns\n false for a key, stops after that key (does not provide any keys after that key).\n\n:param lc: (io.deephaven.util.datastructures.LongAbortableConsumer) - the consumer.\n:return: (boolean) false if the consumer returned false at some point, true if the consumer always returned true and all\n         values in the RowSet were consumed.",
  "get": "Returns the row key at the given row position.\n\n:param rowPosition: (long) - A row position in this RowSet between 0 and size() - 1.\n:return: (long) The row key at the supplied row position",
  "getKeysForPositions": "Returns the sequence of (increasing) keys corresponding to the positions provided as input.\n\n:param inputPositions: (java.util.PrimitiveIterator.OfLong) - an iterator providing row positions in increasing order.\n:param outputKeys: (java.util.function.LongConsumer) - a consumer of corresponding keys for the positions provided as input.",
  "intersect": "Returns a new RowSet representing the intersection of the current RowSet with the input RowSet\n\n:param range: io.deephaven.engine.rowset.RowSet\n:return: io.deephaven.engine.rowset.WritableRowSet",
  "invert": "**Incompatible overloads text - text from the first overload:**\n\n\n Returns a WritableRowSet with the row positions of row keys in this RowSet.\n\n \n This can be thought of as an iterative find() over the values in keys, but all keys must exist\n within this RowSet, because a RowSet result can not represent negative values.\n\n*Overload 1*  \n  :param keys: (io.deephaven.engine.rowset.RowSet) - The keys to find positions for\n  :return: (io.deephaven.engine.rowset.WritableRowSet) A new WritableRowSet containing the positions of the keys in this RowSet\n  \n*Overload 2*  \n  :param keys: (io.deephaven.engine.rowset.RowSet) - The keys to find positions for\n  :param maximumPosition: (long) - The largest position for which we will find a key\n  :return: (io.deephaven.engine.rowset.WritableRowSet) A new WritableRowSet containing the positions of the keys in this RowSet",
  "isEmpty": "Queries whether this RowSet is empty (i.e. has no keys).\n\n:return: (boolean) true if the size() of this RowSet is zero, false if the size is greater than zero",
  "isFlat": "Returns whether or not this RowSet is flat. Unlike a table, this is a mutable property; which may change from\n step to step.\n\n:return: (boolean) true if the RowSet keys are contiguous and start at zero.",
  "isNonempty": "Queries whether this RowSet is non-empty (i.e. has at least one key).\n\n:return: (boolean) true if the size() of this RowSet greater than zero, false if the size is zero",
  "isTracking": ":return: (boolean) Whether this RowSet is actually tracking",
  "isWritable": ":return: (boolean) Whether this RowSet is actually writable",
  "iterator": ":return: io.deephaven.engine.rowset.RowSet.Iterator",
  "lastRowKey": "Get the last row key in this RowSet.\n\n:return: (long) The last row key, or RowSequence.NULL_ROW_KEY if there is none.",
  "minus": "Returns a new RowSet representing the keys of the current set not present inside rowSetToRemove. This operation\n is equivalent to set difference. This RowSet is not modified.\n\n:param rowSetToRemove: io.deephaven.engine.rowset.RowSet\n:return: io.deephaven.engine.rowset.WritableRowSet",
  "overlaps": "Returns true if a RowSet has any overlap.\n\n:param rowSet: io.deephaven.engine.rowset.RowSet\n:return: boolean",
  "overlapsRange": "Returns true if this RowSet has any overlap with the provided range.\n\n:param start: (long) - Start of range, inclusive.\n:param end: (long) - End of range, inclusive.\n:return: (boolean) true if any value x in start <= x <= end is contained in this RowSet.",
  "rangeIterator": ":return: io.deephaven.engine.rowset.RowSet.RangeIterator",
  "reverseIterator": ":return: io.deephaven.engine.rowset.RowSet.SearchIterator",
  "searchIterator": ":return: io.deephaven.engine.rowset.RowSet.SearchIterator",
  "shift": ":param shiftAmount: long\n:return: io.deephaven.engine.rowset.WritableRowSet",
  "size": "How many keys are in this RowSet.\n\n:return: (long) the number of keys in this RowSet.",
  "subSetByKeyRange": "Get a subset of this RowSet within the specified closed range of row keys.\n\n:param startKey: (long) - The first key to include in the output.\n:param endKey: (long) - The last key (inclusive) to include in the output.\n:return: (io.deephaven.engine.rowset.WritableRowSet) A new RowSet, containing only values >= startKey and <= endKey.",
  "subSetByPositionRange": "Get a subset of this RowSet within the specified half-closed range of row positions.\n\n:param startPos: (long) - The first position to included in the output (inclusive)\n:param endPos: (long) - The last position to included in the output (exclusive)\n:return: (io.deephaven.engine.rowset.WritableRowSet) A new RowSet, containing only positions >= startPos and < endPos",
  "subSetForPositions": "Get a subset of this RowSet according to the supplied sequence of row positions in posRowSequence.\n\n*Overload 1*  \n  :param posRowSequence: (io.deephaven.engine.rowset.RowSequence) - The RowSequence of positions ranges to get (as in get(long))\n  :param reversed: (boolean) - Whether to treat posRowSet as offsets relative to size() rather than 0\n  :return: (io.deephaven.engine.rowset.WritableRowSet) A new RowSet, containing the row keys from this RowSet at the row positions in posRowSequence\n  \n*Overload 2*  \n  :param posRowSequence: (io.deephaven.engine.rowset.RowSequence) - The RowSequence of position-based ranges to extract.\n  :return: (io.deephaven.engine.rowset.WritableRowSet) A new RowSet, containing values at the locations in the provided RowSet.",
  "subSetForReversePositions": "Get a subset of this RowSet according to the supplied sequence of row positions relative to size() in\n posRowSequence.\n\n:param posRowSequence: (io.deephaven.engine.rowset.RowSequence) - The RowSequence of positions ranges to get (as in get(long))\n:return: (io.deephaven.engine.rowset.WritableRowSet) A new RowSet, containing the row keys from this RowSet at the row positions in posRowSequence",
  "subsetOf": "Returns true if this RowSet is a (possibly improper) subset of other.\n\n:param other: io.deephaven.engine.rowset.RowSet\n:return: (boolean) true if every element of this exists within other",
  "toRowKeyArray": "*Overload 1*  \n  :param vs: long[]\n  \n*Overload 2*  \n  :param vs: long[]\n  :param offset: int",
  "trackingCast": "Cast this RowSet reference to a TrackingRowSet.\n\n:return: (io.deephaven.engine.rowset.TrackingRowSet) this cast to a TrackingRowSet",
  "union": "Returns a new RowSet representing the keys present in both this RowSet and the argument RowSet.\n\n:param rowSetToAdd: (io.deephaven.engine.rowset.RowSet) - A RowSet whose keys will be joined with our own to produce a new RowSet.\n:return: (io.deephaven.engine.rowset.WritableRowSet) a new RowSet with the union of the keys in both this RowSet and rowSetToAdd.",
  "validate": "*Overload 1*  \n  :param failMsg: java.lang.String\n  \n*Overload 2*",
  "writableCast": "Cast this RowSet reference to a WritableRowSet.\n\n:return: (io.deephaven.engine.rowset.WritableRowSet) this cast to a WritableRowSet"
 },
 "path": "io.deephaven.engine.rowset.RowSet",
 "text": "RowSequence with additional set and set-like capabilities.",
 "typeName": "interface"
}