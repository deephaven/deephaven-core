{
 "className": "io.deephaven.engine.rowset.impl.rsp.container.SingletonContainer",
 "methods": {
  "add": "Return a new container with all shorts in [begin,end) added using an unsigned interpretation.\n\n:param begin: (int) - start of range (inclusive)\n:param end: (int) - end of range (exclusive)\n:return: (io.deephaven.engine.rowset.impl.rsp.container.Container) the new container",
  "and": "Computes the bitwise AND of this container with another (intersection). This container as well as the provided\n container are left unaffected.\n\n*Overload 1*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.ArrayContainer) - Another container\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) aggregated container\n  \n*Overload 2*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.BitmapContainer) - Another container\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) aggregated container\n  \n*Overload 3*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.RunContainer) - Another container\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) aggregated container",
  "andNot": "Computes the bitwise ANDNOT of this container with another (difference). This container as well as the provided\n container are left unaffected.\n\n*Overload 1*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.ArrayContainer) - Another container\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) aggregated container\n  \n*Overload 2*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.BitmapContainer) - Another container\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) aggregated container\n  \n*Overload 3*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.RunContainer) - Another container\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) aggregated container",
  "andRange": "Calculate the intersection of this container and a range, in a new container. The existing container is not\n modified.\n\n:param start: (int) - start of range\n:param end: (int) - end of range, exclusive.\n:return: (io.deephaven.engine.rowset.impl.rsp.container.Container) a new Container containing the intersction of this container and the given range.",
  "bytesAllocated": ":return: (int) The allocated size in bytes of the underlying array backing store used by this container.",
  "bytesUsed": ":return: (int) The size in bytes of the used portion out of the total allocated bytes for the underlying array backing\n         store used by this container.",
  "contains": "**Incompatible overloads text - text from the first overload:**\n\nChecks whether the contain contains the provided value\n\n*Overload 1*  \n  :param x: (short) - value to check\n  :return: (boolean) whether the value is in the container\n  \n*Overload 2*  \n  :param rangeStart: (int) - the inclusive lower bound of the range\n  :param rangeEnd: (int) - the exclusive upper bound of the range\n  :return: (boolean) true if the container contains the range",
  "find": "Searches for the specified short value\n\n:param x: (short) - value to search for\n:return: (int) Relative position of the value in the sorted set of elements in this container, in the range [0 ..\n         cardinality - 1]. If not present, (-(insertion point) - 1) similar to Array.binarySearch.\n         \n         For values of x that Container.contains(short) returns\n         true, this method returns the same value as\n         Container.rank(short).",
  "findRanges": "As find but for all the values in a range.\n\n:param outPositions: (io.deephaven.engine.rowset.impl.rsp.container.RangeConsumer) - accept is called in this consumer for each resulting position range.\n:param inValues: (io.deephaven.engine.rowset.impl.rsp.container.RangeIterator) - input iterator that provides the key ranges; these must each exist in the container.\n:param maxPos: (int) - maximum position to add to outPositions; values of position > maxPos are not added.\n:return: (boolean) true if maxPos was reached, false otherwise.",
  "first": "Get the first integer held in the container\n\n:return: (int) the first integer in the container",
  "forEach": "**Incompatible overloads text - text from the first overload:**\n\nIterate through the values of this container in order and pass them along to the ShortConsumer.\n\n*Overload 1*  \n  :param sc: (io.deephaven.engine.rowset.impl.rsp.container.ShortConsumer) - a shortConsumer\n  :return: (boolean) false if the consumer returned false at some point, true otherwise.\n  \n*Overload 2*  \n  :param rankOffset: (int) - the position (rank) offset of the element where to start\n  :param sc: (io.deephaven.engine.rowset.impl.rsp.container.ShortConsumer) - a ShortConsumer\n  :return: (boolean) false if the consumer returned false at some point, true otherwise.",
  "forEachRange": ":param rankOffset: int\n:param sc: io.deephaven.engine.rowset.impl.rsp.container.ShortRangeConsumer\n:return: boolean",
  "getCardinality": "Computes the distinct number of short values in the container. Can be expected to run in constant time.\n\n:return: (int) the cardinality",
  "getReverseShortIterator": "Iterator to visit the short values in the container in descending order.\n\n:return: (io.deephaven.engine.rowset.impl.rsp.container.ShortAdvanceIterator) iterator",
  "getShortBatchIterator": "Gets an iterator to visit the contents of the container in batches of short values\n\n:param skipFromStartCount: (int) - number of elements to skip from the start of the container.\n:return: (io.deephaven.engine.rowset.impl.rsp.container.ContainerShortBatchIterator) iterator",
  "getShortIterator": "Iterator to visit the short values in the container in ascending order.\n\n:return: (io.deephaven.engine.rowset.impl.rsp.container.ShortIterator) iterator",
  "getShortRangeIterator": "Iterator to visit the short values in container in [start, end) ranges, in increasing order of start values.\n\n:param skipFromStartCount: int\n:return: (io.deephaven.engine.rowset.impl.rsp.container.SearchRangeIterator) iterator",
  "iflip": "Add a short to the container if it is not present, otherwise remove it. May generate a new container.\n\n:param x: (short) - short to be added\n:return: (io.deephaven.engine.rowset.impl.rsp.container.Container) the new container",
  "intValue": ":return: int",
  "isAllOnes": "Checks whether the container spans the full 2^16 range (ie, contains every short value) This is an O(1) operation\n in all container types (some do not cache cardinality).\n\n:return: (boolean) true if the container does not miss any single short value.",
  "isEmpty": "Checks whether the container is empty or not.\n\n:return: (boolean) true if the container is empty.",
  "last": "Get the last integer held in the container\n\n:return: (int) the last integer in the container",
  "nextValue": "Gets the first value greater than or equal to the lower bound, or -1 if no such value exists.\n\n:param fromValue: (short) - the lower bound (inclusive)\n:return: (int) the next value",
  "not": "Computes the bitwise NOT of this container (complement). Only those bits within the range are affected. This is\n equivalent to an xor with a range of ones for the given range. The current container is left unaffected.\n\n:param rangeStart: (int) - beginning of range (inclusive); 0 is beginning of this container.\n:param rangeEnd: (int) - ending of range (exclusive)\n:return: (io.deephaven.engine.rowset.impl.rsp.container.Container) (partially) complemented container",
  "or": "Computes the bitwise OR of this container with another (union). This container as well as the provided container\n are left unaffected.\n\n*Overload 1*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.ArrayContainer) - Another container\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) aggregated container\n  \n*Overload 2*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.BitmapContainer) - Another container\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) aggregated container\n  \n*Overload 3*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.RunContainer) - Another container\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) aggregated container",
  "overlaps": "*Overload 1*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.ArrayContainer) - Another container\n  :return: (boolean) true if at least one key in this container is also a key in x.\n  \n*Overload 2*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.BitmapContainer) - Another container\n  :return: (boolean) true if at least one key in this container is also a key in x.\n  \n*Overload 3*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.RunContainer) - Another container\n  :return: (boolean) true if at least one key in this container is also a key in x.",
  "overlapsRange": ":param start: (int) - the beginning of the range, as an int.\n:param end: (int) - the end of the range (exclusive), as an int.\n:return: (boolean) true if there is any element in this container in the range provided.",
  "rank": "Rank returns the number of integers that are smaller or equal to x (Rank(infinity) would be GetCardinality()).\n\n:param lowbits: (short) - upper limit\n:return: (int) the rank",
  "remove": "Return a new container with all shorts in [begin,end) remove using an unsigned interpretation.\n\n:param begin: (int) - start of range (inclusive)\n:param end: (int) - end of range (exclusive)\n:return: (io.deephaven.engine.rowset.impl.rsp.container.Container) the new container",
  "runOptimize": "Convert to RunContainers, when the result is smaller. Overridden by RunContainer to possibility switch from\n RunContainer to a smaller alternative. Overridden by BitmapContainer with a more efficient approach.\n\n:return: (io.deephaven.engine.rowset.impl.rsp.container.Container) the new container",
  "select": "**Incompatible overloads text - text from the first overload:**\n\nReturn the jth value\n\n*Overload 1*  \n  :param j: (int) - index of the value\n  :return: (short) the value\n  \n*Overload 2*  \n  :param startRank: (int) - rank for the start of the range\n  :param endRank: (int) - rank for the end of the range, exclusive\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) a new Container with all the values between ranks [startPos, endPos)",
  "selectRanges": "As select but for all the positions in a range.\n\n:param outValues: (io.deephaven.engine.rowset.impl.rsp.container.RangeConsumer) - accept is called in this consumer for each resulting range.\n:param inPositions: (io.deephaven.engine.rowset.impl.rsp.container.RangeIterator) - input iterator that provides the position ranges.",
  "set": "Return a new container with the short given as parameter added.\n\n:param x: (short) - a short to be added\n:return: (io.deephaven.engine.rowset.impl.rsp.container.Container) a new container with x added",
  "subsetOf": "*Overload 1*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.ArrayContainer) - Another container\n  :return: (boolean) true if every key in this container is also a key in x.\n  \n*Overload 2*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.BitmapContainer) - Another container\n  :return: (boolean) true if every key in this container is also a key in x.\n  \n*Overload 3*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.RunContainer) - Another container\n  :return: (boolean) true if every key in this container is also a key in x.",
  "toBitmapContainer": "Convert the current container to a BitmapContainer, if a conversion is needed. If the container is already a\n bitmap, the container is returned unchanged.\n \n When multiple container \"merge\" operations are done it might be more efficient to convert to bitmap first, and\n then at the end convert to the efficient container type, to avoid multiple container type conversions, since\n bitmap can always stay a bitmap.\n\n:return: (io.deephaven.engine.rowset.impl.rsp.container.BitmapContainer) a bitmap container",
  "toLargeContainer": ":return: io.deephaven.engine.rowset.impl.rsp.container.Container",
  "toString": ":return: java.lang.String",
  "trim": "If possible, recover wasted memory.",
  "unset": "Remove the short from this container. May create a new container.\n\n*Overload 1*  \n  :param x: (short) - to be removed\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) resulting container.\n  \n*Overload 2*  \n  :param x: short\n  :param positionHint: io.deephaven.engine.rowset.impl.rsp.container.PositionHint\n  :return: io.deephaven.engine.rowset.impl.rsp.container.Container",
  "xor": "Computes the bitwise XOR of this container with another (symmetric difference). This container as well as the\n provided container are left unaffected.\n\n*Overload 1*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.ArrayContainer) - Another container\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) aggregated container\n  \n*Overload 2*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.BitmapContainer) - Another container\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) aggregated container\n  \n*Overload 3*  \n  :param x: (io.deephaven.engine.rowset.impl.rsp.container.RunContainer) - Another container\n  :return: (io.deephaven.engine.rowset.impl.rsp.container.Container) aggregated container"
 },
 "path": "io.deephaven.engine.rowset.impl.rsp.container.SingletonContainer",
 "typeName": "class"
}