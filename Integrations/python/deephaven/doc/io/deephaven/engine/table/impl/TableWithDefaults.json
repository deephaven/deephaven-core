{
 "className": "io.deephaven.engine.table.impl.TableWithDefaults",
 "methods": {
  "absSumBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the sum of the absolute values for\n the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.api.Selectable...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :return: io.deephaven.engine.table.Table",
  "aggAllBy": "*Overload 1*  \n  :param spec: io.deephaven.api.agg.spec.AggSpec\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param spec: io.deephaven.api.agg.spec.AggSpec\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param spec: io.deephaven.api.agg.spec.AggSpec\n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.engine.table.Table",
  "aggBy": "*Overload 1*  \n  :param aggregation: io.deephaven.api.agg.Aggregation\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param aggregation: io.deephaven.api.agg.Aggregation\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param aggregation: io.deephaven.api.agg.Aggregation\n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :param aggregations: java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 5*  \n  :param aggregations: java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>\n  :return: io.deephaven.engine.table.Table",
  "aj": "**Incompatible overloads text - text from the first overload:**\n\nLooks up the columns in the rightTable that meet the match conditions in the columnsToMatch list. Matching is\n done exactly for the first n-1 columns and via a binary search for the last match pair. The columns of the\n original table are returned intact, together with all the columns from rightTable.\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (io.deephaven.engine.table.MatchPair[]) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (io.deephaven.engine.table.MatchPair[]) - A comma separated list with the columns from the left side that need to be added to the right\n          side as a result of the match.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :param asOfJoinRule: (io.deephaven.api.AsOfJoinRule) - The binary search operator for the last match pair.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<java.lang.String>) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 5*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the left side that need to be added to the right\n          side as a result of the match.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 6*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch",
  "apply": "Applies a function to this table.\n \n This is useful if you have a reference to a table or a proxy and want to run a series of operations against the\n table without each individual operation resulting in an RMI.\n\nNote: Java generics information - <R>\n\n:param function: (java.util.function.Function<io.deephaven.engine.table.Table,R>) - the function to run, its single argument will be this table\n:return: (R) the return value of function",
  "applyToAllBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups data according to groupByColumns and applies formulaColumn to each of columns not altered by the grouping\n operation.\n\n*Overload 1*  \n  :param formulaColumn: (java.lang.String) - Formula applied to each column\n  :param columnParamName: (java.lang.String) - The parameter name used as a placeholder for each column\n  :param groupByColumns: (java.util.Collection<? extendsio.deephaven.api.Selectable>) - The grouping columns as in Table.groupBy(Collection)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param formulaColumn: (java.lang.String) - Formula applied to each column, uses parameter each to refer to each colum it being\n          applied to\n  :param groupByColumns: (java.util.Collection<? extendsio.deephaven.api.Selectable>) - The grouping columns as in Table.groupBy(Collection)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param formulaColumn: (java.lang.String) - Formula applied to each column, uses parameter each to refer to each colum it being\n          applied to\n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table",
  "avgBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the average for the rest of the\n fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.api.Selectable...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :return: io.deephaven.engine.table.Table",
  "byteColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.engine.table.iterators.ByteColumnIterator",
  "characterColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.engine.table.iterators.CharacterColumnIterator",
  "close": "Release resources held by this table, possibly destructively. This may render the table unsuitable or unsafe for\n further use.",
  "coalesce": "Explicitly ensure that any work needed to make a table addressable, iterable, or queryable has been done, and\n return the coalesced child table if appropriate.\n\n:return: (io.deephaven.engine.table.Table) This table, or a fully-coalesced child",
  "columnIterator": "Note: Java generics information - <TYPE>\n\n:param columnName: java.lang.String\n:return: java.util.Iterator<TYPE>",
  "countBy": "*Overload 1*  \n  :param countColumnName: java.lang.String\n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param countColumnName: java.lang.String\n  :param groupByColumns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param countColumnName: java.lang.String\n  :return: io.deephaven.engine.table.Table",
  "dateTimeColumnAsNanos": ":param columnName: (java.lang.String) - name of column to convert from DateTime to nanos\n:return: (io.deephaven.engine.table.Table) The result of dateTimeColumnAsNanos(columnName, columnName).",
  "doubleColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.engine.table.iterators.DoubleColumnIterator",
  "dropColumnFormats": ":return: io.deephaven.engine.table.Table",
  "dropColumns": ":param columnNames: java.util.Collection<java.lang.String>\n:return: io.deephaven.engine.table.Table",
  "exactJoin": "**Incompatible overloads text - text from the first overload:**\n\nPerform an exact-join with the rightTable.\n\n \n Delegates to TableOperations.exactJoin(Object, Collection, Collection).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (io.deephaven.engine.table.Table) the exact-joined table\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to be added to the left\n          side as a result of the match.\n  :return: (io.deephaven.engine.table.Table) the exact-joined table\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (io.deephaven.engine.table.Table) the exact-joined table",
  "firstBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and retrieves the first for the rest of the\n fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.api.Selectable...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :return: io.deephaven.engine.table.Table",
  "floatColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.engine.table.iterators.FloatColumnIterator",
  "formatColumnWhere": ":param columnName: java.lang.String\n:param condition: java.lang.String\n:param formula: java.lang.String\n:return: io.deephaven.engine.table.Table",
  "formatRowWhere": ":param condition: java.lang.String\n:param formula: java.lang.String\n:return: io.deephaven.engine.table.Table",
  "getAttributes": "Get all attributes from this Table.\n\n:return: (java.util.Map<java.lang.String,java.lang.Object>) A map containing all attributes from this Table",
  "getColumn": ":param columnIndex: int\n:return: io.deephaven.engine.table.DataColumn",
  "getColumnSource": "Retrieves a ColumnSource and casts it to the target class clazz.\n\nNote: Java generics information - <T>\n\n:param sourceName: (java.lang.String) - The name of the column\n:param extend: java.lang.Class<?\n:return: (io.deephaven.engine.table.ColumnSource<T>) The column source for sourceName, parameterized by T",
  "getColumns": ":return: io.deephaven.engine.table.DataColumn[]",
  "getMeta": "Provides column metadata in Table form. Convenience method, behaves exactly the same as\n getDefinition().getColumnDefinitionsTable().\n\n:return: (io.deephaven.engine.table.Table) A Table of metadata about this Table's columns.",
  "groupBy": "*Overload 1*  \n  :param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param groupByColumns: java.lang.String...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :return: io.deephaven.engine.table.Table",
  "hasColumns": "**Incompatible overloads text - text from the first overload:**\n\nDetermines whether this Table contains a column for each string in the specified array of columnNames.\n\n*Overload 1*  \n  :param columnNames: (java.lang.String...) - The array of column names to be checked for inclusion in this table. Must not be null.\n  :return: (boolean) true if this Table contains a column for each and every string in the columnNames array;\n           false if any element of columnNames is not the name of a column in this table\n  \n*Overload 2*  \n  :param columnNames: (java.util.Collection<java.lang.String>) - The collection of column names to be checked for inclusion in this table. Must not be\n          null.\n  :return: (boolean) true if this Table contains a column for each and every string in the columnNames\n           collection; false if any element of columnNames is not the name of a column in\n           this table",
  "headBy": ":param nRows: long\n:param groupByColumnNames: java.util.Collection<java.lang.String>\n:return: io.deephaven.engine.table.Table",
  "integerColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.engine.table.iterators.IntegerColumnIterator",
  "isEmpty": "Returns true if this table has no rows (i.e. size() == 0).\n\n:return: (boolean) true if this table has no rows",
  "isFailed": ":return: (boolean) true if this table is in a failure state.",
  "join": "**Incompatible overloads text - text from the first overload:**\n\nPerform a cross join with the right table.\n \n Returns a table that is the cartesian product of left rows X right rows, with one column for each of the left\n table's columns, and one column corresponding to each of the right table's columns that are included in the\n columnsToAdd argument. The rows are ordered first by the left table then by the right table. If columnsToMatch is\n non-empty then the product is filtered by the supplied match conditions.\n \n To efficiently produce updates, the bits that represent a key for a given row are split into two. Unless\n specified, join reserves 16 bits to represent a right row. When there are too few bits to represent all of the\n right rows for a given aggregation group the table will shift a bit from the left side to the right side. The\n default of 16 bits was carefully chosen because it results in an efficient implementation to process live\n updates.\n \n An OutOfKeySpaceException is thrown when the total number of bits needed\n to express the result table exceeds that needed to represent Long.MAX_VALUE. There are a few work arounds: - If\n the left table is sparse, consider flattening the left table. - If there are no key-columns and the right table\n is sparse, consider flattening the right table. - If the maximum size of a right table's group is small, you can\n reserve fewer bits by setting numRightBitsToReserve on initialization.\n \n Note: If you can prove that a given group has at most one right-row then you should prefer using\n Table.naturalJoin(io.deephaven.engine.table.Table, io.deephaven.engine.table.MatchPair[], io.deephaven.engine.table.MatchPair[]).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification with zero key-columns and includes all right columns\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param numRightBitsToReserve: (int) - The number of bits to reserve for rightTable groups.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification with zero key-columns and includes all right columns\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and includes all non-key-columns from\n           the right table\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param numRightBitsToReserve: (int) - The number of bits to reserve for rightTable groups.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and includes all non-key-columns from\n           the right table\n  \n*Overload 5*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to be added to the left\n          side as a result of the match.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 6*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to be added to the left\n          side as a result of the match.\n  :param numRightBitsToReserve: (int) - The number of bits to reserve for rightTable groups.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 7*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (io.deephaven.engine.table.MatchPair[]) - An array of match pair conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n  :param columnsToAdd: (io.deephaven.engine.table.MatchPair[]) - An array of the columns from the right side that need to be added to the left side as a\n          result of the match.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 8*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 9*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :param numRightBitsToReserve: (int) - The number of bits to reserve for rightTable groups.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "lastBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and retrieves the last for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.api.Selectable...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :return: io.deephaven.engine.table.Table",
  "lazyUpdate": "*Overload 1*  \n  :param newColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param newColumns: java.lang.String...\n  :return: io.deephaven.engine.table.Table",
  "listenForUpdates": "Subscribe for updates to this table. listener will be invoked via the NotificationQueue\n associated with this Table.\n\n:param listener: (io.deephaven.engine.table.ShiftObliviousListener) - listener for updates",
  "longColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.engine.table.iterators.LongColumnIterator",
  "maxBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the max for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.api.Selectable...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>) }\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>) }\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>) }\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :return: io.deephaven.engine.table.Table",
  "medianBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the median for the rest of the\n fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.api.Selectable...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>) }\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>) }\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>) }\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :return: io.deephaven.engine.table.Table",
  "mergeAfter": "Merge this Table with others. All rows in this Table will appear after all rows in others. If\n Tables in others are the result of a prior merge operation, they may be expanded in an attempt\n to avoid deeply nested structures.\n\n:param others: (io.deephaven.engine.table.Table...) - The Tables to merge with\n:return: (io.deephaven.engine.table.Table) The merged Table",
  "mergeBefore": "Merge this Table with others. All rows in this Table will appear before all rows in others. If\n Tables in others are the result of a prior merge operation, they may be expanded in an attempt\n to avoid deeply nested structures.\n\n:param others: (io.deephaven.engine.table.Table...) - The Tables to merge with\n:return: (io.deephaven.engine.table.Table) The merged Table",
  "minBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the min for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.api.Selectable...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :return: io.deephaven.engine.table.Table",
  "moveColumns": "Produce a new table with the specified columns moved to the specified index. Column indices begin at 0.\n Columns can be renamed with the usual syntax, i.e. \"NewColumnName=OldColumnName\").\n\n:param index: (int) - The index to which the specified columns should be moved\n:param columnsToMove: (java.lang.String...) - The columns to move to the specified index (and, optionally, to rename)\n:return: (io.deephaven.engine.table.Table) The new table, with the columns rearranged as explained above",
  "moveColumnsDown": "Produce a new table with the specified columns moved to the rightmost position. Columns can be renamed with the\n usual syntax, i.e. \"NewColumnName=OldColumnName\").\n\n:param columnsToMove: (java.lang.String...) - The columns to move to the right (and, optionally, to rename)\n:return: (io.deephaven.engine.table.Table) The new table, with the columns rearranged as explained above Table.moveColumns(int, String...)",
  "moveColumnsUp": "Produce a new table with the specified columns moved to the leftmost position. Columns can be renamed with the\n usual syntax, i.e. \"NewColumnName=OldColumnName\").\n\n:param columnsToMove: (java.lang.String...) - The columns to move to the left (and, optionally, to rename)\n:return: (io.deephaven.engine.table.Table) The new table, with the columns rearranged as explained above Table.moveColumns(int, String...)",
  "naturalJoin": "**Incompatible overloads text - text from the first overload:**\n\nPerform a natural-join with the rightTable.\n\n \n Delegates to TableOperations.naturalJoin(Object, Collection, Collection).\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (io.deephaven.engine.table.Table) the natural-joined table\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the right side that need to be added to the left\n          side as a result of the match.\n  :return: (io.deephaven.engine.table.Table) the natural-joined table\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (io.deephaven.engine.table.Table) the natural-joined table",
  "partitionBy": "Create a TableMap from this table, keyed by the specified columns.\n\n \n The returned TableMap contains each row in this table in exactly one of the tables within the map. If you have\n exactly one key column the TableMap is keyed by the value in that column. If you have zero key columns, then the\n TableMap is keyed by io.deephaven.datastructures.util.SmartKey.EMPTY (and will contain this table as the\n value). If you have multiple key columns, then the TableMap is keyed by a\n io.deephaven.datastructures.util.SmartKey. The SmartKey will have one value for each of your column\n values, in the order specified by keyColumnNames.\n \n\n For example if you have a Table keyed by a String column named USym, and a DateTime column named Expiry; a value\n could be retrieved from the TableMap with\n tableMap.get(new SmartKey(\"SPY\";, DateTimeUtils.convertDateTime(\"2020-06-19T16:15:00 NY\"))). For a table\n with an Integer column named Bucket, you simply use the desired value as in tableMap.get(1).\n \n\n:param keyColumnNames: (java.lang.String...) - the name of the key columns to use.\n:return: (io.deephaven.engine.table.TableMap) a TableMap keyed by keyColumnNames",
  "raj": "**Incompatible overloads text - text from the first overload:**\n\nJust like .aj(), but the matching on the last column is in reverse order, so that you find the row after the\n given timestamp instead of the row before.\n \n Looks up the columns in the rightTable that meet the match conditions in the columnsToMatch list. Matching is\n done exactly for the first n-1 columns and via a binary search for the last match pair. The columns of the\n original table are returned intact, together with the all columns from rightTable.\n\n*Overload 1*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (io.deephaven.engine.table.MatchPair[]) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (io.deephaven.engine.table.MatchPair[]) - A comma separated list with the columns from the left side that need to be added to the right\n          side as a result of the match.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 2*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 3*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - The match pair conditions.\n  :param columnsToAdd: (java.util.Collection<? extendsio.deephaven.api.JoinAddition>) - The columns from the right side that need to be added to the left side as a result of the\n          match.\n  :param reverseAsOfJoinRule: (io.deephaven.api.ReverseAsOfJoinRule) - The binary search operator for the last match pair.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 4*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.util.Collection<java.lang.String>) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 5*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\")\n  :param columnsToAdd: (java.lang.String) - A comma separated list with the columns from the left side that need to be added to the right\n          side as a result of the match.\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd\n  \n*Overload 6*  \n  :param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n  :param columnsToMatch: (java.lang.String) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n          \"columnFoundInBoth\").\n  :return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch",
  "releaseCachedResources": "Attempt to release cached resources held by this table. Unlike Table.close(), this must not render the table\n unusable for subsequent read operations. Implementations should be sure to call\n super.releaseCachedResources().",
  "renameAllColumns": ":param renameFunction: java.util.function.UnaryOperator<java.lang.String>\n:return: io.deephaven.engine.table.Table",
  "renameColumns": "*Overload 1*  \n  :param columns: java.util.Collection<java.lang.String>\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.engine.table.Table",
  "rollup": "**Incompatible overloads text - text from the first overload:**\n\nCreate a rollup table.\n \n A rollup table aggregates all rows of the table.\n\n*Overload 1*  \n  :param aggregations: (java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>) - The aggregations to perform\n  :param columns: (java.util.Collection<java.lang.String>) - the columns to group by\n  :return: (io.deephaven.engine.table.Table) a hierarchical table with the rollup applied\n  \n*Overload 2*  \n  :param aggregations: (java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>) - The aggregations to perform\n  :param includeConstituents: (boolean) - set to true to include the constituent rows at the leaf level\n  :param columns: (java.util.Collection<java.lang.String>) - the columns to group by\n  :return: (io.deephaven.engine.table.Table) a hierarchical table with the rollup applied\n  \n*Overload 3*  \n  :param aggregations: (java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>) - The aggregations to perform\n  :param columns: (java.lang.String...) - the columns to group by\n  :return: (io.deephaven.engine.table.Table) a hierarchical table with the rollup applied\n  \n*Overload 4*  \n  :param aggregations: (java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>) - The aggregations to perform\n  :param includeConstituents: (boolean) - set to true to include the constituent rows at the leaf level\n  :param columns: (java.lang.String...) - the columns to group by\n  :return: (io.deephaven.engine.table.Table) a hierarchical table with the rollup applied\n  \n*Overload 5*  \n  :param aggregations: (java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>) - The aggregations to perform\n  :param columns: (io.deephaven.api.Selectable...) - the columns to group by\n  :return: (io.deephaven.engine.table.Table) a hierarchical table with the rollup applied\n  \n*Overload 6*  \n  :param aggregations: (java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>) - The aggregations to perform\n  :return: (io.deephaven.engine.table.Table) a hierarchical table with the rollup applied\n  \n*Overload 7*  \n  :param aggregations: (java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>) - The aggregations to perform\n  :param includeConstituents: (boolean) - set to true to include the constituent rows at the leaf level\n  :return: (io.deephaven.engine.table.Table) a hierarchical table with the rollup applied",
  "select": "*Overload 1*  \n  :param columns: io.deephaven.api.Selectable...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :return: io.deephaven.engine.table.Table",
  "selectDistinct": "*Overload 1*  \n  :param columns: io.deephaven.api.Selectable...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :return: io.deephaven.engine.table.Table",
  "shortColumnIterator": ":param columnName: java.lang.String\n:return: io.deephaven.engine.table.iterators.ShortColumnIterator",
  "sizeForInstrumentation": ":return: (long) Size if it is currently known without subsequent steps to coalesce the Table, else\n         null",
  "snapshot": "**Incompatible overloads text - text from the first overload:**\n\nSnapshot baseTable, triggered by this table, and return a new table as a result.\n\n \nthis table is the triggering table, i.e. the table whose change events cause a new snapshot to be taken.\n The result table includes a \"snapshot key\" which is a subset (possibly all) of this table's columns. The\n remaining columns in the result table come from baseTable, the table being snapshotted.\n\n*Overload 1*  \n  :param baseTable: (io.deephaven.engine.table.Table) - The table to be snapshotted\n  :param stampColumns: (java.lang.String...) - The columns forming the \"snapshot key\", i.e. some subset of this Table's columns to be\n          included in the result at snapshot time. As a special case, an empty stampColumns is taken to mean\n          \"include all columns\".\n  :return: (io.deephaven.engine.table.Table) The result table\n  \n*Overload 2*  \n  :param baseTable: (io.deephaven.engine.table.Table) - The table to be snapshotted\n  :param doInitialSnapshot: (boolean) - Take the first snapshot now (otherwise wait for a change event)\n  :param stampColumns: (java.util.Collection<io.deephaven.api.ColumnName>) - The columns forming the \"snapshot key\", i.e. some subset of this Table's columns to be\n          included in the result at snapshot time. As a special case, an empty stampColumns is taken to mean\n          \"include all columns\".\n  :return: (io.deephaven.engine.table.Table) The result table",
  "snapshotIncremental": ":param rightTable: io.deephaven.engine.table.Table\n:param stampColumns: java.lang.String...\n:return: io.deephaven.engine.table.Table",
  "sort": ":param columnsToSortBy: java.lang.String...\n:return: io.deephaven.engine.table.Table",
  "sortDescending": ":param columnsToSortBy: java.lang.String...\n:return: io.deephaven.engine.table.Table",
  "stdBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the standard deviation for the rest\n of the fields\n\n*Overload 1*  \n  :param groupByColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :return: io.deephaven.engine.table.Table",
  "sumBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the sum for the rest of the fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.api.Selectable...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :return: io.deephaven.engine.table.Table",
  "tailBy": ":param nRows: long\n:param groupByColumnNames: java.util.Collection<java.lang.String>\n:return: io.deephaven.engine.table.Table",
  "ungroup": "*Overload 1*  \n  :param columnsToUngroup: java.lang.String...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param nullFill: boolean\n  :return: io.deephaven.engine.table.Table",
  "ungroupAllBut": ":param columnsNotToUngroup: java.lang.String...\n:return: io.deephaven.engine.table.Table",
  "update": "*Overload 1*  \n  :param newColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param newColumns: java.lang.String...\n  :return: io.deephaven.engine.table.Table",
  "updateView": "*Overload 1*  \n  :param newColumns: io.deephaven.api.Selectable...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param newColumns: java.lang.String...\n  :return: io.deephaven.engine.table.Table",
  "varBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the variance for the rest of the\n fields\n\n*Overload 1*  \n  :param groupByColumns: (io.deephaven.api.Selectable...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :return: io.deephaven.engine.table.Table",
  "view": "*Overload 1*  \n  :param columns: io.deephaven.api.Selectable...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param columns: java.lang.String...\n  :return: io.deephaven.engine.table.Table",
  "wavgBy": "**Incompatible overloads text - text from the first overload:**\n\nGroups the data column according to groupByColumns and computes the weighted average using\n weightColumn for the rest of the fields\n\n*Overload 1*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :param groupByColumns: (io.deephaven.api.Selectable...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :return: io.deephaven.engine.table.Table",
  "where": "*Overload 1*  \n  :param filters: io.deephaven.api.filter.Filter...\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param filters: java.lang.String...\n  :return: io.deephaven.engine.table.Table",
  "whereIn": "Filters this table based on the set of values in the rightTable.\n\n \n Delegates to TableOperations.whereIn(Object, Collection).\n\n:param rightTable: (io.deephaven.engine.table.Table) - the filtering table.\n:param columnsToMatch: (java.lang.String...) - the columns to match between the two tables\n:return: (io.deephaven.engine.table.Table) a new table filtered on right table",
  "whereNotIn": "Filters this table based on the set of values not in the rightTable.\n\n \n Delegates to TableOperations.whereNotIn(Object, Collection).\n\n:param rightTable: (io.deephaven.engine.table.Table) - the filtering table.\n:param columnsToMatch: (java.lang.String...) - the columns to match between the two tables\n:return: (io.deephaven.engine.table.Table) a new table filtered on right table",
  "withColumnDescription": "Add a description for a specific column. You may use Table.withColumnDescription(Map) to set several\n descriptions at once.\n\n:param column: (java.lang.String) - the name of the column\n:param description: (java.lang.String) - the column description\n:return: (io.deephaven.engine.table.Table) a copy of the source table with the description applied",
  "wouldMatch": ":param expressions: java.lang.String...\n:return: io.deephaven.engine.table.Table",
  "wsumBy": "**Incompatible overloads text - text from the first overload:**\n\nComputes the weighted sum for all rows in the table using weightColumn for the rest of the fields\n \n If the weight column is a floating point type, all result columns will be doubles. If the weight column is an\n integral type, all integral input columns will have long results and all floating point input columns will have\n double results.\n\n*Overload 1*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :param groupByColumns: (io.deephaven.api.Selectable...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 2*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :param groupByColumns: (java.lang.String...) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 4*  \n  :param weightColumn: (java.lang.String) - the column to use for the weight\n  :param groupByColumns: (java.util.Collection<java.lang.String>) - The grouping columns as in Table.groupBy(java.util.Collection<? extends io.deephaven.api.Selectable>)\n  :return: io.deephaven.engine.table.Table"
 },
 "path": "io.deephaven.engine.table.impl.TableWithDefaults",
 "text": "Sub-interface to capture default methods rom Table.",
 "typeName": "interface"
}