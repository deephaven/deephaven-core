{
 "className": "io.deephaven.engine.table.impl.util.ChunkUtils",
 "methods": {
  "contains": "*Overload 1*  \n  :param chunk: io.deephaven.chunk.CharChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :param value: char\n  :return: boolean\n  \n*Overload 2*  \n  :param chunk: io.deephaven.chunk.ByteChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :param value: byte\n  :return: boolean\n  \n*Overload 3*  \n  :param chunk: io.deephaven.chunk.ShortChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :param value: short\n  :return: boolean\n  \n*Overload 4*  \n  :param chunk: io.deephaven.chunk.IntChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :param value: int\n  :return: boolean\n  \n*Overload 5*  \n  :param chunk: io.deephaven.chunk.LongChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :param value: long\n  :return: boolean\n  \n*Overload 6*  \n  :param chunk: io.deephaven.chunk.FloatChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :param value: float\n  :return: boolean\n  \n*Overload 7*  \n  :param chunk: io.deephaven.chunk.DoubleChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :param value: double\n  :return: boolean\n  \n*Overload 8*  \n  :param chunk: io.deephaven.chunk.ObjectChunk<?,? extendsio.deephaven.chunk.attributes.Any>\n  :param value: java.lang.Object\n  :return: boolean",
  "copyData": "Copy data from sources to destinations for the provided source and destination keys.\n\n Sources and destinations must not overlap.\n\n*Overload 1*  \n  :param src: (io.deephaven.engine.table.ChunkSource.WithPrev<? extendsio.deephaven.chunk.attributes.Values>) - The source of the data.\n  :param srcAllKeys: (io.deephaven.engine.rowset.RowSequence) - The source keys.\n  :param dest: (io.deephaven.engine.table.WritableColumnSource<?>) - The destination of the data (dest != src).\n  :param destAllKeys: (io.deephaven.engine.rowset.RowSequence) - The destination keys. It is ok for srcAllKeys == destAllKeys.\n  :param usePrev: (boolean) - Should we read previous values from src\n  \n*Overload 2*  \n  :param sources: (io.deephaven.engine.table.ChunkSource.WithPrev<? extendsio.deephaven.chunk.attributes.Values>[]) - The sources of the data, parallel with destinations\n  :param srcAllKeys: (io.deephaven.engine.rowset.RowSequence) - The source keys.\n  :param destinations: (io.deephaven.engine.table.WritableColumnSource<?>[]) - The destinations, parallel with sources, of the data (dest != src).\n  :param destAllKeys: (io.deephaven.engine.rowset.RowSequence) - The destination keys. It is ok for srcAllKeys == destAllKeys.\n  :param usePrev: (boolean) - Should we read previous values from src",
  "dumpChunk": "*Overload 1*  \n  :param chunk: io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Any>\n  :return: java.lang.String\n  \n*Overload 2*  \n  :param chunk: io.deephaven.chunk.CharChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :return: java.lang.String\n  \n*Overload 3*  \n  :param chunk: io.deephaven.chunk.ByteChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :return: java.lang.String\n  \n*Overload 4*  \n  :param chunk: io.deephaven.chunk.ShortChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :return: java.lang.String\n  \n*Overload 5*  \n  :param chunk: io.deephaven.chunk.IntChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :return: java.lang.String\n  \n*Overload 6*  \n  :param chunk: io.deephaven.chunk.LongChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :return: java.lang.String\n  \n*Overload 7*  \n  :param chunk: io.deephaven.chunk.FloatChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :return: java.lang.String\n  \n*Overload 8*  \n  :param chunk: io.deephaven.chunk.DoubleChunk<? extendsio.deephaven.chunk.attributes.Any>\n  :return: java.lang.String\n  \n*Overload 9*  \n  :param chunk: io.deephaven.chunk.ObjectChunk<?,? extendsio.deephaven.chunk.attributes.Any>\n  :return: java.lang.String",
  "extractKeyStringFromChunk": "Produce a pretty key for error messages from an element within parallel chunks.\n\n*Overload 1*  \n  :param keyChunkType: io.deephaven.chunk.ChunkType\n  :param chunk: io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>\n  :param chunkPosition: int\n  :return: java.lang.String\n  \n*Overload 2*  \n  :param chunk: io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>\n  :param chunkPosition: int\n  :return: java.lang.String",
  "extractKeyStringFromChunks": "Produce a pretty key for error messages from an element within parallel chunks.\n\n:param keyChunkTypes: io.deephaven.chunk.ChunkType[]\n:param chunks: io.deephaven.chunk.Chunk<io.deephaven.chunk.attributes.Values>[]\n:param chunkPosition: int\n:return: java.lang.String",
  "fillInOrder": "Fill inOrderChunk with consecutive integers from 0..size() - 1.\n\n*Overload 1*  \n  Note: Java generics information - <T extends io.deephaven.chunk.attributes.Any>\n  \n  :param inOrderChunk: (io.deephaven.chunk.WritableIntChunk<T>) - the chunk to fill\n  \n*Overload 2*  \n  Note: Java generics information - <T extends io.deephaven.chunk.attributes.Any>\n  \n  :param inOrderChunk: (io.deephaven.chunk.WritableLongChunk<T>) - the chunk to fill",
  "fillWithNullValue": "Note: Java generics information - <T extends io.deephaven.chunk.attributes.Values>\n\n:param dest: io.deephaven.engine.table.ChunkSink<T>\n:param allKeys: io.deephaven.engine.rowset.RowSequence",
  "makeInOrderIntChunk": "Make a chunk of integers in order.\n\nNote: Java generics information - <T extends io.deephaven.chunk.attributes.Any>\n\n:param chunkSize: (int) - the size of the chunk to make\n:return: (io.deephaven.chunk.WritableIntChunk<T>) a chunk of integers from 0 to chunkSize - 1"
 },
 "path": "io.deephaven.engine.table.impl.util.ChunkUtils",
 "typeName": "class"
}