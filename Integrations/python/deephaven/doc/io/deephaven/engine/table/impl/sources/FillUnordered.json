{
 "className": "io.deephaven.engine.table.impl.sources.FillUnordered",
 "methods": {
  "fillChunkUnordered": "Populates a contiguous portion of the given destination chunk with data corresponding to the keys from the given\n LongChunk.\n\n:param context: (io.deephaven.engine.table.ChunkSource.FillContext) - A context containing all mutable/state related data used in retrieving the Chunk.\n:param dest: (io.deephaven.chunk.WritableChunk<? superio.deephaven.chunk.attributes.Values>) - The chunk to be populated according to keys\n:param keys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - A chunk of individual, not assumed to be ordered keys to be fetched",
  "fillPrevChunkUnordered": "Populates a contiguous portion of the given destination chunk with prev data corresponding to the keys from the\n given LongChunk.\n\n:param context: (io.deephaven.engine.table.ChunkSource.FillContext) - A context containing all mutable/state related data used in retrieving the Chunk.\n:param dest: (io.deephaven.chunk.WritableChunk<? superio.deephaven.chunk.attributes.Values>) - The chunk to be populated according to keys\n:param keys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - A chunk of individual, not assumed to be ordered keys to be fetched",
  "providesFillUnordered": "Returns true if this column source can efficiently provide an unordered fill.\n\n If this method returns false, then fillChunkUnordered and fillPrevChunkUnordered may throw an\n UnsupportedOperationException.\n\n*Overload 1*  \n  :return: (boolean) if this column source can provide an unordered fill\n  \n*Overload 2*  \n  :param chunkSource: io.deephaven.engine.table.ChunkSource<?>\n  :return: boolean"
 },
 "path": "io.deephaven.engine.table.impl.sources.FillUnordered",
 "typeName": "interface"
}