{
 "className": "io.deephaven.engine.table.impl.sources.immutable.ImmutableLongArraySource",
 "methods": {
  "allowsReinterpret": "Test if a reinterpret call will succeed.\n\nNote: Java generics information - <ALTERNATE_DATA_TYPE>\n\n:param alternateDataType: (java.lang.Class<ALTERNATE_DATA_TYPE>) - The alternative type to consider\n:return: (boolean) If a reinterpret on this column source with the supplied alternateDataType will succeed.",
  "ensureCapacity": "Ensure that this WritableColumnSource can accept row keys in range [0, capacity).\n\n:param capacity: (long) - The new minimum capacity\n:param nullFilled: (boolean) - Whether data should be \"null-filled\". If true, get operations at row keys that have not been\n        set will return the appropriate null value; otherwise such gets produce undefined results.",
  "fillChunk": "Populates the given destination chunk with data corresponding to the keys from the given RowSequence.\n\n:param context: (io.deephaven.engine.table.ChunkSource.FillContext) - A context containing all mutable/state related data used in retrieving the Chunk.\n:param destination: (io.deephaven.chunk.WritableChunk<? superio.deephaven.chunk.attributes.Values>) - The chunk to be populated according to rowSequence. No assumptions shall be made about\n        the size of the chunk shall be made. The chunk will be populated from position [0,rowSequence.size()).\n:param rowSequence: (io.deephaven.engine.rowset.RowSequence) - An RowSequence representing the keys to be fetched",
  "fillChunkUnordered": "Populates a contiguous portion of the given destination chunk with data corresponding to the keys from the given\n LongChunk.\n\n:param context: (io.deephaven.engine.table.ChunkSource.FillContext) - A context containing all mutable/state related data used in retrieving the Chunk.\n:param dest: (io.deephaven.chunk.WritableChunk<? superio.deephaven.chunk.attributes.Values>) - The chunk to be populated according to keys\n:param keys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - A chunk of individual, not assumed to be ordered keys to be fetched",
  "fillFromChunk": "Our default, inefficient, implementation. Inheritors who care should provide a better implementation.\n\n:param context: (io.deephaven.engine.table.ChunkSink.FillFromContext) - A context containing all mutable/state related data used in writing the Chunk.\n:param src: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - The source of the data rowSequence\n:param rowSequence: (io.deephaven.engine.rowset.RowSequence) - An RowSequence representing the keys to be written",
  "fillFromChunkUnordered": "Fills the ChunkSink with data from the source, with data corresponding to the keys from the given key chunk.\n\n:param context: (io.deephaven.engine.table.ChunkSink.FillFromContext) - A context containing all mutable/state related data used in writing the Chunk.\n:param src: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - The source of the data RowSequence\n:param keys: (io.deephaven.chunk.LongChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>) - A LongChunk representing the keys to be written",
  "fillPrevChunk": "Populates the given destination chunk with data corresponding to the keys from the given RowSequence.\n\n:param context: (io.deephaven.engine.table.ChunkSource.FillContext) - A context containing all mutable/state related data used in retrieving the Chunk.\n:param destination: (io.deephaven.chunk.WritableChunk<? superio.deephaven.chunk.attributes.Values>) - The chunk to be populated according to rowSequence. No assumptions shall be made\n        about the size of the chunk shall be made. The chunk will be populated from position\n        [0,rowSequence.size()).\n:param rowSequence: (io.deephaven.engine.rowset.RowSequence) - An RowSequence representing the keys to be fetched",
  "fillPrevChunkUnordered": "Populates a contiguous portion of the given destination chunk with prev data corresponding to the keys from the\n given LongChunk.\n\n:param context: (io.deephaven.engine.table.ChunkSource.FillContext) - A context containing all mutable/state related data used in retrieving the Chunk.\n:param dest: (io.deephaven.chunk.WritableChunk<? superio.deephaven.chunk.attributes.Values>) - The chunk to be populated according to keys\n:param keys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - A chunk of individual, not assumed to be ordered keys to be fetched",
  "getChunk": "**Incompatible overloads text - text from the first overload:**\n\nReturns a chunk of data corresponding to the keys from the given RowSequence.\n\n*Overload 1*  \n  :param context: (io.deephaven.engine.table.ChunkSource.GetContext) - A context containing all mutable/state related data used in retrieving the Chunk. In particular,\n          the Context may be used to provide a Chunk data pool\n  :param rowSequence: (io.deephaven.engine.rowset.RowSequence) - An RowSequence representing the keys to be fetched\n  :return: (io.deephaven.chunk.Chunk<? extends io.deephaven.chunk.attributes.Values>) A chunk of data corresponding to the keys from the given RowSequence\n  \n*Overload 2*  \n  :param context: (io.deephaven.engine.table.ChunkSource.GetContext) - A context containing all mutable/state related data used in retrieving the Chunk. In particular,\n          the Context may be used to provide a Chunk data pool\n  :param firstKey: (long) - The beginning key (inclusive) of the range to fetch in the chunk\n  :param lastKey: (long) - The last key (inclusive) of the range to fetch in the chunk\n  :return: io.deephaven.chunk.Chunk<? extends io.deephaven.chunk.attributes.Values>",
  "getLong": ":param index: long\n:return: long",
  "getPrevChunk": "**Incompatible overloads text - text from the first overload:**\n\nReturns a chunk of previous data corresponding to the keys from the given RowSequence.\n\n*Overload 1*  \n  :param context: (io.deephaven.engine.table.ChunkSource.GetContext) - A context containing all mutable/state related data used in retrieving the Chunk. In\n          particular, the Context may be used to provide a Chunk data pool\n  :param rowSequence: (io.deephaven.engine.rowset.RowSequence) - An RowSequence representing the keys to be fetched\n  :return: (io.deephaven.chunk.Chunk<? extends io.deephaven.chunk.attributes.Values>) A chunk of data corresponding to the keys from the given RowSequence\n  \n*Overload 2*  \n  :param context: io.deephaven.engine.table.ChunkSource.GetContext\n  :param firstKey: long\n  :param lastKey: long\n  :return: io.deephaven.chunk.Chunk<? extends io.deephaven.chunk.attributes.Values>",
  "getUnsafe": ":param index: long\n:return: long",
  "providesFillUnordered": "Returns true if this column source can efficiently provide an unordered fill.\n\n If this method returns false, then fillChunkUnordered and fillPrevChunkUnordered may throw an\n UnsupportedOperationException.\n\n:return: (boolean) if this column source can provide an unordered fill",
  "resetWritableChunkToBackingStore": "Resets the given chunk to provide a write-through reference to our backing array.\n \n Note: This is unsafe to use if previous tracking has been enabled!\n\n:param chunk: (io.deephaven.chunk.ResettableWritableChunk<?>) - the writable chunk to reset to our backing array.\n:param position: (long) - position that we require\n:return: (long) the first position addressable by the chunk",
  "resetWritableChunkToBackingStoreSlice": "Resets the given chunk to provide a write-through reference to our backing array.\n \n Note: This is unsafe to use if previous tracking has been enabled!\n\n:param chunk: (io.deephaven.chunk.ResettableWritableChunk<?>) - the writable chunk to reset to a slice of our backing array.\n:param position: (long) - position of the first value in the returned chunk\n:return: (long) the capacity of the returned chunk",
  "set": ":param key: long\n:param value: long"
 },
 "path": "io.deephaven.engine.table.impl.sources.immutable.ImmutableLongArraySource",
 "text": "Simple flat array source that supports fillFromChunk for initial creation.\n\n No previous value tracking is permitted, so this column source is only useful as a flat static source.\n\n A single array backs the result, so getChunk calls with contiguous ranges should always be able to return a\n reference to the backing store without an array copy.  The immediate consequence is that you may not create\n sources that have a capacity larger than the maximum capacity of an array.\n\n If your size is greater than the maximum capacity of an array, prefer Immutable2DLongArraySource.",
 "typeName": "class"
}