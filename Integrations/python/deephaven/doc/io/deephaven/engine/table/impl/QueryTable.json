{
 "className": "io.deephaven.engine.table.impl.QueryTable",
 "methods": {
  "aggAllBy": ":param spec: io.deephaven.api.agg.spec.AggSpec\n:param groupByColumns: io.deephaven.api.Selectable...\n:return: io.deephaven.engine.table.Table",
  "aggBy": ":param aggregations: java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>\n:param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n:return: io.deephaven.engine.table.Table",
  "aj": "Looks up the columns in the rightTable that meet the match conditions in the columnsToMatch list. Matching is\n done exactly for the first n-1 columns and via a binary search for the last match pair. The columns of the\n original table are returned intact, together with the columns from rightTable defined in a comma separated list\n \"columnsToAdd\"\n\n:param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n:param columnsToMatch: (io.deephaven.engine.table.MatchPair[]) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n        \"columnFoundInBoth\")\n:param columnsToAdd: (io.deephaven.engine.table.MatchPair[]) - A comma separated list with the columns from the left side that need to be added to the right\n        side as a result of the match.\n:param asOfMatchRule: io.deephaven.engine.table.Table.AsOfMatchRule\n:return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "apply": "Applies a function to this table.\n \n This is useful if you have a reference to a table or a proxy and want to run a series of operations against the\n table without each individual operation resulting in an RMI.\n\nNote: Java generics information - <R>\n\n:param function: (java.util.function.Function<io.deephaven.engine.table.Table,R>) - the function to run, its single argument will be this table\n:return: (R) the return value of function",
  "copy": "Copies this table, but with a new set of attributes.\n\n*Overload 1*  \n  :return: (io.deephaven.engine.table.Table) an identical table; but with a new set of attributes\n  \n*Overload 2*  \n  :param shouldCopy: java.util.function.Predicate<java.lang.String>\n  :return: io.deephaven.engine.table.Table\n  \n*Overload 3*  \n  :param definition: io.deephaven.engine.table.TableDefinition\n  :param shouldCopy: java.util.function.Predicate<java.lang.String>\n  :return: io.deephaven.engine.table.Table",
  "countBy": ":param countColumnName: java.lang.String\n:param groupByColumns: io.deephaven.api.Selectable...\n:return: io.deephaven.engine.table.Table",
  "dateTimeColumnAsNanos": "Produce a new table with the same columns as this table, but with a new column presenting the specified DateTime\n column as a Long column (with each DateTime represented instead as the corresponding number of nanos since the\n epoch).\n \n NOTE: This is a really just an updateView(), and behaves accordingly for column ordering and (re)placement. This\n doesn't work on data that has been brought fully into memory (e.g. via select()). Use a view instead.\n\n:param dateTimeColumnName: (java.lang.String) - Name of date time column\n:param nanosColumnName: (java.lang.String) - Name of nanos column\n:return: (io.deephaven.engine.table.Table) The new table, constructed as explained above.",
  "dropColumns": ":param columnNames: java.lang.String...\n:return: io.deephaven.engine.table.Table",
  "exactJoin": ":param table: io.deephaven.engine.table.Table\n:param columnsToMatch: io.deephaven.engine.table.MatchPair[]\n:param columnsToAdd: io.deephaven.engine.table.MatchPair[]\n:return: io.deephaven.engine.table.Table",
  "flatten": "Creates a version of this table with a flat RowSet.\n\n:return: io.deephaven.engine.table.Table",
  "formatColumns": ":param columnFormats: java.lang.String...\n:return: io.deephaven.engine.table.Table",
  "getColumn": ":param columnName: java.lang.String\n:return: io.deephaven.engine.table.DataColumn",
  "getColumnSource": "Retrieves a ColumnSource. It is conveniently cast to @{code ColumnSource} using the type that caller\n expects. This differs from Table.getColumnSource(String, Class) which uses the provided Class object\n to verify that the data type is a subclass of the expected class.\n\nNote: Java generics information - <T>\n\n:param sourceName: (java.lang.String) - The name of the column\n:return: (io.deephaven.engine.table.ColumnSource<T>) The column source for sourceName, parameterized by T",
  "getColumnSourceMap": ":return: java.util.Map<java.lang.String,io.deephaven.engine.table.ColumnSource<?>>",
  "getColumnSources": ":return: java.util.Collection<? extends io.deephaven.engine.table.ColumnSource<?>>",
  "getModifiedColumnSetForUpdates": "Producers of tables should use the modified column set embedded within the table for their result.\n\n You must not mutate the result of this method if you are not generating the updates for this table. Callers\n should not rely on the dirty state of this modified column set.\n\n:return: (io.deephaven.engine.table.ModifiedColumnSet) the modified column set for this table",
  "getRecord": ":param rowNo: long\n:param columnNames: java.lang.String...\n:return: java.lang.Object[]",
  "getResult": ":param operation: io.deephaven.engine.table.impl.QueryTable.Operation<T>\n:return: T",
  "getRowSet": ":return: (io.deephaven.engine.rowset.TrackingRowSet) The TrackingRowSet that exposes the row keys present in this Table",
  "getSubTable": "Get a Table that contains a sub-set of the rows from this.\n\n*Overload 1*  \n  :param rowSet: (io.deephaven.engine.rowset.TrackingRowSet) - The row set for the result.\n  :return: (io.deephaven.engine.table.impl.QueryTable) A new sub-table\n  \n*Overload 2*  \n  :param rowSet: io.deephaven.engine.rowset.TrackingRowSet\n  :param resultModifiedColumnSet: io.deephaven.engine.table.ModifiedColumnSet\n  :param parents: java.lang.Object...\n  :return: io.deephaven.engine.table.impl.QueryTable",
  "head": ":param size: long\n:return: io.deephaven.engine.table.Table",
  "headBy": ":param nRows: long\n:param groupByColumns: java.lang.String...\n:return: io.deephaven.engine.table.Table",
  "headPct": "Provides a head that selects a dynamic number of rows based on a percent.\n\n:param percent: (double) - the fraction of the table to return (0..1), the number of rows will be rounded up. For example if\n        there are 3 rows, headPct(50) returns the first two rows.\n:return: io.deephaven.engine.table.Table",
  "isFlat": "Return true if this table is guaranteed to be flat. The RowSet of a flat table will be from 0...numRows-1.\n\n:return: boolean",
  "join": "Perform a cross join with the right table.\n \n Returns a table that is the cartesian product of left rows X right rows, with one column for each of the left\n table's columns, and one column corresponding to each of the right table's columns that are included in the\n columnsToAdd argument. The rows are ordered first by the left table then by the right table. If columnsToMatch is\n non-empty then the product is filtered by the supplied match conditions.\n \n To efficiently produce updates, the bits that represent a key for a given row are split into two. Unless\n specified, join reserves 16 bits to represent a right row. When there are too few bits to represent all of the\n right rows for a given aggregation group the table will shift a bit from the left side to the right side. The\n default of 16 bits was carefully chosen because it results in an efficient implementation to process live\n updates.\n \n An OutOfKeySpaceException is thrown when the total number of bits needed\n to express the result table exceeds that needed to represent Long.MAX_VALUE. There are a few work arounds: - If\n the left table is sparse, consider flattening the left table. - If there are no key-columns and the right table\n is sparse, consider flattening the right table. - If the maximum size of a right table's group is small, you can\n reserve fewer bits by setting numRightBitsToReserve on initialization.\n \n Note: If you can prove that a given group has at most one right-row then you should prefer using\n Table.naturalJoin(io.deephaven.engine.table.Table, io.deephaven.engine.table.MatchPair[], io.deephaven.engine.table.MatchPair[]).\n\n:param rightTableCandidate: (io.deephaven.engine.table.Table) - The right side table on the join.\n:param columnsToMatch: (io.deephaven.engine.table.MatchPair[]) - An array of match pair conditions (\"leftColumn=rightColumn\" or \"columnFoundInBoth\")\n:param columnsToAdd: (io.deephaven.engine.table.MatchPair[]) - An array of the columns from the right side that need to be added to the left side as a\n        result of the match.\n:param numRightBitsToReserve: (int) - The number of bits to reserve for rightTable groups.\n:return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "lazyUpdate": "Compute column formulas on demand.\n\n \n Lazy update defers computation until required for a set of values, and caches the results for a set of input\n values. This uses less RAM than an update statement when you have a smaller set of unique values. Less\n computation than an updateView is needed, because the results are saved in a cache.\n \n\n If you have many unique values, you should instead use an update statement, which will have more memory efficient\n structures. Values are never removed from the lazyUpdate cache, so it should be used judiciously on a ticking\n table.\n \n\n:param newColumns: (java.util.Collection<? extendsio.deephaven.api.Selectable>) - the columns to add\n:return: (io.deephaven.engine.table.Table) a new Table with the columns added; to be computed on demand",
  "memoizeResult": "Saves a weak reference to the result of the given operation.\n\nNote: Java generics information - <R>\n\n:param memoKey: (io.deephaven.engine.table.impl.MemoizedOperationKey) - a complete description of the operation, if null no memoization is performed\n:param operation: (java.util.function.Supplier<R>) - a supplier for the result\n:return: (R) either the cached or newly generated result",
  "moveColumns": ":param index: int\n:param moveToEnd: boolean\n:param columnsToMove: java.lang.String...\n:return: io.deephaven.engine.table.Table",
  "naturalJoin": ":param rightTable: io.deephaven.engine.table.Table\n:param columnsToMatch: io.deephaven.engine.table.MatchPair[]\n:param columnsToAdd: io.deephaven.engine.table.MatchPair[]\n:return: io.deephaven.engine.table.Table",
  "newModifiedColumnSet": "Create a ModifiedColumnSet to use when propagating updates from this table.\n\n:param columnNames: (java.lang.String...) - The columns that should belong to the resulting set\n:return: (io.deephaven.engine.table.ModifiedColumnSet) The resulting ModifiedColumnSet for the given columnNames",
  "newModifiedColumnSetIdentityTransformer": "**Incompatible overloads text - text from the first overload:**\n\nCreate a transformer that uses an identity mapping from one ColumnSourceMap to another. The two CSMs must have\n equivalent column names and column ordering.\n\n*Overload 1*  \n  :param newColumns: (java.util.Map<java.lang.String,io.deephaven.engine.table.ColumnSource<?>>) - the column source map for result table\n  :return: (io.deephaven.engine.table.ModifiedColumnSet.Transformer) a simple Transformer that makes a cheap, but CSM compatible copy\n  \n*Overload 2*  \n  :param other: (io.deephaven.engine.table.Table) - the result table\n  :return: (io.deephaven.engine.table.ModifiedColumnSet.Transformer) a simple Transformer that makes a cheap, but CSM compatible copy",
  "newModifiedColumnSetTransformer": "**Incompatible overloads text - text from the first overload:**\n\nCreate a ModifiedColumnSet.Transformer that can be used to propagate dirty columns from this table to\n listeners of the provided resultTable.\n\n*Overload 1*  \n  :param resultTable: (io.deephaven.engine.table.impl.QueryTable) - the destination table\n  :param columnNames: (java.lang.String...) - the columns that map one-to-one with the result table\n  :return: (io.deephaven.engine.table.ModifiedColumnSet.Transformer) a transformer that passes dirty details via an identity mapping\n  \n*Overload 2*  \n  :param resultTable: (io.deephaven.engine.table.impl.QueryTable) - the destination table\n  :param matchPairs: (io.deephaven.engine.table.MatchPair...) - the columns that map one-to-one with the result table\n  :return: (io.deephaven.engine.table.ModifiedColumnSet.Transformer) a transformer that passes dirty details via an identity mapping\n  \n*Overload 3*  \n  :param columnNames: (java.lang.String[]) - the source columns\n  :param columnSets: (io.deephaven.engine.table.ModifiedColumnSet[]) - the destination columns in the convenient ModifiedColumnSet form\n  :return: (io.deephaven.engine.table.ModifiedColumnSet.Transformer) a transformer that knows the dirty details",
  "partitionBy": "Create a TableMap from this table, keyed by the specified columns.\n\n \n The returned TableMap contains each row in this table in exactly one of the tables within the map. If you have\n exactly one key column the TableMap is keyed by the value in that column. If you have zero key columns, then the\n TableMap is keyed by io.deephaven.datastructures.util.SmartKey.EMPTY (and will contain this table as the\n value). If you have multiple key columns, then the TableMap is keyed by a\n io.deephaven.datastructures.util.SmartKey. The SmartKey will have one value for each of your column\n values, in the order specified by keyColumnNames.\n \n\n For example if you have a Table keyed by a String column named USym, and a DateTime column named Expiry; a value\n could be retrieved from the TableMap with\n tableMap.get(new SmartKey(\"SPY\";, DateTimeUtils.convertDateTime(\"2020-06-19T16:15:00 NY\"))). For a table\n with an Integer column named Bucket, you simply use the desired value as in tableMap.get(1).\n \n\n:param dropKeys: (boolean) - if true, drop key columns in the output Tables\n:param keyColumnNames: (java.lang.String...) - the name of the key columns to use.\n:return: (io.deephaven.engine.table.impl.LocalTableMap) a TableMap keyed by keyColumnNames",
  "raj": "Just like .aj(), but the matching on the last column is in reverse order, so that you find the row after the\n given timestamp instead of the row before.\n \n Looks up the columns in the rightTable that meet the match conditions in the columnsToMatch list. Matching is\n done exactly for the first n-1 columns and via a binary search for the last match pair. The columns of the\n original table are returned intact, together with the columns from rightTable defined in a comma separated list\n \"columnsToAdd\"\n\n:param rightTable: (io.deephaven.engine.table.Table) - The right side table on the join.\n:param columnsToMatch: (io.deephaven.engine.table.MatchPair[]) - A comma separated list of match conditions (\"leftColumn=rightColumn\" or\n        \"columnFoundInBoth\")\n:param columnsToAdd: (io.deephaven.engine.table.MatchPair[]) - A comma separated list with the columns from the left side that need to be added to the right\n        side as a result of the match.\n:param asOfMatchRule: io.deephaven.engine.table.Table.AsOfMatchRule\n:return: (io.deephaven.engine.table.Table) a new table joined according to the specification in columnsToMatch and columnsToAdd",
  "releaseCachedResources": "Attempt to release cached resources held by this table. Unlike Table.close(), this must not render the table\n unusable for subsequent read operations. Implementations should be sure to call\n super.releaseCachedResources().",
  "renameColumns": ":param pairs: io.deephaven.engine.table.MatchPair...\n:return: io.deephaven.engine.table.Table",
  "reverse": "The reverse operation returns a new table that is the same as the original table, but the first row is last, and\n the last row is first. This is an internal API to be used by .raj(), but is accessible for unit tests.\n\n:return: (io.deephaven.engine.table.Table) the reversed table",
  "rollup": ":param aggregations: java.util.Collection<? extendsio.deephaven.api.agg.Aggregation>\n:param includeConstituents: boolean\n:param groupByColumns: io.deephaven.api.Selectable...\n:return: io.deephaven.engine.table.Table",
  "select": ":param columns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n:return: io.deephaven.engine.table.Table",
  "selectDistinct": ":param groupByColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n:return: io.deephaven.engine.table.Table",
  "setMemoizeResults": "For unit tests, provide a method to turn memoization on or off.\n\n:param memoizeResults: (boolean) - should results be memoized?\n:return: (boolean) the prior value",
  "silent": ":return: io.deephaven.engine.table.Table",
  "size": "The size of this data structure.\n\n:return: (long) The size",
  "slice": "Extracts a subset of a table by row position.\n \n If both firstPosition and lastPosition are positive, then the rows are counted from the beginning of the table.\n The firstPosition is inclusive, and the lastPosition is exclusive. The Table.head(long)(N) call is equivalent to\n slice(0, N). The firstPosition must be less than or equal to the lastPosition.\n \n If firstPosition is positive and lastPosition is negative, then the firstRow is counted from the beginning of the\n table, inclusively. The lastPosition is counted from the end of the table. For example, slice(1, -1) includes all\n rows but the first and last. If the lastPosition would be before the firstRow, the result is an emptyTable.\n \n If firstPosition is negative, and lastPosition is zero, then the firstRow is counted from the end of the table,\n and the end of the slice is the size of the table. slice(-N, 0) is equivalent to Table.tail(long)(N).\n \n If the firstPosition is nega tive and the lastPosition is negative, they are both counted from the end of the\n table. For example, slice(-2, -1) returns the second to last row of the table.\n\n:param firstPositionInclusive: (long) - the first position to include in the result\n:param lastPositionExclusive: (long) - the last position to include in the result\n:return: (io.deephaven.engine.table.Table) a new Table, which is the request subset of rows from the original table",
  "snapshot": "Snapshot baseTable, triggered by this table, and return a new table as a result.\n\n \n Delegates to TableOperations.snapshot(Object, boolean, Collection).\n\n:param baseTable: (io.deephaven.engine.table.Table) - The table to be snapshotted\n:param doInitialSnapshot: (boolean) - Take the first snapshot now (otherwise wait for a change event)\n:param stampColumns: (java.lang.String...) - The columns forming the \"snapshot key\", i.e. some subset of this Table's columns to be\n        included in the result at snapshot time. As a special case, an empty stampColumns is taken to mean\n        \"include all columns\".\n:return: (io.deephaven.engine.table.Table) The result table",
  "snapshotHistory": ":param rightTable: io.deephaven.engine.table.Table\n:return: io.deephaven.engine.table.Table",
  "snapshotIncremental": ":param tableToSnapshot: io.deephaven.engine.table.Table\n:param doInitialSnapshot: boolean\n:param stampColumns: java.lang.String...\n:return: io.deephaven.engine.table.Table",
  "sort": ":param columnsToSortBy: java.util.Collection<io.deephaven.api.SortColumn>\n:return: io.deephaven.engine.table.Table",
  "tail": ":param size: long\n:return: io.deephaven.engine.table.Table",
  "tailBy": ":param nRows: long\n:param groupByColumns: java.lang.String...\n:return: io.deephaven.engine.table.Table",
  "tailPct": ":param percent: double\n:return: io.deephaven.engine.table.Table",
  "treeTable": "Create a hierarchical tree table.\n \n The structure of the table is encoded by an \"id\" and a \"parent\" column. The id column should represent a unique\n identifier for a given row, and the parent column indicates which row is the parent for a given row. Rows that\n have a null parent, are shown in the main table. It is possible for rows to be \"orphaned\", if their parent\n reference is non-null and does not exist in the table.\n\n:param idColumn: (java.lang.String) - the name of a column containing a unique identifier for a particular row in the table\n:param parentColumn: (java.lang.String) - the name of a column containing the parent's identifier, null for elements that are part of\n        the root table\n:return: (io.deephaven.engine.table.Table) a hierarchical table grouped according to the parentColumn",
  "ungroup": "Ungroups a table by converting arrays into columns.\n\n:param nullFill: (boolean) - indicates if the ungrouped table should allow disparate sized arrays filling shorter columns with\n        null values. If set to false, then all arrays should be the same length.\n:param columnsToUngroupBy: (java.lang.String...) - the columns to ungroup\n:return: (io.deephaven.engine.table.Table) the ungrouped table",
  "update": ":param newColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n:return: io.deephaven.engine.table.Table",
  "updateView": ":param viewColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n:return: io.deephaven.engine.table.Table",
  "validateSelect": "This does a certain amount of validation and can be used to get confidence that the formulas are valid. If it is\n not valid, you will get an exception. Positive test (should pass validation): \"X = 12\", \"Y = X + 1\") Negative\n test (should fail validation): \"X = 12\", \"Y = Z + 1\")\n\n DO NOT USE -- this API is in flux and may change or disappear in the future.\n\n:param selectColumns: io.deephaven.engine.table.impl.select.SelectColumn...\n:return: io.deephaven.engine.table.impl.SelectValidationResult",
  "view": ":param viewColumns: java.util.Collection<? extendsio.deephaven.api.Selectable>\n:return: io.deephaven.engine.table.Table",
  "where": ":param filters: java.util.Collection<? extendsio.deephaven.api.filter.Filter>\n:return: io.deephaven.engine.table.Table",
  "whereIn": "Filters this table based on the set of values in the rightTable.\n\n \n Note that when the rightTable ticks, all of the rows in this table are going to be re-evaluated,\n thus the intention is that the rightTable is fairly slow moving compared with this table.\n\n:param rightTable: (io.deephaven.engine.table.Table) - the filtering table.\n:param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - the columns to match between the two tables\n:return: (io.deephaven.engine.table.Table) a new table filtered on right table",
  "whereNotIn": "Filters this table based on the set of values not in the rightTable.\n\n \n Note that when the rightTable ticks, all of the rows in this table are going to be re-evaluated,\n thus the intention is that the rightTable is fairly slow moving compared with this table.\n\n:param rightTable: (io.deephaven.engine.table.Table) - the filtering table.\n:param columnsToMatch: (java.util.Collection<? extendsio.deephaven.api.JoinMatch>) - the columns to match between the two tables\n:return: (io.deephaven.engine.table.Table) a new table filtered on right table",
  "withDefinitionUnsafe": "Create a new query table with the ColumnDefinitions of template, but in the\n order of this. The tables must be mutually compatible, as defined via\n TableDefinition.checkCompatibility(TableDefinition).\n\n:param template: (io.deephaven.engine.table.TableDefinition) - the new definition template to use\n:return: (io.deephaven.engine.table.impl.QueryTable) the new query table",
  "wouldMatch": "A table operation that applies the supplied predicate to each row in the table and produces columns containing\n the pass/fail result of the predicate application. This is similar to Table.where(String...) except that\n instead of selecting only rows that meet the criteria, new columns are added with the result of the comparison.\n\n:param matchers: io.deephaven.engine.table.WouldMatchPair...\n:return: (io.deephaven.engine.table.Table) a table with new columns containing the filter result for each row."
 },
 "path": "io.deephaven.engine.table.impl.QueryTable",
 "text": "Primary coalesced table implementation.",
 "typeName": "class"
}