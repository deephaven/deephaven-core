{
 "className": "io.deephaven.engine.table.ColumnSource",
 "methods": {
  "allowsReinterpret": "Test if a reinterpret call will succeed.\n\nNote: Java generics information - <ALTERNATE_DATA_TYPE>\n\n:param alternateDataType: (java.lang.Class<ALTERNATE_DATA_TYPE>) - The alternative type to consider\n:return: (boolean) If a reinterpret on this column source with the supplied alternateDataType will succeed.",
  "cast": "Returns this ColumnSource, parameterized by <TYPE>, if the data type of this column (as given by\n getType()) can be cast to clazz. This is analogous to casting the objects provided by this\n column source to clazz.\n \n For example, the following code will throw an exception if the \"MyString\" column does not actually contain\n String data:\n\n \n     ColumnSource<String> colSource = table.getColumnSource(\"MyString\").getParameterized(String.class)\n \n\n Due to the nature of type erasure, the JVM will still insert an additional cast to TYPE when elements are\n retrieved from the column source, such as with String myStr = colSource.get(0).\n\nNote: Java generics information - <TYPE>\n\n:param extend: java.lang.Class<?\n:return: (io.deephaven.engine.table.ColumnSource<TYPE>) A ColumnSource parameterized by TYPE.",
  "createPreviousTuple": "Create a tuple for previous key column values at the supplied row key.\n\n:param rowKey: (long) - The row key\n:return: (ColumnSource.T) The resulting tuple",
  "createTuple": "Create a tuple for key column values at the supplied row key.\n\n:param rowKey: (long) - The row key\n:return: (ColumnSource.T) The resulting tuple",
  "createTupleFromValues": "Create a tuple for the supplied (boxed) values.\n\n:param values: (java.lang.Object...) - The values\n:return: (ColumnSource.T) The resulting tuple",
  "exportElement": "**Incompatible overloads text - text from the first overload:**\n\nExport a single element from the tuple, identified by its element index, to an Object\n \n \n For the empty tuple, this is unsupported.\n \n For singles, this will copy the sole element, possibly in boxed form.\n \n For doubles and longer, this will copy the specified element without any unnecessary boxing.\n\n*Overload 1*  \n  Note: Java generics information - <ELEMENT_TYPE>\n  \n  :param tuple: (ColumnSource.T) - The tuple to export an element from\n  :param elementIndex: (int) - The element index to export\n  :param writableSource: (io.deephaven.engine.table.WritableColumnSource<ELEMENT_TYPE>) - The destination\n  :param destinationIndexKey: (long) - The destination row key\n  \n*Overload 2*  \n  :param tuple: (ColumnSource.T) - The tuple to export an element from\n  :param elementIndex: (int) - The element index to export\n  :return: java.lang.Object",
  "exportToExternalKey": "Export this tuple's element list as a key suitable for the table maps resulting from\n Table.partitionBy(boolean, java.lang.String...).\n \n For the empty tuple this is a unsupported.\n \n For singles, this is the (boxed) sole element itself.\n \n For doubles and longer, this is a newly-allocated \"SmartKey\".\n\n:param tuple: (ColumnSource.T) - The tuple to export all elements from\n:return: (java.lang.Object) The new smart key",
  "getChunkType": "Get the most suitable ChunkType for use with this ChunkSource.\n\n:return: (io.deephaven.chunk.ChunkType) The ChunkType",
  "getColumnSources": "Get the ColumnSources backing this tuple source.\n\n:return: (java.util.List<io.deephaven.engine.table.ColumnSource>) The column sources",
  "getComponentType": ":return: java.lang.Class<?>",
  "getGroupToRange": "**Incompatible overloads text - text from the first overload:**\n\nCompute grouping information for (at least) all keys present in rowSet.\n\n*Overload 1*  \n  :return: (java.util.Map<ColumnSource.T,io.deephaven.engine.rowset.RowSet>) A map from distinct data values to a RowSet that contains those values\n  \n*Overload 2*  \n  :param rowSet: (io.deephaven.engine.rowset.RowSet) - The RowSet to consider\n  :return: (java.util.Map<ColumnSource.T,io.deephaven.engine.rowset.RowSet>) A map from distinct data values to a RowSet that contains those values",
  "getPrevSource": ":return: (io.deephaven.engine.table.ColumnSource<ColumnSource.T>) a chunk source which accesses the previous values.",
  "getType": ":return: java.lang.Class<ColumnSource.T>",
  "getValuesMapping": ":param subRange: io.deephaven.engine.rowset.RowSet\n:return: java.util.Map<ColumnSource.T,io.deephaven.engine.rowset.RowSet>",
  "isImmutable": "Determine if this column source is immutable, meaning that the values at a given row key never change.\n\n:return: (boolean) true if the values at a given row key of the column source never change, false otherwise",
  "isStateless": "Most column sources will return the same value for a given row without respect to the order that the rows are\n read. Those columns sources are considered \"stateless\" and should return true.\n\n Some column sources, however may be dependent on evaluation order. For example, a formula that updates a Map must\n be evaluated from the first row to the last row. A column source that has the potential to depend on the order of\n evaluation must return false.\n\n:return: (boolean) true if this is a stateless column source",
  "match": ":param invertMatch: boolean\n:param usePrev: boolean\n:param caseInsensitive: boolean\n:param mapper: io.deephaven.engine.rowset.RowSet\n:param keys: java.lang.Object...\n:return: io.deephaven.engine.rowset.WritableRowSet",
  "preventsParallelism": "Can this column source be evaluated on an arbitrary thread?\n\n Most column sources can be evaluated on an arbitrary thread, however those that do call into Python can not be\n evaluated on an arbitrary thread as the calling thread may already have the GIL, which would result in a deadlock\n when the column source takes the GIL to evaluate formulas.\n\n:return: (boolean) true if this column prevents parallelization",
  "reinterpret": "Provide an alternative view into the data underlying this column source.\n\nNote: Java generics information - <ALTERNATE_DATA_TYPE>\n\n:param alternateDataType: (java.lang.Class<ALTERNATE_DATA_TYPE>) - The alternative type to expose\n:return: (io.deephaven.engine.table.ColumnSource<ALTERNATE_DATA_TYPE>) A column source of the alternate data type, backed by the same underlying data.",
  "releaseCachedResources": "Release any resources held for caching purposes. Implementations need not guarantee that concurrent accesses are\n correct, as the purpose of this method is to ensure cleanup for column sources that will no longer be used.",
  "startTrackingPrevValues": "ColumnSource implementations that track previous values have the option to not actually start tracking previous\n values until this method is called. This is an option, not an obligation: some simple ColumnSource\n implementations (like TSingleValueSource for various T) always track previous values; other implementations (like\n PrevColumnSource) never do; some (like TArrayColumnSource) only start tracking once this method is called.\n\n An immutable column source can not have distinct prev values; therefore it is implemented as a no-op."
 },
 "path": "io.deephaven.engine.table.ColumnSource",
 "text": "A \"source\" for column data - allows cell values to be looked up by (long) keys.\n\n \n Note for implementors: All ColumnSource implementations must map RowSequence.NULL_ROW_KEY to a null value\n for all get and getPrev methods.",
 "typeName": "interface"
}