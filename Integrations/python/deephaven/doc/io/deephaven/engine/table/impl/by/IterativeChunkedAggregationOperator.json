{
 "className": "io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator",
 "methods": {
  "addChunk": "Aggregate a chunk of data into the result columns.\n\n*Overload 1*  \n  :param context: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param values: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values to aggregate\n  :param inputRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in post-shift space\n  :param destinations: (io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>) - the destinations in resultColumn to aggregate into, parallel with startPositions and length\n  :param startPositions: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param context: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param chunkSize: (int) - the size of the addition\n  :param values: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - the values to aggregate\n  :param inputRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in post-shift space\n  :param destination: (long) - the destination in the result columns\n  :return: (boolean) true if the state was modified, false otherwise",
  "addRowSet": ":param context: io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.SingletonContext\n:param rowSet: io.deephaven.engine.rowset.RowSet\n:param destination: long\n:return: boolean",
  "ensureCapacity": "Ensure that this operator can handle destinations up to tableSize - 1.\n\n:param tableSize: (long) - the new size of the table",
  "getResultColumns": "Return a map of result columns produced by this operator.\n\n:return: (java.util.Map<java.lang.String,? extends io.deephaven.engine.table.ColumnSource<?>>) a map of name to columns for the result table",
  "initializeRefreshing": "Initialize refreshing result support for this operator. As a side effect, make a factory method for converting\n upstream modified column sets to result modified column sets, to be invoked whenever this operator reports a\n modification in order to determine the operator's contribution to the final result modified column set.\n\n:param resultTable: (io.deephaven.engine.table.impl.QueryTable) - The result QueryTable after initialization\n:param aggregationUpdateListener: (io.deephaven.engine.liveness.LivenessReferent) - The aggregation update listener, which may be needed for referential integrity\n:return: (java.util.function.UnaryOperator<io.deephaven.engine.table.ModifiedColumnSet>) A factory that produces a result modified column set from the upstream modified column set",
  "makeBucketedContext": "Make a IterativeChunkedAggregationOperator.BucketedContext suitable for this operator if necessary.\n\n:param size: (int) - The maximum size of input chunks that will be used with the result context\n:return: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext) A new IterativeChunkedAggregationOperator.BucketedContext, or null if none is necessary",
  "makeSingletonContext": "Make a IterativeChunkedAggregationOperator.SingletonContext suitable for this operator if necessary.\n\n:param size: (int) - The maximum size of input chunks that will be used with the result context\n:return: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.SingletonContext) A new IterativeChunkedAggregationOperator.SingletonContext, or null if none is necessary",
  "modifyChunk": "**Incompatible overloads text - text from the first overload:**\n\nModify a chunk of data previously aggregated into the result columns using a parallel chunk of new values. Never\n includes modifies that have been shifted if requiresRowKeys() returns true - those are handled in\n shiftChunk(BucketedContext, Chunk, Chunk, LongChunk, LongChunk, IntChunk, IntChunk, IntChunk, WritableBooleanChunk).\n\n*Overload 1*  \n  :param context: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param previousValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values that have been previously aggregated\n  :param newValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values to aggregate\n  :param postShiftRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in post-shift space\n  :param destinations: (io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>) - the destinations in resultColumn to remove the values from, parallel with startPositions and\n          length\n  :param startPositions: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param context: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param chunkSize: (int) - the size of the modification\n  :param previousValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values that have been previously aggregated.\n  :param newValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values to aggregate\n  :param postShiftRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in post-shift space\n  :param destination: long\n  :return: (boolean) true if the state was modified, false otherwise",
  "modifyRowKeys": "Called with the modified row keys when requiresRowKeys() returns true if our input columns have not\n changed (or we have none).\n\n*Overload 1*  \n  :param context: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param inputRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in post-shift space\n  :param destinations: (io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>) - the destinations in resultColumn to aggregate into, parallel with startPositions and length\n  :param startPositions: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param context: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param rowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the modified row keys for a given destination, in post-shift space\n  :param destination: (long) - the destination that was modified\n  :return: (boolean) true if the result should be considered modified",
  "propagateFailure": "Called on error to propagate listener failure to this operator.\n\n:param originalException: (java.lang.Throwable) - The error Throwable\n:param sourceEntry: (io.deephaven.engine.table.TableListener.Entry) - The UpdatePerformanceTracker.Entry for the failed listener",
  "propagateInitialState": "Perform any internal state keeping needed for destinations that were added during initialization.\n\n:param resultTable: (io.deephaven.engine.table.impl.QueryTable) - The result QueryTable after initialization",
  "propagateUpdates": "Perform any internal state keeping needed for destinations that were added (went from 0 keys to > 0), removed\n (went from > 0 keys to 0), or modified (keys added or removed, or keys modified) by this iteration. Note that\n the arguments to this method should not be mutated in any way.\n\n:param downstream: (io.deephaven.engine.table.TableUpdate) - The downstream ShiftAwareListener.Update (which does not have its\n        ModifiedColumnSet finalized yet)\n:param newDestinations: (io.deephaven.engine.rowset.RowSet) - New destinations added on this update",
  "removeChunk": "Remove a chunk of data previously aggregated into the result columns.\n\n*Overload 1*  \n  :param context: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param values: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values that have been previously aggregated.\n  :param inputRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in pre-shift space\n  :param destinations: (io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>) - the destinations in resultColumn to remove the values from, parallel with startPositions and\n          length\n  :param startPositions: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param context: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param chunkSize: (int) - the size of the removal\n  :param values: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - the values to remove from the aggregation\n  :param inputRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in pre-shift space\n  :param destination: (long) - the destination in the result columns\n  :return: (boolean) true if the state was modified, false otherwise",
  "requiresRowKeys": "Whether the operator requires row keys. This implies that the operator must process shifts (i.e.\n shiftChunk(io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext, io.deephaven.chunk.Chunk<? extends io.deephaven.chunk.attributes.Values>, io.deephaven.chunk.Chunk<? extends io.deephaven.chunk.attributes.Values>, io.deephaven.chunk.LongChunk<? extends io.deephaven.engine.rowset.chunkattributes.RowKeys>, io.deephaven.chunk.LongChunk<? extends io.deephaven.engine.rowset.chunkattributes.RowKeys>, io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>, io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>, io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>, io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>)), and must observe modifications even when its input columns (if any) are not modified (i.e.\n modifyRowKeys(io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext, io.deephaven.chunk.LongChunk<? extends io.deephaven.engine.rowset.chunkattributes.RowKeys>, io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>, io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>, io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>, io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>)).\n\n:return: (boolean) true if the operator requires row keys, false otherwise",
  "requiresRunFinds": "Some operators require that all values for a destination within a given chunk are adjacent. These operators must\n return true.\n\n:return: (boolean) true if the operator requires runs of the same destination to be adjacent",
  "resetForStep": "Reset any per-step internal state. Note that the arguments to this method should not be mutated in any way.\n\n:param upstream: (io.deephaven.engine.table.TableUpdate) - The upstream ShiftAwareListener.Update",
  "shiftChunk": "**Incompatible overloads text - text from the first overload:**\n\nCalled with shifted row keys when requiresRowKeys() returns true, including shifted same-slot modifies.\n\n*Overload 1*  \n  :param context: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param previousValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values that have been previously aggregated.\n  :param newValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values to aggregate\n  :param preShiftRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in pre-shift space\n  :param postShiftRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in post-shift space\n  :param destinations: (io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>) - the destinations in resultColumn to aggregate into, parallel with startPositions and length\n  :param startPositions: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param context: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param previousValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values that have been previously aggregated.\n  :param newValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values to aggregate\n  :param preShiftRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in pre-shift space\n  :param postShiftRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in post-shift space\n  :param destination: (long) - the destination in the result columns\n  :return: (boolean) true if the result should be considered modified",
  "startTrackingPrevValues": "Called after initialization; when the operator's result columns must have previous tracking enabled.",
  "unchunkedRowSet": "Whether the operator can deal with an unchunked RowSet more efficiently than a chunked RowSet.\n\n:return: (boolean) true if the operator can deal with unchunked RowSets, false otherwise"
 },
 "path": "io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator",
 "text": "A chunked, iterative operator that processes row keys and/or data from one input column to produce one or more output\n columns.",
 "typeName": "interface"
}