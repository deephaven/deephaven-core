{
 "className": "io.deephaven.engine.table.impl.util.copy.ByteCopyKernel",
 "methods": {
  "conditionalCopy": "Copy values from baseInput / overInput into output.\n \n Pseudo-implementation: output[i] = useOverInput.forBit(i) ? overInput[i] : baseInput[i];\n \n Note that useOverInput should cover the same data range as baseInput such that\n useOverInput.length == (overInput.length + 63) / 64 is true.\n\n*Overload 1*  \n  Note: Java generics information - <T extends io.deephaven.chunk.attributes.Any>\n  \n  :param output: (io.deephaven.chunk.WritableByteChunk<T>) - the output chunk\n  :param baseInput: (byte[]) - the input array to use when bit in useOverInput is zero (array)\n  :param overInput: (byte[]) - the input array to use when bit in useOverInput is one (array)\n  :param useOverInput: (long[]) - the bitset array to indicate whether to use baseInput or overInput for each element\n  :param srcOffset: (int) - the offset in baseInput/overInput\n  :param dstOffset: (int) - the offset in output\n  :param length: (int) - the number of elements to copy\n  \n*Overload 2*  \n  Note: Java generics information - <T extends io.deephaven.chunk.attributes.Any>\n  \n  :param output: (io.deephaven.chunk.WritableChunk<T>) - the output chunk\n  :param baseInput: (java.lang.Object) - the input array to use when bit in useOverInput is zero (array)\n  :param overInput: (java.lang.Object) - the input array to use when bit in useOverInput is one (array)\n  :param useOverInput: (long[]) - the bitset array to indicate whether to use baseInput or overInput for each element\n  :param srcOffset: (int) - the offset in baseInput/overInput\n  :param dstOffset: (int) - the offset in output\n  :param length: (int) - the number of elements to copy"
 },
 "path": "io.deephaven.engine.table.impl.util.copy.ByteCopyKernel",
 "typeName": "class"
}