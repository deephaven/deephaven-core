{
 "className": "io.deephaven.engine.updategraph.UpdateGraphProcessor",
 "methods": {
  "addNotification": "Enqueue a notification to be flushed according to its priority. Non-terminal notifications should only be\n enqueued during the updating phase of a cycle. That is, they should be enqueued from an update source or\n subsequent notification delivery.\n\n:param notification: (io.deephaven.engine.updategraph.NotificationQueue.Notification) - The notification to enqueue",
  "addNotifications": "Enqueue a collection of notifications to be flushed.\n\n:param notifications: (java.util.Collection<io.deephaven.engine.updategraph.NotificationQueue.Notification>) - The notification to enqueue",
  "addSource": "Add a table to the list of tables to run and mark it as refreshing if\n it was a DynamicNode.\n\n:param updateSource: (java.lang.Runnable) - The table to be added to the run list",
  "append": ":param logOutput: io.deephaven.base.log.LogOutput\n:return: io.deephaven.base.log.LogOutput",
  "checkInitiateTableOperation": "If we are establishing a new table operation, on a refreshing table without the UpdateGraphProcessor lock; then\n we are likely committing a grievous error, but one that will only occasionally result in us getting the wrong\n answer or if we are lucky an assertion. This method is called from various query operations that should not be\n established without the UGP lock.\n \n\n The run thread pool threads are allowed to instantiate operations, even though that thread does not have the\n lock; because they are protected by the main run thread and dependency tracking.\n \n\n If you are sure that you know what you are doing better than the query engine, you may call\n setCheckTableOperations(boolean) to set a thread local variable bypassing this check.",
  "completeCycleForUnitTests": "Do the second half of the update cycle, including flushing notifications, and completing the\n LogicalClock update cycle. Note that this happens on a simulated UGP\n run thread, rather than this thread.",
  "doUnchecked": "Execute the supplied code while table operations are unchecked.\n\n*Overload 1*  \n  Note: Java generics information - <T>\n  \n  :param supplier: (java.util.function.Supplier<T>) - the function to run\n  :return: (T) the result of supplier\n  \n*Overload 2*  \n  :param runnable: (java.lang.Runnable) - the function to run",
  "enableUnitTestMode": "Enable unit test mode.\n \n\n In this mode calls to addSource(Runnable) will only mark tables as\n refreshing. Additionally start() may not be called.",
  "exclusiveLock": "Get the exclusive lock for this UpdateGraphProcessor.\n \n Using this lock will prevent run or read-only processing from proceeding concurrently.\n \n The exclusive lock implementation is expected to support reentrance.\n \n Note that using the exclusive lock while the shared lock is held by the current thread will result in exceptions,\n as lock upgrade is not supported.\n \n This lock does support Lock.newCondition().\n\n:return: (io.deephaven.util.locks.AwareFunctionalLock) The exclusive lock for this UpdateGraphProcessor",
  "flushAllNormalNotificationsForUnitTests": "**Incompatible overloads text - text from the first overload:**\n\nFlush all the normal notifications from the UGP queue, continuing until done returns true. Note\n that the flushing happens on a simulated UGP run thread, rather than this thread.\n\n*Overload 1*  \n  \n  \n*Overload 2*  \n  :param done: (java.util.function.BooleanSupplier) - Function to determine when we can stop waiting for new notifications\n  :param timeoutMillis: long\n  :return: (java.lang.Runnable) A Runnable that may be used to wait for the concurrent flush job to complete",
  "flushOneNotificationForUnitTests": "Flush a single notification from the UGP queue. Note that this happens on a simulated UGP run thread, rather than\n this thread.\n\n:return: (boolean) whether a notification was found in the queue",
  "flushOneNotificationForUnitTestsInternal": ":return: boolean",
  "getCheckTableOperations": "Should this thread check table operations for safety with respect to the update lock?\n\n:return: (boolean) if we should check table operations.",
  "getTargetCycleDurationMillis": "Get the target duration of an update cycle, including the updating phase and the idle phase. This is also the\n target interval between the start of one cycle and the start of the next.\n\n:return: (long) The current target cycle duration",
  "getUpdateThreads": "Retrieve the number of update threads.\n\n \n The UpdateGraphProcessor has a configurable number of update processing threads. The number of threads is exposed\n in your method to enable you to partition a query based on the number of threads.\n \n\n:return: (int) the number of update threads configured.",
  "getWatchDogMillis": "Get the current watchdog timeout value.\n\n:return: (int) The current timeout for the watchdog, 0 for disabled",
  "isRefreshThread": "Test if this thread is part of our run thread executor service.\n\n:return: (boolean) whether this is one of our run threads.",
  "logDependencies": ":return: io.deephaven.io.log.LogEntry",
  "maybeAddNotification": "Add a notification for this NotificationQueue to deliver (by invoking its run() method), iff the delivery step is\n the current step and the update cycle for that step is still in process. This is only supported for non-terminal\n notifications.\n\n:param notification: (io.deephaven.engine.updategraph.NotificationQueue.Notification) - The notification to add\n:param deliveryStep: (long) - The step to deliver this notification on\n:return: boolean",
  "refreshUpdateSourceForUnitTests": "Refresh an update source on a simulated UGP run thread, rather than this thread.\n\n:param updateSource: (java.lang.Runnable) - The update source to run",
  "removeSource": "Remove a source from this registrar.\n\n:param updateSource: (java.lang.Runnable) - The table to remove",
  "removeSources": "Remove a collection of sources from the list of refreshing sources.\n\n:param sourcesToRemove: (java.util.Collection<java.lang.Runnable>) - The sources to remove from the list of refreshing sources",
  "requestRefresh": "Request that the next update cycle begin as soon as practicable. This \"hurry-up\" cycle happens through normal\n means using the refresh thread and its workers.",
  "requestSignal": ":param updateGraphProcessorCondition: java.util.concurrent.locks.Condition",
  "resetCycleDuration": "Resets the run cycle time to the default target configured via the\n \"UpdateGraphProcessor.targetCycleDurationMillis\" property.",
  "resetForUnitTests": "Clear all monitored tables and enqueued notifications to support unit-tests.\n\n*Overload 1*  \n  :param after: (boolean) - Whether this is *after* a unit test completed. If true, held locks should result in an exception and\n          the LivenessScopeStack will be cleared.\n  \n*Overload 2*  \n  :param after: (boolean) - Whether this is *after* a unit test completed. If true, held locks should result in an exception and\n          the LivenessScopeStack will be cleared.\n  :param randomizedNotifications: (boolean) - Whether the notification processor should randomize the order of delivery\n  :param seed: (int) - Seed for randomized notification delivery order and delays\n  :param maxRandomizedThreadCount: (int) - Maximum number of threads handling randomized notification delivery\n  :param notificationStartDelay: (int) - Maximum randomized notification start delay\n  :param notificationAdditionDelay: (int) - Maximum randomized notification addition delay",
  "runWithinUnitTestCycle": "Execute the given runnable wrapped with startCycleForUnitTests() and\n completeCycleForUnitTests(). Note that the runnable is run on the current thread.\n\nNote: Java generics information - <T extends java.lang.Exception>\n\n:param runnable: (io.deephaven.util.FunctionalInterfaces.ThrowingRunnable<T>) - the runnable to execute.",
  "satisfied": "Is this ancestor satisfied? Note that this method must be safe to call on any thread.\n\n:param step: (long) - The step for which we are testing satisfaction\n:return: (boolean) Whether the dependency is satisfied on step (and will not fire subsequent notifications)",
  "setCheckTableOperations": "If you know that the table operations you are performing are indeed safe, then call this method with false to\n disable table operation checking. Conversely, if you want to enforce checking even if the configuration\n disagrees; call it with true.\n\n:param value: (boolean) - the new value of check table operations\n:return: (boolean) the old value of check table operations",
  "setTargetCycleDurationMillis": "Set the target duration of an update cycle, including the updating phase and the idle phase. This is also the\n target interval between the start of one cycle and the start of the next.\n \n Can be reset to default via resetCycleDuration().\n\n:param targetCycleDurationMillis: (long) - The target duration for update cycles in milliseconds",
  "setWatchDogMillis": "Enable the loop watchdog with the specified timeout. A value of 0 disables the watchdog.\n\n:param watchDogMillis: (int) - The time in milliseconds to set the watchdog, or 0 to disable.",
  "setWatchDogTimeoutProcedure": "Set the procedure to be called when the watchdog times out.\n\n:param procedure: (java.util.function.LongConsumer) - The procedure to call",
  "sharedLock": "Get the shared lock for this UpdateGraphProcessor.\n \n Using this lock will prevent run processing from proceeding concurrently, but will allow other read-only\n processing to proceed.\n \n The shared lock implementation is expected to support reentrance.\n \n This lock does not support Lock.newCondition(). Use the exclusive\n lock if you need to wait on events that are driven by run processing.\n\n:return: (io.deephaven.util.locks.AwareFunctionalLock) The shared lock for this UpdateGraphProcessor",
  "sourceCount": "Return the number of valid sources.\n\n:return: (int) the number of valid sources",
  "start": "Start the table run thread.",
  "startCycleForUnitTests": "Begin the next update cycle while in unit-test mode. Note that this happens on a simulated UGP run thread, rather than this thread.",
  "toString": ":return: java.lang.String",
  "valueOf": "Returns the enum constant of this type with the specified name.\nThe string must match exactly an identifier used to declare an\nenum constant in this type.  (Extraneous whitespace characters are \nnot permitted.)\n\n:param name: (java.lang.String) - the name of the enum constant to be returned.\n:return: (io.deephaven.engine.updategraph.UpdateGraphProcessor) the enum constant with the specified name",
  "values": "Returns an array containing the constants of this enum type, in\nthe order they are declared.\n\n:return: (io.deephaven.engine.updategraph.UpdateGraphProcessor[]) an array containing the constants of this enum type, in the order they are declared",
  "wakeRefreshThreadForUnitTests": "If the run thread is waiting in flushNormalNotificationsAndCompleteCycle() or\n flushAllNormalNotificationsForUnitTests(BooleanSupplier, long), wake it up."
 },
 "path": "io.deephaven.engine.updategraph.UpdateGraphProcessor",
 "text": "This class uses a thread (or pool of threads) to periodically update a set of monitored update sources at a specified\n target cycle interval. The target cycle interval can be configured to\n reduce or increase the run rate of the monitored sources.\n \n This class can be configured via the following Configuration property\n \n* \"UpdateGraphProcessor.targetCycleDurationMillis\"(optional) - The default target cycle time in ms (1000 if\n not defined)",
 "typeName": "enum"
}