{
 "className": "io.deephaven.util.MultiException",
 "methods": {
  "getCauses": ":return: (java.lang.Throwable[]) all of the exceptions that resulted in this one.",
  "getMessage": ":return: java.lang.String",
  "maybeWrapInMultiException": "If there is a single exception, return that exception; otherwise wrap the causes into a MultiException.\n\n*Overload 1*  \n  :param description: (java.lang.String) - the description for the MultiException\n  :param causes: (java.lang.Throwable...) - the array of causes\n  :return: (java.lang.Throwable) a MultiException or the single Throwable\n  \n*Overload 2*  \n  :param description: (java.lang.String) - the description for the MultiException\n  :param causes: (java.util.List<? extendsjava.lang.Throwable>) - the list of causes\n  :return: (java.lang.Throwable) a MultiException or the single Throwable\n  \n*Overload 3*  \n  :param description: (java.lang.String) - the description for the MultiException\n  :param causes: (java.lang.Exception...) - the array of causes\n  :return: (java.lang.Exception) a MultiException or the single Exception",
  "printStackTrace": "*Overload 1*  \n  :param s: java.io.PrintWriter\n  \n*Overload 2*  \n  :param s: java.io.PrintStream",
  "toString": ":return: java.lang.String"
 },
 "path": "io.deephaven.util.MultiException",
 "text": "An exception to use when a series of operations must all be executed, but may all throw exceptions themselves. This\n allows for retention of all exception data.",
 "typeName": "class"
}