{
 "className": "io.deephaven.extensions.barrage.chunk.array.LongArrayExpansionKernel",
 "methods": {
  "contract": "This contracts the source from a pair of LongChunk and Chunk<T> and produces a Chunk<T[]>. The returned\n chunk is owned by the caller.\n\nNote: Java generics information - <T,\nA extends io.deephaven.chunk.attributes.Any>\n\n:param source: (io.deephaven.chunk.Chunk<A>) - the source chunk of T to contract\n:param perElementLengthDest: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>) - the source IntChunk for which dest.get(i + 1) - dest.get(i) is equivalent to source.get(i).length\n:param outChunk: (io.deephaven.chunk.WritableChunk<A>) - the returned chunk from an earlier record batch\n:param outOffset: (int) - the offset to start writing into outChunk\n:param totalRows: (int) - the total known rows for this column; if known (else 0)\n:return: (io.deephaven.chunk.WritableObjectChunk<T,A>) a result chunk of T[]",
  "expand": "This expands the source from a T[] per element to a flat T per element. The kernel records the number of\n consecutive elements that belong to a row in perElementLengthDest. The returned chunk is owned by the caller.\n\nNote: Java generics information - <T,\nA extends io.deephaven.chunk.attributes.Any>\n\n:param source: (io.deephaven.chunk.ObjectChunk<T,A>) - the source chunk of T[] to expand\n:param perElementLengthDest: (io.deephaven.chunk.WritableIntChunk<io.deephaven.chunk.attributes.ChunkPositions>) - the destination IntChunk for which dest.get(i + 1) - dest.get(i) is equivalent to source.get(i).length\n:return: (io.deephaven.chunk.WritableChunk<A>) an unrolled/flattened chunk of T"
 },
 "path": "io.deephaven.extensions.barrage.chunk.array.LongArrayExpansionKernel",
 "typeName": "class"
}