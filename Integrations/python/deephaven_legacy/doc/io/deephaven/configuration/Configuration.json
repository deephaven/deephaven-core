{
 "className": "io.deephaven.configuration.Configuration",
 "methods": {
  "TEST_NEW_Configuration": ":return: io.deephaven.configuration.Configuration",
  "checkDirectory": ":param dir: java.lang.String\n:param createDirectory: boolean\n:param message: java.lang.String",
  "determineConfFileProperty": "Find the name of the property specifying the root configuration file. The first property set in the ordered list\n of candidates is returned, or null if none is set.\n\n:return: (java.lang.String) the name of the property specifying a configuration file, or NULL if none is set",
  "expandLinuxPath": "Expand the Linux-style path.\n \n* Change linux-style absolute paths to platform independent absolute. If the path starts with \"/\", replace \"/\"\n with the current directory's root (e.g. \"C:\\\" on Windows.\n* If the path begins with \"~/\", then replace the ~ with the user.home system property.\n* If the path does not begin with \"~/\", then replace all occurrences of ~ with system property user.name.\n* Make sure the path ends in File.separator.\n\n\n:param path: (java.lang.String) - the path to be adjusted\n:return: (java.lang.String) the path with substitutions performed",
  "getConfFileName": ":return: java.lang.String",
  "getConfFileNameFromProperties": "If one of the valid configuration file properties is set, return the value, else return NULL\n\n:return: (java.lang.String) the configuration file value, or NULL if no valid property is set.",
  "getContextKeyValues": "Return the configuration contexts for this process. This is the list of properties that may have been used to\n parse the configuration file. If the configuration has not been parsed, this collection may be empty. This\n collection will be immutable.\n\n:return: (java.util.Collection<java.lang.String>) the configuration contexts.",
  "getDevRootPath": "*Overload 1*  \n  :param propertyName: java.lang.String\n  :return: java.lang.String\n  \n*Overload 2*  \n  :return: java.lang.String",
  "getInstance": "Get the default Configuration instance.\n\n:return: (io.deephaven.configuration.Configuration) the single instance of Configuration allowed in an application",
  "getLogDir": "**Incompatible overloads text - text from the first overload:**\n\nDetermine the directory where process logs should be written using getLogDir(boolean), validating that\n the directory exists or creating the directory if it doesn't exist.\n\n*Overload 1*  \n  :param validateOrCreateDirectory: (boolean) - if true, then if the directory exists validate that it is a directory, and\n          create it if it doesn't exist\n  :return: (java.lang.String) the directory where process logs should be written\n  \n*Overload 2*  \n  :return: (java.lang.String) the directory where process logs should be written",
  "getLogPath": "Compute the log dir and filename for the provided log file name.\n\n:param filename: (java.lang.String) - the name of the log file\n:return: (java.lang.String) the full path and filename for the given filename",
  "getProcessName": "**Incompatible overloads text - text from the first overload:**\n\nGet the process name based on the standard process name property PROCESS_NAME_PROPERTY. If the property\n does not exist and requireProcessName is true, throw an exception. If the property does not exist and\n requireProcessName is false, return null.\n\n*Overload 1*  \n  :return: (java.lang.String) the process name\n  \n*Overload 2*  \n  :param requireProcessName: (boolean) - if true, throw an exception if the process name can't be found or is empty\n  :return: (java.lang.String) the process name, or null if the process name can't be determined and requireProcessName is false",
  "getServerTimezone": ":return: (java.util.TimeZone) the TimeZone the server is running in",
  "getTempPath": ":param componentName: java.lang.String\n:return: java.lang.String",
  "getWorkspacePath": "*Overload 1*  \n  :param propertyName: java.lang.String\n  :return: java.lang.String\n  \n*Overload 2*  \n  :return: java.lang.String",
  "lookupPath": "Treat the system property propertyName as a path, and perform substitution with expandLinuxPath(String).\n\n:param propertyName: (java.lang.String) - system property containing a path\n:return: (java.lang.String) The value of property propertyName after the manipulations.",
  "main": "The following main method compares two directories of prop files and outputs a CSV report of the differences.\n Usually run before the release of a new version into prod\n\n:param args: (java.lang.String[]) - dir1 dir2 outFile.csv",
  "normalizeLogDirectoryPath": "Normalize a directory path. This performs the following substitutions and manipulations.\n \n* <workspace> - replaced with the process workspace\n* <devroot> - replaced with the installation root directory\n* <processname> - replaced with the process name\n* <logroot> - replaced with the value found by the property LOGDIR_ROOT_PROPERTY\n* After all substitutions, expandLinuxPath(String) is called\n* Finally, Path.normalize() is called\n\n\n:param directoryName: (java.lang.String) - the directory name to be normalized\n:return: (java.lang.String) the normalized directory path after the substitutions have been performed",
  "reloadProperties": "Reload properties, then update with all system properties (properties set in System take precedence).",
  "reset": "Clear the current instance, so the next call to getInstance() gives us a new one"
 },
 "path": "io.deephaven.configuration.Configuration",
 "text": "Utility class to provide an enhanced view and common access point for java properties files, as well as common\n configuration pieces such as log directories and workspace-related properties.",
 "typeName": "class"
}