{
 "className": "io.deephaven.client.impl.BarrageSubscriptionImpl",
 "methods": {
  "append": ":param logOutput: io.deephaven.base.log.LogOutput\n:return: io.deephaven.base.log.LogOutput",
  "descriptorFor": "Note: Java generics information - <ReqT,\nRespT>\n\n:param methodType: io.grpc.MethodDescriptor.MethodType\n:param serviceName: java.lang.String\n:param methodName: java.lang.String\n:param requestMarshaller: io.grpc.MethodDescriptor.Marshaller<ReqT>\n:param responseMarshaller: io.grpc.MethodDescriptor.Marshaller<RespT>\n:param descriptor: io.grpc.MethodDescriptor<?,?>\n:return: io.grpc.MethodDescriptor<ReqT,RespT>",
  "entireTable": "**Incompatible overloads text - text from the first overload:**\n\nRequest a full subscription of the data and populate a BarrageTable with the incrementally updating data\n that is received.\n\n*Overload 1*  \n  :return: (io.deephaven.extensions.barrage.table.BarrageTable) the BarrageTable\n  \n*Overload 2*  \n  :param blockUntilComplete: (boolean) - block execution until all rows for the subscribed table are available\n  :return: (io.deephaven.extensions.barrage.table.BarrageTable) the BarrageTable",
  "getClientDoExchangeDescriptor": "Fetch the client side descriptor for a specific table schema.\n\n:param options: (io.deephaven.extensions.barrage.BarrageSubscriptionOptions) - the set of options that last across the entire life of the subscription\n:param columnChunkTypes: (io.deephaven.chunk.ChunkType[]) - the chunk types per column\n:param columnTypes: (java.lang.Class<?>[]) - the class type per column\n:param componentTypes: (java.lang.Class<?>[]) - the component class type per column\n:param streamReader: (io.deephaven.extensions.barrage.util.StreamReader) - the stream reader - intended to be thread safe and re-usable\n:return: (io.grpc.MethodDescriptor<org.apache.arrow.flight.impl.Flight.FlightData,io.deephaven.engine.table.impl.util.BarrageMessage>) the client side method descriptor",
  "isCompleted": "This call will return false until all rows for the subscribed table are available.\n\n:return: (boolean) true when all rows for the subscribed table are available, false otherwise",
  "partialTable": "**Incompatible overloads text - text from the first overload:**\n\nRequest a partial subscription of the data limited by viewport or column set and populate a BarrageTable\n with the data that is received. Allows the viewport to be reversed.\n\n*Overload 1*  \n  :param viewport: (io.deephaven.engine.rowset.RowSet) - the position-space viewport to use for the subscription\n  :param columns: (java.util.BitSet) - the columns to include in the subscription\n  :return: (io.deephaven.extensions.barrage.table.BarrageTable) the BarrageTable\n  \n*Overload 2*  \n  :param viewport: (io.deephaven.engine.rowset.RowSet) - the position-space viewport to use for the subscription\n  :param columns: (java.util.BitSet) - the columns to include in the subscription\n  :param reverseViewport: (boolean) - Whether to treat posRowSet as offsets from #size() rather than 0\n  :return: (io.deephaven.extensions.barrage.table.BarrageTable) the BarrageTable\n  \n*Overload 3*  \n  :param viewport: (io.deephaven.engine.rowset.RowSet) - the position-space viewport to use for the subscription\n  :param columns: (java.util.BitSet) - the columns to include in the subscription\n  :param reverseViewport: (boolean) - Whether to treat posRowSet as offsets from #size() rather than 0\n  :param blockUntilComplete: (boolean) - block execution until the subscribed table viewport is satisfied\n  :return: (io.deephaven.extensions.barrage.table.BarrageTable) the BarrageTable"
 },
 "path": "io.deephaven.client.impl.BarrageSubscriptionImpl",
 "typeName": "class"
}