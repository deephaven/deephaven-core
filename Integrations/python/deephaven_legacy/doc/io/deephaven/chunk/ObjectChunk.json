{
 "className": "io.deephaven.chunk.ObjectChunk",
 "methods": {
  "asTypedObjectChunk": "Note: Java generics information - <T_DERIV extends ObjectChunk.T>\n\n:return: io.deephaven.chunk.ObjectChunk<T_DERIV,ObjectChunk.ATTR>",
  "chunkWrap": "*Overload 1*  \n  Note: Java generics information - <T,\n  ATTR extends io.deephaven.chunk.attributes.Any>\n  \n  :param data: T[]\n  :return: io.deephaven.chunk.ObjectChunk<T,ATTR>\n  \n*Overload 2*  \n  Note: Java generics information - <T,\n  ATTR extends io.deephaven.chunk.attributes.Any>\n  \n  :param data: T[]\n  :param offset: int\n  :param capacity: int\n  :return: io.deephaven.chunk.ObjectChunk<T,ATTR>",
  "copyToArray": "Copy a subrange of this Chunk to the subrange of the 'dest' array.\n\n:param srcOffset: (int) - Starting position in 'this' (the source)\n:param dest: (java.lang.Object) - Destination array.\n:param destOffset: (int) - Starting offset in the destination.\n:param length: (int) - Number of values to copy",
  "copyToChunk": "Copy a subrange of this Chunk to the subrange of the 'dest' writable chunk.\n\n:param srcOffset: (int) - Starting position in 'this' (the source)\n:param dest: (io.deephaven.chunk.WritableChunk<? superObjectChunk.ATTR>) - Destination writable chunk.\n:param destOffset: (int) - Starting offset in the destination.\n:param length: (int) - Number of values to copy",
  "copyToTypedArray": ":param srcOffset: int\n:param destData: ObjectChunk.T[]\n:param destOffset: int\n:param length: int",
  "downcast": "Note: Java generics information - <T,\nATTR extends io.deephaven.chunk.attributes.Any,\nATTR_DERIV extends ATTR>\n\n:param self: io.deephaven.chunk.WritableObjectChunk<T,ATTR>\n:return: io.deephaven.chunk.WritableObjectChunk<T,ATTR_DERIV>",
  "get": ":param index: int\n:return: ObjectChunk.T",
  "getChunkType": ":return: (io.deephaven.chunk.ChunkType) The underlying chunk type",
  "getEmptyChunk": "Note: Java generics information - <T,\nATTR extends io.deephaven.chunk.attributes.Any>\n\n:return: io.deephaven.chunk.ObjectChunk<T,ATTR>",
  "isAlias": "*Overload 1*  \n  :param array: java.lang.Object\n  :return: (boolean) true iff this and array are aliases, that is they refer to the same underlying data\n  \n*Overload 2*  \n  :param chunk: io.deephaven.chunk.Chunk\n  :return: (boolean) true iff this and chunk are aliases, that is they refer to the same underlying data",
  "makeArray": "Note: Java generics information - <T>\n\n:param capacity: int\n:return: T[]",
  "slice": "Make a new Chunk that represents either exactly the same view on the underlying data as this Chunk, or a subrange\n of that view. The view is defined as [0..size) (in the coordinate space of this Chunk).\n\n:param offset: (int) - Offset of the new Chunk, relative to this Chunk. 0   offset   this.size\n:param capacity: (int) - Capacity and initial size of the new Chunk. 0   capacity   this.size - offset.\n:return: (io.deephaven.chunk.ObjectChunk<ObjectChunk.T,ObjectChunk.ATTR>) The new Chunk. A new Chunk will always be returned, even if the Chunks represent the same view.",
  "walk": "Note: Java generics information - <V extends io.deephaven.chunk.Chunk.Visitor<ObjectChunk.ATTR>>\n\n:param visitor: V\n:return: V"
 },
 "path": "io.deephaven.chunk.ObjectChunk",
 "text": "Chunk implementation for Object data.",
 "typeName": "class"
}