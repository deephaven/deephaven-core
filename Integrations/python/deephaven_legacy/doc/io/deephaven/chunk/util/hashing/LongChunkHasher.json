{
 "className": "io.deephaven.chunk.util.hashing.LongChunkHasher",
 "methods": {
  "hashInitial": "**Incompatible overloads text - text from the first overload:**\n\nCalled for the first (or only) hash value, sets the hash codes in destination corresponding to values.\n\n*Overload 1*  \n  :param value: (java.lang.Object) - the boxed object to hash\n  :return: (int) the hashcode, as if you called the chunked version of this function\n  \n*Overload 2*  \n  :param values: (io.deephaven.chunk.Chunk<io.deephaven.chunk.attributes.Values>) - the values to hash\n  :param destination: (io.deephaven.chunk.WritableIntChunk<io.deephaven.chunk.attributes.HashCodes>) - the chunk to write hash values into",
  "hashInitialSingle": ":param value: long\n:return: int",
  "hashUpdate": "**Incompatible overloads text - text from the first overload:**\n\nCalled for subsequent hash values, updates the hash codes in destination corresponding to values.\n\n*Overload 1*  \n  :param existing: (int) - the existing hashcode\n  :param value: (java.lang.Object) - the boxed object to add to the hash code\n  :return: (int) the hashcode, as if you called the chunked version of this function\n  \n*Overload 2*  \n  :param values: (io.deephaven.chunk.Chunk<io.deephaven.chunk.attributes.Values>) - the values to hash\n  :param destination: (io.deephaven.chunk.WritableIntChunk<io.deephaven.chunk.attributes.HashCodes>) - the chunk to update hash values into",
  "hashUpdateSingle": ":param existing: int\n:param newValue: long\n:return: int"
 },
 "path": "io.deephaven.chunk.util.hashing.LongChunkHasher",
 "typeName": "class"
}