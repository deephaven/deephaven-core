{
 "className": "io.deephaven.engine.util.parametrized.TableMapSupplier",
 "methods": {
  "addKeyListener": "Listen to changes in the map's keys.\n\n:param listener: (io.deephaven.engine.table.TableMap.KeyListener) - key change listener",
  "addListener": "Add a new listener for changes to the map.\n\n:param listener: (io.deephaven.engine.table.TableMap.Listener) - map change listener",
  "apply": "Applies a function to this tableMap.\n\n This is useful if you have a reference to a tableMap and want to run a series of operations against the table map\n without each individual operation resulting in a remote method invocation.\n\nNote: Java generics information - <R>\n\n:param function: (java.util.function.Function<io.deephaven.engine.table.TableMap,R>) - the function to run, its single argument will be this table map.\n:return: (R) the return value of function",
  "asTable": "Create a Table out of this TableMap's values.\n\n \n Creates a proxy object that in many respects acts like a Table, you can perform many of the table operations on\n it, which are then applied using TableMap.transformTables(java.util.function.Function) or\n TableMap.transformTablesWithMap(TableMap, BiFunction) if the right hand side of an operation is another\n TableMap.\n \n\n The returned table acts as if it were an uncoalesced table; when two of our Proxy objects are operated on\n together, e.g., by a Table.join(io.deephaven.engine.table.Table)) operation, then tables with identical keys are used. If strictKeys is\n set, an error occurs if the two TableMaps do not have identical keySets.\n \n\n Supported operations include those which return a Table, LongSizedDataStructure.size(),\n Table.getDefinition() and operations to retrieve attributes. Operations which retrieve data (such as\n Table.getRowSet()} or Table.getColumn(int) require a coalesce operation. If allowCoalesce is not\n set to true, then the coalescing operations will fail with an IllegalArgumentException.\n \n\n:param strictKeys: (boolean) - if we should fail when our RHS TableMap does not have the same keySet\n:param allowCoalesce: (boolean) - if we should allow this TableMap to be automatically coalesced into a table\n:param sanityCheckJoins: (boolean) - if we should sanity check join keys, meaning that we should refuse to perform any joins\n        if the join keys would span two segments of the TableMap. This option is safer, but requires additional\n        work on the query engine to perform the safety checks.\n:return: (io.deephaven.engine.table.Table) a Table object that performs operations by segment",
  "dropReference": "Drop a previously-retained reference to this referent.",
  "entrySet": "Gets the entries.\n\n:return: (java.util.Collection<java.util.Map.Entry<java.lang.Object,io.deephaven.engine.table.Table>>) the entries",
  "flatten": "Flattens all of the result tables within the tablemap.\n\n:return: io.deephaven.engine.table.TableMap",
  "get": "Gets a table with a given key. Note that this causes the current\n LivenessManager (see\n LivenessScopeStack) to manage the result if non-null.\n\n:param key: (java.lang.Object) - key\n:return: (io.deephaven.engine.table.Table) table associated with the key, or null if the key is not present.",
  "getKeySet": "Gets the keys.\n\n:return: (java.lang.Object[]) keys",
  "getWeakReference": "Get a WeakReference to this referent. This may be cached, or newly created.\n\n:return: (java.lang.ref.WeakReference<? extends io.deephaven.engine.liveness.LivenessReferent>) A new or cached reference to this referent",
  "getWithTransform": "Gets a table with a given key, applying the specified transform before returning.\n\n:param key: (java.lang.Object) - key\n:param transform: java.util.function.Function<io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>\n:return: (io.deephaven.engine.table.Table) table associated with the key, or null if the key is not present.",
  "merge": "Merges all the component tables into a single Table.\n\n:return: (io.deephaven.engine.table.Table) all of our component tables merged into a single Table.",
  "populateKeys": "When creating the table map, some of the keys that we would like to be there eventually may not exist. This call\n lets you pre-populate keys, so that at initialization time you can perform the appropriate joins, etc., on empty\n tables that you expect to be populated in the future.\n\n:param keys: (java.lang.Object...) - the keys to add to the map\n:return: (io.deephaven.engine.table.TableMap) this TableMap",
  "removeKeyListener": "Removes a key change listener.\n\n:param listener: (io.deephaven.engine.table.TableMap.KeyListener) - key change listener to remove",
  "removeListener": "Removes a map change listener.\n\n:param listener: (io.deephaven.engine.table.TableMap.Listener) - map change listener.",
  "size": "Number of tables in the map.\n\n:return: (int) number of tables in the map.",
  "transformTablesWithKey": "**Incompatible overloads text - text from the first overload:**\n\nApplies a transformation function on all tables in the TableMap, producing a new TableMap which will update as\n new keys are added.\n\n*Overload 1*  \n  :param function: (java.util.function.BiFunction<java.lang.Object,io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>) - the bifunction to apply to each table in this TableMap\n  :return: (io.deephaven.engine.table.TableMap) a new TableMap where each table has had function applied\n  \n*Overload 2*  \n  :param returnDefinition: (io.deephaven.engine.table.TableDefinition) - the table definition for the tables the function will return\n  :param function: (java.util.function.BiFunction<java.lang.Object,io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>) - the bifunction to apply to each table in this TableMap\n  :return: (io.deephaven.engine.table.TableMap) a new TableMap where each table has had function applied",
  "transformTablesWithMap": "Applies a BiFunction function on all tables in this TableMap and otherMap that have matching keys, producing a\n new TableMap which will update as new keys are added. Only applies the function to tables which exist in both\n maps.\n\n:param otherMap: (io.deephaven.engine.table.TableMap) - the other TableMap\n:param function: (java.util.function.BiFunction<io.deephaven.engine.table.Table,io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>) - the function to apply to each table in this TableMap, the tables in this map are the first\n        argument the tables in the other map are the second argument.\n:return: (io.deephaven.engine.table.TableMap) a new TableMap where each table has had function applied",
  "tryManage": "Attempt to add the specified referent to this manager.\n\n:param referent: (io.deephaven.engine.liveness.LivenessReferent) - The referent to add\n:return: (boolean) Whether the referent was in fact added",
  "tryRetainReference": "If this referent is \"live\", behave as LivenessReferent.retainReference() and return true. Otherwise, returns false rather\n than throwing an exception.\n\n:return: (boolean) True if this referent was retained, false otherwise",
  "values": "Gets the values.\n\n:return: (java.util.Collection<io.deephaven.engine.table.Table>) values"
 },
 "path": "io.deephaven.engine.util.parametrized.TableMapSupplier",
 "text": "A TableMapSupplier uses a source TableMap and applies a set of operations in the get method.",
 "typeName": "class"
}