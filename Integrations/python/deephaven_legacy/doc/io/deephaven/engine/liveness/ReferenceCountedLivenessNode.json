{
 "className": "io.deephaven.engine.liveness.ReferenceCountedLivenessNode",
 "methods": {
  "dropReference": "Drop a previously-retained reference to this referent.",
  "getWeakReference": "Get a WeakReference to this referent. This may be cached, or newly created.\n\n:return: (java.lang.ref.WeakReference<? extends io.deephaven.engine.liveness.LivenessReferent>) A new or cached reference to this referent",
  "initializeTransientFieldsForLiveness": "Package-private for Serializable sub-classes to use in readObject only.\n Public to allow unit tests in another package to work around mock issues where the constructor is never invoked.",
  "tryManage": "Attempt to add referent to this manager. Will succeed if referent is live and if this manager is\n not a LivenessReferent or is live.\n\n:param referent: (io.deephaven.engine.liveness.LivenessReferent) - The referent to add\n:return: (boolean) Whether the referent was in fact added",
  "tryRetainReference": "If this referent is \"live\", behave as LivenessReferent.retainReference() and return true. Otherwise, returns false rather\n than throwing an exception.\n\n:return: (boolean) True if this referent was retained, false otherwise",
  "tryUnmanage": "**Incompatible overloads text - text from the first overload:**\n\nFor each referent in referents, if this node is still live and manages referent one or more times, drop one such\n reference.\n\n*Overload 1*  \n  :param referent: (io.deephaven.engine.liveness.LivenessReferent) - The referent to drop\n  :return: (boolean) Whether this node was live and thus in fact tried to drop a reference\n  \n*Overload 2*  \n  :param referents: (java.util.stream.Stream<? extendsio.deephaven.engine.liveness.LivenessReferent>) - The referents to drop\n  :return: (boolean) Whether this node was live and thus in fact tried to drop a reference"
 },
 "path": "io.deephaven.engine.liveness.ReferenceCountedLivenessNode",
 "text": "LivenessNode implementation that relies on reference counting to determine its liveness.",
 "typeName": "class"
}