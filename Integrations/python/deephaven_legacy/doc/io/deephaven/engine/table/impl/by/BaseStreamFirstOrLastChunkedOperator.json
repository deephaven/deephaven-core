{
 "className": "io.deephaven.engine.table.impl.by.BaseStreamFirstOrLastChunkedOperator",
 "methods": {
  "getResultColumns": "Return a map of result columns produced by this operator.\n\n:return: (java.util.Map<java.lang.String,? extends io.deephaven.engine.table.ColumnSource<?>>) a map of name to columns for the result table",
  "modifyChunk": "**Incompatible overloads text - text from the first overload:**\n\nModify a chunk of data previously aggregated into the result columns using a parallel chunk of new values. Never\n includes modifies that have been shifted if IterativeChunkedAggregationOperator.requiresRowKeys() returns true - those are handled in\n IterativeChunkedAggregationOperator.shiftChunk(BucketedContext, Chunk, Chunk, LongChunk, LongChunk, IntChunk, IntChunk, IntChunk, WritableBooleanChunk).\n\n*Overload 1*  \n  :param bucketedContext: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param previousValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values that have been previously aggregated\n  :param newValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values to aggregate\n  :param postShiftRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in post-shift space\n  :param destinations: (io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>) - the destinations in resultColumn to remove the values from, parallel with startPositions and\n          length\n  :param startPositions: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param singletonContext: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param chunkSize: (int) - the size of the modification\n  :param previousValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values that have been previously aggregated.\n  :param newValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values to aggregate\n  :param postShiftRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in post-shift space\n  :param destination: long\n  :return: (boolean) true if the state was modified, false otherwise",
  "modifyRowKeys": "Called with the modified row keys when IterativeChunkedAggregationOperator.requiresRowKeys() returns true if our input columns have not\n changed (or we have none).\n\n*Overload 1*  \n  :param context: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param inputRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in post-shift space\n  :param destinations: (io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>) - the destinations in resultColumn to aggregate into, parallel with startPositions and length\n  :param startPositions: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param context: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param rowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the modified row keys for a given destination, in post-shift space\n  :param destination: (long) - the destination that was modified\n  :return: (boolean) true if the result should be considered modified",
  "removeChunk": "Remove a chunk of data previously aggregated into the result columns.\n\n*Overload 1*  \n  :param bucketedContext: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param values: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values that have been previously aggregated.\n  :param inputRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in pre-shift space\n  :param destinations: (io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>) - the destinations in resultColumn to remove the values from, parallel with startPositions and\n          length\n  :param startPositions: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param singletonContext: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param chunkSize: (int) - the size of the removal\n  :param values: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - the values to remove from the aggregation\n  :param inputRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in pre-shift space\n  :param destination: (long) - the destination in the result columns\n  :return: (boolean) true if the state was modified, false otherwise",
  "requiresRowKeys": "Whether the operator requires row keys. This implies that the operator must process shifts (i.e.\n IterativeChunkedAggregationOperator.shiftChunk(io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext, io.deephaven.chunk.Chunk<? extends io.deephaven.chunk.attributes.Values>, io.deephaven.chunk.Chunk<? extends io.deephaven.chunk.attributes.Values>, io.deephaven.chunk.LongChunk<? extends io.deephaven.engine.rowset.chunkattributes.RowKeys>, io.deephaven.chunk.LongChunk<? extends io.deephaven.engine.rowset.chunkattributes.RowKeys>, io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>, io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>, io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>, io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>)), and must observe modifications even when its input columns (if any) are not modified (i.e.\n IterativeChunkedAggregationOperator.modifyRowKeys(io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext, io.deephaven.chunk.LongChunk<? extends io.deephaven.engine.rowset.chunkattributes.RowKeys>, io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>, io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>, io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>, io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>)).\n\n:return: (boolean) true if the operator requires row keys, false otherwise",
  "resetForStep": "Reset any per-step internal state. Note that the arguments to this method should not be mutated in any way.\n\n:param upstream: (io.deephaven.engine.table.TableUpdate) - The upstream ShiftAwareListener.Update",
  "shiftChunk": "**Incompatible overloads text - text from the first overload:**\n\nCalled with shifted row keys when IterativeChunkedAggregationOperator.requiresRowKeys() returns true, including shifted same-slot modifies.\n\n*Overload 1*  \n  :param bucketedContext: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.BucketedContext) - the operator-specific context\n  :param previousValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values that have been previously aggregated.\n  :param newValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values to aggregate\n  :param preShiftRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in pre-shift space\n  :param postShiftRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in post-shift space\n  :param destinations: (io.deephaven.chunk.IntChunk<io.deephaven.engine.rowset.chunkattributes.RowKeys>) - the destinations in resultColumn to aggregate into, parallel with startPositions and length\n  :param startPositions: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkPositions>) - the starting positions in the chunk for each destination\n  :param length: (io.deephaven.chunk.IntChunk<io.deephaven.chunk.attributes.ChunkLengths>) - the number of values in the chunk for each destination\n  :param stateModified: (io.deephaven.chunk.WritableBooleanChunk<io.deephaven.chunk.attributes.Values>) - a boolean output array, parallel to destinations, which is set to true if the corresponding\n          destination has been modified\n  \n*Overload 2*  \n  :param singletonContext: (io.deephaven.engine.table.impl.by.IterativeChunkedAggregationOperator.SingletonContext) - the operator-specific context\n  :param previousValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values that have been previously aggregated.\n  :param newValues: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - a chunk of values to aggregate\n  :param preShiftRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in pre-shift space\n  :param postShiftRowKeys: (io.deephaven.chunk.LongChunk<? extendsio.deephaven.engine.rowset.chunkattributes.RowKeys>) - the input row keys, in post-shift space\n  :param destination: (long) - the destination in the result columns\n  :return: (boolean) true if the result should be considered modified"
 },
 "path": "io.deephaven.engine.table.impl.by.BaseStreamFirstOrLastChunkedOperator",
 "text": "Base class with shared boilerplate for StreamFirstChunkedOperator and StreamLastChunkedOperator.",
 "typeName": "class"
}