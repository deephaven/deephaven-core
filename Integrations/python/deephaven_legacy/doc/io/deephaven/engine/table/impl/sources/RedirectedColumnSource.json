{
 "className": "io.deephaven.engine.table.impl.sources.RedirectedColumnSource",
 "methods": {
  "allowsReinterpret": "Test if a reinterpret call will succeed.\n\nNote: Java generics information - <ALTERNATE_DATA_TYPE>\n\n:param alternateDataType: (java.lang.Class<ALTERNATE_DATA_TYPE>) - The alternative type to consider\n:return: (boolean) If a reinterpret on this column source with the supplied alternateDataType will succeed.",
  "fillChunk": "Populates the given destination chunk with data corresponding to the keys from the given RowSequence.\n\n:param context: (io.deephaven.engine.table.ChunkSource.FillContext) - A context containing all mutable/state related data used in retrieving the Chunk.\n:param destination: (io.deephaven.chunk.WritableChunk<? superio.deephaven.chunk.attributes.Values>) - The chunk to be populated according to rowSequence. No assumptions shall be made about\n        the size of the chunk shall be made. The chunk will be populated from position [0,rowSequence.size()).\n:param rowSequence: (io.deephaven.engine.rowset.RowSequence) - An RowSequence representing the keys to be fetched",
  "fillPrevChunk": "Populates the given destination chunk with data corresponding to the keys from the given RowSequence.\n\n:param context: (io.deephaven.engine.table.ChunkSource.FillContext) - A context containing all mutable/state related data used in retrieving the Chunk.\n:param destination: (io.deephaven.chunk.WritableChunk<? superio.deephaven.chunk.attributes.Values>) - The chunk to be populated according to rowSequence. No assumptions shall be made\n        about the size of the chunk shall be made. The chunk will be populated from position\n        [0,rowSequence.size()).\n:param rowSequence: (io.deephaven.engine.rowset.RowSequence) - An RowSequence representing the keys to be fetched",
  "get": ":param rowKey: long\n:return: RedirectedColumnSource.T",
  "getBoolean": ":param rowKey: long\n:return: java.lang.Boolean",
  "getByte": ":param rowKey: long\n:return: byte",
  "getChar": ":param rowKey: long\n:return: char",
  "getComponentType": ":return: java.lang.Class<?>",
  "getDouble": ":param rowKey: long\n:return: double",
  "getFloat": ":param rowKey: long\n:return: float",
  "getInt": ":param rowKey: long\n:return: int",
  "getLong": ":param rowKey: long\n:return: long",
  "getPrev": ":param rowKey: long\n:return: RedirectedColumnSource.T",
  "getPrevBoolean": ":param rowKey: long\n:return: java.lang.Boolean",
  "getPrevByte": ":param rowKey: long\n:return: byte",
  "getPrevChar": ":param rowKey: long\n:return: char",
  "getPrevDouble": ":param rowKey: long\n:return: double",
  "getPrevFloat": ":param rowKey: long\n:return: float",
  "getPrevInt": ":param rowKey: long\n:return: int",
  "getPrevLong": ":param rowKey: long\n:return: long",
  "getPrevShort": ":param rowKey: long\n:return: short",
  "getRowRedirection": ":return: io.deephaven.engine.table.impl.util.RowRedirection",
  "getShort": ":param rowKey: long\n:return: short",
  "getUngrouped": "Reach into a grouped column source and pull one element out of the array.\n\n:param columnIndex: (long) - the row key within the column of the cell to get\n:param arrayIndex: (int) - the index within the array at the specified cell\n:return: (RedirectedColumnSource.T) Equivalent to ((Vector)columnSource.get(columnIndex)).get(arrayIndex)",
  "getUngroupedBoolean": ":param columnIndex: long\n:param arrayIndex: int\n:return: java.lang.Boolean",
  "getUngroupedByte": ":param columnIndex: long\n:param arrayIndex: int\n:return: byte",
  "getUngroupedChar": ":param columnIndex: long\n:param arrayIndex: int\n:return: char",
  "getUngroupedDouble": ":param columnIndex: long\n:param arrayIndex: int\n:return: double",
  "getUngroupedFloat": ":param columnIndex: long\n:param arrayIndex: int\n:return: float",
  "getUngroupedInt": ":param columnIndex: long\n:param arrayIndex: int\n:return: int",
  "getUngroupedLong": ":param columnIndex: long\n:param arrayIndex: int\n:return: long",
  "getUngroupedPrev": ":param columnIndex: long\n:param arrayIndex: int\n:return: RedirectedColumnSource.T",
  "getUngroupedPrevBoolean": ":param columnIndex: long\n:param arrayIndex: int\n:return: java.lang.Boolean",
  "getUngroupedPrevByte": ":param columnIndex: long\n:param arrayIndex: int\n:return: byte",
  "getUngroupedPrevChar": ":param columnIndex: long\n:param arrayIndex: int\n:return: char",
  "getUngroupedPrevDouble": ":param columnIndex: long\n:param arrayIndex: int\n:return: double",
  "getUngroupedPrevFloat": ":param columnIndex: long\n:param arrayIndex: int\n:return: float",
  "getUngroupedPrevInt": ":param columnIndex: long\n:param arrayIndex: int\n:return: int",
  "getUngroupedPrevLong": ":param columnIndex: long\n:param arrayIndex: int\n:return: long",
  "getUngroupedPrevShort": ":param columnIndex: long\n:param arrayIndex: int\n:return: short",
  "getUngroupedPrevSize": ":param columnIndex: long\n:return: long",
  "getUngroupedShort": ":param columnIndex: long\n:param arrayIndex: int\n:return: short",
  "getUngroupedSize": ":param columnIndex: (long) - the row key within this column to interrogate\n:return: (long) the size of the Vector at columnIndex.",
  "isImmutable": "Determine if this column source is immutable, meaning that the values at a given row key never change.\n\n:return: (boolean) true if the values at a given row key of the column source never change, false otherwise",
  "isStateless": "Most column sources will return the same value for a given row without respect to the order that the rows are\n read. Those columns sources are considered \"stateless\" and should return true.\n\n Some column sources, however may be dependent on evaluation order. For example, a formula that updates a Map must\n be evaluated from the first row to the last row. A column source that has the potential to depend on the order of\n evaluation must return false.\n\n:return: (boolean) true if this is a stateless column source",
  "isUngroupable": "Does this particular instance of the column source support ungrouping?\n\n:return: (boolean) true if you can call the getUngrouped family of methods and get a valid answer.",
  "makeFillContext": "Allocate a new ChunkSource.FillContext for filling chunks from this FillContextMaker, typically a\n ChunkSource.\n\n:param chunkCapacity: (int) - The maximum size of any WritableChunk that will be filled with this context\n:param sharedContext: (io.deephaven.engine.table.SharedContext) - Shared store of intermediate results.\n:return: (io.deephaven.engine.table.impl.sources.RedirectedColumnSource.FillContext) A context for use with fill operations",
  "preventsParallelism": "Can this column source be evaluated on an arbitrary thread?\n\n Most column sources can be evaluated on an arbitrary thread, however those that do call into Python can not be\n evaluated on an arbitrary thread as the calling thread may already have the GIL, which would result in a deadlock\n when the column source takes the GIL to evaluate formulas.\n\n:return: (boolean) true if this column prevents parallelization",
  "releaseCachedResources": "Release any resources held for caching purposes. Implementations need not guarantee that concurrent accesses are\n correct, as the purpose of this method is to ensure cleanup for column sources that will no longer be used.",
  "startTrackingPrevValues": "ColumnSource implementations that track previous values have the option to not actually start tracking previous\n values until this method is called. This is an option, not an obligation: some simple ColumnSource\n implementations (like TSingleValueSource for various T) always track previous values; other implementations (like\n PrevColumnSource) never do; some (like TArrayColumnSource) only start tracking once this method is called.\n\n An immutable column source can not have distinct prev values; therefore it is implemented as a no-op."
 },
 "path": "io.deephaven.engine.table.impl.sources.RedirectedColumnSource",
 "text": "A ColumnSource that uses a RowRedirection to direct access into an underlying wrapped\n ColumnSource. This is used, for example, in a Table.sort(String...).",
 "typeName": "class"
}