{
 "className": "io.deephaven.engine.table.impl.select.AutoTuningIncrementalReleaseFilter",
 "methods": {
  "copy": "Create a copy of this WhereFilter.\n\n:return: (io.deephaven.engine.table.impl.select.AutoTuningIncrementalReleaseFilter) an independent copy of this WhereFilter."
 },
 "path": "io.deephaven.engine.table.impl.select.AutoTuningIncrementalReleaseFilter",
 "text": "Filter that releases the required number of rows from a table to saturate the UGP cycle.\n \n The table has an initial size, which can be thought of as the size during query initialization. There is an initial\n number of rows that are released, which is then used to tune the number of rows to release on the subsequent cycle.\n \n You must invoke the BaseIncrementalReleaseFilter.start() method to begin producing rows.\n \n\n The targetFactor parameter is multiplied by the UGP's targetCycle. This allows you to determine how busy you want the\n UGP to be. For example a factor of 1, will attempt to hit the target cycle exactly. A target of 0.5 should result an\n UGP ratio of about 50%. A factor of 10 would mean that the system will extend beyond the target cycle time, coalesce\n updates accordingly and have a ratio that is nearly 100%.\n \n The time the rows are released is recorded, and a terminal notification is enqueued to record the end of the cycle.\n On each cycle, the number of rows per second is computed; and then the number of rows released is the UGP's target\n cycle multiplied by the rows per second multiplied by the target factor.\n\n\n \n The AutotuningIncrementalReleaseFilter can be used to benchmark how many rows of data a query can process. In its\n simplest form we can measure how many rows a lastBy statement can process. For example:\n \n\n import io.deephaven.engine.table.impl.select.AutoTuningIncrementalReleaseFilter\n\n quotes = engine.t(\"FeedOS\", \"EquityQuoteL1\").where(\"Date=lastBusinessDateNy()\")\n filter=new AutoTuningIncrementalReleaseFilter(10000, 10000, 1)\n quotesFiltered = quotes.where(filter)\n currentQuote = quotesFiltered.lastBy(\"LocalCodeStr\").update(\"Mid=(Bid + Ask)/2\")\n \n \n Produces a currentQuote table, and you can view the Log tab to determine how many rows per second were processed. The\n summary is sent to the WARN level:\n \n \n 12:55:49.985 WARN Completed release 6.97 seconds, rows=19630961, rows/second=2,817,053.86\n \n \n If verbose mode is enabled, progress is displayed for each cycle at the INFO level.\n \n\n \n You may specify a StreamLoggerImpl() to send the data to STDOUT, as follows:\n \n\n import io.deephaven.engine.table.impl.select.AutoTuningIncrementalReleaseFilter\n\n quotes = engine.t(\"FeedOS\", \"EquityQuoteL1\").where(\"Date=lastBusinessDateNy()\")\n logger = new io.deephaven.io.logger.StreamLoggerImpl()\n filterQuotes=new AutoTuningIncrementalReleaseFilter(logger, 10000, 10000, 1.0d, true)\n quotesFiltered = quotes.where(filterQuotes)\n currentQuote = quotesFiltered.lastBy(\"LocalCodeStr\").update(\"Mid=(Bid + Ask)/2\")\n filterQuotes.start()\n \n\n The verbose information and the final report are easily visible on your console.\n \n\n The AutotuningIncrementalReleaseFilter is best suited for queries that have a single source table with arbitrary\n amounts of processing on that table. Multiple incremental release filters may be combined, and each filter will\n report the number of rows that were released per second, however the data is not synchronized between tables and it\n is not possible to differentiate which table is contributing more to the query's load without examining the\n performance tables. You may need to adjust the initial size parameters so that one table does not complete processing\n before another.\n \n \n import io.deephaven.engine.table.impl.select.AutoTuningIncrementalReleaseFilter\n\n quotes = engine.t(\"FeedOS\", \"EquityQuoteL1\").where(\"Date=lastBusinessDateNy()\")\n trades = engine.t(\"FeedOS\", \"EquityTradeL1\").where(\"Date=lastBusinessDateNy()\")\n filterQuotes=new AutoTuningIncrementalReleaseFilter(10000, 10000, 1, true)\n quotesFiltered = quotes.where(filterQuotes)\n filterTrades=new AutoTuningIncrementalReleaseFilter(10000, 10000, 1, true)\n tradesFiltered = trades.where(filterTrades)\n\n decorated = tradesFiltered.aj(quotesFiltered, \"LocalCodeStr,MarketTimestamp\", \"QuoteTime=MarketTimestamp,Bid,BidSize,Ask,AskSize\")\n\n filterTrades.start()\n filterQuotes.start()",
 "typeName": "class"
}