{
 "className": "io.deephaven.engine.table.TableMap",
 "methods": {
  "addKeyListener": "Listen to changes in the map's keys.\n\n:param listener: (io.deephaven.engine.table.TableMap.KeyListener) - key change listener",
  "addListener": "Add a new listener for changes to the map.\n\n:param listener: (io.deephaven.engine.table.TableMap.Listener) - map change listener",
  "apply": "Applies a function to this tableMap.\n\n This is useful if you have a reference to a tableMap and want to run a series of operations against the table map\n without each individual operation resulting in a remote method invocation.\n\nNote: Java generics information - <R>\n\n:param function: (java.util.function.Function<io.deephaven.engine.table.TableMap,R>) - the function to run, its single argument will be this table map.\n:return: (R) the return value of function",
  "asTableMap": "If you're a TableMap return this, otherwise if you're a Proxy return the underlying TableMap.\n\n:return: (io.deephaven.engine.table.TableMap) a TableMap representation of this object",
  "entrySet": "Gets the entries.\n\n:return: (java.util.Collection<java.util.Map.Entry<java.lang.Object,io.deephaven.engine.table.Table>>) the entries",
  "flatten": "Flattens all of the result tables within the tablemap.\n\n:return: io.deephaven.engine.table.TableMap",
  "get": "Gets a table with a given key. Note that this causes the current\n LivenessManager (see\n LivenessScopeStack) to manage the result if non-null.\n\n:param key: (java.lang.Object) - key\n:return: (io.deephaven.engine.table.Table) table associated with the key, or null if the key is not present.",
  "getKeySet": "Gets the keys.\n\n:return: (java.lang.Object[]) keys",
  "getWithTransform": "Gets a table with a given key, applying the specified transform before returning.\n\n:param key: (java.lang.Object) - key\n:param transform: java.util.function.Function<io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>\n:return: (io.deephaven.engine.table.Table) table associated with the key, or null if the key is not present.",
  "isSentinel": "Check the key passed to the function in transformTablesWithKey(BiFunction), to see if it's the sentinel.\n\n:param key: (java.lang.Object) - the object\n:return: (boolean) true if the key is the sentinel",
  "populateKeys": "When creating the table map, some of the keys that we would like to be there eventually may not exist. This call\n lets you pre-populate keys, so that at initialization time you can perform the appropriate joins, etc., on empty\n tables that you expect to be populated in the future.\n\n:param keys: (java.lang.Object...) - the keys to add to the map\n:return: (io.deephaven.engine.table.TableMap) this TableMap",
  "removeKeyListener": "Removes a key change listener.\n\n:param listener: (io.deephaven.engine.table.TableMap.KeyListener) - key change listener to remove",
  "removeListener": "Removes a map change listener.\n\n:param listener: (io.deephaven.engine.table.TableMap.Listener) - map change listener.",
  "size": "Number of tables in the map.\n\n:return: (int) number of tables in the map.",
  "transformTables": "Applies a transformation function on all tables in the TableMap, producing a new TableMap which will update as\n new keys are added.\n\n*Overload 1*  \n  :param function: (java.util.function.Function<io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>) - the function to apply to each table in this TableMap\n  :return: (io.deephaven.engine.table.TableMap) a new TableMap where each table has had function applied\n  \n*Overload 2*  \n  :param returnDefinition: (io.deephaven.engine.table.TableDefinition) - the table definition for the tables the function will return\n  :param function: (java.util.function.Function<io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>) - the function to apply to each table in this TableMap\n  :return: (io.deephaven.engine.table.TableMap) a new TableMap where each table has had function applied",
  "transformTablesWithKey": "**Incompatible overloads text - text from the first overload:**\n\nApplies a transformation function on all tables in the TableMap, producing a new TableMap which will update as\n new keys are added.\n\n*Overload 1*  \n  :param function: (java.util.function.BiFunction<java.lang.Object,io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>) - the bifunction to apply to each table in this TableMap\n  :return: (io.deephaven.engine.table.TableMap) a new TableMap where each table has had function applied\n  \n*Overload 2*  \n  :param returnDefinition: (io.deephaven.engine.table.TableDefinition) - the table definition for the tables the function will return\n  :param function: (java.util.function.BiFunction<java.lang.Object,io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>) - the bifunction to apply to each table in this TableMap\n  :return: (io.deephaven.engine.table.TableMap) a new TableMap where each table has had function applied",
  "transformTablesWithMap": "Applies a BiFunction function on all tables in this TableMap and otherMap that have matching keys, producing a\n new TableMap which will update as new keys are added. Only applies the function to tables which exist in both\n maps.\n\n:param otherMap: (io.deephaven.engine.table.TableMap) - the other TableMap\n:param function: (java.util.function.BiFunction<io.deephaven.engine.table.Table,io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>) - the function to apply to each table in this TableMap, the tables in this map are the first\n        argument the tables in the other map are the second argument.\n:return: (io.deephaven.engine.table.TableMap) a new TableMap where each table has had function applied",
  "values": "Gets the values.\n\n:return: (java.util.Collection<io.deephaven.engine.table.Table>) values"
 },
 "path": "io.deephaven.engine.table.TableMap",
 "text": "A map of tables.",
 "typeName": "interface"
}