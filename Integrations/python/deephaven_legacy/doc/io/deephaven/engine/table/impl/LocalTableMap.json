{
 "className": "io.deephaven.engine.table.impl.LocalTableMap",
 "methods": {
  "apply": "Applies a function to this tableMap.\n\n This is useful if you have a reference to a tableMap and want to run a series of operations against the table map\n without each individual operation resulting in a remote method invocation.\n\nNote: Java generics information - <R>\n\n:param function: (java.util.function.Function<io.deephaven.engine.table.TableMap,R>) - the function to run, its single argument will be this table map.\n:return: (R) the return value of function",
  "asTable": "Create a Table out of this TableMap's values.\n\n \n Creates a proxy object that in many respects acts like a Table, you can perform many of the table operations on\n it, which are then applied using TableMap.transformTables(java.util.function.Function) or\n TableMap.transformTablesWithMap(TableMap, BiFunction) if the right hand side of an operation is another\n TableMap.\n \n\n The returned table acts as if it were an uncoalesced table; when two of our Proxy objects are operated on\n together, e.g., by a Table.join(io.deephaven.engine.table.Table)) operation, then tables with identical keys are used. If strictKeys is\n set, an error occurs if the two TableMaps do not have identical keySets.\n \n\n Supported operations include those which return a Table, LongSizedDataStructure.size(),\n Table.getDefinition() and operations to retrieve attributes. Operations which retrieve data (such as\n Table.getRowSet()} or Table.getColumn(int) require a coalesce operation. If allowCoalesce is not\n set to true, then the coalescing operations will fail with an IllegalArgumentException.\n \n\n:param strictKeys: (boolean) - if we should fail when our RHS TableMap does not have the same keySet\n:param allowCoalesce: (boolean) - if we should allow this TableMap to be automatically coalesced into a table\n:param sanityCheckJoins: (boolean) - if we should sanity check join keys, meaning that we should refuse to perform any joins\n        if the join keys would span two segments of the TableMap. This option is safer, but requires additional\n        work on the query engine to perform the safety checks.\n:return: (io.deephaven.engine.table.Table) a Table object that performs operations by segment",
  "computeIfAbsent": ":param key: java.lang.Object\n:param tableFactory: java.util.function.Function<java.lang.Object,io.deephaven.engine.table.Table>\n:return: io.deephaven.engine.table.Table",
  "containsKey": ":param key: java.lang.Object\n:return: boolean",
  "entrySet": "Gets the entries.\n\n:return: (java.util.Collection<java.util.Map.Entry<java.lang.Object,io.deephaven.engine.table.Table>>) the entries",
  "flatten": "Flattens all of the result tables within the tablemap.\n\n:return: io.deephaven.engine.table.TableMap",
  "get": "Gets a table with a given key. Note that this causes the current\n LivenessManager (see\n LivenessScopeStack) to manage the result if non-null.\n\n:param key: (java.lang.Object) - key\n:return: (io.deephaven.engine.table.Table) table associated with the key, or null if the key is not present.",
  "getCallback": ":return: io.deephaven.engine.table.impl.LocalTableMap.PopulateCallback",
  "getConstituentDefinition": ":return: java.util.Optional<io.deephaven.engine.table.TableDefinition>",
  "getConstituentDefinitionOrErr": ":return: io.deephaven.engine.table.TableDefinition",
  "getKeySet": "Gets the keys.\n\n:return: (java.lang.Object[]) keys",
  "getTransformationThreads": "Returns the number of transformation threads that will be used (if this TableMap is not configured to use the\n global thread pool). If this TableMap is configured to use the global thread pool, then this value is ignored.\n\n:return: (int) the number of threads that will be used for transformations",
  "getWithTransform": "Gets a table with a given key, applying the specified transform before returning.\n\n:param key: (java.lang.Object) - key\n:param transform: java.util.function.Function<io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>\n:return: (io.deephaven.engine.table.Table) table associated with the key, or null if the key is not present.",
  "isMergeable": ":return: boolean",
  "isSystemicObject": "Returns true if this is a systemically important object (see SystemicObjectTracker).\n\n:return: (boolean) true if this is a systemically important object, false otherwise.",
  "markSystemic": "Mark this object as systemically important.",
  "merge": "Merges all the component tables into a single Table.\n\n:return: (io.deephaven.engine.table.Table) all of our component tables merged into a single Table.",
  "populateKeys": "When creating the table map, some of the keys that we would like to be there eventually may not exist. This call\n lets you pre-populate keys, so that at initialization time you can perform the appropriate joins, etc., on empty\n tables that you expect to be populated in the future.\n\n:param keys: (java.lang.Object...) - the keys to add to the map\n:return: (io.deephaven.engine.table.TableMap) this TableMap",
  "put": "Add a table to the map with the given key. Return the previous value, if any.\n\n:param key: (java.lang.Object) - the key to add\n:param table: (io.deephaven.engine.table.Table) - the value to add\n:return: (io.deephaven.engine.table.Table) the previous table for the given key",
  "removeKeys": ":param keys: java.lang.Object...",
  "satisfied": "Is this ancestor satisfied? Note that this method must be safe to call on any thread.\n\n:param step: (long) - The step for which we are testing satisfaction\n:return: (boolean) Whether the dependency is satisfied on step (and will not fire subsequent notifications)",
  "setDependency": ":param dependency: io.deephaven.engine.updategraph.NotificationQueue.Dependency",
  "setTransformationThreads": "Set the number of transformation threads that should be used. Additionally, the global transformation thread pool\n is disabled for this TableMap.\n\n Derived TableMaps will inherit this setting (but use their own thread pool).\n\n:param transformationThreads: (int) - the number of threads that should be used for transformations",
  "setUseGlobalTransformationThreadPool": "Sets whether this LocalTableMap is configured to use the global transformation thread pool.\n\n When set to true, the global thread pool configured in OperationInitializationThreadPool is used.\n\n When set to false, a thread pool for this particular TableMap is used (or no thread pool if transformation\n threads is set to 1).\n\n:param useGlobalTransformationThreadPool: boolean",
  "size": "Number of tables in the map.\n\n:return: (int) number of tables in the map.",
  "toString": ":return: java.lang.String",
  "transformTablesWithKey": "**Incompatible overloads text - text from the first overload:**\n\nApplies a transformation function on all tables in the TableMap, producing a new TableMap which will update as\n new keys are added.\n\n*Overload 1*  \n  :param function: (java.util.function.BiFunction<java.lang.Object,io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>) - the bifunction to apply to each table in this TableMap\n  :return: (io.deephaven.engine.table.TableMap) a new TableMap where each table has had function applied\n  \n*Overload 2*  \n  :param returnDefinition: (io.deephaven.engine.table.TableDefinition) - the table definition for the tables the function will return\n  :param function: (java.util.function.BiFunction<java.lang.Object,io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>) - the bifunction to apply to each table in this TableMap\n  :return: (io.deephaven.engine.table.TableMap) a new TableMap where each table has had function applied",
  "transformTablesWithMap": "Applies a BiFunction function on all tables in this TableMap and otherMap that have matching keys, producing a\n new TableMap which will update as new keys are added. Only applies the function to tables which exist in both\n maps.\n\n:param other: (io.deephaven.engine.table.TableMap) - the other TableMap\n:param function: (java.util.function.BiFunction<io.deephaven.engine.table.Table,io.deephaven.engine.table.Table,io.deephaven.engine.table.Table>) - the function to apply to each table in this TableMap, the tables in this map are the first\n        argument the tables in the other map are the second argument.\n:return: (io.deephaven.engine.table.TableMap) a new TableMap where each table has had function applied",
  "useGlobalTransformationThreadPool": "Returns whether this LocalTableMap is configured to use the global transformation thread pool.\n\n Derived TableMaps will inherit this setting (but use their own thread pool).\n\n:return: (boolean) true if transformTables and transformTablesWithMap will use the global thread pool; false if they will\n         use a private thread pool",
  "values": "Gets the values.\n\n:return: (java.util.Collection<io.deephaven.engine.table.Table>) values"
 },
 "path": "io.deephaven.engine.table.impl.LocalTableMap",
 "text": "A TableMap implementation backed by a Map.",
 "typeName": "class"
}