{
 "className": "io.deephaven.engine.table.PartitionedTable",
 "methods": {
  "constituentChangesPermitted": "Can the constituents of the underlying partitioned table change?\n \n This is completely unrelated to whether the constituents themselves are refreshing,\n or whether the underlying partitioned table is refreshing. Note that the underlying partitioned table\n must be refreshing if it contains any refreshing constituents.\n \n PartitionedTables that specify constituentChangesPermitted() == false must be guaranteed to never change\n their constituents. Formally, it is expected that table() will never report additions, removals, or\n shifts, and that any modifications reported will not change values in the constituent column (that is,\n table().getColumnSource(constituentColumnName())).\n\n:return: (boolean) Whether the constituents of the underlying partitioned table can change",
  "constituentColumnName": "Get the name of the \"constituent\" column of tables.\n\n:return: (java.lang.String) The constituent column name",
  "constituentDefinition": "Get a definition shared by or\n mutually compatible with all constituent\n tables.\n\n:return: (io.deephaven.engine.table.TableDefinition) The constituent definition",
  "constituentFor": "Get a single constituent by its corresponding key column values.\n \n The keyColumnValues can be thought of as a tuple constraining the values for the corresponding key\n columns for the result row. If there are no matching rows, the result is null. If there are multiple\n matching rows, an UnsupportedOperationException is thrown.\n \n The result will be managed by the\n enclosing liveness scope.\n \n Note that if constituentChangesPermitted(), this method may return different results if invoked multiple\n times.\n\n:param keyColumnValues: (java.lang.Object...) - Ordered, boxed values for the key columns in the same order as keyColumnNames()\n:return: (io.deephaven.engine.table.Table) The constituent at the single row in table() matching the keyColumnValues,\n         or null if no matches were found",
  "constituents": "Get all the current constituents.\n \n The results will be managed by the\n enclosing liveness scope.\n \n Note that if constituentChangesPermitted(), this method may return different results if invoked multiple\n times.\n\n:return: (io.deephaven.engine.table.Table[]) An array of all current constituents",
  "filter": "Make a new PartitionedTable from the result of applying filters to the underlying partitioned table.\n \nfilters must not reference the constituent column.\n\n:param filters: (java.util.Collection<? extendsio.deephaven.api.filter.Filter>) - The filters to apply. Must not reference the constituent column.\n:return: (io.deephaven.engine.table.PartitionedTable) The filtered PartitionedTable",
  "keyColumnNames": "Get the names of all \"key\" columns that are part of table().getDefinition(). If there are no key columns,\n the result will be empty. This set is explicitly ordered.\n\n:return: (java.util.Set<java.lang.String>) The key column names",
  "merge": "Make a new Table that contains the rows from all the constituent tables of this PartitionedTable, in the\n same relative order as the underlying partitioned table and its constituents. If constituent tables contain extra\n columns not in the constituent definition, those columns will be ignored. If\n constituent tables are missing columns in the constituent definition, the corresponding output rows will be\n null.\n\n:return: (io.deephaven.engine.table.Table) A merged representation of the constituent tables",
  "partitionedTransform": "Apply transformer to all constituent tables found in this and other with\n the same key column values, and produce a new PartitionedTable containing the results.\n \n Note that other's key columns must match this PartitionedTable's key columns. Two matching\n mechanisms are supported, and will be attempted in the order listed:\n \n* Match by column name. Both PartitionedTables must have all the same key column\n names. Like-named columns must have the same data type and\n component type.\n* Match by column order. Both PartitionedTables must have their matchable columns in the same order within\n their key column names. Like-positioned columns must have the same\n data type and component type.\n\n\ntransformer must be stateless, safe for concurrent use, and able to return a valid result for empty input\n tables.\n\n:param other: (io.deephaven.engine.table.PartitionedTable) - The other PartitionedTable to find constituents in\n:param transformer: (java.util.function.BinaryOperator<io.deephaven.engine.table.Table>) - The BinaryOperator to apply to all pairs of constituent tables\n:return: (io.deephaven.engine.table.PartitionedTable) The new PartitionedTable containing the resulting constituents",
  "proxy": "**Incompatible overloads text - text from the first overload:**\n\n\n Make a proxy that allows table operations to be applied to the constituent tables of this\n PartitionedTable.\n \n Each operation thus applied will produce a new PartitionedTable with the results as in\n transform(UnaryOperator) or partitionedTransform(PartitionedTable, BinaryOperator), and return\n a new proxy to that PartitionedTable.\n\n*Overload 1*  \n  :return: (io.deephaven.engine.table.PartitionedTable.Proxy) A proxy that allows table operations to be applied to the constituent tables of\n           this PartitionedTable\n  \n*Overload 2*  \n  :param requireMatchingKeys: (boolean) - Whether to ensure that both partitioned tables have all the same keys present when a\n          proxied operation uses this and another PartitionedTable as inputs for a\n          partitioned transform\n  :param sanityCheckJoinOperations: (boolean) - Whether to check that proxied join operations will only find a given join key in\n          one constituent table for this and the table argument if it is also a\n          proxy\n  :return: (io.deephaven.engine.table.PartitionedTable.Proxy) A proxy that allows table operations to be applied to the constituent tables of\n           this PartitionedTable",
  "sort": "Make a new PartitionedTable from the result of applying sortColumns to the underlying partitioned table.\n \nsortColumns must not reference the constituent column.\n\n:param sortColumns: (java.util.Collection<io.deephaven.api.SortColumn>) - The columns to sort by. Must not reference the constituent column.\n:return: (io.deephaven.engine.table.PartitionedTable) The sorted PartitionedTable",
  "table": "Get the \"raw\" partitioned table underlying this PartitionedTable.\n\n:return: (io.deephaven.engine.table.Table) The underlying partitioned table",
  "transform": "Apply transformer to all constituent tables, and produce a new PartitionedTable containing\n the results.\n \ntransformer must be stateless, safe for concurrent use, and able to return a valid result for an empty\n input table.\n\n:param transformer: (java.util.function.UnaryOperator<io.deephaven.engine.table.Table>) - The UnaryOperator to apply to all constituent tables\n:return: (io.deephaven.engine.table.PartitionedTable) The new PartitionedTable containing the resulting constituents",
  "uniqueKeys": "Are the keys (key column values for a row considered as a tuple) in the underlying partitioned\n table unique?\n \n If keys are unique, one can expect that table().selectDistinct(keyColumnNames.toArray(String[]::new)) is\n equivalent to table().view(keyColumnNames.toArray(String[]::new)).\n\n:return: (boolean) Whether the keys in the underlying partitioned table are unique"
 },
 "path": "io.deephaven.engine.table.PartitionedTable",
 "text": "Interface for working with partitioned tables.\n \n A partitioned table is a Table with one or more columns containing non-null, like-defined constituent\n tables, optionally with \"key\" columns defined to allow\n partitionedTransform(PartitionedTable, BinaryOperator) or proxied joins with other like-keyed partitioned\n tables.\n \n Note that partitioned tables should depend on\n and manage their\n refreshing constituents.",
 "typeName": "interface"
}