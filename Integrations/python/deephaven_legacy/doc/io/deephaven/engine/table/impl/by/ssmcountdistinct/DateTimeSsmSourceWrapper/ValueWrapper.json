{
 "className": "io.deephaven.engine.table.impl.by.ssmcountdistinct.DateTimeSsmSourceWrapper$ValueWrapper",
 "methods": {
  "equals": ":param o: java.lang.Object\n:return: boolean",
  "get": ":param i: long\n:return: io.deephaven.time.DateTime",
  "getComponentType": ":return: java.lang.Class<io.deephaven.time.DateTime>",
  "getDirect": "Return a version of this Vector that is flattened out to only reference memory.\n\n:return: io.deephaven.vector.ObjectVector<io.deephaven.time.DateTime>",
  "getPrevValues": ":param previousLongs: io.deephaven.vector.LongVector\n:return: io.deephaven.vector.ObjectVector<io.deephaven.time.DateTime>",
  "hashCode": ":return: int",
  "intSize": "Returns LongSizedDataStructure.size() cast to an int, if this can be done without losing precision. Otherwise, throws\n SizeException.\n\n*Overload 1*  \n  :return: (int) LongSizedDataStructure.size(), cast to an int\n  \n*Overload 2*  \n  :param operation: (java.lang.String) - A description of the operation that requires an int size\n  :return: (int) LongSizedDataStructure.size(), cast to an int",
  "isEmpty": ":return: boolean",
  "size": "The size of this data structure.\n\n:return: (long) The size",
  "subVector": ":param fromIndexInclusive: long\n:param toIndexExclusive: long\n:return: io.deephaven.vector.ObjectVector<io.deephaven.time.DateTime>",
  "subVectorByPositions": ":param positions: long[]\n:return: io.deephaven.vector.ObjectVector<io.deephaven.time.DateTime>",
  "toArray": ":return: io.deephaven.time.DateTime[]",
  "toString": ":return: java.lang.String"
 },
 "path": "io.deephaven.engine.table.impl.by.ssmcountdistinct.DateTimeSsmSourceWrapper.ValueWrapper",
 "typeName": "class"
}