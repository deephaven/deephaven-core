{
 "className": "io.deephaven.base.string.cache.CharSequenceAdapter",
 "methods": {
  "clear": "Prepare this adapter for re-use, and eliminate references to external resources.\n\n:return: io.deephaven.base.string.cache.CharSequenceAdapter",
  "compareTo": "Implementations MUST compare StringCompatibles and Strings char-by-char.\n\n:param that: java.lang.CharSequence\n:return: (int) 0, <0, or >0 if that compares equal-to, less-than, or greater-than this.",
  "equals": ":param that: java.lang.Object\n:return: (boolean) true iff that is a StringCompatible of the same class with identical members.",
  "hashCode": "Implementations MUST match the current implementation of String.hashCode().\n\n:return: (int) A hashcode value for this StringCompatible that matches the value a String of the same chars.",
  "subSequence": ":param start: int\n:param end: int\n:return: java.lang.CharSequence",
  "toString": "Convert this StringCompatible into a String. Implementations should not cache result Strings, in order to avoid\n inadvertently allowing promotion of short-lived objects under generational garbage collection.\n\n:return: (java.lang.String) A newly constructed String representing the same sequence of characters as this StringCompatible."
 },
 "path": "io.deephaven.base.string.cache.CharSequenceAdapter",
 "text": "This class provides base functionality for several implementations of CharSequenceAdapter. Currently, there's one for\n ByteBuffers, another for byte arrays, one for sequences of chars, and one for chains of Strings. If you have\n array-backed, writable ByteBuffers, it's probably best to use the byte array implementation with the backing array,\n e.g. for ByteBuffer b, ByteBufferCharSequenceAdapterImpl a, proto-String length l, use: a.set(b.array(), b.position()\n + b.arrayOffset(), l);\n\n Note: trim() support hasn't been needed/implemented so far. Note: Only Latin-1 (ISO-8859-1) characters are expected\n at this time. Bytes are converted to chars one-for-one with the result masked by 0xFF.\n\n Implementations are not thread-safe. Pool them, create ThreadLocal instances, or (better) instantiate them along\n natural concurrency boundaries. Implementations allow any proto-String (that is, anything that can be expressed as a\n sequence of chars) to be used as a cache key (in ConcurrentUnboundedStringCache instances) and a String creator.\n\n Note Subclasses *must* support length(), and charAt(int index).\n\n Note The makeString() implementation *must* be consistent with length() and charAt(int index) - that is, we require\n that makeString().contentEquals(this).\n\n Note subSequence(int start, int end) is unsupported by default - no StringCache implementations need it at this time.",
 "typeName": "class"
}