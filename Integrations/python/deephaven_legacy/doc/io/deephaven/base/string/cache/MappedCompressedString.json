{
 "className": "io.deephaven.base.string.cache.MappedCompressedString",
 "methods": {
  "capacity": ":return: int",
  "putIfAbsent": "Add the specified  pair if no mapping already exists for key.\n\n:param key: (io.deephaven.base.reference.SimpleReference<?>) - A non-null Reference to an arbitrary object whose reachability determines mapping validity.\n:param potentialValue: (int) - The value to insert if none already exists. Must not equal NULL_MAPPING_VALUE.\n:return: (int) The existing mapped value, if present, or NULL_MAPPING_VALUE if potentialValue was used.",
  "toCompressedString": "Convert this StringCompatible into a CompressedString. Implementations should not cache result CompressedStrings,\n in order to avoid inadvertently allowing promotion of short-lived objects under generational garbage collection.\n\n:return: (io.deephaven.base.string.cache.CompressedString) A newly constructed CompressedString representing the same sequence of characters as this\n         StringCompatible (or this object, if appropriate).",
  "toMappedCompressedString": "Convert this StringCompatible into a MappedCompressedString. Implementations should not cache result\n CompressedStrings, in order to avoid inadvertently allowing promotion of short-lived objects under generational\n garbage collection.\n\n:return: (io.deephaven.base.string.cache.MappedCompressedString) A newly constructed MappedCompressedString representing the same sequence of characters as this\n         StringCompatible (or this object, if appropriate)."
 },
 "path": "io.deephaven.base.string.cache.MappedCompressedString",
 "text": "This is a ridiculously simple, light-as-I-can-make-it, but decidedly single-purpose data structure. Specifically,\n it's a CompressedString with an embedded (to avoid reference or Object instance overhead) open-addressed\n SimpleReference-identity -> int hash map with load factor 1 (100%) and no public operations other than\n \"putIfAbsent\".\n\n The reason for requiring that key objects be SimpleReferences is to allow for O(1) automatic slot reclamation across\n many MappedCompressedString instances at the same time. A given source of mappings creates a single SimpleReference\n to use as a key, and may invalidate mappings (creating a deleted slot) simply by clearing the SimpleReference. In\n practice, a WeakSimpleReference to the source itself is used, in order to also allow garbage collection of the\n mapping source object to invalidate all of its mappings.\n\n Unfortunately, I haven't figured out a way to make this allow concurrent gets.\n\n The intended use is in Deephaven import code, for storing SymbolManager -> SymbolId mappings on the CompressedString\n that represents the Symbol itself, typically inside of a (bounded) StringCache of MappedCompressedString instances.\n\n Note that this uses io.deephaven.base.reference.SimpleReference instead of java.lang.ref.Reference so that unit tests\n can avoid being required to use the concrete sub-classes of Reference, which all come with GC-related side-effects.",
 "typeName": "class"
}