{
 "className": "io.deephaven.base.string.cache.StringAlike",
 "methods": {
  "codePointAt": ":param index: int\n:return: int",
  "codePointBefore": ":param index: int\n:return: int",
  "codePointCount": ":param beginIndex: int\n:param endIndex: int\n:return: int",
  "compareToIgnoreCase": ":param that: java.lang.CharSequence\n:return: int",
  "concat": "*Overload 1*  \n  :param other: java.lang.String\n  :return: StringAlike.TYPE\n  \n*Overload 2*  \n  :param other: StringAlike.TYPE\n  :return: StringAlike.TYPE",
  "contains": ":param cs: java.lang.CharSequence\n:return: boolean",
  "contentEquals": ":param cs: java.lang.CharSequence\n:return: boolean",
  "endsWith": ":param suffix: java.lang.CharSequence\n:return: boolean",
  "equalsIgnoreCase": ":param that: java.lang.CharSequence\n:return: boolean",
  "getBytes": ":return: byte[]",
  "getChars": ":param srcBegin: int\n:param srcEnd: int\n:param dst: char[]\n:param dstBegin: int",
  "indexOf": "*Overload 1*  \n  :param ch: int\n  :param fromIndex: int\n  :return: int\n  \n*Overload 2*  \n  :param ch: int\n  :return: int\n  \n*Overload 3*  \n  :param cs: java.lang.CharSequence\n  :param fromIndex: int\n  :return: int\n  \n*Overload 4*  \n  :param cs: java.lang.CharSequence\n  :return: int",
  "intern": ":return: StringAlike.TYPE",
  "isEmpty": ":return: boolean",
  "lastIndexOf": "*Overload 1*  \n  :param ch: int\n  :param fromIndex: int\n  :return: int\n  \n*Overload 2*  \n  :param ch: int\n  :return: int\n  \n*Overload 3*  \n  :param cs: java.lang.CharSequence\n  :param fromIndex: int\n  :return: int\n  \n*Overload 4*  \n  :param cs: java.lang.CharSequence\n  :return: int",
  "matches": ":param regex: java.lang.CharSequence\n:return: boolean",
  "regionMatches": ":param ignoreCase: boolean\n:param offset: int\n:param that: java.lang.CharSequence\n:param thatOffset: int\n:param length: int\n:return: boolean",
  "replace": "*Overload 1*  \n  :param oldChar: char\n  :param newChar: char\n  :return: StringAlike.TYPE\n  \n*Overload 2*  \n  :param target: java.lang.CharSequence\n  :param replacement: java.lang.CharSequence\n  :return: StringAlike.TYPE",
  "replaceAll": ":param regex: java.lang.CharSequence\n:param replacement: java.lang.CharSequence\n:return: StringAlike.TYPE",
  "replaceFirst": ":param regex: java.lang.CharSequence\n:param replacement: java.lang.CharSequence\n:return: StringAlike.TYPE",
  "split": "*Overload 1*  \n  :param regex: java.lang.CharSequence\n  :param limit: int\n  :return: StringAlike.TYPE[]\n  \n*Overload 2*  \n  :param regex: java.lang.CharSequence\n  :return: StringAlike.TYPE[]",
  "startsWith": "*Overload 1*  \n  :param prefix: java.lang.CharSequence\n  :param offset: int\n  :return: boolean\n  \n*Overload 2*  \n  :param prefix: java.lang.CharSequence\n  :return: boolean",
  "substring": "*Overload 1*  \n  :param beginIndex: int\n  :param endIndex: int\n  :return: StringAlike.TYPE\n  \n*Overload 2*  \n  :param beginIndex: int\n  :return: StringAlike.TYPE",
  "toCharArray": ":return: char[]",
  "toLowerCase": "*Overload 1*  \n  :param locale: java.util.Locale\n  :return: StringAlike.TYPE\n  \n*Overload 2*  \n  :return: StringAlike.TYPE",
  "toUpperCase": "*Overload 1*  \n  :param locale: java.util.Locale\n  :return: StringAlike.TYPE\n  \n*Overload 2*  \n  :return: StringAlike.TYPE",
  "trim": ":return: StringAlike.TYPE"
 },
 "path": "io.deephaven.base.string.cache.StringAlike",
 "text": "This creates an interface (with more permissive argument types, and generified return types) for most public instance\n methods of class String.\n\n For static methods, often the String implementation should be used and its results converted to the desired type via\n construction. That is, for String method M, and StringAlike class SAC, follow the following pattern: new\n SAC(String.M(args...))\n\n For JavaDocs, see String.",
 "typeName": "interface"
}