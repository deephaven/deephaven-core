{
 "className": "io.deephaven.clientsupport.plotdownsampling.IntValueTracker",
 "methods": {
  "append": "Indicates that a new value is being added to the original table being downsampled, and its value should be\n considered as possibly interesting. Implementations should read the value from the chunk and specialize based on\n that type of data.\n\n If it is the only value in the bucket (specified by the offset), include this value as both the max and the min.\n If there are other values, check to see if the new value is either the new max or the new min. In any case where\n this becomes the new max or the new min, mark that position as being valid, indicating that we are confident that\n we have the largest or smallest value at that offset.\n\n Implementations must take care to check if the value is null. If so, if nulls is present, the current\n row key should be added to it. If the\n\n:param offset: (int) - the offset of the bucket state to use - use this with minValuePosition/maxValuePosition to compute\n               the actual position in the underlying array sources\n:param rowKey: (long) - the row key in the original table of the specified value. If the current given value is interesting\n                 in some way, record this using setMinIndex/setMaxIndex so we can construct the full downsampled\n                 table row set later\n:param valuesChunk: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - the chunk that we're currently examining\n:param indexInChunk: (int) - the index in the chunk that we're currently examining\n:param nulls: io.deephaven.engine.rowset.WritableRowSet",
  "toString": "Create a String representation of the tracked values and metadata at the given offset for logging/debugging\n purposes.\n\n:param offset: int\n:return: java.lang.String",
  "update": "Indicates that a value has changed in the original table that is being downsampled, and we should consider if the\n old value or the new value was interesting. Implementations should read the value from the chunk and specialize\n based on that type of data.\n\n There are three cases to consider for each min and max, so six cases in total. Here is the summary for the three\n \"max\" cases, the opposite must be likewise done for the min cases:\n\n If the updated row was the old max, then we cover two of the cases:\n   o  if the new value is greater than the old value, record the new value, but we are still the max and still\n      valid.\n   o  if the new value is less than the old value, invalidate this row but keep the old max, we may need to\n      rescan later\n\n Otherwise, if the new value is greater than the old max, then the current row is now the new max, and are now\n valid.\n\n:param offset: (int) - the offset of the bucket state to use - use this with minValuePosition/maxValuePosition to compute\n               the actual position in the underlying array sources\n:param rowKey: (long) - the row key in the original table of the specified value. If the current given value is interesting\n                 in some way, record this using setMinIndex/setMaxIndex so we can construct the full downsampled\n                 table row set later\n:param valuesChunk: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - the chunk that we're currently examining\n:param indexInChunk: (int) - the index in the chunk that we're currently examining\n:param nulls: io.deephaven.engine.rowset.WritableRowSet",
  "validate": "Scan the given chunk and confirm that whichever values are currently selected as max and min are correct, and\n that the current data is now valid.\n\n:param offset: int\n:param rowKey: long\n:param valuesChunk: io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>\n:param indexInChunk: int\n:param nulls: io.deephaven.engine.rowset.RowSet"
 },
 "path": "io.deephaven.clientsupport.plotdownsampling.IntValueTracker",
 "text": "See ReplicateDownsamplingValueTrackers for notes on changing this file.",
 "typeName": "class"
}