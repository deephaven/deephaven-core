{
 "className": "io.deephaven.clientsupport.plotdownsampling.ValueTracker",
 "methods": {
  "append": "Indicates that a new value is being added to the original table being downsampled, and its value should be\n considered as possibly interesting. Implementations should read the value from the chunk and specialize based on\n that type of data.\n\n If it is the only value in the bucket (specified by the offset), include this value as both the max and the min.\n If there are other values, check to see if the new value is either the new max or the new min. In any case where\n this becomes the new max or the new min, mark that position as being valid, indicating that we are confident that\n we have the largest or smallest value at that offset.\n\n Implementations must take care to check if the value is null. If so, if nulls is present, the current\n row key should be added to it. If the\n\n:param offset: (int) - the offset of the bucket state to use - use this with minValuePosition/maxValuePosition to compute\n               the actual position in the underlying array sources\n:param rowKey: (long) - the row key in the original table of the specified value. If the current given value is interesting\n                 in some way, record this using setMinIndex/setMaxIndex so we can construct the full downsampled\n                 table row set later\n:param valuesChunk: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - the chunk that we're currently examining\n:param indexInChunk: (int) - the index in the chunk that we're currently examining\n:param nulls: io.deephaven.engine.rowset.WritableRowSet",
  "of": "Creates a set of value trackers to share across a given RunChartDownsample's BucketState instances.\n\n:param valueColumnSources: (java.util.List<io.deephaven.engine.table.ColumnSource<?>>) - the Y columns being downsampled and tracked\n:param bucketCount: (int) - the initial size to allocate in each tracker, usually the number of pixels\n                        to be displayed\n:return: (io.deephaven.clientsupport.plotdownsampling.ValueTracker[]) an array of correctly typed and sizes value trackers for use with the given Y value column sources",
  "remove": "Indicates that a row was removed from the original table being downsampled. If that row key was previously\n considered to be interesting, mark this offset as invalid, so that we can rescan later to find the next\n interesting value.\n\n:param offset: (int) - the offset of the bucket state to use\n:param rowKey: (long) - the row key in the original table.",
  "shiftMaxIndex": ":param offset: int\n:param shiftData: io.deephaven.engine.rowset.RowSetShiftData",
  "shiftMinIndex": ":param offset: int\n:param shiftData: io.deephaven.engine.rowset.RowSetShiftData",
  "toString": "Create a String representation of the tracked values and metadata at the given offset for logging/debugging\n purposes.\n\n:param offset: int\n:return: java.lang.String",
  "update": "Indicates that a value has changed in the original table that is being downsampled, and we should consider if the\n old value or the new value was interesting. Implementations should read the value from the chunk and specialize\n based on that type of data.\n\n There are three cases to consider for each min and max, so six cases in total. Here is the summary for the three\n \"max\" cases, the opposite must be likewise done for the min cases:\n\n If the updated row was the old max, then we cover two of the cases:\n   o  if the new value is greater than the old value, record the new value, but we are still the max and still\n      valid.\n   o  if the new value is less than the old value, invalidate this row but keep the old max, we may need to\n      rescan later\n\n Otherwise, if the new value is greater than the old max, then the current row is now the new max, and are now\n valid.\n\n:param offset: (int) - the offset of the bucket state to use - use this with minValuePosition/maxValuePosition to compute\n               the actual position in the underlying array sources\n:param rowKey: (long) - the row key in the original table of the specified value. If the current given value is interesting\n                 in some way, record this using setMinIndex/setMaxIndex so we can construct the full downsampled\n                 table row set later\n:param valuesChunk: (io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>) - the chunk that we're currently examining\n:param chunkIndex: (int) - the index in the chunk that we're currently examining\n:param nulls: io.deephaven.engine.rowset.WritableRowSet",
  "validate": "Scan the given chunk and confirm that whichever values are currently selected as max and min are correct, and\n that the current data is now valid.\n\n:param offset: int\n:param rowKey: long\n:param valuesChunk: io.deephaven.chunk.Chunk<? extendsio.deephaven.chunk.attributes.Values>\n:param indexInChunk: int\n:param nulls: io.deephaven.engine.rowset.RowSet"
 },
 "path": "io.deephaven.clientsupport.plotdownsampling.ValueTracker",
 "text": "Wraps all values in a given Y column when downsampling and apply operations consistently to supported\n column types. Each operation includes an offset, which is the BucketState.offset value - internally\n this is transformed to the position in the array sources.\n\n Each tracker maintains 6 pieces of data/metadata on all possible buckets, spread across 3 array sources:\n   o  the min and max value\n   o  the indexes of those min and max values in the original table\n   o  a flag indicating whether or not the each min and max are presently valid - these must always be true\n      except when a shift aware update is currently being processed.\n\n It is possible that there are gaps in the data - this is not understood directly by the ValueTracker, but\n instead by the fact that no BucketState exists with a corresponding offset.",
 "typeName": "class"
}