{
 "className": "io.deephaven.io.sched.YASchedulerImpl",
 "methods": {
  "cancelJob": "Cancel a job's selection key with the scheduler.\n\n:param job: (io.deephaven.io.sched.Job) - the job to be cancelled.",
  "close": "Shuts down the scheduler, calling close() on the underlying Selector instance.",
  "currentTimeMillis": "Return the scheduler's idea of the current time.\n\n:return: long",
  "installJob": "**Incompatible overloads text - text from the first overload:**\n\nInstall a job in association with a channel and an interest set.\n\n*Overload 1*  \n  :param job: io.deephaven.io.sched.Job\n  :param deadline: long\n  :param channel: java.nio.channels.SelectableChannel\n  :param interest: int\n  \n*Overload 2*  \n  :param job: io.deephaven.io.sched.Job\n  :param deadline: long",
  "isClosed": "Return true if the scheduler is closed, or in the process of closing.\n\n:return: boolean",
  "junitGetAllJobs": "return the set of all jobs known to the scheduler, in whatever state\n\n:return: java.util.Set<io.deephaven.io.sched.Job>",
  "junitGetAllKeys": "Return the selection keys currently known to the scheduler.\n\n:return: java.util.ArrayList<java.nio.channels.SelectionKey>",
  "junitGetChannelsAndJobs": "Return a map containing all channels and the jobs to which they are associated.\n\n:return: java.util.Map<java.nio.channels.SelectableChannel,io.deephaven.io.sched.Job>",
  "junitGetReadyKeys": "Return the selection keys currently known to the scheduler.\n\n:return: java.util.ArrayList<java.nio.channels.SelectionKey>",
  "junitGetSelector": "Return a reference to the selector\n\n:return: java.nio.channels.Selector",
  "junitGetTimeoutQueue": "Return the contents of the timeout queue, in deadline order\n\n:return: (java.util.ArrayList<io.deephaven.io.sched.Job>) the jobs in the timeout queue",
  "junitTestTimeoutQueueInvariant": "Return true if the timeout queue invariant holds.\n\n:return: boolean",
  "work": "Wait for jobs to become ready, then invoke() them all. This method will form the core of the main loop of a\n scheduler-driven application. The method first waits until:\n\n -- the given timeout expires, -- the earliest job-specific timeout expires, or -- one or more jobs becomes ready\n\n Note that this method is not synchronized. The application must ensure that it is never called concurrently by\n more than one thread.\n\n:param timeout: long\n:param handoff: io.deephaven.base.Procedure.Nullary\n:return: (boolean) true, if some work was done."
 },
 "path": "io.deephaven.io.sched.YASchedulerImpl",
 "text": "Yet Another implementation of the Scheduler interface -- the best one yet.\n\n This class provides a singleton wrapper for scheduling invocations of multiple Job instances from a single thread.\n Job are scheduled in accordance with an interest set on a java.nio.Channel, deadline based time scheduling, and/or\n custom criteria defined by the Jobs' implementation of the ready() method.\n\n Jobs are instantiated by the application and made known to the scheduler by one of the installJob() methods. A\n previously installed job can be removed from the scheduler with the cancelJob() method. The installJob() and\n cancelJob() methods are thread-safe. It is allowed to call installJob() on a job that is already installed, or\n cancelJob() on a job that is not current in the scheduler. In the former case, the channel and/or deadline will be\n updated accordingly; in the latter, the call will be ignored.\n\n Once the job is installed, the scheduler promises to call exactly one of its invoke(), timedOut() or cancelled()\n methods exactly once. The invoke() method will be called only if the job was (last) installed with a channel and\n non-zero interest set. The timedOut() method can be called for any job, since all jobs have an associated deadline\n (although the timeout value can be set to Integer.MAX_VALUE to make if effectively infinite). The cancelled() method\n is called only if the job is removed by a cancelJob() call before either the channe is ready or the deadline expires.\n\n After the job is called back, the scheduler forgets about the job completely, unless the application installs it\n again. That is, from the scheduler's point of view *all* jobs are one-shots. This design is based on the observation\n that it is easier to reschedule jobs on every invocation in the style of a tail-recursive loop, as opposed to\n maintaining persistent state in the scheduler.\n\n The application must drive the scheduler by calling the work() method in a loop. The work() method is *not*\n thread-safe; the application must either call it from a single thread or synchronize calls accordingly.",
 "typeName": "class"
}