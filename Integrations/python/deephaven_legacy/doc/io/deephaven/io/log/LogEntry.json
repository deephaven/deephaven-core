{
 "className": "io.deephaven.io.log.LogEntry",
 "methods": {
  "append": "Appends the character equivalent of each byte remaining in the given ByteBuffer ([65 66 67] == \"ABC\" not\n \"656667\"), but does not modify the mark, position, or limit of the ByteBuffer.\n\n*Overload 1*  \n  :param b: boolean\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 2*  \n  :param c: char\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 3*  \n  :param s: short\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 4*  \n  :param i: int\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 5*  \n  :param l: long\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 6*  \n  :param appendable: io.deephaven.base.log.LogOutputAppendable\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 7*  \n  :param formatter: io.deephaven.base.log.LogOutput.LongFormatter\n  :param n: long\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 8*  \n  Note: Java generics information - <T>\n  \n  :param objFormatter: io.deephaven.base.log.LogOutput.ObjFormatter<T>\n  :param t: T\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 9*  \n  Note: Java generics information - <T>\n  \n  :param objFormatter: io.deephaven.base.log.LogOutput.ObjIntIntFormatter<T>\n  :param t: T\n  :param nOffset: int\n  :param nLength: int\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 10*  \n  Note: Java generics information - <T,\n  U>\n  \n  :param objObjFormatter: io.deephaven.base.log.LogOutput.ObjObjFormatter<T,U>\n  :param t: T\n  :param u: U\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 11*  \n  :param seq: java.lang.CharSequence\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 12*  \n  :param seq: java.lang.CharSequence\n  :param start: int\n  :param length: int\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 13*  \n  :param buffer: java.nio.ByteBuffer\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 14*  \n  :param t: java.lang.Throwable\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 15*  \n  :param ba: byte[]\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 16*  \n  :param ba: byte[]\n  :param pos: int\n  :param length: int\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 17*  \n  :param ba: byte[]\n  :param terminator: byte\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 18*  \n  :param b: java.lang.Boolean\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 19*  \n  :param c: java.lang.Character\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 20*  \n  :param s: java.lang.Short\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 21*  \n  :param i: java.lang.Integer\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 22*  \n  :param l: java.lang.Long\n  :return: io.deephaven.io.log.LogEntry",
  "appendDouble": "**Incompatible overloads text - text from the first overload:**\n\nAppend a double rounded to the given number of decimal places, rounding half up. If to the given decimal places\n of precision\n\n*Overload 1*  \n  :param f: double\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 2*  \n  :param f: java.lang.Double\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 3*  \n  :param doubleValue: (double) - a double value to append to the logEntry\n  :param decimalPlaces: (int) - a positive integer between 0 and 9\n  :return: (io.deephaven.io.log.LogEntry) the resulting LogEntry\n  \n*Overload 4*  \n  :param doubleValue: (double) - a double value to append to the logEntry\n  :param decimalPlaces: (int) - a positive integer between 0 and 9 for the target number of decimal places to round to\n  :param maxTrailingZeroesToDiscard: (int) - a positive integer between 0 and 9 for the maximum trailing zeroes (if any) to\n          discard from the fractional part of the result. The fractional part of the result will have always at\n          least (decimalPlaces - maxTrailingZeroesToDiscard) places.\n  :return: (io.deephaven.io.log.LogEntry) the resulting LogEntry",
  "appendTimestamp": ":param utcMillis: long\n:param tb: io.deephaven.base.text.TimestampBuffer\n:return: io.deephaven.io.log.LogEntry",
  "appendTimestampMicros": ":param utcMicros: long\n:param tb: io.deephaven.base.text.TimestampBufferMicros\n:return: io.deephaven.io.log.LogEntry",
  "end": ":return: io.deephaven.io.log.LogEntry",
  "endl": ":return: io.deephaven.io.log.LogEntry",
  "nf": ":return: io.deephaven.io.log.LogEntry",
  "nl": ":return: io.deephaven.io.log.LogEntry",
  "start": "*Overload 1*  \n  :param sink: io.deephaven.io.log.LogSink\n  :param level: io.deephaven.io.log.LogLevel\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 2*  \n  :param sink: io.deephaven.io.log.LogSink\n  :param level: io.deephaven.io.log.LogLevel\n  :param currentTimeMicros: long\n  :return: io.deephaven.io.log.LogEntry\n  \n*Overload 3*  \n  :param sink: io.deephaven.io.log.LogSink\n  :param level: io.deephaven.io.log.LogLevel\n  :param currentTimeMicros: long\n  :param t: java.lang.Throwable\n  :return: io.deephaven.io.log.LogEntry"
 },
 "path": "io.deephaven.io.log.LogEntry",
 "typeName": "interface"
}