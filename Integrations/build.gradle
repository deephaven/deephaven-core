import com.bmuschko.gradle.docker.tasks.image.Dockerfile

plugins {
    id 'com.bmuschko.docker-remote-api'
    id 'com.avast.gradle.docker-compose' version '0.14.9'
}

evaluationDependsOn ':deephaven-jpy'

configurations {
    compile.extendsFrom dhIntegrations
    testCompile.extendsFrom fishBaseTest
}

dependencies {

    compile project(':DB'), project(':DbTypes')
    testRuntimeOnly project(':log-to-slf4j')
    // add configs, and some runtime dependencies to test classpaths
    testRuntime project(':configs'), project(':test-configs'),
            // need these projects so session default imports / generated type wrappers resolve correctly
            project(':Numerics'), project(':Plot'), project(':Kafka'), project(':DbTypesImpl')
}

sourceSets {
    main {
        java {
            srcDir 'src/main/java'
        }
        // For gradle, we _probably_ do not want to put r into the jar,
        // and definitely do not want to put in python, which is delivered as a wheel.
        // This used to be `resources.srcDirs '.'` with inclusions for 'r' and 'python'
        // We can't use srcDirs '.' and expect IntelliJ to like it, so we'll just remove
        // the sourceSet resources entirely, and then manually staple r into the jar
        // until we can verify that it is safe to remove (and then we'll just remove the jar {} block below)
        resources.srcDirs = ['src/main/resources']
    }
    test {
        java.srcDirs = ['src/test/java']
        resources.srcDirs = ['test_python', 'src/test/resources']
    }
}

// Even though we don't want gradle to treat these directories as resources (for jar packing),
// we do want IntelliJ to treat them as resources in IDE.
idea {
    module {
        resourceDirs += [file('r'), file('python')] 
        testResourceDirs += [file('python/test')]
    }
}

// This wiring is probably not needed.
// It only exists to maintain legacy jar structure
// (we changed the sourceSets.main.resources srcDirs,
// which affects where files would normally be packed into the jar).
// TODO: verify nobody pulls r from the Integrations jar, then delete this)
(tasks.jar as Jar).configure {
    Jar j ->
        j.from('r') {
            CopySpec c->
                c.into 'r'
        }
}

task prepareDockerForWheel(type: Sync) {
    from 'python'
    into layout.buildDirectory.dir('docker')
}
def buildDockerForWheel = Docker.registerDockerImage(project, 'buildDockerForWheel') {
    dependsOn prepareDockerForWheel
    buildArgs.put('DEEPHAVEN_VERSION', "${project.version}")
    images.add('deephaven/deephaven-wheel:local-build')
    target.set('build')
}

/**
 * Produce a docker image with the prereqs to run and use deephaven python
 */
task deephavenPythonDockerfile(type: Dockerfile) {
    destFile.set layout.buildDirectory.file('deephaven-python-docker/Dockerfile')
    from new Dockerfile.From('deephaven/deephaven-jpy-wheel:local-build').withStage('deephaven-jpy-wheel')
    from new Dockerfile.From('deephaven/deephaven-wheel:local-build').withStage('deephaven-wheel')
    from new Dockerfile.From('deephaven/java-and-python:local-build')

    copyFile(new Dockerfile.CopyFile('/usr/src/app/dist', '.').withStage('deephaven-jpy-wheel'))
    copyFile(new Dockerfile.CopyFile('/usr/src/app/dist', '.').withStage('deephaven-wheel'))

    // liblzo2-2 below is needed for supporting LZO parquet encoding.
    runCommand('''set -eux; \\
                  apt update; \\
                  apt -y install liblzo2-2; \\
                  apt -y install curl; \\
                  pip3 install setuptools wheel; \\
                  pip3 install *.whl; \\
                  rm *.whl
                  ''')
}
Docker.registerDockerImage(project, 'buildDeephavenPython') {
    def dhJpyTasks = project(':deephaven-jpy').tasks
    inputs.files dhJpyTasks.getByName('buildDockerForRuntime').outputs.files,
            dhJpyTasks.getByName('buildDockerForWheel').outputs.files,
            buildDockerForWheel.get().outputs.files,
            deephavenPythonDockerfile.outputs.files

    inputDir.set layout.buildDirectory.dir('deephaven-python-docker')

    images.add('deephaven/runtime-base:local-build')
}

JavaPluginConvention java = project.convention.plugins.get('java') as JavaPluginConvention
SourceSet test = java.sourceSets.maybeCreate('test')

def runInDocker = { String name, List<String> command ->
    Docker.registerDockerTask(project, name) {
        copyIn {
            from('python') {
                into 'python'
            }
            from(test.runtimeClasspath) {
                into 'classpath'
            }

            // Unpack the config contents for now, since we don't seem to read the configs from inside a jar.
            // This does not add a task dependency, but we already put :configs in the testRuntime classpath,
            // so it is part of the previous statement
            from(zipTree(project(':configs').tasks.getByName('jar').outputs.files.singleFile)) {
                into 'python/configs'
            }
        }
        parentContainers = [tasks.findByName('buildDeephavenPython')] // deephaven/runtime-base

        imageName = 'deephaven/py-integrations:local-build'
        network = 'integrations_default'
        dockerfile {
            // set up the container, env vars - things that aren't likely to change
            from 'deephaven/runtime-base:local-build'
            runCommand '''set -eux; \\
                      pip3 install unittest-xml-reporting==3.0.4;\\
                      mkdir -p /out/report;\\
                      mkdir -p /workspace/cache/classes'''
            environmentVariable 'DEEPHAVEN_CLASSPATH', '/classpath/*:/classpath'
            environmentVariable 'DEEPHAVEN_WORKSPACE', '/workspace'
            environmentVariable 'DEEPHAVEN_DEVROOT', '/python'
            environmentVariable 'DEEPHAVEN_PROPFILE', 'dh-defaults.prop'
            environmentVariable 'JDK_HOME', '/usr/lib/jvm/zulu8/jre/'
            environmentVariable 'JAVA_VERSION', '1.8'
            environmentVariable 'DEEPHAVEN_VERSION', project.version

            workingDir '/python'

            // copy in the contents that we do expect to change as the project updates
            copyFile 'python', '/python'
            copyFile 'classpath', '/classpath'
        }
        entrypoint = command

        copyOut {
            into layout.buildDirectory.dir('test-results')
        }
    }
}
def pyTest = runInDocker("test-py-37", ['python3', '-m', 'xmlrunner', 'discover', '-v', '-o', '/out/report'])
def pyFunctionalTest = runInDocker('py-functional-test', ['/bin/bash', 'run-functional-tests.sh'])
pyTest.configure({
    onlyIf { TestTools.shouldRunTests(project) }
})
tasks.getByName('check').dependsOn(pyTest)

pyFunctionalTest.configure({
    onlyIf { TestTools.shouldRunTests(project) }
})
tasks.getByName('check').dependsOn(pyFunctionalTest)

dockerCompose.isRequiredBy(pyTest)
dockerCompose.isRequiredBy(pyFunctionalTest)

dockerCompose {
    waitForTcpPortsTimeout = java.time.Duration.ofMinutes(2)
    waitForHealthyStateTimeout = java.time.Duration.ofMinutes(1)
    // Avoid compose project mangling: we are depending on the default
    // name for the compose network (matching the directory name)
    projectName=null
}
