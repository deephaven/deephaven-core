import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.Dockerfile

plugins {
    id 'com.bmuschko.docker-remote-api'
}

evaluationDependsOn ':deephaven-jpy'

configurations {
    compile.extendsFrom irisIntegrations
    testCompile.extendsFrom fishBaseTest
}

dependencies {

    compile project(':DB'), project(':DbTypes')
    testRuntimeOnly project(':log-to-slf4j')
    // add configs, and some runtime dependencies to test classpaths
    testRuntime project(':configs'), project(':test-configs'),
            // need these projects so session default imports / generated type wrappers resolve correctly
            project(':Numerics'), project(':Plot')
}

sourceSets {
    main {
        java {
            srcDir 'src/main/java'
        }
        // For gradle, we _probably_ do not want to put r into the jar,
        // and definitely do not want to put in python, which is delivered as a wheel.
        // This used to be `resources.srcDirs '.'` with inclusions for 'r' and 'python'
        // We can't use srcDirs '.' and expect IntelliJ to like it, so we'll just remove
        // the sourceSet resources entirely, and then manually staple r into the jar
        // until we can verify that it is safe to remove (and then we'll just remove the jar {} block below)
        resources.srcDirs = ['src/main/resources']
    }
    test {
        java.srcDirs = []
        // TODO: test doesn't compile
        //java.srcDirs = ['src/test/java']
        resources.srcDirs = ['test_python', 'src/test/resources']
    }
}

// Even though we don't want gradle to treat these directories as resources (for jar packing),
// we do want IntelliJ to treat them as resources in IDE.
idea {
    module {
        resourceDirs += [file('r'), file('python')] 
        testResourceDirs += [file('python/test')]
    }
}

// This wiring is probably not needed.
// It only exists to maintain legacy jar structure
// (we changed the sourceSets.main.resources srcDirs,
// which affects where files would normally be packed into the jar).
// TODO: verify nobody pulls r from the Integrations jar, then delete this)
(tasks.jar as Jar).configure {
    Jar j ->
        j.from('r') {
            CopySpec c->
                c.into 'r'
        }
}

task prepareDockerForWheel(type: Sync) {
    from 'python'
    into "${buildDir}/docker"
}

task buildDockerForWheel(type: DockerBuildImage) {
    dependsOn prepareDockerForWheel
    buildArgs.put('DEEPHAVEN_VERSION', "${project.version}")
    images.add('deephaven/deephaven-wheel')
    target.set('build')
}

/**
 * Produce a docker image with the prereqs to run and use deephaven python
 */
task deephavenPythonDockerfile(type: Dockerfile) {
    destFile.set layout.buildDirectory.file("$buildDir/deephaven-python-docker/Dockerfile")
    from new Dockerfile.From('deephaven/deephaven-jpy-wheel').withStage('deephaven-jpy-wheel')
    from new Dockerfile.From('deephaven/deephaven-wheel').withStage('deephaven-wheel')
    from new Dockerfile.From('deephaven/java-and-python')

    copyFile(new Dockerfile.CopyFile('/usr/src/app/dist', '.').withStage('deephaven-jpy-wheel'))
    copyFile(new Dockerfile.CopyFile('/usr/src/app/dist', '.').withStage('deephaven-wheel'))

    runCommand('''set -eux;\\
                  pip3 install setuptools wheel; \\
                  pip3 install *.whl; \\
                  rm *.whl
                  ''')
}
task buildDeephavenPython(type: DockerBuildImage) {
    //
    inputs.files deephavenPythonDockerfile.outputs.files
    inputDir.set layout.buildDirectory.dir("$buildDir/deephaven-python-docker")

    images.add('deephaven/runtime-base')
}

/**
 * We are not yet enabling the building of jpy on all environments yet.
 * It requires the ability of the running machine to build/install python:
 *
 * https://github.com/JetBrains/gradle-python-envs
 * https://github.com/pyenv/pyenv/wiki/common-build-problems
 * https://github.com/pyenv/pyenv/wiki
 *
 * TODO IDO-436: zip up working installations on each OS, and pull them from artifactory instead of building on developer machine
 *
 */
if (PyEnv.pythonEnabled(project)) {
    PyEnv env = PyEnv.getEnv(project)

    Exec wheel = env.getTaskBuildDhWheel()

    for (pv in [PythonVersion.PY_37]) {
        PyInstall install = env.getInstall(pv)
        Venv venvTest = install.getVenv(VenvType.TEST_DH)
        venvTest.pythonTest(project, "test-${pv.name}")
    }

} else {
    JavaPluginConvention java = project.convention.plugins.get('java') as JavaPluginConvention
    SourceSet test = java.sourceSets.maybeCreate('test')

    def pyTest = Docker.registerDockerTask(project, "test-py-37") {
        copyIn {
            from('python') {
                into 'python'
            }
            from(test.runtimeClasspath) {
                into 'classpath'
            }

            // Unpack the config contents for now, since we don't seem to read the configs from inside a jar.
            // This does not add a task dependency, but we already put :configs in the testRuntime classpath,
            // so it is part of the previous statement
            from(zipTree(project(':configs').tasks.getByName('jar').outputs.files.singleFile)) {
                into 'python/configs'
            }
        }
        parentContainers = [tasks.findByName('buildDeephavenPython')] // deephaven/runtime-base

        dockerfile {
            // set up the container, env vars - things that aren't likely to change
            from 'deephaven/runtime-base'
            runCommand 'pip3 install unittest-xml-reporting==3.0.4'
            environmentVariable 'DEEPHAVEN_CLASSPATH', '/classpath/*:/classpath'
            environmentVariable 'DEEPHAVEN_WORKSPACE', '/workspace'
            environmentVariable 'DEEPHAVEN_DEVROOT', '/python'
            environmentVariable 'DEEPHAVEN_PROPFILE', 'iris-defaults.prop'
            environmentVariable 'JDK_HOME', '/usr/lib/jvm/zulu8/jre/'
            environmentVariable 'JAVA_VERSION', '1.8'
            environmentVariable 'DEEPHAVEN_VERSION', project.version

            // copy in the contents that we do expect to change as the project updates
            copyFile 'python', '/python'
            copyFile 'classpath', '/classpath'

            // run the tests and report results, status code
            runCommand '''set -eux;\\
                          mkdir -p /out/report; \\
                          mkdir -p /workspace/cache/classes; \\
                          cd /python; \\
                          set +e; \\
                          python3 -m xmlrunner discover -v -o /out/report; \\
                          echo $? > /out/exitCode'''
        }

        copyOut {
            into "$buildDir/test-results"
        }
    }
    pyTest.configure({
        onlyIf { TestTools.shouldRunTests(project) }
        doLast {
            def exitCodeFile = new File("$buildDir/test-results/exitCode")
            if (exitCodeFile.exists()) {
                int exitCode = exitCodeFile.text.toInteger()
                if (exitCode != 0) {
                    String error = """$path failed w/ exit code $exitCode
    See $buildDir/test-results/report/."""
                    if (TestTools.allowFailure(gradle.rootProject)) {
                        logger.error(error)
                    } else {
                        throw new GradleException(error)
                    }
                }
            }
        }
    })
}