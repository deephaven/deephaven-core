---
title: Generate tables with Groovy functions
---

This guide will show you how to create and use function-generated tables. As the name suggests, function-generated tables are tables generated by a user-defined Groovy function.

The `FunctionGeneratedTableFactory`'s [`create`](../reference/table-operations/create/create.md) method allows you to create ticking tables via a Groovy function. The ticking tables can be triggered by one or more source tables, or by a refresh interval.

## Usage

The basic syntax for [`create`](../reference/table-operations/create/create.md) is as follows:

```groovy syntax
create(tableGenerator, sourceTables...)
create(tableGenerator, refreshIntervalMs)
```

The workflow for this method is to first define a function that returns a table, then pass it to `create`, which will re-run the with that function at pre-defined intervals based on either one or more source tables or a refresh interval.

If one or more source tables are used, the function will be re-run any time any of the tables tick. If a refresh interval is used, the function is re-run once per interval in milliseconds. You must only use one or the other as the trigger.

The user-defined `table_generator` function can source its data from anywhere - the only limit is the user's imagination, and the requirement that the function return a valid table.

### Execution context

The `function_generated_table` method requires an [execution context](../conceptual/execution-context.md) to run in. If you don't specify an execution context, the method will use the systemic [execution context](../conceptual/execution-context.md). The examples below do not specify one, so the systemic execution context is used.

### Define a `tableGenerator` function

Next, we create a `tableGenerator` function. Transform your data any way you want - the only rule is that this function has to return a table.

Here's a simple example:

```groovy order=result
import io.deephaven.engine.context.ExecutionContext
import io.deephaven.util.SafeCloseable

// create execution context
defaultCtx = ExecutionContext.getContext()

// define tableGenerator function
tableGenerator = { ->
    Random rand = new Random()
    for (int i = 0; i < 5; ++i) {
        try (SafeCloseable ignored = defaultCtx.open()) {
            myTable = emptyTable(5).update("X = randomInt(0, 10)", "Y = randomDouble(0.0, 100.0)")
        }
        sleep(10)
    }
    return myTable
}
```

### Generate tables with a Groovy function

Now, we'll create two function-generated tables: one that re-runs the `tableGenerator` whenever the source table updates, and one that re-runs the `tableGenerator` function every 2000ms.

```groovy order=resultTime,resultTick reset
import io.deephaven.engine.context.ExecutionContext
import io.deephaven.util.SafeCloseable
import io.deephaven.engine.table.impl.util.FunctionGeneratedTableFactory

// create execution context
defaultCtx = ExecutionContext.getContext()

// define tableGenerator function
tableGenerator = { ->
    Random rand = new Random()
    for (int i = 0; i < 5; ++i) {
        try (SafeCloseable ignored = defaultCtx.open()) {
            myTable = emptyTable(5).update("X = randomInt(0, 10)", "Y = randomDouble(0.0, 100.0)")
        }
        sleep(10)
    }
    return myTable
}

// Create a time table
timeTable1 = timeTable("PT1S")

// create a function-generated table that re-runs tableGenerator every 2000ms
resultTime = FunctionGeneratedTableFactory.create(tableGenerator, 2000)

// create a function-generated table that re-runs tableGenerator whenever timeTable1 ticks
resultTick = FunctionGeneratedTableFactory.create(tableGenerator, timeTable1)
```

<!--TODO: Change this example to match the Python one? Or can it be simplified in the same way?-->

## Related documentation

- [`create`](../reference/table-operations/create/create.md)
- [`emptyTable`](../reference/table-operations/create/emptyTable.md)
- [`timeTable`](../reference/table-operations/create/timeTable.md)
- [Execution Context](../conceptual/execution-context.md)
