import io.deephaven.tools.License

plugins {
  id 'java'
  id 'com.bmuschko.docker-java-application'
}

evaluationDependsOn(":Integrations")

dependencies {
  implementation(project(':grpc-api')) {
    // way too many dependencies right now
    // but at least we can cut-off slf4j-simple
    exclude group: 'org.slf4j', module: 'slf4j-simple'
  }

  runtimeOnly project(':log-to-slf4j')
  Classpaths.inheritSlf4j(project, 'jcl-over-slf4j', 'runtimeOnly')
  runtimeOnly project(':logback-print-stream-globals')
  runtimeOnly project(':logback-logbuffer')
  runtimeOnly 'ch.qos.logback:logback-classic:1.2.3'
}


String GRPC_HEALTH_PROBE_VERSION = 'v0.3.1'
TaskProvider<Task> downloadHealthProbe = tasks.register('downloadGrpcHealthProbe') {
  Task dl ->
    String dlUrl = "https://github.com/grpc-ecosystem/grpc-health-probe/releases/download/${GRPC_HEALTH_PROBE_VERSION}/grpc_health_probe-linux-amd64"
    Provider<RegularFile> outputFile = layout.buildDirectory.file('healthProbe/grpc_health_probe').forUseAtConfigurationTime()
    File file = outputFile.get().asFile
    dl.outputs.file(file)
    dl.inputs.property("healthProbeVersion", GRPC_HEALTH_PROBE_VERSION)
    dl.doFirst {
      file.withOutputStream { OutputStream output ->
        new URL(dlUrl).withInputStream { InputStream input ->
          output << input
        }
      }
      file.setExecutable(true)
    }
}

Sync dockerLicenses = License.createFrom(project).syncDockerLicense().get()

docker {

  // note: end user can still override completely.
  // docker run -e JAVA_TOOL_OPTIONS="-Xmx100M" --rm deephaven/grpc-api

  javaApplication {
    mainClassName = 'io.deephaven.grpc_api.runner.Main'
    images = [ "${project.property('grpc-api-docker.imageName')}" ]
    baseImage = project.property('grpc-api-docker.baseImage')
    maintainer = 'Devin Smith "devinsmith@deephaven.io"'
//    ports = [ 8080 ]
    ports = [ 8080, 5005 ]  // Add for debugging: change 5005 to match the port set below in the '-agentlib...' line.
    jvmArgs = [
        '-server',
        '-XX:+UseG1GC',
        '-XX:MaxGCPauseMillis=100',
        '-XX:+UseStringDeduplication',
	    // Add for debugging, select port to match what you expect from your debugger/IDE side.
	    '-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005',

        // Settings based on the cgroup limits:
        // https://www.oracle.com/java/technologies/javase/8u191-relnotes.html
        // the initial memory reservation, expressed as a percentage of (todo - is this as a percentage against the JVMs computed maximum, or the system memory?)
        // Note: this feature works w/ cgroups v1, and not cgroups v2 *yet* (except in java 15+).
        // Maybe we can request backport: https://bugs.openjdk.java.net/browse/JDK-8230305 ?
        // https://www.redhat.com/sysadmin/fedora-31-control-group-v2
        '-XX:InitialRAMPercentage=25.0',
        // the percentage of system memory that the JVM will use as maximum in low-memory systems
        '-XX:MinRAMPercentage=70.0',
        // the percentage of system memory that the JVM will use as maximum
        '-XX:MaxRAMPercentage=80.0',
        '-XshowSettings:vm'
    ]
  }

  dockerSyncBuildContext {
    from(dockerLicenses.outputs) {
      into 'licenses'
    }
    from(downloadHealthProbe.get().outputs.files) {
      into 'health_probe'
    }
  }

  dockerCreateDockerfile {
    //volume("/app/resources")

    runCommand('''set -eux;\\
                  GRPC_HEALTH_PROBE_VERSION=v0.3.1;\\
                  curl -L -o /bin/grpc_health_probe https://github.com/grpc-ecosystem/grpc-health-probe/releases/download/${GRPC_HEALTH_PROBE_VERSION}/grpc_health_probe-linux-amd64; \\
                  chmod +x /bin/grpc_health_probe
                  ''')

    copyFile('licenses/', '/')
    copyFile('health_probe/', '/health')

    volume("/data")
    volume("/cache")

    // Breakdown of the following command:
    //   * Wait 3 seconds before checking the status of the container after each test.
    //   * After three failing checks, mark the container as failed.
    //   * The HEALTHCHECK will wait 11 seconds for a result, but the grpc_health_probe process
    //     will time out after only 10 seconds of trying to connect. This one second leaves room
    //     for the grpc probe to have a delay starting up, and gives some visiblity into this
    //     failure mode (via docker inspect, but only until that failure stales out).
    //   * If grpc_health_probe fails with any non-zero exit code, normalize to 1.
    // The net effect is that the server will have 3s until the earliest possible success, and
    // 33-36s until it is considered to have failed startup (so downstream docker-compose services
    // will not attempt to start). If the server is running but trying to shut down, failure will
    // occur within about 9s, as the port will connect correctly, but respond that it isn't
    // available.
    instruction('HEALTHCHECK --interval=3s --retries=3 --timeout=11s CMD /bin/grpc_health_probe -addr=localhost:8080 -connect-timeout=10s || exit 1')
  }
}


// deephaven/runtime-base
def grpcApiBase = project(':Integrations').tasks.findByName('buildDeephavenPython')
dockerBuildImage.dependsOn grpcApiBase
dockerBuildImage.inputs.file grpcApiBase.outputs.files.singleFile
// Currently, GH build-ci.yml calls dockerCreateDockerfile, and relies on buildx; so we need to
// make sure that dockerCreateDockerfile has the proper dependencies.
// If we change how our build works in the future (so that gradle is responsible for pushing the
// image), we can remove this extra dependency.
dockerCreateDockerfile.dependsOn grpcApiBase

assemble.dependsOn dockerBuildImage
dockerBuildImage.outputs.upToDateWhen { t -> return Docker.isImageUpToDate(t) }
