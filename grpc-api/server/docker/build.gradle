plugins {
  id 'java'
  id 'com.bmuschko.docker-java-application'
}

dependencies {
  implementation(project(':grpc-api')) {
    // way too many dependencies right now
    // but at least we can cut-off slf4j-simple
    exclude group: 'org.slf4j', module: 'slf4j-simple'
  }

  runtimeOnly project(':log-to-slf4j')
  runtimeOnly project(':logback-print-stream-globals')
  runtimeOnly project(':logback-logbuffer')
  runtimeOnly 'ch.qos.logback:logback-classic:1.2.3'
}

docker {

  // note: end user can still override completely.
  // docker run -e JAVA_TOOL_OPTIONS="-Xmx100M" --rm deephaven/grpc-api

  javaApplication {
    mainClassName = 'io.deephaven.grpc_api.runner.Main'
    images = [ "${project.property('grpc-api-docker.imageName')}:latest" ]
    baseImage = project.property('grpc-api-docker.baseImage')
    maintainer = 'Devin Smith "devinsmith@deephaven.io"'
    ports = [ 8080 ]
    // ports = [ 8080, 5005 ]  // Add for debugging: change 5005 to match the port set below in the '-agentlib...' line.
    jvmArgs = [
        '-server',
        '-XX:+UseG1GC',
        '-XX:MaxGCPauseMillis=100',
        '-XX:+UseStringDeduplication',
	// Add for debugging, select port to match what you expect from your debugger/IDE side.
	// '-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005',

        // Settings based on the cgroup limits:
        // https://www.oracle.com/java/technologies/javase/8u191-relnotes.html
        // the initial memory reservation, expressed as a percentage of (todo - is this as a percentage against the JVMs computed maximum, or the system memory?)
        // Note: this feature works w/ cgroups v1, and not cgroups v2 *yet* (except in java 15+).
        // Maybe we can request backport: https://bugs.openjdk.java.net/browse/JDK-8230305 ?
        // https://www.redhat.com/sysadmin/fedora-31-control-group-v2
        '-XX:InitialRAMPercentage=25.0',
        // the percentage of system memory that the JVM will use as maximum in low-memory systems
        '-XX:MinRAMPercentage=70.0',
        // the percentage of system memory that the JVM will use as maximum
        '-XX:MaxRAMPercentage=80.0',
        '-XshowSettings:vm'
    ]
  }

  dockerCreateDockerfile {
    //volume("/app/resources")

    volume("/data")
    volume("/cache")

    // https://github.com/opencontainers/image-spec/blob/master/annotations.md#pre-defined-annotation-keys
    label([
        'org.opencontainers.image.vendor': "${project.property('grpc-api-docker.vendor')}",
        'org.opencontainers.image.title': "${project.property('grpc-api-docker.title')}",
        'org.opencontainers.image.description': "${project.property('grpc-api-docker.description')}",
        'org.opencontainers.image.source': "${project.property('grpc-api-docker.source')}",
        'org.opencontainers.image.licenses': "${project.property('grpc-api-docker.licenses')}",
        'org.opencontainers.image.version': "${project.version}",
        //'org.opencontainers.image.revision': "${sha}",
        // todo: do we even want this? causes invalidation every single build, and makes builds non-reproducible
        // consider sourcing this from a file instead?
        //'org.opencontainers.image.created': "${Instant.now()}"
    ])
  }
}


// deephaven/runtime-base
def grpcApiBase = project(':Integrations').tasks.findByName('buildDeephavenPython')
dockerBuildImage.dependsOn grpcApiBase
dockerBuildImage.inputs.file grpcApiBase.outputs.files.singleFile
// Currently, GH build-ci.yml calls dockerCreateDockerfile, and relies on buildx; so we need to
// make sure that dockerCreateDockerfile has the proper dependencies.
// If we change how our build works in the future (so that gradle is responsible for pushing the
// image), we can remove this extra dependency.
dockerCreateDockerfile.dependsOn grpcApiBase

assemble.dependsOn dockerBuildImage
dockerBuildImage.outputs.upToDateWhen { t -> return Docker.isImageUpToDate(t) }
