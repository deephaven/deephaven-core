// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: deephaven/proto/console.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2fconsole_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2fconsole_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "deephaven/proto/table.pb.h"
#include "deephaven/proto/ticket.pb.h"
#include "deephaven/proto/application.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_deephaven_2fproto_2fconsole_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_deephaven_2fproto_2fconsole_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_deephaven_2fproto_2fconsole_2eproto;
namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace script {
namespace grpc {
class AutoCompleteRequest;
struct AutoCompleteRequestDefaultTypeInternal;
extern AutoCompleteRequestDefaultTypeInternal _AutoCompleteRequest_default_instance_;
class AutoCompleteResponse;
struct AutoCompleteResponseDefaultTypeInternal;
extern AutoCompleteResponseDefaultTypeInternal _AutoCompleteResponse_default_instance_;
class BindTableToVariableRequest;
struct BindTableToVariableRequestDefaultTypeInternal;
extern BindTableToVariableRequestDefaultTypeInternal _BindTableToVariableRequest_default_instance_;
class BindTableToVariableResponse;
struct BindTableToVariableResponseDefaultTypeInternal;
extern BindTableToVariableResponseDefaultTypeInternal _BindTableToVariableResponse_default_instance_;
class BrowserNextResponse;
struct BrowserNextResponseDefaultTypeInternal;
extern BrowserNextResponseDefaultTypeInternal _BrowserNextResponse_default_instance_;
class CancelCommandRequest;
struct CancelCommandRequestDefaultTypeInternal;
extern CancelCommandRequestDefaultTypeInternal _CancelCommandRequest_default_instance_;
class CancelCommandResponse;
struct CancelCommandResponseDefaultTypeInternal;
extern CancelCommandResponseDefaultTypeInternal _CancelCommandResponse_default_instance_;
class ChangeDocumentRequest;
struct ChangeDocumentRequestDefaultTypeInternal;
extern ChangeDocumentRequestDefaultTypeInternal _ChangeDocumentRequest_default_instance_;
class ChangeDocumentRequest_TextDocumentContentChangeEvent;
struct ChangeDocumentRequest_TextDocumentContentChangeEventDefaultTypeInternal;
extern ChangeDocumentRequest_TextDocumentContentChangeEventDefaultTypeInternal _ChangeDocumentRequest_TextDocumentContentChangeEvent_default_instance_;
class CloseDocumentRequest;
struct CloseDocumentRequestDefaultTypeInternal;
extern CloseDocumentRequestDefaultTypeInternal _CloseDocumentRequest_default_instance_;
class CompletionContext;
struct CompletionContextDefaultTypeInternal;
extern CompletionContextDefaultTypeInternal _CompletionContext_default_instance_;
class CompletionItem;
struct CompletionItemDefaultTypeInternal;
extern CompletionItemDefaultTypeInternal _CompletionItem_default_instance_;
class DocumentRange;
struct DocumentRangeDefaultTypeInternal;
extern DocumentRangeDefaultTypeInternal _DocumentRange_default_instance_;
class ExecuteCommandRequest;
struct ExecuteCommandRequestDefaultTypeInternal;
extern ExecuteCommandRequestDefaultTypeInternal _ExecuteCommandRequest_default_instance_;
class ExecuteCommandResponse;
struct ExecuteCommandResponseDefaultTypeInternal;
extern ExecuteCommandResponseDefaultTypeInternal _ExecuteCommandResponse_default_instance_;
class FigureDescriptor;
struct FigureDescriptorDefaultTypeInternal;
extern FigureDescriptorDefaultTypeInternal _FigureDescriptor_default_instance_;
class FigureDescriptor_AxisDescriptor;
struct FigureDescriptor_AxisDescriptorDefaultTypeInternal;
extern FigureDescriptor_AxisDescriptorDefaultTypeInternal _FigureDescriptor_AxisDescriptor_default_instance_;
class FigureDescriptor_BoolMapWithDefault;
struct FigureDescriptor_BoolMapWithDefaultDefaultTypeInternal;
extern FigureDescriptor_BoolMapWithDefaultDefaultTypeInternal _FigureDescriptor_BoolMapWithDefault_default_instance_;
class FigureDescriptor_BusinessCalendarDescriptor;
struct FigureDescriptor_BusinessCalendarDescriptorDefaultTypeInternal;
extern FigureDescriptor_BusinessCalendarDescriptorDefaultTypeInternal _FigureDescriptor_BusinessCalendarDescriptor_default_instance_;
class FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod;
struct FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriodDefaultTypeInternal;
extern FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriodDefaultTypeInternal _FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod_default_instance_;
class FigureDescriptor_BusinessCalendarDescriptor_Holiday;
struct FigureDescriptor_BusinessCalendarDescriptor_HolidayDefaultTypeInternal;
extern FigureDescriptor_BusinessCalendarDescriptor_HolidayDefaultTypeInternal _FigureDescriptor_BusinessCalendarDescriptor_Holiday_default_instance_;
class FigureDescriptor_BusinessCalendarDescriptor_LocalDate;
struct FigureDescriptor_BusinessCalendarDescriptor_LocalDateDefaultTypeInternal;
extern FigureDescriptor_BusinessCalendarDescriptor_LocalDateDefaultTypeInternal _FigureDescriptor_BusinessCalendarDescriptor_LocalDate_default_instance_;
class FigureDescriptor_ChartDescriptor;
struct FigureDescriptor_ChartDescriptorDefaultTypeInternal;
extern FigureDescriptor_ChartDescriptorDefaultTypeInternal _FigureDescriptor_ChartDescriptor_default_instance_;
class FigureDescriptor_DoubleMapWithDefault;
struct FigureDescriptor_DoubleMapWithDefaultDefaultTypeInternal;
extern FigureDescriptor_DoubleMapWithDefaultDefaultTypeInternal _FigureDescriptor_DoubleMapWithDefault_default_instance_;
class FigureDescriptor_MultiSeriesDescriptor;
struct FigureDescriptor_MultiSeriesDescriptorDefaultTypeInternal;
extern FigureDescriptor_MultiSeriesDescriptorDefaultTypeInternal _FigureDescriptor_MultiSeriesDescriptor_default_instance_;
class FigureDescriptor_MultiSeriesSourceDescriptor;
struct FigureDescriptor_MultiSeriesSourceDescriptorDefaultTypeInternal;
extern FigureDescriptor_MultiSeriesSourceDescriptorDefaultTypeInternal _FigureDescriptor_MultiSeriesSourceDescriptor_default_instance_;
class FigureDescriptor_OneClickDescriptor;
struct FigureDescriptor_OneClickDescriptorDefaultTypeInternal;
extern FigureDescriptor_OneClickDescriptorDefaultTypeInternal _FigureDescriptor_OneClickDescriptor_default_instance_;
class FigureDescriptor_SeriesDescriptor;
struct FigureDescriptor_SeriesDescriptorDefaultTypeInternal;
extern FigureDescriptor_SeriesDescriptorDefaultTypeInternal _FigureDescriptor_SeriesDescriptor_default_instance_;
class FigureDescriptor_SourceDescriptor;
struct FigureDescriptor_SourceDescriptorDefaultTypeInternal;
extern FigureDescriptor_SourceDescriptorDefaultTypeInternal _FigureDescriptor_SourceDescriptor_default_instance_;
class FigureDescriptor_StringMapWithDefault;
struct FigureDescriptor_StringMapWithDefaultDefaultTypeInternal;
extern FigureDescriptor_StringMapWithDefaultDefaultTypeInternal _FigureDescriptor_StringMapWithDefault_default_instance_;
class GetCompletionItemsRequest;
struct GetCompletionItemsRequestDefaultTypeInternal;
extern GetCompletionItemsRequestDefaultTypeInternal _GetCompletionItemsRequest_default_instance_;
class GetCompletionItemsResponse;
struct GetCompletionItemsResponseDefaultTypeInternal;
extern GetCompletionItemsResponseDefaultTypeInternal _GetCompletionItemsResponse_default_instance_;
class GetConsoleTypesRequest;
struct GetConsoleTypesRequestDefaultTypeInternal;
extern GetConsoleTypesRequestDefaultTypeInternal _GetConsoleTypesRequest_default_instance_;
class GetConsoleTypesResponse;
struct GetConsoleTypesResponseDefaultTypeInternal;
extern GetConsoleTypesResponseDefaultTypeInternal _GetConsoleTypesResponse_default_instance_;
class LogSubscriptionData;
struct LogSubscriptionDataDefaultTypeInternal;
extern LogSubscriptionDataDefaultTypeInternal _LogSubscriptionData_default_instance_;
class LogSubscriptionRequest;
struct LogSubscriptionRequestDefaultTypeInternal;
extern LogSubscriptionRequestDefaultTypeInternal _LogSubscriptionRequest_default_instance_;
class OpenDocumentRequest;
struct OpenDocumentRequestDefaultTypeInternal;
extern OpenDocumentRequestDefaultTypeInternal _OpenDocumentRequest_default_instance_;
class Position;
struct PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class StartConsoleRequest;
struct StartConsoleRequestDefaultTypeInternal;
extern StartConsoleRequestDefaultTypeInternal _StartConsoleRequest_default_instance_;
class StartConsoleResponse;
struct StartConsoleResponseDefaultTypeInternal;
extern StartConsoleResponseDefaultTypeInternal _StartConsoleResponse_default_instance_;
class TextDocumentItem;
struct TextDocumentItemDefaultTypeInternal;
extern TextDocumentItemDefaultTypeInternal _TextDocumentItem_default_instance_;
class TextEdit;
struct TextEditDefaultTypeInternal;
extern TextEditDefaultTypeInternal _TextEdit_default_instance_;
class VersionedTextDocumentIdentifier;
struct VersionedTextDocumentIdentifierDefaultTypeInternal;
extern VersionedTextDocumentIdentifierDefaultTypeInternal _VersionedTextDocumentIdentifier_default_instance_;
}  // namespace grpc
}  // namespace script
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io
PROTOBUF_NAMESPACE_OPEN
template<> ::io::deephaven::proto::backplane::script::grpc::AutoCompleteRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::AutoCompleteRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::AutoCompleteResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::AutoCompleteResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::BindTableToVariableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::BindTableToVariableResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::BrowserNextResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::BrowserNextResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::CancelCommandRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::CancelCommandResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::CompletionContext* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::CompletionContext>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::CompletionItem* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::CompletionItem>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::DocumentRange* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::DocumentRange>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::ExecuteCommandRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::ExecuteCommandResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::GetConsoleTypesResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::LogSubscriptionData>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::LogSubscriptionRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::Position* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::Position>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::StartConsoleRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::StartConsoleResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::TextDocumentItem>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::TextEdit* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::TextEdit>(Arena*);
template<> ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace script {
namespace grpc {

enum FigureDescriptor_ChartDescriptor_ChartType : int {
  FigureDescriptor_ChartDescriptor_ChartType_XY = 0,
  FigureDescriptor_ChartDescriptor_ChartType_PIE = 1,
  FigureDescriptor_ChartDescriptor_ChartType_OHLC = 2,
  FigureDescriptor_ChartDescriptor_ChartType_CATEGORY = 3,
  FigureDescriptor_ChartDescriptor_ChartType_XYZ = 4,
  FigureDescriptor_ChartDescriptor_ChartType_CATEGORY_3D = 5,
  FigureDescriptor_ChartDescriptor_ChartType_TREEMAP = 6,
  FigureDescriptor_ChartDescriptor_ChartType_FigureDescriptor_ChartDescriptor_ChartType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FigureDescriptor_ChartDescriptor_ChartType_FigureDescriptor_ChartDescriptor_ChartType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FigureDescriptor_ChartDescriptor_ChartType_IsValid(int value);
constexpr FigureDescriptor_ChartDescriptor_ChartType FigureDescriptor_ChartDescriptor_ChartType_ChartType_MIN = FigureDescriptor_ChartDescriptor_ChartType_XY;
constexpr FigureDescriptor_ChartDescriptor_ChartType FigureDescriptor_ChartDescriptor_ChartType_ChartType_MAX = FigureDescriptor_ChartDescriptor_ChartType_TREEMAP;
constexpr int FigureDescriptor_ChartDescriptor_ChartType_ChartType_ARRAYSIZE = FigureDescriptor_ChartDescriptor_ChartType_ChartType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FigureDescriptor_ChartDescriptor_ChartType_descriptor();
template<typename T>
inline const std::string& FigureDescriptor_ChartDescriptor_ChartType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FigureDescriptor_ChartDescriptor_ChartType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FigureDescriptor_ChartDescriptor_ChartType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FigureDescriptor_ChartDescriptor_ChartType_descriptor(), enum_t_value);
}
inline bool FigureDescriptor_ChartDescriptor_ChartType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FigureDescriptor_ChartDescriptor_ChartType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FigureDescriptor_ChartDescriptor_ChartType>(
    FigureDescriptor_ChartDescriptor_ChartType_descriptor(), name, value);
}
enum FigureDescriptor_AxisDescriptor_AxisFormatType : int {
  FigureDescriptor_AxisDescriptor_AxisFormatType_CATEGORY = 0,
  FigureDescriptor_AxisDescriptor_AxisFormatType_NUMBER = 1,
  FigureDescriptor_AxisDescriptor_AxisFormatType_FigureDescriptor_AxisDescriptor_AxisFormatType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FigureDescriptor_AxisDescriptor_AxisFormatType_FigureDescriptor_AxisDescriptor_AxisFormatType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FigureDescriptor_AxisDescriptor_AxisFormatType_IsValid(int value);
constexpr FigureDescriptor_AxisDescriptor_AxisFormatType FigureDescriptor_AxisDescriptor_AxisFormatType_AxisFormatType_MIN = FigureDescriptor_AxisDescriptor_AxisFormatType_CATEGORY;
constexpr FigureDescriptor_AxisDescriptor_AxisFormatType FigureDescriptor_AxisDescriptor_AxisFormatType_AxisFormatType_MAX = FigureDescriptor_AxisDescriptor_AxisFormatType_NUMBER;
constexpr int FigureDescriptor_AxisDescriptor_AxisFormatType_AxisFormatType_ARRAYSIZE = FigureDescriptor_AxisDescriptor_AxisFormatType_AxisFormatType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FigureDescriptor_AxisDescriptor_AxisFormatType_descriptor();
template<typename T>
inline const std::string& FigureDescriptor_AxisDescriptor_AxisFormatType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FigureDescriptor_AxisDescriptor_AxisFormatType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FigureDescriptor_AxisDescriptor_AxisFormatType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FigureDescriptor_AxisDescriptor_AxisFormatType_descriptor(), enum_t_value);
}
inline bool FigureDescriptor_AxisDescriptor_AxisFormatType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FigureDescriptor_AxisDescriptor_AxisFormatType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FigureDescriptor_AxisDescriptor_AxisFormatType>(
    FigureDescriptor_AxisDescriptor_AxisFormatType_descriptor(), name, value);
}
enum FigureDescriptor_AxisDescriptor_AxisType : int {
  FigureDescriptor_AxisDescriptor_AxisType_X = 0,
  FigureDescriptor_AxisDescriptor_AxisType_Y = 1,
  FigureDescriptor_AxisDescriptor_AxisType_SHAPE = 2,
  FigureDescriptor_AxisDescriptor_AxisType_SIZE = 3,
  FigureDescriptor_AxisDescriptor_AxisType_LABEL = 4,
  FigureDescriptor_AxisDescriptor_AxisType_COLOR = 5,
  FigureDescriptor_AxisDescriptor_AxisType_FigureDescriptor_AxisDescriptor_AxisType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FigureDescriptor_AxisDescriptor_AxisType_FigureDescriptor_AxisDescriptor_AxisType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FigureDescriptor_AxisDescriptor_AxisType_IsValid(int value);
constexpr FigureDescriptor_AxisDescriptor_AxisType FigureDescriptor_AxisDescriptor_AxisType_AxisType_MIN = FigureDescriptor_AxisDescriptor_AxisType_X;
constexpr FigureDescriptor_AxisDescriptor_AxisType FigureDescriptor_AxisDescriptor_AxisType_AxisType_MAX = FigureDescriptor_AxisDescriptor_AxisType_COLOR;
constexpr int FigureDescriptor_AxisDescriptor_AxisType_AxisType_ARRAYSIZE = FigureDescriptor_AxisDescriptor_AxisType_AxisType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FigureDescriptor_AxisDescriptor_AxisType_descriptor();
template<typename T>
inline const std::string& FigureDescriptor_AxisDescriptor_AxisType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FigureDescriptor_AxisDescriptor_AxisType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FigureDescriptor_AxisDescriptor_AxisType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FigureDescriptor_AxisDescriptor_AxisType_descriptor(), enum_t_value);
}
inline bool FigureDescriptor_AxisDescriptor_AxisType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FigureDescriptor_AxisDescriptor_AxisType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FigureDescriptor_AxisDescriptor_AxisType>(
    FigureDescriptor_AxisDescriptor_AxisType_descriptor(), name, value);
}
enum FigureDescriptor_AxisDescriptor_AxisPosition : int {
  FigureDescriptor_AxisDescriptor_AxisPosition_TOP = 0,
  FigureDescriptor_AxisDescriptor_AxisPosition_BOTTOM = 1,
  FigureDescriptor_AxisDescriptor_AxisPosition_LEFT = 2,
  FigureDescriptor_AxisDescriptor_AxisPosition_RIGHT = 3,
  FigureDescriptor_AxisDescriptor_AxisPosition_NONE = 4,
  FigureDescriptor_AxisDescriptor_AxisPosition_FigureDescriptor_AxisDescriptor_AxisPosition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FigureDescriptor_AxisDescriptor_AxisPosition_FigureDescriptor_AxisDescriptor_AxisPosition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FigureDescriptor_AxisDescriptor_AxisPosition_IsValid(int value);
constexpr FigureDescriptor_AxisDescriptor_AxisPosition FigureDescriptor_AxisDescriptor_AxisPosition_AxisPosition_MIN = FigureDescriptor_AxisDescriptor_AxisPosition_TOP;
constexpr FigureDescriptor_AxisDescriptor_AxisPosition FigureDescriptor_AxisDescriptor_AxisPosition_AxisPosition_MAX = FigureDescriptor_AxisDescriptor_AxisPosition_NONE;
constexpr int FigureDescriptor_AxisDescriptor_AxisPosition_AxisPosition_ARRAYSIZE = FigureDescriptor_AxisDescriptor_AxisPosition_AxisPosition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FigureDescriptor_AxisDescriptor_AxisPosition_descriptor();
template<typename T>
inline const std::string& FigureDescriptor_AxisDescriptor_AxisPosition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FigureDescriptor_AxisDescriptor_AxisPosition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FigureDescriptor_AxisDescriptor_AxisPosition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FigureDescriptor_AxisDescriptor_AxisPosition_descriptor(), enum_t_value);
}
inline bool FigureDescriptor_AxisDescriptor_AxisPosition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FigureDescriptor_AxisDescriptor_AxisPosition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FigureDescriptor_AxisDescriptor_AxisPosition>(
    FigureDescriptor_AxisDescriptor_AxisPosition_descriptor(), name, value);
}
enum FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek : int {
  FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_SUNDAY = 0,
  FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_MONDAY = 1,
  FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_TUESDAY = 2,
  FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_WEDNESDAY = 3,
  FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_THURSDAY = 4,
  FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_FRIDAY = 5,
  FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_SATURDAY = 6,
  FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_IsValid(int value);
constexpr FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_DayOfWeek_MIN = FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_SUNDAY;
constexpr FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_DayOfWeek_MAX = FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_SATURDAY;
constexpr int FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_DayOfWeek_ARRAYSIZE = FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_DayOfWeek_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_descriptor();
template<typename T>
inline const std::string& FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_descriptor(), enum_t_value);
}
inline bool FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek>(
    FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_descriptor(), name, value);
}
enum FigureDescriptor_SeriesPlotStyle : int {
  FigureDescriptor_SeriesPlotStyle_BAR = 0,
  FigureDescriptor_SeriesPlotStyle_STACKED_BAR = 1,
  FigureDescriptor_SeriesPlotStyle_LINE = 2,
  FigureDescriptor_SeriesPlotStyle_AREA = 3,
  FigureDescriptor_SeriesPlotStyle_STACKED_AREA = 4,
  FigureDescriptor_SeriesPlotStyle_PIE = 5,
  FigureDescriptor_SeriesPlotStyle_HISTOGRAM = 6,
  FigureDescriptor_SeriesPlotStyle_OHLC = 7,
  FigureDescriptor_SeriesPlotStyle_SCATTER = 8,
  FigureDescriptor_SeriesPlotStyle_STEP = 9,
  FigureDescriptor_SeriesPlotStyle_ERROR_BAR = 10,
  FigureDescriptor_SeriesPlotStyle_TREEMAP = 11,
  FigureDescriptor_SeriesPlotStyle_FigureDescriptor_SeriesPlotStyle_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FigureDescriptor_SeriesPlotStyle_FigureDescriptor_SeriesPlotStyle_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FigureDescriptor_SeriesPlotStyle_IsValid(int value);
constexpr FigureDescriptor_SeriesPlotStyle FigureDescriptor_SeriesPlotStyle_SeriesPlotStyle_MIN = FigureDescriptor_SeriesPlotStyle_BAR;
constexpr FigureDescriptor_SeriesPlotStyle FigureDescriptor_SeriesPlotStyle_SeriesPlotStyle_MAX = FigureDescriptor_SeriesPlotStyle_TREEMAP;
constexpr int FigureDescriptor_SeriesPlotStyle_SeriesPlotStyle_ARRAYSIZE = FigureDescriptor_SeriesPlotStyle_SeriesPlotStyle_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FigureDescriptor_SeriesPlotStyle_descriptor();
template<typename T>
inline const std::string& FigureDescriptor_SeriesPlotStyle_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FigureDescriptor_SeriesPlotStyle>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FigureDescriptor_SeriesPlotStyle_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FigureDescriptor_SeriesPlotStyle_descriptor(), enum_t_value);
}
inline bool FigureDescriptor_SeriesPlotStyle_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FigureDescriptor_SeriesPlotStyle* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FigureDescriptor_SeriesPlotStyle>(
    FigureDescriptor_SeriesPlotStyle_descriptor(), name, value);
}
enum FigureDescriptor_SourceType : int {
  FigureDescriptor_SourceType_X = 0,
  FigureDescriptor_SourceType_Y = 1,
  FigureDescriptor_SourceType_Z = 2,
  FigureDescriptor_SourceType_X_LOW = 3,
  FigureDescriptor_SourceType_X_HIGH = 4,
  FigureDescriptor_SourceType_Y_LOW = 5,
  FigureDescriptor_SourceType_Y_HIGH = 6,
  FigureDescriptor_SourceType_TIME = 7,
  FigureDescriptor_SourceType_OPEN = 8,
  FigureDescriptor_SourceType_HIGH = 9,
  FigureDescriptor_SourceType_LOW = 10,
  FigureDescriptor_SourceType_CLOSE = 11,
  FigureDescriptor_SourceType_SHAPE = 12,
  FigureDescriptor_SourceType_SIZE = 13,
  FigureDescriptor_SourceType_LABEL = 14,
  FigureDescriptor_SourceType_COLOR = 15,
  FigureDescriptor_SourceType_PARENT = 16,
  FigureDescriptor_SourceType_HOVER_TEXT = 17,
  FigureDescriptor_SourceType_TEXT = 18,
  FigureDescriptor_SourceType_FigureDescriptor_SourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FigureDescriptor_SourceType_FigureDescriptor_SourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FigureDescriptor_SourceType_IsValid(int value);
constexpr FigureDescriptor_SourceType FigureDescriptor_SourceType_SourceType_MIN = FigureDescriptor_SourceType_X;
constexpr FigureDescriptor_SourceType FigureDescriptor_SourceType_SourceType_MAX = FigureDescriptor_SourceType_TEXT;
constexpr int FigureDescriptor_SourceType_SourceType_ARRAYSIZE = FigureDescriptor_SourceType_SourceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FigureDescriptor_SourceType_descriptor();
template<typename T>
inline const std::string& FigureDescriptor_SourceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FigureDescriptor_SourceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FigureDescriptor_SourceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FigureDescriptor_SourceType_descriptor(), enum_t_value);
}
inline bool FigureDescriptor_SourceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FigureDescriptor_SourceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FigureDescriptor_SourceType>(
    FigureDescriptor_SourceType_descriptor(), name, value);
}
// ===================================================================

class GetConsoleTypesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesRequest) */ {
 public:
  inline GetConsoleTypesRequest() : GetConsoleTypesRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR GetConsoleTypesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConsoleTypesRequest(const GetConsoleTypesRequest& from);
  GetConsoleTypesRequest(GetConsoleTypesRequest&& from) noexcept
    : GetConsoleTypesRequest() {
    *this = ::std::move(from);
  }

  inline GetConsoleTypesRequest& operator=(const GetConsoleTypesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConsoleTypesRequest& operator=(GetConsoleTypesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConsoleTypesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConsoleTypesRequest* internal_default_instance() {
    return reinterpret_cast<const GetConsoleTypesRequest*>(
               &_GetConsoleTypesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetConsoleTypesRequest& a, GetConsoleTypesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConsoleTypesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConsoleTypesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConsoleTypesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConsoleTypesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetConsoleTypesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetConsoleTypesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.GetConsoleTypesRequest";
  }
  protected:
  explicit GetConsoleTypesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class GetConsoleTypesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse) */ {
 public:
  inline GetConsoleTypesResponse() : GetConsoleTypesResponse(nullptr) {}
  ~GetConsoleTypesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetConsoleTypesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetConsoleTypesResponse(const GetConsoleTypesResponse& from);
  GetConsoleTypesResponse(GetConsoleTypesResponse&& from) noexcept
    : GetConsoleTypesResponse() {
    *this = ::std::move(from);
  }

  inline GetConsoleTypesResponse& operator=(const GetConsoleTypesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetConsoleTypesResponse& operator=(GetConsoleTypesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetConsoleTypesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetConsoleTypesResponse* internal_default_instance() {
    return reinterpret_cast<const GetConsoleTypesResponse*>(
               &_GetConsoleTypesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetConsoleTypesResponse& a, GetConsoleTypesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetConsoleTypesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetConsoleTypesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetConsoleTypesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetConsoleTypesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetConsoleTypesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetConsoleTypesResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetConsoleTypesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse";
  }
  protected:
  explicit GetConsoleTypesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsoleTypesFieldNumber = 1,
  };
  // repeated string console_types = 1;
  int console_types_size() const;
  private:
  int _internal_console_types_size() const;
  public:
  void clear_console_types();
  const std::string& console_types(int index) const;
  std::string* mutable_console_types(int index);
  void set_console_types(int index, const std::string& value);
  void set_console_types(int index, std::string&& value);
  void set_console_types(int index, const char* value);
  void set_console_types(int index, const char* value, size_t size);
  std::string* add_console_types();
  void add_console_types(const std::string& value);
  void add_console_types(std::string&& value);
  void add_console_types(const char* value);
  void add_console_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& console_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_console_types();
  private:
  const std::string& _internal_console_types(int index) const;
  std::string* _internal_add_console_types();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> console_types_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class StartConsoleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.StartConsoleRequest) */ {
 public:
  inline StartConsoleRequest() : StartConsoleRequest(nullptr) {}
  ~StartConsoleRequest() override;
  explicit PROTOBUF_CONSTEXPR StartConsoleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartConsoleRequest(const StartConsoleRequest& from);
  StartConsoleRequest(StartConsoleRequest&& from) noexcept
    : StartConsoleRequest() {
    *this = ::std::move(from);
  }

  inline StartConsoleRequest& operator=(const StartConsoleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartConsoleRequest& operator=(StartConsoleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartConsoleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartConsoleRequest* internal_default_instance() {
    return reinterpret_cast<const StartConsoleRequest*>(
               &_StartConsoleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StartConsoleRequest& a, StartConsoleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartConsoleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartConsoleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartConsoleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartConsoleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartConsoleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartConsoleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartConsoleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.StartConsoleRequest";
  }
  protected:
  explicit StartConsoleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionTypeFieldNumber = 2,
    kResultIdFieldNumber = 1,
  };
  // string session_type = 2;
  void clear_session_type();
  const std::string& session_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_type();
  PROTOBUF_NODISCARD std::string* release_session_type();
  void set_allocated_session_type(std::string* session_type);
  private:
  const std::string& _internal_session_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_type(const std::string& value);
  std::string* _internal_mutable_session_type();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.StartConsoleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_type_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class StartConsoleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.StartConsoleResponse) */ {
 public:
  inline StartConsoleResponse() : StartConsoleResponse(nullptr) {}
  ~StartConsoleResponse() override;
  explicit PROTOBUF_CONSTEXPR StartConsoleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartConsoleResponse(const StartConsoleResponse& from);
  StartConsoleResponse(StartConsoleResponse&& from) noexcept
    : StartConsoleResponse() {
    *this = ::std::move(from);
  }

  inline StartConsoleResponse& operator=(const StartConsoleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartConsoleResponse& operator=(StartConsoleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartConsoleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartConsoleResponse* internal_default_instance() {
    return reinterpret_cast<const StartConsoleResponse*>(
               &_StartConsoleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StartConsoleResponse& a, StartConsoleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartConsoleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartConsoleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartConsoleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartConsoleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartConsoleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StartConsoleResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartConsoleResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.StartConsoleResponse";
  }
  protected:
  explicit StartConsoleResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.StartConsoleResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class LogSubscriptionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest) */ {
 public:
  inline LogSubscriptionRequest() : LogSubscriptionRequest(nullptr) {}
  ~LogSubscriptionRequest() override;
  explicit PROTOBUF_CONSTEXPR LogSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogSubscriptionRequest(const LogSubscriptionRequest& from);
  LogSubscriptionRequest(LogSubscriptionRequest&& from) noexcept
    : LogSubscriptionRequest() {
    *this = ::std::move(from);
  }

  inline LogSubscriptionRequest& operator=(const LogSubscriptionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogSubscriptionRequest& operator=(LogSubscriptionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogSubscriptionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogSubscriptionRequest* internal_default_instance() {
    return reinterpret_cast<const LogSubscriptionRequest*>(
               &_LogSubscriptionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(LogSubscriptionRequest& a, LogSubscriptionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogSubscriptionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogSubscriptionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogSubscriptionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogSubscriptionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogSubscriptionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogSubscriptionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogSubscriptionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest";
  }
  protected:
  explicit LogSubscriptionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLevelsFieldNumber = 2,
    kLastSeenLogTimestampFieldNumber = 1,
  };
  // repeated string levels = 2;
  int levels_size() const;
  private:
  int _internal_levels_size() const;
  public:
  void clear_levels();
  const std::string& levels(int index) const;
  std::string* mutable_levels(int index);
  void set_levels(int index, const std::string& value);
  void set_levels(int index, std::string&& value);
  void set_levels(int index, const char* value);
  void set_levels(int index, const char* value, size_t size);
  std::string* add_levels();
  void add_levels(const std::string& value);
  void add_levels(std::string&& value);
  void add_levels(const char* value);
  void add_levels(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& levels() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_levels();
  private:
  const std::string& _internal_levels(int index) const;
  std::string* _internal_add_levels();
  public:

  // int64 last_seen_log_timestamp = 1 [jstype = JS_STRING];
  void clear_last_seen_log_timestamp();
  int64_t last_seen_log_timestamp() const;
  void set_last_seen_log_timestamp(int64_t value);
  private:
  int64_t _internal_last_seen_log_timestamp() const;
  void _internal_set_last_seen_log_timestamp(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> levels_;
  int64_t last_seen_log_timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class LogSubscriptionData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData) */ {
 public:
  inline LogSubscriptionData() : LogSubscriptionData(nullptr) {}
  ~LogSubscriptionData() override;
  explicit PROTOBUF_CONSTEXPR LogSubscriptionData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogSubscriptionData(const LogSubscriptionData& from);
  LogSubscriptionData(LogSubscriptionData&& from) noexcept
    : LogSubscriptionData() {
    *this = ::std::move(from);
  }

  inline LogSubscriptionData& operator=(const LogSubscriptionData& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogSubscriptionData& operator=(LogSubscriptionData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogSubscriptionData& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogSubscriptionData* internal_default_instance() {
    return reinterpret_cast<const LogSubscriptionData*>(
               &_LogSubscriptionData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(LogSubscriptionData& a, LogSubscriptionData& b) {
    a.Swap(&b);
  }
  inline void Swap(LogSubscriptionData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogSubscriptionData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogSubscriptionData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogSubscriptionData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogSubscriptionData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LogSubscriptionData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogSubscriptionData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.LogSubscriptionData";
  }
  protected:
  explicit LogSubscriptionData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogLevelFieldNumber = 2,
    kMessageFieldNumber = 3,
    kMicrosFieldNumber = 1,
  };
  // string log_level = 2;
  void clear_log_level();
  const std::string& log_level() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log_level(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log_level();
  PROTOBUF_NODISCARD std::string* release_log_level();
  void set_allocated_log_level(std::string* log_level);
  private:
  const std::string& _internal_log_level() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log_level(const std::string& value);
  std::string* _internal_mutable_log_level();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // int64 micros = 1 [jstype = JS_STRING];
  void clear_micros();
  int64_t micros() const;
  void set_micros(int64_t value);
  private:
  int64_t _internal_micros() const;
  void _internal_set_micros(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_level_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int64_t micros_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class ExecuteCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest) */ {
 public:
  inline ExecuteCommandRequest() : ExecuteCommandRequest(nullptr) {}
  ~ExecuteCommandRequest() override;
  explicit PROTOBUF_CONSTEXPR ExecuteCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteCommandRequest(const ExecuteCommandRequest& from);
  ExecuteCommandRequest(ExecuteCommandRequest&& from) noexcept
    : ExecuteCommandRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteCommandRequest& operator=(const ExecuteCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteCommandRequest& operator=(ExecuteCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteCommandRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteCommandRequest*>(
               &_ExecuteCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ExecuteCommandRequest& a, ExecuteCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteCommandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteCommandRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteCommandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest";
  }
  protected:
  explicit ExecuteCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 3,
    kConsoleIdFieldNumber = 1,
  };
  // string code = 3;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
  bool has_console_id() const;
  private:
  bool _internal_has_console_id() const;
  public:
  void clear_console_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& console_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_console_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_console_id();
  void set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_console_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_console_id();
  public:
  void unsafe_arena_set_allocated_console_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_console_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::io::deephaven::proto::backplane::grpc::Ticket* console_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class ExecuteCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse) */ {
 public:
  inline ExecuteCommandResponse() : ExecuteCommandResponse(nullptr) {}
  ~ExecuteCommandResponse() override;
  explicit PROTOBUF_CONSTEXPR ExecuteCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteCommandResponse(const ExecuteCommandResponse& from);
  ExecuteCommandResponse(ExecuteCommandResponse&& from) noexcept
    : ExecuteCommandResponse() {
    *this = ::std::move(from);
  }

  inline ExecuteCommandResponse& operator=(const ExecuteCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteCommandResponse& operator=(ExecuteCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteCommandResponse* internal_default_instance() {
    return reinterpret_cast<const ExecuteCommandResponse*>(
               &_ExecuteCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ExecuteCommandResponse& a, ExecuteCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecuteCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecuteCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteCommandResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteCommandResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteCommandResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse";
  }
  protected:
  explicit ExecuteCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMessageFieldNumber = 1,
    kChangesFieldNumber = 2,
  };
  // string error_message = 1;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .io.deephaven.proto.backplane.grpc.FieldsChangeUpdate changes = 2;
  bool has_changes() const;
  private:
  bool _internal_has_changes() const;
  public:
  void clear_changes();
  const ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate& changes() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* release_changes();
  ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* mutable_changes();
  void set_allocated_changes(::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* changes);
  private:
  const ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate& _internal_changes() const;
  ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* _internal_mutable_changes();
  public:
  void unsafe_arena_set_allocated_changes(
      ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* changes);
  ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* unsafe_arena_release_changes();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* changes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class BindTableToVariableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest) */ {
 public:
  inline BindTableToVariableRequest() : BindTableToVariableRequest(nullptr) {}
  ~BindTableToVariableRequest() override;
  explicit PROTOBUF_CONSTEXPR BindTableToVariableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BindTableToVariableRequest(const BindTableToVariableRequest& from);
  BindTableToVariableRequest(BindTableToVariableRequest&& from) noexcept
    : BindTableToVariableRequest() {
    *this = ::std::move(from);
  }

  inline BindTableToVariableRequest& operator=(const BindTableToVariableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BindTableToVariableRequest& operator=(BindTableToVariableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BindTableToVariableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BindTableToVariableRequest* internal_default_instance() {
    return reinterpret_cast<const BindTableToVariableRequest*>(
               &_BindTableToVariableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(BindTableToVariableRequest& a, BindTableToVariableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BindTableToVariableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BindTableToVariableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BindTableToVariableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BindTableToVariableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BindTableToVariableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BindTableToVariableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BindTableToVariableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest";
  }
  protected:
  explicit BindTableToVariableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVariableNameFieldNumber = 3,
    kConsoleIdFieldNumber = 1,
    kTableIdFieldNumber = 4,
  };
  // string variable_name = 3;
  void clear_variable_name();
  const std::string& variable_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_variable_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_variable_name();
  PROTOBUF_NODISCARD std::string* release_variable_name();
  void set_allocated_variable_name(std::string* variable_name);
  private:
  const std::string& _internal_variable_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_variable_name(const std::string& value);
  std::string* _internal_mutable_variable_name();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
  bool has_console_id() const;
  private:
  bool _internal_has_console_id() const;
  public:
  void clear_console_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& console_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_console_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_console_id();
  void set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_console_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_console_id();
  public:
  void unsafe_arena_set_allocated_console_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_console_id();

  // .io.deephaven.proto.backplane.grpc.Ticket table_id = 4;
  bool has_table_id() const;
  private:
  bool _internal_has_table_id() const;
  public:
  void clear_table_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& table_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_table_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_table_id();
  void set_allocated_table_id(::io::deephaven::proto::backplane::grpc::Ticket* table_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_table_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_table_id();
  public:
  void unsafe_arena_set_allocated_table_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* table_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_table_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr variable_name_;
  ::io::deephaven::proto::backplane::grpc::Ticket* console_id_;
  ::io::deephaven::proto::backplane::grpc::Ticket* table_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class BindTableToVariableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.BindTableToVariableResponse) */ {
 public:
  inline BindTableToVariableResponse() : BindTableToVariableResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR BindTableToVariableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BindTableToVariableResponse(const BindTableToVariableResponse& from);
  BindTableToVariableResponse(BindTableToVariableResponse&& from) noexcept
    : BindTableToVariableResponse() {
    *this = ::std::move(from);
  }

  inline BindTableToVariableResponse& operator=(const BindTableToVariableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BindTableToVariableResponse& operator=(BindTableToVariableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BindTableToVariableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BindTableToVariableResponse* internal_default_instance() {
    return reinterpret_cast<const BindTableToVariableResponse*>(
               &_BindTableToVariableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(BindTableToVariableResponse& a, BindTableToVariableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BindTableToVariableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BindTableToVariableResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BindTableToVariableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BindTableToVariableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BindTableToVariableResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BindTableToVariableResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.BindTableToVariableResponse";
  }
  protected:
  explicit BindTableToVariableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.BindTableToVariableResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class CancelCommandRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.CancelCommandRequest) */ {
 public:
  inline CancelCommandRequest() : CancelCommandRequest(nullptr) {}
  ~CancelCommandRequest() override;
  explicit PROTOBUF_CONSTEXPR CancelCommandRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelCommandRequest(const CancelCommandRequest& from);
  CancelCommandRequest(CancelCommandRequest&& from) noexcept
    : CancelCommandRequest() {
    *this = ::std::move(from);
  }

  inline CancelCommandRequest& operator=(const CancelCommandRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelCommandRequest& operator=(CancelCommandRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelCommandRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelCommandRequest* internal_default_instance() {
    return reinterpret_cast<const CancelCommandRequest*>(
               &_CancelCommandRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CancelCommandRequest& a, CancelCommandRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelCommandRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelCommandRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelCommandRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelCommandRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CancelCommandRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CancelCommandRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelCommandRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.CancelCommandRequest";
  }
  protected:
  explicit CancelCommandRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsoleIdFieldNumber = 1,
    kCommandIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
  bool has_console_id() const;
  private:
  bool _internal_has_console_id() const;
  public:
  void clear_console_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& console_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_console_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_console_id();
  void set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_console_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_console_id();
  public:
  void unsafe_arena_set_allocated_console_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_console_id();

  // .io.deephaven.proto.backplane.grpc.Ticket command_id = 2;
  bool has_command_id() const;
  private:
  bool _internal_has_command_id() const;
  public:
  void clear_command_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& command_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_command_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_command_id();
  void set_allocated_command_id(::io::deephaven::proto::backplane::grpc::Ticket* command_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_command_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_command_id();
  public:
  void unsafe_arena_set_allocated_command_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* command_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_command_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.CancelCommandRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* console_id_;
  ::io::deephaven::proto::backplane::grpc::Ticket* command_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class CancelCommandResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.CancelCommandResponse) */ {
 public:
  inline CancelCommandResponse() : CancelCommandResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CancelCommandResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CancelCommandResponse(const CancelCommandResponse& from);
  CancelCommandResponse(CancelCommandResponse&& from) noexcept
    : CancelCommandResponse() {
    *this = ::std::move(from);
  }

  inline CancelCommandResponse& operator=(const CancelCommandResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CancelCommandResponse& operator=(CancelCommandResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CancelCommandResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CancelCommandResponse* internal_default_instance() {
    return reinterpret_cast<const CancelCommandResponse*>(
               &_CancelCommandResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CancelCommandResponse& a, CancelCommandResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CancelCommandResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CancelCommandResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CancelCommandResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CancelCommandResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CancelCommandResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CancelCommandResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.CancelCommandResponse";
  }
  protected:
  explicit CancelCommandResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.CancelCommandResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class AutoCompleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest) */ {
 public:
  inline AutoCompleteRequest() : AutoCompleteRequest(nullptr) {}
  ~AutoCompleteRequest() override;
  explicit PROTOBUF_CONSTEXPR AutoCompleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoCompleteRequest(const AutoCompleteRequest& from);
  AutoCompleteRequest(AutoCompleteRequest&& from) noexcept
    : AutoCompleteRequest() {
    *this = ::std::move(from);
  }

  inline AutoCompleteRequest& operator=(const AutoCompleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoCompleteRequest& operator=(AutoCompleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoCompleteRequest& default_instance() {
    return *internal_default_instance();
  }
  enum RequestCase {
    kOpenDocument = 1,
    kChangeDocument = 2,
    kGetCompletionItems = 3,
    kCloseDocument = 4,
    REQUEST_NOT_SET = 0,
  };

  static inline const AutoCompleteRequest* internal_default_instance() {
    return reinterpret_cast<const AutoCompleteRequest*>(
               &_AutoCompleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AutoCompleteRequest& a, AutoCompleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoCompleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoCompleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoCompleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoCompleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AutoCompleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AutoCompleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoCompleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest";
  }
  protected:
  explicit AutoCompleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpenDocumentFieldNumber = 1,
    kChangeDocumentFieldNumber = 2,
    kGetCompletionItemsFieldNumber = 3,
    kCloseDocumentFieldNumber = 4,
  };
  // .io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest open_document = 1;
  bool has_open_document() const;
  private:
  bool _internal_has_open_document() const;
  public:
  void clear_open_document();
  const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& open_document() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* release_open_document();
  ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* mutable_open_document();
  void set_allocated_open_document(::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* open_document);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& _internal_open_document() const;
  ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* _internal_mutable_open_document();
  public:
  void unsafe_arena_set_allocated_open_document(
      ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* open_document);
  ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* unsafe_arena_release_open_document();

  // .io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest change_document = 2;
  bool has_change_document() const;
  private:
  bool _internal_has_change_document() const;
  public:
  void clear_change_document();
  const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& change_document() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* release_change_document();
  ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* mutable_change_document();
  void set_allocated_change_document(::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* change_document);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& _internal_change_document() const;
  ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* _internal_mutable_change_document();
  public:
  void unsafe_arena_set_allocated_change_document(
      ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* change_document);
  ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* unsafe_arena_release_change_document();

  // .io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest get_completion_items = 3;
  bool has_get_completion_items() const;
  private:
  bool _internal_has_get_completion_items() const;
  public:
  void clear_get_completion_items();
  const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& get_completion_items() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* release_get_completion_items();
  ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* mutable_get_completion_items();
  void set_allocated_get_completion_items(::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* get_completion_items);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& _internal_get_completion_items() const;
  ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* _internal_mutable_get_completion_items();
  public:
  void unsafe_arena_set_allocated_get_completion_items(
      ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* get_completion_items);
  ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* unsafe_arena_release_get_completion_items();

  // .io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest close_document = 4;
  bool has_close_document() const;
  private:
  bool _internal_has_close_document() const;
  public:
  void clear_close_document();
  const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& close_document() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* release_close_document();
  ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* mutable_close_document();
  void set_allocated_close_document(::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* close_document);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& _internal_close_document() const;
  ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* _internal_mutable_close_document();
  public:
  void unsafe_arena_set_allocated_close_document(
      ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* close_document);
  ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* unsafe_arena_release_close_document();

  void clear_request();
  RequestCase request_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest)
 private:
  class _Internal;
  void set_has_open_document();
  void set_has_change_document();
  void set_has_get_completion_items();
  void set_has_close_document();

  inline bool has_request() const;
  inline void clear_has_request();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union RequestUnion {
    constexpr RequestUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* open_document_;
    ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* change_document_;
    ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* get_completion_items_;
    ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* close_document_;
  } request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class AutoCompleteResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.AutoCompleteResponse) */ {
 public:
  inline AutoCompleteResponse() : AutoCompleteResponse(nullptr) {}
  ~AutoCompleteResponse() override;
  explicit PROTOBUF_CONSTEXPR AutoCompleteResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AutoCompleteResponse(const AutoCompleteResponse& from);
  AutoCompleteResponse(AutoCompleteResponse&& from) noexcept
    : AutoCompleteResponse() {
    *this = ::std::move(from);
  }

  inline AutoCompleteResponse& operator=(const AutoCompleteResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AutoCompleteResponse& operator=(AutoCompleteResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AutoCompleteResponse& default_instance() {
    return *internal_default_instance();
  }
  enum ResponseCase {
    kCompletionItems = 1,
    RESPONSE_NOT_SET = 0,
  };

  static inline const AutoCompleteResponse* internal_default_instance() {
    return reinterpret_cast<const AutoCompleteResponse*>(
               &_AutoCompleteResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(AutoCompleteResponse& a, AutoCompleteResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AutoCompleteResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AutoCompleteResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AutoCompleteResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AutoCompleteResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AutoCompleteResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AutoCompleteResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AutoCompleteResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.AutoCompleteResponse";
  }
  protected:
  explicit AutoCompleteResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompletionItemsFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse completion_items = 1;
  bool has_completion_items() const;
  private:
  bool _internal_has_completion_items() const;
  public:
  void clear_completion_items();
  const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse& completion_items() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* release_completion_items();
  ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* mutable_completion_items();
  void set_allocated_completion_items(::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* completion_items);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse& _internal_completion_items() const;
  ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* _internal_mutable_completion_items();
  public:
  void unsafe_arena_set_allocated_completion_items(
      ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* completion_items);
  ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* unsafe_arena_release_completion_items();

  void clear_response();
  ResponseCase response_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.AutoCompleteResponse)
 private:
  class _Internal;
  void set_has_completion_items();

  inline bool has_response() const;
  inline void clear_has_response();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ResponseUnion {
    constexpr ResponseUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* completion_items_;
  } response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class BrowserNextResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.BrowserNextResponse) */ {
 public:
  inline BrowserNextResponse() : BrowserNextResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR BrowserNextResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BrowserNextResponse(const BrowserNextResponse& from);
  BrowserNextResponse(BrowserNextResponse&& from) noexcept
    : BrowserNextResponse() {
    *this = ::std::move(from);
  }

  inline BrowserNextResponse& operator=(const BrowserNextResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrowserNextResponse& operator=(BrowserNextResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BrowserNextResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BrowserNextResponse* internal_default_instance() {
    return reinterpret_cast<const BrowserNextResponse*>(
               &_BrowserNextResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BrowserNextResponse& a, BrowserNextResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BrowserNextResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrowserNextResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BrowserNextResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BrowserNextResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const BrowserNextResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const BrowserNextResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.BrowserNextResponse";
  }
  protected:
  explicit BrowserNextResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.BrowserNextResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class OpenDocumentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest) */ {
 public:
  inline OpenDocumentRequest() : OpenDocumentRequest(nullptr) {}
  ~OpenDocumentRequest() override;
  explicit PROTOBUF_CONSTEXPR OpenDocumentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenDocumentRequest(const OpenDocumentRequest& from);
  OpenDocumentRequest(OpenDocumentRequest&& from) noexcept
    : OpenDocumentRequest() {
    *this = ::std::move(from);
  }

  inline OpenDocumentRequest& operator=(const OpenDocumentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenDocumentRequest& operator=(OpenDocumentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenDocumentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenDocumentRequest* internal_default_instance() {
    return reinterpret_cast<const OpenDocumentRequest*>(
               &_OpenDocumentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(OpenDocumentRequest& a, OpenDocumentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenDocumentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenDocumentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenDocumentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenDocumentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenDocumentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OpenDocumentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenDocumentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest";
  }
  protected:
  explicit OpenDocumentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsoleIdFieldNumber = 1,
    kTextDocumentFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
  bool has_console_id() const;
  private:
  bool _internal_has_console_id() const;
  public:
  void clear_console_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& console_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_console_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_console_id();
  void set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_console_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_console_id();
  public:
  void unsafe_arena_set_allocated_console_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_console_id();

  // .io.deephaven.proto.backplane.script.grpc.TextDocumentItem text_document = 2;
  bool has_text_document() const;
  private:
  bool _internal_has_text_document() const;
  public:
  void clear_text_document();
  const ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem& text_document() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* release_text_document();
  ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* mutable_text_document();
  void set_allocated_text_document(::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* text_document);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem& _internal_text_document() const;
  ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* _internal_mutable_text_document();
  public:
  void unsafe_arena_set_allocated_text_document(
      ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* text_document);
  ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* unsafe_arena_release_text_document();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* console_id_;
  ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* text_document_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class TextDocumentItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.TextDocumentItem) */ {
 public:
  inline TextDocumentItem() : TextDocumentItem(nullptr) {}
  ~TextDocumentItem() override;
  explicit PROTOBUF_CONSTEXPR TextDocumentItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextDocumentItem(const TextDocumentItem& from);
  TextDocumentItem(TextDocumentItem&& from) noexcept
    : TextDocumentItem() {
    *this = ::std::move(from);
  }

  inline TextDocumentItem& operator=(const TextDocumentItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextDocumentItem& operator=(TextDocumentItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextDocumentItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextDocumentItem* internal_default_instance() {
    return reinterpret_cast<const TextDocumentItem*>(
               &_TextDocumentItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TextDocumentItem& a, TextDocumentItem& b) {
    a.Swap(&b);
  }
  inline void Swap(TextDocumentItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextDocumentItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextDocumentItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextDocumentItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextDocumentItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TextDocumentItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextDocumentItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.TextDocumentItem";
  }
  protected:
  explicit TextDocumentItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kLanguageIdFieldNumber = 2,
    kTextFieldNumber = 4,
    kVersionFieldNumber = 3,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // string language_id = 2;
  void clear_language_id();
  const std::string& language_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language_id();
  PROTOBUF_NODISCARD std::string* release_language_id();
  void set_allocated_language_id(std::string* language_id);
  private:
  const std::string& _internal_language_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language_id(const std::string& value);
  std::string* _internal_mutable_language_id();
  public:

  // string text = 4;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // int32 version = 3;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.TextDocumentItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  int32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class CloseDocumentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest) */ {
 public:
  inline CloseDocumentRequest() : CloseDocumentRequest(nullptr) {}
  ~CloseDocumentRequest() override;
  explicit PROTOBUF_CONSTEXPR CloseDocumentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CloseDocumentRequest(const CloseDocumentRequest& from);
  CloseDocumentRequest(CloseDocumentRequest&& from) noexcept
    : CloseDocumentRequest() {
    *this = ::std::move(from);
  }

  inline CloseDocumentRequest& operator=(const CloseDocumentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CloseDocumentRequest& operator=(CloseDocumentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CloseDocumentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CloseDocumentRequest* internal_default_instance() {
    return reinterpret_cast<const CloseDocumentRequest*>(
               &_CloseDocumentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CloseDocumentRequest& a, CloseDocumentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CloseDocumentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CloseDocumentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CloseDocumentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CloseDocumentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CloseDocumentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CloseDocumentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloseDocumentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest";
  }
  protected:
  explicit CloseDocumentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsoleIdFieldNumber = 1,
    kTextDocumentFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
  bool has_console_id() const;
  private:
  bool _internal_has_console_id() const;
  public:
  void clear_console_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& console_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_console_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_console_id();
  void set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_console_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_console_id();
  public:
  void unsafe_arena_set_allocated_console_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_console_id();

  // .io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier text_document = 2;
  bool has_text_document() const;
  private:
  bool _internal_has_text_document() const;
  public:
  void clear_text_document();
  const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier& text_document() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* release_text_document();
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* mutable_text_document();
  void set_allocated_text_document(::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier& _internal_text_document() const;
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* _internal_mutable_text_document();
  public:
  void unsafe_arena_set_allocated_text_document(
      ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document);
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* unsafe_arena_release_text_document();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* console_id_;
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class ChangeDocumentRequest_TextDocumentContentChangeEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent) */ {
 public:
  inline ChangeDocumentRequest_TextDocumentContentChangeEvent() : ChangeDocumentRequest_TextDocumentContentChangeEvent(nullptr) {}
  ~ChangeDocumentRequest_TextDocumentContentChangeEvent() override;
  explicit PROTOBUF_CONSTEXPR ChangeDocumentRequest_TextDocumentContentChangeEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeDocumentRequest_TextDocumentContentChangeEvent(const ChangeDocumentRequest_TextDocumentContentChangeEvent& from);
  ChangeDocumentRequest_TextDocumentContentChangeEvent(ChangeDocumentRequest_TextDocumentContentChangeEvent&& from) noexcept
    : ChangeDocumentRequest_TextDocumentContentChangeEvent() {
    *this = ::std::move(from);
  }

  inline ChangeDocumentRequest_TextDocumentContentChangeEvent& operator=(const ChangeDocumentRequest_TextDocumentContentChangeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeDocumentRequest_TextDocumentContentChangeEvent& operator=(ChangeDocumentRequest_TextDocumentContentChangeEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeDocumentRequest_TextDocumentContentChangeEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeDocumentRequest_TextDocumentContentChangeEvent* internal_default_instance() {
    return reinterpret_cast<const ChangeDocumentRequest_TextDocumentContentChangeEvent*>(
               &_ChangeDocumentRequest_TextDocumentContentChangeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ChangeDocumentRequest_TextDocumentContentChangeEvent& a, ChangeDocumentRequest_TextDocumentContentChangeEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeDocumentRequest_TextDocumentContentChangeEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeDocumentRequest_TextDocumentContentChangeEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeDocumentRequest_TextDocumentContentChangeEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeDocumentRequest_TextDocumentContentChangeEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeDocumentRequest_TextDocumentContentChangeEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeDocumentRequest_TextDocumentContentChangeEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeDocumentRequest_TextDocumentContentChangeEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent";
  }
  protected:
  explicit ChangeDocumentRequest_TextDocumentContentChangeEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 3,
    kRangeFieldNumber = 1,
    kRangeLengthFieldNumber = 2,
  };
  // string text = 3;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .io.deephaven.proto.backplane.script.grpc.DocumentRange range = 1;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::io::deephaven::proto::backplane::script::grpc::DocumentRange& range() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::DocumentRange* release_range();
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* mutable_range();
  void set_allocated_range(::io::deephaven::proto::backplane::script::grpc::DocumentRange* range);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::DocumentRange& _internal_range() const;
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::io::deephaven::proto::backplane::script::grpc::DocumentRange* range);
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* unsafe_arena_release_range();

  // int32 range_length = 2;
  void clear_range_length();
  int32_t range_length() const;
  void set_range_length(int32_t value);
  private:
  int32_t _internal_range_length() const;
  void _internal_set_range_length(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* range_;
  int32_t range_length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class ChangeDocumentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest) */ {
 public:
  inline ChangeDocumentRequest() : ChangeDocumentRequest(nullptr) {}
  ~ChangeDocumentRequest() override;
  explicit PROTOBUF_CONSTEXPR ChangeDocumentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChangeDocumentRequest(const ChangeDocumentRequest& from);
  ChangeDocumentRequest(ChangeDocumentRequest&& from) noexcept
    : ChangeDocumentRequest() {
    *this = ::std::move(from);
  }

  inline ChangeDocumentRequest& operator=(const ChangeDocumentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangeDocumentRequest& operator=(ChangeDocumentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangeDocumentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangeDocumentRequest* internal_default_instance() {
    return reinterpret_cast<const ChangeDocumentRequest*>(
               &_ChangeDocumentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ChangeDocumentRequest& a, ChangeDocumentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ChangeDocumentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangeDocumentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangeDocumentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChangeDocumentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChangeDocumentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ChangeDocumentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChangeDocumentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest";
  }
  protected:
  explicit ChangeDocumentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChangeDocumentRequest_TextDocumentContentChangeEvent TextDocumentContentChangeEvent;

  // accessors -------------------------------------------------------

  enum : int {
    kContentChangesFieldNumber = 3,
    kConsoleIdFieldNumber = 1,
    kTextDocumentFieldNumber = 2,
  };
  // repeated .io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent content_changes = 3;
  int content_changes_size() const;
  private:
  int _internal_content_changes_size() const;
  public:
  void clear_content_changes();
  ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent* mutable_content_changes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent >*
      mutable_content_changes();
  private:
  const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent& _internal_content_changes(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent* _internal_add_content_changes();
  public:
  const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent& content_changes(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent* add_content_changes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent >&
      content_changes() const;

  // .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
  bool has_console_id() const;
  private:
  bool _internal_has_console_id() const;
  public:
  void clear_console_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& console_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_console_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_console_id();
  void set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_console_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_console_id();
  public:
  void unsafe_arena_set_allocated_console_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_console_id();

  // .io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier text_document = 2;
  bool has_text_document() const;
  private:
  bool _internal_has_text_document() const;
  public:
  void clear_text_document();
  const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier& text_document() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* release_text_document();
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* mutable_text_document();
  void set_allocated_text_document(::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier& _internal_text_document() const;
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* _internal_mutable_text_document();
  public:
  void unsafe_arena_set_allocated_text_document(
      ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document);
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* unsafe_arena_release_text_document();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent > content_changes_;
  ::io::deephaven::proto::backplane::grpc::Ticket* console_id_;
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class DocumentRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.DocumentRange) */ {
 public:
  inline DocumentRange() : DocumentRange(nullptr) {}
  ~DocumentRange() override;
  explicit PROTOBUF_CONSTEXPR DocumentRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DocumentRange(const DocumentRange& from);
  DocumentRange(DocumentRange&& from) noexcept
    : DocumentRange() {
    *this = ::std::move(from);
  }

  inline DocumentRange& operator=(const DocumentRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline DocumentRange& operator=(DocumentRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DocumentRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const DocumentRange* internal_default_instance() {
    return reinterpret_cast<const DocumentRange*>(
               &_DocumentRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DocumentRange& a, DocumentRange& b) {
    a.Swap(&b);
  }
  inline void Swap(DocumentRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DocumentRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DocumentRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DocumentRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DocumentRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DocumentRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DocumentRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.DocumentRange";
  }
  protected:
  explicit DocumentRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.script.grpc.Position start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::io::deephaven::proto::backplane::script::grpc::Position& start() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::Position* release_start();
  ::io::deephaven::proto::backplane::script::grpc::Position* mutable_start();
  void set_allocated_start(::io::deephaven::proto::backplane::script::grpc::Position* start);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::Position& _internal_start() const;
  ::io::deephaven::proto::backplane::script::grpc::Position* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::io::deephaven::proto::backplane::script::grpc::Position* start);
  ::io::deephaven::proto::backplane::script::grpc::Position* unsafe_arena_release_start();

  // .io.deephaven.proto.backplane.script.grpc.Position end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::io::deephaven::proto::backplane::script::grpc::Position& end() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::Position* release_end();
  ::io::deephaven::proto::backplane::script::grpc::Position* mutable_end();
  void set_allocated_end(::io::deephaven::proto::backplane::script::grpc::Position* end);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::Position& _internal_end() const;
  ::io::deephaven::proto::backplane::script::grpc::Position* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::io::deephaven::proto::backplane::script::grpc::Position* end);
  ::io::deephaven::proto::backplane::script::grpc::Position* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.DocumentRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::script::grpc::Position* start_;
  ::io::deephaven::proto::backplane::script::grpc::Position* end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class VersionedTextDocumentIdentifier final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier) */ {
 public:
  inline VersionedTextDocumentIdentifier() : VersionedTextDocumentIdentifier(nullptr) {}
  ~VersionedTextDocumentIdentifier() override;
  explicit PROTOBUF_CONSTEXPR VersionedTextDocumentIdentifier(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VersionedTextDocumentIdentifier(const VersionedTextDocumentIdentifier& from);
  VersionedTextDocumentIdentifier(VersionedTextDocumentIdentifier&& from) noexcept
    : VersionedTextDocumentIdentifier() {
    *this = ::std::move(from);
  }

  inline VersionedTextDocumentIdentifier& operator=(const VersionedTextDocumentIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionedTextDocumentIdentifier& operator=(VersionedTextDocumentIdentifier&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VersionedTextDocumentIdentifier& default_instance() {
    return *internal_default_instance();
  }
  static inline const VersionedTextDocumentIdentifier* internal_default_instance() {
    return reinterpret_cast<const VersionedTextDocumentIdentifier*>(
               &_VersionedTextDocumentIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(VersionedTextDocumentIdentifier& a, VersionedTextDocumentIdentifier& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionedTextDocumentIdentifier* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VersionedTextDocumentIdentifier* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VersionedTextDocumentIdentifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VersionedTextDocumentIdentifier>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VersionedTextDocumentIdentifier& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VersionedTextDocumentIdentifier& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionedTextDocumentIdentifier* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier";
  }
  protected:
  explicit VersionedTextDocumentIdentifier(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUriFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // string uri = 1;
  void clear_uri();
  const std::string& uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uri();
  PROTOBUF_NODISCARD std::string* release_uri();
  void set_allocated_uri(std::string* uri);
  private:
  const std::string& _internal_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uri(const std::string& value);
  std::string* _internal_mutable_uri();
  public:

  // int32 version = 2;
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uri_;
  int32_t version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class Position final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.Position) */ {
 public:
  inline Position() : Position(nullptr) {}
  ~Position() override;
  explicit PROTOBUF_CONSTEXPR Position(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Position(const Position& from);
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  inline Position& operator=(Position&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Position& default_instance() {
    return *internal_default_instance();
  }
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }
  inline void Swap(Position* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Position* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Position* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Position& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Position& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.Position";
  }
  protected:
  explicit Position(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLineFieldNumber = 1,
    kCharacterFieldNumber = 2,
  };
  // int32 line = 1;
  void clear_line();
  int32_t line() const;
  void set_line(int32_t value);
  private:
  int32_t _internal_line() const;
  void _internal_set_line(int32_t value);
  public:

  // int32 character = 2;
  void clear_character();
  int32_t character() const;
  void set_character(int32_t value);
  private:
  int32_t _internal_character() const;
  void _internal_set_character(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.Position)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t line_;
  int32_t character_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class GetCompletionItemsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest) */ {
 public:
  inline GetCompletionItemsRequest() : GetCompletionItemsRequest(nullptr) {}
  ~GetCompletionItemsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetCompletionItemsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCompletionItemsRequest(const GetCompletionItemsRequest& from);
  GetCompletionItemsRequest(GetCompletionItemsRequest&& from) noexcept
    : GetCompletionItemsRequest() {
    *this = ::std::move(from);
  }

  inline GetCompletionItemsRequest& operator=(const GetCompletionItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCompletionItemsRequest& operator=(GetCompletionItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCompletionItemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCompletionItemsRequest* internal_default_instance() {
    return reinterpret_cast<const GetCompletionItemsRequest*>(
               &_GetCompletionItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetCompletionItemsRequest& a, GetCompletionItemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCompletionItemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCompletionItemsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCompletionItemsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCompletionItemsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCompletionItemsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCompletionItemsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCompletionItemsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest";
  }
  protected:
  explicit GetCompletionItemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConsoleIdFieldNumber = 1,
    kContextFieldNumber = 2,
    kTextDocumentFieldNumber = 3,
    kPositionFieldNumber = 4,
    kRequestIdFieldNumber = 5,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
  bool has_console_id() const;
  private:
  bool _internal_has_console_id() const;
  public:
  void clear_console_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& console_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_console_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_console_id();
  void set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_console_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_console_id();
  public:
  void unsafe_arena_set_allocated_console_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* console_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_console_id();

  // .io.deephaven.proto.backplane.script.grpc.CompletionContext context = 2;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::io::deephaven::proto::backplane::script::grpc::CompletionContext& context() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::CompletionContext* release_context();
  ::io::deephaven::proto::backplane::script::grpc::CompletionContext* mutable_context();
  void set_allocated_context(::io::deephaven::proto::backplane::script::grpc::CompletionContext* context);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::CompletionContext& _internal_context() const;
  ::io::deephaven::proto::backplane::script::grpc::CompletionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::io::deephaven::proto::backplane::script::grpc::CompletionContext* context);
  ::io::deephaven::proto::backplane::script::grpc::CompletionContext* unsafe_arena_release_context();

  // .io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier text_document = 3;
  bool has_text_document() const;
  private:
  bool _internal_has_text_document() const;
  public:
  void clear_text_document();
  const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier& text_document() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* release_text_document();
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* mutable_text_document();
  void set_allocated_text_document(::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier& _internal_text_document() const;
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* _internal_mutable_text_document();
  public:
  void unsafe_arena_set_allocated_text_document(
      ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document);
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* unsafe_arena_release_text_document();

  // .io.deephaven.proto.backplane.script.grpc.Position position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::io::deephaven::proto::backplane::script::grpc::Position& position() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::Position* release_position();
  ::io::deephaven::proto::backplane::script::grpc::Position* mutable_position();
  void set_allocated_position(::io::deephaven::proto::backplane::script::grpc::Position* position);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::Position& _internal_position() const;
  ::io::deephaven::proto::backplane::script::grpc::Position* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::io::deephaven::proto::backplane::script::grpc::Position* position);
  ::io::deephaven::proto::backplane::script::grpc::Position* unsafe_arena_release_position();

  // int32 request_id = 5;
  void clear_request_id();
  int32_t request_id() const;
  void set_request_id(int32_t value);
  private:
  int32_t _internal_request_id() const;
  void _internal_set_request_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* console_id_;
  ::io::deephaven::proto::backplane::script::grpc::CompletionContext* context_;
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document_;
  ::io::deephaven::proto::backplane::script::grpc::Position* position_;
  int32_t request_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class CompletionContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.CompletionContext) */ {
 public:
  inline CompletionContext() : CompletionContext(nullptr) {}
  ~CompletionContext() override;
  explicit PROTOBUF_CONSTEXPR CompletionContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompletionContext(const CompletionContext& from);
  CompletionContext(CompletionContext&& from) noexcept
    : CompletionContext() {
    *this = ::std::move(from);
  }

  inline CompletionContext& operator=(const CompletionContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompletionContext& operator=(CompletionContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompletionContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompletionContext* internal_default_instance() {
    return reinterpret_cast<const CompletionContext*>(
               &_CompletionContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CompletionContext& a, CompletionContext& b) {
    a.Swap(&b);
  }
  inline void Swap(CompletionContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompletionContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompletionContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompletionContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompletionContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompletionContext& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompletionContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.CompletionContext";
  }
  protected:
  explicit CompletionContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTriggerCharacterFieldNumber = 2,
    kTriggerKindFieldNumber = 1,
  };
  // string trigger_character = 2;
  void clear_trigger_character();
  const std::string& trigger_character() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trigger_character(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trigger_character();
  PROTOBUF_NODISCARD std::string* release_trigger_character();
  void set_allocated_trigger_character(std::string* trigger_character);
  private:
  const std::string& _internal_trigger_character() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trigger_character(const std::string& value);
  std::string* _internal_mutable_trigger_character();
  public:

  // int32 trigger_kind = 1;
  void clear_trigger_kind();
  int32_t trigger_kind() const;
  void set_trigger_kind(int32_t value);
  private:
  int32_t _internal_trigger_kind() const;
  void _internal_set_trigger_kind(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.CompletionContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trigger_character_;
  int32_t trigger_kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class GetCompletionItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse) */ {
 public:
  inline GetCompletionItemsResponse() : GetCompletionItemsResponse(nullptr) {}
  ~GetCompletionItemsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetCompletionItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCompletionItemsResponse(const GetCompletionItemsResponse& from);
  GetCompletionItemsResponse(GetCompletionItemsResponse&& from) noexcept
    : GetCompletionItemsResponse() {
    *this = ::std::move(from);
  }

  inline GetCompletionItemsResponse& operator=(const GetCompletionItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCompletionItemsResponse& operator=(GetCompletionItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCompletionItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCompletionItemsResponse* internal_default_instance() {
    return reinterpret_cast<const GetCompletionItemsResponse*>(
               &_GetCompletionItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GetCompletionItemsResponse& a, GetCompletionItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCompletionItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCompletionItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCompletionItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCompletionItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCompletionItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCompletionItemsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCompletionItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse";
  }
  protected:
  explicit GetCompletionItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kSuccessFieldNumber = 3,
  };
  // repeated .io.deephaven.proto.backplane.script.grpc.CompletionItem items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::io::deephaven::proto::backplane::script::grpc::CompletionItem* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::CompletionItem >*
      mutable_items();
  private:
  const ::io::deephaven::proto::backplane::script::grpc::CompletionItem& _internal_items(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::CompletionItem* _internal_add_items();
  public:
  const ::io::deephaven::proto::backplane::script::grpc::CompletionItem& items(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::CompletionItem* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::CompletionItem >&
      items() const;

  // int32 request_id = 2;
  void clear_request_id();
  int32_t request_id() const;
  void set_request_id(int32_t value);
  private:
  int32_t _internal_request_id() const;
  void _internal_set_request_id(int32_t value);
  public:

  // bool success = 3;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::CompletionItem > items_;
  int32_t request_id_;
  bool success_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class CompletionItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.CompletionItem) */ {
 public:
  inline CompletionItem() : CompletionItem(nullptr) {}
  ~CompletionItem() override;
  explicit PROTOBUF_CONSTEXPR CompletionItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompletionItem(const CompletionItem& from);
  CompletionItem(CompletionItem&& from) noexcept
    : CompletionItem() {
    *this = ::std::move(from);
  }

  inline CompletionItem& operator=(const CompletionItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompletionItem& operator=(CompletionItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompletionItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompletionItem* internal_default_instance() {
    return reinterpret_cast<const CompletionItem*>(
               &_CompletionItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CompletionItem& a, CompletionItem& b) {
    a.Swap(&b);
  }
  inline void Swap(CompletionItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompletionItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompletionItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompletionItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompletionItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompletionItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompletionItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.CompletionItem";
  }
  protected:
  explicit CompletionItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAdditionalTextEditsFieldNumber = 13,
    kCommitCharactersFieldNumber = 14,
    kLabelFieldNumber = 3,
    kDetailFieldNumber = 5,
    kDocumentationFieldNumber = 6,
    kSortTextFieldNumber = 10,
    kFilterTextFieldNumber = 11,
    kTextEditFieldNumber = 9,
    kStartFieldNumber = 1,
    kLengthFieldNumber = 2,
    kKindFieldNumber = 4,
    kDeprecatedFieldNumber = 7,
    kPreselectFieldNumber = 8,
    kInsertTextFormatFieldNumber = 12,
  };
  // repeated .io.deephaven.proto.backplane.script.grpc.TextEdit additional_text_edits = 13;
  int additional_text_edits_size() const;
  private:
  int _internal_additional_text_edits_size() const;
  public:
  void clear_additional_text_edits();
  ::io::deephaven::proto::backplane::script::grpc::TextEdit* mutable_additional_text_edits(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::TextEdit >*
      mutable_additional_text_edits();
  private:
  const ::io::deephaven::proto::backplane::script::grpc::TextEdit& _internal_additional_text_edits(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::TextEdit* _internal_add_additional_text_edits();
  public:
  const ::io::deephaven::proto::backplane::script::grpc::TextEdit& additional_text_edits(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::TextEdit* add_additional_text_edits();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::TextEdit >&
      additional_text_edits() const;

  // repeated string commit_characters = 14;
  int commit_characters_size() const;
  private:
  int _internal_commit_characters_size() const;
  public:
  void clear_commit_characters();
  const std::string& commit_characters(int index) const;
  std::string* mutable_commit_characters(int index);
  void set_commit_characters(int index, const std::string& value);
  void set_commit_characters(int index, std::string&& value);
  void set_commit_characters(int index, const char* value);
  void set_commit_characters(int index, const char* value, size_t size);
  std::string* add_commit_characters();
  void add_commit_characters(const std::string& value);
  void add_commit_characters(std::string&& value);
  void add_commit_characters(const char* value);
  void add_commit_characters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& commit_characters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_commit_characters();
  private:
  const std::string& _internal_commit_characters(int index) const;
  std::string* _internal_add_commit_characters();
  public:

  // string label = 3;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // string detail = 5;
  void clear_detail();
  const std::string& detail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail();
  PROTOBUF_NODISCARD std::string* release_detail();
  void set_allocated_detail(std::string* detail);
  private:
  const std::string& _internal_detail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail(const std::string& value);
  std::string* _internal_mutable_detail();
  public:

  // string documentation = 6;
  void clear_documentation();
  const std::string& documentation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_documentation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_documentation();
  PROTOBUF_NODISCARD std::string* release_documentation();
  void set_allocated_documentation(std::string* documentation);
  private:
  const std::string& _internal_documentation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_documentation(const std::string& value);
  std::string* _internal_mutable_documentation();
  public:

  // string sort_text = 10;
  void clear_sort_text();
  const std::string& sort_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sort_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sort_text();
  PROTOBUF_NODISCARD std::string* release_sort_text();
  void set_allocated_sort_text(std::string* sort_text);
  private:
  const std::string& _internal_sort_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sort_text(const std::string& value);
  std::string* _internal_mutable_sort_text();
  public:

  // string filter_text = 11;
  void clear_filter_text();
  const std::string& filter_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter_text();
  PROTOBUF_NODISCARD std::string* release_filter_text();
  void set_allocated_filter_text(std::string* filter_text);
  private:
  const std::string& _internal_filter_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_text(const std::string& value);
  std::string* _internal_mutable_filter_text();
  public:

  // .io.deephaven.proto.backplane.script.grpc.TextEdit text_edit = 9;
  bool has_text_edit() const;
  private:
  bool _internal_has_text_edit() const;
  public:
  void clear_text_edit();
  const ::io::deephaven::proto::backplane::script::grpc::TextEdit& text_edit() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::TextEdit* release_text_edit();
  ::io::deephaven::proto::backplane::script::grpc::TextEdit* mutable_text_edit();
  void set_allocated_text_edit(::io::deephaven::proto::backplane::script::grpc::TextEdit* text_edit);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::TextEdit& _internal_text_edit() const;
  ::io::deephaven::proto::backplane::script::grpc::TextEdit* _internal_mutable_text_edit();
  public:
  void unsafe_arena_set_allocated_text_edit(
      ::io::deephaven::proto::backplane::script::grpc::TextEdit* text_edit);
  ::io::deephaven::proto::backplane::script::grpc::TextEdit* unsafe_arena_release_text_edit();

  // int32 start = 1;
  void clear_start();
  int32_t start() const;
  void set_start(int32_t value);
  private:
  int32_t _internal_start() const;
  void _internal_set_start(int32_t value);
  public:

  // int32 length = 2;
  void clear_length();
  int32_t length() const;
  void set_length(int32_t value);
  private:
  int32_t _internal_length() const;
  void _internal_set_length(int32_t value);
  public:

  // int32 kind = 4;
  void clear_kind();
  int32_t kind() const;
  void set_kind(int32_t value);
  private:
  int32_t _internal_kind() const;
  void _internal_set_kind(int32_t value);
  public:

  // bool deprecated = 7;
  void clear_deprecated();
  bool deprecated() const;
  void set_deprecated(bool value);
  private:
  bool _internal_deprecated() const;
  void _internal_set_deprecated(bool value);
  public:

  // bool preselect = 8;
  void clear_preselect();
  bool preselect() const;
  void set_preselect(bool value);
  private:
  bool _internal_preselect() const;
  void _internal_set_preselect(bool value);
  public:

  // int32 insert_text_format = 12;
  void clear_insert_text_format();
  int32_t insert_text_format() const;
  void set_insert_text_format(int32_t value);
  private:
  int32_t _internal_insert_text_format() const;
  void _internal_set_insert_text_format(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.CompletionItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::TextEdit > additional_text_edits_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> commit_characters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr documentation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sort_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_text_;
  ::io::deephaven::proto::backplane::script::grpc::TextEdit* text_edit_;
  int32_t start_;
  int32_t length_;
  int32_t kind_;
  bool deprecated_;
  bool preselect_;
  int32_t insert_text_format_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class TextEdit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.TextEdit) */ {
 public:
  inline TextEdit() : TextEdit(nullptr) {}
  ~TextEdit() override;
  explicit PROTOBUF_CONSTEXPR TextEdit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TextEdit(const TextEdit& from);
  TextEdit(TextEdit&& from) noexcept
    : TextEdit() {
    *this = ::std::move(from);
  }

  inline TextEdit& operator=(const TextEdit& from) {
    CopyFrom(from);
    return *this;
  }
  inline TextEdit& operator=(TextEdit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TextEdit& default_instance() {
    return *internal_default_instance();
  }
  static inline const TextEdit* internal_default_instance() {
    return reinterpret_cast<const TextEdit*>(
               &_TextEdit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(TextEdit& a, TextEdit& b) {
    a.Swap(&b);
  }
  inline void Swap(TextEdit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TextEdit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TextEdit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TextEdit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TextEdit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TextEdit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TextEdit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.TextEdit";
  }
  protected:
  explicit TextEdit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 2,
    kRangeFieldNumber = 1,
  };
  // string text = 2;
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // .io.deephaven.proto.backplane.script.grpc.DocumentRange range = 1;
  bool has_range() const;
  private:
  bool _internal_has_range() const;
  public:
  void clear_range();
  const ::io::deephaven::proto::backplane::script::grpc::DocumentRange& range() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::DocumentRange* release_range();
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* mutable_range();
  void set_allocated_range(::io::deephaven::proto::backplane::script::grpc::DocumentRange* range);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::DocumentRange& _internal_range() const;
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* _internal_mutable_range();
  public:
  void unsafe_arena_set_allocated_range(
      ::io::deephaven::proto::backplane::script::grpc::DocumentRange* range);
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* unsafe_arena_release_range();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.TextEdit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* range_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_ChartDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor) */ {
 public:
  inline FigureDescriptor_ChartDescriptor() : FigureDescriptor_ChartDescriptor(nullptr) {}
  ~FigureDescriptor_ChartDescriptor() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_ChartDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_ChartDescriptor(const FigureDescriptor_ChartDescriptor& from);
  FigureDescriptor_ChartDescriptor(FigureDescriptor_ChartDescriptor&& from) noexcept
    : FigureDescriptor_ChartDescriptor() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_ChartDescriptor& operator=(const FigureDescriptor_ChartDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_ChartDescriptor& operator=(FigureDescriptor_ChartDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_ChartDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_ChartDescriptor* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_ChartDescriptor*>(
               &_FigureDescriptor_ChartDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(FigureDescriptor_ChartDescriptor& a, FigureDescriptor_ChartDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_ChartDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_ChartDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_ChartDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_ChartDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_ChartDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_ChartDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_ChartDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor";
  }
  protected:
  explicit FigureDescriptor_ChartDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FigureDescriptor_ChartDescriptor_ChartType ChartType;
  static constexpr ChartType XY =
    FigureDescriptor_ChartDescriptor_ChartType_XY;
  static constexpr ChartType PIE =
    FigureDescriptor_ChartDescriptor_ChartType_PIE;
  static constexpr ChartType OHLC =
    FigureDescriptor_ChartDescriptor_ChartType_OHLC;
  static constexpr ChartType CATEGORY =
    FigureDescriptor_ChartDescriptor_ChartType_CATEGORY;
  static constexpr ChartType XYZ =
    FigureDescriptor_ChartDescriptor_ChartType_XYZ;
  static constexpr ChartType CATEGORY_3D =
    FigureDescriptor_ChartDescriptor_ChartType_CATEGORY_3D;
  static constexpr ChartType TREEMAP =
    FigureDescriptor_ChartDescriptor_ChartType_TREEMAP;
  static inline bool ChartType_IsValid(int value) {
    return FigureDescriptor_ChartDescriptor_ChartType_IsValid(value);
  }
  static constexpr ChartType ChartType_MIN =
    FigureDescriptor_ChartDescriptor_ChartType_ChartType_MIN;
  static constexpr ChartType ChartType_MAX =
    FigureDescriptor_ChartDescriptor_ChartType_ChartType_MAX;
  static constexpr int ChartType_ARRAYSIZE =
    FigureDescriptor_ChartDescriptor_ChartType_ChartType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ChartType_descriptor() {
    return FigureDescriptor_ChartDescriptor_ChartType_descriptor();
  }
  template<typename T>
  static inline const std::string& ChartType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChartType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChartType_Name.");
    return FigureDescriptor_ChartDescriptor_ChartType_Name(enum_t_value);
  }
  static inline bool ChartType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ChartType* value) {
    return FigureDescriptor_ChartDescriptor_ChartType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSeriesFieldNumber = 3,
    kMultiSeriesFieldNumber = 4,
    kAxesFieldNumber = 5,
    kTitleFieldNumber = 7,
    kTitleFontFieldNumber = 8,
    kTitleColorFieldNumber = 9,
    kLegendFontFieldNumber = 11,
    kLegendColorFieldNumber = 12,
    kColspanFieldNumber = 1,
    kRowspanFieldNumber = 2,
    kChartTypeFieldNumber = 6,
    kShowLegendFieldNumber = 10,
    kIs3DFieldNumber = 13,
  };
  // repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor series = 3;
  int series_size() const;
  private:
  int _internal_series_size() const;
  public:
  void clear_series();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor* mutable_series(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor >*
      mutable_series();
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor& _internal_series(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor* _internal_add_series();
  public:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor& series(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor* add_series();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor >&
      series() const;

  // repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor multi_series = 4;
  int multi_series_size() const;
  private:
  int _internal_multi_series_size() const;
  public:
  void clear_multi_series();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor* mutable_multi_series(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor >*
      mutable_multi_series();
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor& _internal_multi_series(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor* _internal_add_multi_series();
  public:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor& multi_series(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor* add_multi_series();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor >&
      multi_series() const;

  // repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor axes = 5;
  int axes_size() const;
  private:
  int _internal_axes_size() const;
  public:
  void clear_axes();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor* mutable_axes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor >*
      mutable_axes();
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor& _internal_axes(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor* _internal_add_axes();
  public:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor& axes(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor* add_axes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor >&
      axes() const;

  // optional string title = 7;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string title_font = 8;
  void clear_title_font();
  const std::string& title_font() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title_font(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title_font();
  PROTOBUF_NODISCARD std::string* release_title_font();
  void set_allocated_title_font(std::string* title_font);
  private:
  const std::string& _internal_title_font() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title_font(const std::string& value);
  std::string* _internal_mutable_title_font();
  public:

  // string title_color = 9;
  void clear_title_color();
  const std::string& title_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title_color();
  PROTOBUF_NODISCARD std::string* release_title_color();
  void set_allocated_title_color(std::string* title_color);
  private:
  const std::string& _internal_title_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title_color(const std::string& value);
  std::string* _internal_mutable_title_color();
  public:

  // string legend_font = 11;
  void clear_legend_font();
  const std::string& legend_font() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_legend_font(ArgT0&& arg0, ArgT... args);
  std::string* mutable_legend_font();
  PROTOBUF_NODISCARD std::string* release_legend_font();
  void set_allocated_legend_font(std::string* legend_font);
  private:
  const std::string& _internal_legend_font() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_legend_font(const std::string& value);
  std::string* _internal_mutable_legend_font();
  public:

  // string legend_color = 12;
  void clear_legend_color();
  const std::string& legend_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_legend_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_legend_color();
  PROTOBUF_NODISCARD std::string* release_legend_color();
  void set_allocated_legend_color(std::string* legend_color);
  private:
  const std::string& _internal_legend_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_legend_color(const std::string& value);
  std::string* _internal_mutable_legend_color();
  public:

  // int32 colspan = 1;
  void clear_colspan();
  int32_t colspan() const;
  void set_colspan(int32_t value);
  private:
  int32_t _internal_colspan() const;
  void _internal_set_colspan(int32_t value);
  public:

  // int32 rowspan = 2;
  void clear_rowspan();
  int32_t rowspan() const;
  void set_rowspan(int32_t value);
  private:
  int32_t _internal_rowspan() const;
  void _internal_set_rowspan(int32_t value);
  public:

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.ChartType chart_type = 6;
  void clear_chart_type();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor_ChartType chart_type() const;
  void set_chart_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor_ChartType value);
  private:
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor_ChartType _internal_chart_type() const;
  void _internal_set_chart_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor_ChartType value);
  public:

  // bool show_legend = 10;
  void clear_show_legend();
  bool show_legend() const;
  void set_show_legend(bool value);
  private:
  bool _internal_show_legend() const;
  void _internal_set_show_legend(bool value);
  public:

  // bool is3d = 13;
  void clear_is3d();
  bool is3d() const;
  void set_is3d(bool value);
  private:
  bool _internal_is3d() const;
  void _internal_set_is3d(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor > series_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor > multi_series_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor > axes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_font_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr legend_font_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr legend_color_;
  int32_t colspan_;
  int32_t rowspan_;
  int chart_type_;
  bool show_legend_;
  bool is3d_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_SeriesDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor) */ {
 public:
  inline FigureDescriptor_SeriesDescriptor() : FigureDescriptor_SeriesDescriptor(nullptr) {}
  ~FigureDescriptor_SeriesDescriptor() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_SeriesDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_SeriesDescriptor(const FigureDescriptor_SeriesDescriptor& from);
  FigureDescriptor_SeriesDescriptor(FigureDescriptor_SeriesDescriptor&& from) noexcept
    : FigureDescriptor_SeriesDescriptor() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_SeriesDescriptor& operator=(const FigureDescriptor_SeriesDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_SeriesDescriptor& operator=(FigureDescriptor_SeriesDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_SeriesDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_SeriesDescriptor* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_SeriesDescriptor*>(
               &_FigureDescriptor_SeriesDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(FigureDescriptor_SeriesDescriptor& a, FigureDescriptor_SeriesDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_SeriesDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_SeriesDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_SeriesDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_SeriesDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_SeriesDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_SeriesDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_SeriesDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor";
  }
  protected:
  explicit FigureDescriptor_SeriesDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataSourcesFieldNumber = 15,
    kNameFieldNumber = 2,
    kLineColorFieldNumber = 6,
    kPointLabelFormatFieldNumber = 8,
    kXToolTipPatternFieldNumber = 9,
    kYToolTipPatternFieldNumber = 10,
    kShapeLabelFieldNumber = 11,
    kShapeColorFieldNumber = 13,
    kShapeFieldNumber = 14,
    kPlotStyleFieldNumber = 1,
    kLinesVisibleFieldNumber = 3,
    kShapesVisibleFieldNumber = 4,
    kGradientVisibleFieldNumber = 5,
    kShapeSizeFieldNumber = 12,
  };
  // repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor data_sources = 15;
  int data_sources_size() const;
  private:
  int _internal_data_sources_size() const;
  public:
  void clear_data_sources();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor* mutable_data_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor >*
      mutable_data_sources();
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor& _internal_data_sources(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor* _internal_add_data_sources();
  public:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor& data_sources(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor* add_data_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor >&
      data_sources() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string line_color = 6;
  void clear_line_color();
  const std::string& line_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_line_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_line_color();
  PROTOBUF_NODISCARD std::string* release_line_color();
  void set_allocated_line_color(std::string* line_color);
  private:
  const std::string& _internal_line_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_line_color(const std::string& value);
  std::string* _internal_mutable_line_color();
  public:

  // optional string point_label_format = 8;
  bool has_point_label_format() const;
  private:
  bool _internal_has_point_label_format() const;
  public:
  void clear_point_label_format();
  const std::string& point_label_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_point_label_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_point_label_format();
  PROTOBUF_NODISCARD std::string* release_point_label_format();
  void set_allocated_point_label_format(std::string* point_label_format);
  private:
  const std::string& _internal_point_label_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_point_label_format(const std::string& value);
  std::string* _internal_mutable_point_label_format();
  public:

  // optional string x_tool_tip_pattern = 9;
  bool has_x_tool_tip_pattern() const;
  private:
  bool _internal_has_x_tool_tip_pattern() const;
  public:
  void clear_x_tool_tip_pattern();
  const std::string& x_tool_tip_pattern() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_x_tool_tip_pattern(ArgT0&& arg0, ArgT... args);
  std::string* mutable_x_tool_tip_pattern();
  PROTOBUF_NODISCARD std::string* release_x_tool_tip_pattern();
  void set_allocated_x_tool_tip_pattern(std::string* x_tool_tip_pattern);
  private:
  const std::string& _internal_x_tool_tip_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_x_tool_tip_pattern(const std::string& value);
  std::string* _internal_mutable_x_tool_tip_pattern();
  public:

  // optional string y_tool_tip_pattern = 10;
  bool has_y_tool_tip_pattern() const;
  private:
  bool _internal_has_y_tool_tip_pattern() const;
  public:
  void clear_y_tool_tip_pattern();
  const std::string& y_tool_tip_pattern() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_y_tool_tip_pattern(ArgT0&& arg0, ArgT... args);
  std::string* mutable_y_tool_tip_pattern();
  PROTOBUF_NODISCARD std::string* release_y_tool_tip_pattern();
  void set_allocated_y_tool_tip_pattern(std::string* y_tool_tip_pattern);
  private:
  const std::string& _internal_y_tool_tip_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_y_tool_tip_pattern(const std::string& value);
  std::string* _internal_mutable_y_tool_tip_pattern();
  public:

  // string shape_label = 11;
  void clear_shape_label();
  const std::string& shape_label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shape_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shape_label();
  PROTOBUF_NODISCARD std::string* release_shape_label();
  void set_allocated_shape_label(std::string* shape_label);
  private:
  const std::string& _internal_shape_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape_label(const std::string& value);
  std::string* _internal_mutable_shape_label();
  public:

  // string shape_color = 13;
  void clear_shape_color();
  const std::string& shape_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shape_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shape_color();
  PROTOBUF_NODISCARD std::string* release_shape_color();
  void set_allocated_shape_color(std::string* shape_color);
  private:
  const std::string& _internal_shape_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape_color(const std::string& value);
  std::string* _internal_mutable_shape_color();
  public:

  // string shape = 14;
  void clear_shape();
  const std::string& shape() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shape(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shape();
  PROTOBUF_NODISCARD std::string* release_shape();
  void set_allocated_shape(std::string* shape);
  private:
  const std::string& _internal_shape() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shape(const std::string& value);
  std::string* _internal_mutable_shape();
  public:

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesPlotStyle plot_style = 1;
  void clear_plot_style();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle plot_style() const;
  void set_plot_style(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle value);
  private:
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle _internal_plot_style() const;
  void _internal_set_plot_style(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle value);
  public:

  // optional bool lines_visible = 3;
  bool has_lines_visible() const;
  private:
  bool _internal_has_lines_visible() const;
  public:
  void clear_lines_visible();
  bool lines_visible() const;
  void set_lines_visible(bool value);
  private:
  bool _internal_lines_visible() const;
  void _internal_set_lines_visible(bool value);
  public:

  // optional bool shapes_visible = 4;
  bool has_shapes_visible() const;
  private:
  bool _internal_has_shapes_visible() const;
  public:
  void clear_shapes_visible();
  bool shapes_visible() const;
  void set_shapes_visible(bool value);
  private:
  bool _internal_shapes_visible() const;
  void _internal_set_shapes_visible(bool value);
  public:

  // bool gradient_visible = 5;
  void clear_gradient_visible();
  bool gradient_visible() const;
  void set_gradient_visible(bool value);
  private:
  bool _internal_gradient_visible() const;
  void _internal_set_gradient_visible(bool value);
  public:

  // optional double shape_size = 12;
  bool has_shape_size() const;
  private:
  bool _internal_has_shape_size() const;
  public:
  void clear_shape_size();
  double shape_size() const;
  void set_shape_size(double value);
  private:
  double _internal_shape_size() const;
  void _internal_set_shape_size(double value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor > data_sources_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr line_color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr point_label_format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x_tool_tip_pattern_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr y_tool_tip_pattern_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shape_label_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shape_color_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shape_;
  int plot_style_;
  bool lines_visible_;
  bool shapes_visible_;
  bool gradient_visible_;
  double shape_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_MultiSeriesDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor) */ {
 public:
  inline FigureDescriptor_MultiSeriesDescriptor() : FigureDescriptor_MultiSeriesDescriptor(nullptr) {}
  ~FigureDescriptor_MultiSeriesDescriptor() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_MultiSeriesDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_MultiSeriesDescriptor(const FigureDescriptor_MultiSeriesDescriptor& from);
  FigureDescriptor_MultiSeriesDescriptor(FigureDescriptor_MultiSeriesDescriptor&& from) noexcept
    : FigureDescriptor_MultiSeriesDescriptor() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_MultiSeriesDescriptor& operator=(const FigureDescriptor_MultiSeriesDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_MultiSeriesDescriptor& operator=(FigureDescriptor_MultiSeriesDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_MultiSeriesDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_MultiSeriesDescriptor* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_MultiSeriesDescriptor*>(
               &_FigureDescriptor_MultiSeriesDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(FigureDescriptor_MultiSeriesDescriptor& a, FigureDescriptor_MultiSeriesDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_MultiSeriesDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_MultiSeriesDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_MultiSeriesDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_MultiSeriesDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_MultiSeriesDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_MultiSeriesDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_MultiSeriesDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor";
  }
  protected:
  explicit FigureDescriptor_MultiSeriesDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataSourcesFieldNumber = 14,
    kNameFieldNumber = 2,
    kLineColorFieldNumber = 3,
    kPointColorFieldNumber = 4,
    kLinesVisibleFieldNumber = 5,
    kPointsVisibleFieldNumber = 6,
    kGradientVisibleFieldNumber = 7,
    kPointLabelFormatFieldNumber = 8,
    kXToolTipPatternFieldNumber = 9,
    kYToolTipPatternFieldNumber = 10,
    kPointLabelFieldNumber = 11,
    kPointSizeFieldNumber = 12,
    kPointShapeFieldNumber = 13,
    kPlotStyleFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor data_sources = 14;
  int data_sources_size() const;
  private:
  int _internal_data_sources_size() const;
  public:
  void clear_data_sources();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor* mutable_data_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor >*
      mutable_data_sources();
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor& _internal_data_sources(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor* _internal_add_data_sources();
  public:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor& data_sources(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor* add_data_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor >&
      data_sources() const;

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault line_color = 3;
  bool has_line_color() const;
  private:
  bool _internal_has_line_color() const;
  public:
  void clear_line_color();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& line_color() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* release_line_color();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* mutable_line_color();
  void set_allocated_line_color(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* line_color);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& _internal_line_color() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _internal_mutable_line_color();
  public:
  void unsafe_arena_set_allocated_line_color(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* line_color);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* unsafe_arena_release_line_color();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault point_color = 4;
  bool has_point_color() const;
  private:
  bool _internal_has_point_color() const;
  public:
  void clear_point_color();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& point_color() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* release_point_color();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* mutable_point_color();
  void set_allocated_point_color(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_color);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& _internal_point_color() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _internal_mutable_point_color();
  public:
  void unsafe_arena_set_allocated_point_color(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_color);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* unsafe_arena_release_point_color();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault lines_visible = 5;
  bool has_lines_visible() const;
  private:
  bool _internal_has_lines_visible() const;
  public:
  void clear_lines_visible();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault& lines_visible() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* release_lines_visible();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* mutable_lines_visible();
  void set_allocated_lines_visible(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* lines_visible);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault& _internal_lines_visible() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* _internal_mutable_lines_visible();
  public:
  void unsafe_arena_set_allocated_lines_visible(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* lines_visible);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* unsafe_arena_release_lines_visible();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault points_visible = 6;
  bool has_points_visible() const;
  private:
  bool _internal_has_points_visible() const;
  public:
  void clear_points_visible();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault& points_visible() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* release_points_visible();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* mutable_points_visible();
  void set_allocated_points_visible(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* points_visible);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault& _internal_points_visible() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* _internal_mutable_points_visible();
  public:
  void unsafe_arena_set_allocated_points_visible(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* points_visible);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* unsafe_arena_release_points_visible();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault gradient_visible = 7;
  bool has_gradient_visible() const;
  private:
  bool _internal_has_gradient_visible() const;
  public:
  void clear_gradient_visible();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault& gradient_visible() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* release_gradient_visible();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* mutable_gradient_visible();
  void set_allocated_gradient_visible(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* gradient_visible);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault& _internal_gradient_visible() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* _internal_mutable_gradient_visible();
  public:
  void unsafe_arena_set_allocated_gradient_visible(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* gradient_visible);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* unsafe_arena_release_gradient_visible();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault point_label_format = 8;
  bool has_point_label_format() const;
  private:
  bool _internal_has_point_label_format() const;
  public:
  void clear_point_label_format();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& point_label_format() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* release_point_label_format();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* mutable_point_label_format();
  void set_allocated_point_label_format(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_label_format);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& _internal_point_label_format() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _internal_mutable_point_label_format();
  public:
  void unsafe_arena_set_allocated_point_label_format(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_label_format);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* unsafe_arena_release_point_label_format();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault x_tool_tip_pattern = 9;
  bool has_x_tool_tip_pattern() const;
  private:
  bool _internal_has_x_tool_tip_pattern() const;
  public:
  void clear_x_tool_tip_pattern();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& x_tool_tip_pattern() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* release_x_tool_tip_pattern();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* mutable_x_tool_tip_pattern();
  void set_allocated_x_tool_tip_pattern(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* x_tool_tip_pattern);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& _internal_x_tool_tip_pattern() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _internal_mutable_x_tool_tip_pattern();
  public:
  void unsafe_arena_set_allocated_x_tool_tip_pattern(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* x_tool_tip_pattern);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* unsafe_arena_release_x_tool_tip_pattern();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault y_tool_tip_pattern = 10;
  bool has_y_tool_tip_pattern() const;
  private:
  bool _internal_has_y_tool_tip_pattern() const;
  public:
  void clear_y_tool_tip_pattern();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& y_tool_tip_pattern() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* release_y_tool_tip_pattern();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* mutable_y_tool_tip_pattern();
  void set_allocated_y_tool_tip_pattern(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* y_tool_tip_pattern);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& _internal_y_tool_tip_pattern() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _internal_mutable_y_tool_tip_pattern();
  public:
  void unsafe_arena_set_allocated_y_tool_tip_pattern(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* y_tool_tip_pattern);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* unsafe_arena_release_y_tool_tip_pattern();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault point_label = 11;
  bool has_point_label() const;
  private:
  bool _internal_has_point_label() const;
  public:
  void clear_point_label();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& point_label() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* release_point_label();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* mutable_point_label();
  void set_allocated_point_label(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_label);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& _internal_point_label() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _internal_mutable_point_label();
  public:
  void unsafe_arena_set_allocated_point_label(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_label);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* unsafe_arena_release_point_label();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault point_size = 12;
  bool has_point_size() const;
  private:
  bool _internal_has_point_size() const;
  public:
  void clear_point_size();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault& point_size() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* release_point_size();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* mutable_point_size();
  void set_allocated_point_size(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* point_size);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault& _internal_point_size() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* _internal_mutable_point_size();
  public:
  void unsafe_arena_set_allocated_point_size(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* point_size);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* unsafe_arena_release_point_size();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault point_shape = 13;
  bool has_point_shape() const;
  private:
  bool _internal_has_point_shape() const;
  public:
  void clear_point_shape();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& point_shape() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* release_point_shape();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* mutable_point_shape();
  void set_allocated_point_shape(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_shape);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& _internal_point_shape() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _internal_mutable_point_shape();
  public:
  void unsafe_arena_set_allocated_point_shape(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_shape);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* unsafe_arena_release_point_shape();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesPlotStyle plot_style = 1;
  void clear_plot_style();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle plot_style() const;
  void set_plot_style(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle value);
  private:
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle _internal_plot_style() const;
  void _internal_set_plot_style(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor > data_sources_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* line_color_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_color_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* lines_visible_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* points_visible_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* gradient_visible_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_label_format_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* x_tool_tip_pattern_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* y_tool_tip_pattern_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_label_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* point_size_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_shape_;
  int plot_style_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_StringMapWithDefault final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault) */ {
 public:
  inline FigureDescriptor_StringMapWithDefault() : FigureDescriptor_StringMapWithDefault(nullptr) {}
  ~FigureDescriptor_StringMapWithDefault() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_StringMapWithDefault(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_StringMapWithDefault(const FigureDescriptor_StringMapWithDefault& from);
  FigureDescriptor_StringMapWithDefault(FigureDescriptor_StringMapWithDefault&& from) noexcept
    : FigureDescriptor_StringMapWithDefault() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_StringMapWithDefault& operator=(const FigureDescriptor_StringMapWithDefault& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_StringMapWithDefault& operator=(FigureDescriptor_StringMapWithDefault&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_StringMapWithDefault& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_StringMapWithDefault* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_StringMapWithDefault*>(
               &_FigureDescriptor_StringMapWithDefault_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(FigureDescriptor_StringMapWithDefault& a, FigureDescriptor_StringMapWithDefault& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_StringMapWithDefault* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_StringMapWithDefault* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_StringMapWithDefault* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_StringMapWithDefault>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_StringMapWithDefault& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_StringMapWithDefault& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_StringMapWithDefault* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault";
  }
  protected:
  explicit FigureDescriptor_StringMapWithDefault(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kValuesFieldNumber = 3,
    kDefaultStringFieldNumber = 1,
  };
  // repeated string keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // repeated string values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  const std::string& values(int index) const;
  std::string* mutable_values(int index);
  void set_values(int index, const std::string& value);
  void set_values(int index, std::string&& value);
  void set_values(int index, const char* value);
  void set_values(int index, const char* value, size_t size);
  std::string* add_values();
  void add_values(const std::string& value);
  void add_values(std::string&& value);
  void add_values(const char* value);
  void add_values(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_values();
  private:
  const std::string& _internal_values(int index) const;
  std::string* _internal_add_values();
  public:

  // optional string default_string = 1;
  bool has_default_string() const;
  private:
  bool _internal_has_default_string() const;
  public:
  void clear_default_string();
  const std::string& default_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_string();
  PROTOBUF_NODISCARD std::string* release_default_string();
  void set_allocated_default_string(std::string* default_string);
  private:
  const std::string& _internal_default_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_string(const std::string& value);
  std::string* _internal_mutable_default_string();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_string_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_DoubleMapWithDefault final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault) */ {
 public:
  inline FigureDescriptor_DoubleMapWithDefault() : FigureDescriptor_DoubleMapWithDefault(nullptr) {}
  ~FigureDescriptor_DoubleMapWithDefault() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_DoubleMapWithDefault(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_DoubleMapWithDefault(const FigureDescriptor_DoubleMapWithDefault& from);
  FigureDescriptor_DoubleMapWithDefault(FigureDescriptor_DoubleMapWithDefault&& from) noexcept
    : FigureDescriptor_DoubleMapWithDefault() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_DoubleMapWithDefault& operator=(const FigureDescriptor_DoubleMapWithDefault& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_DoubleMapWithDefault& operator=(FigureDescriptor_DoubleMapWithDefault&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_DoubleMapWithDefault& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_DoubleMapWithDefault* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_DoubleMapWithDefault*>(
               &_FigureDescriptor_DoubleMapWithDefault_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(FigureDescriptor_DoubleMapWithDefault& a, FigureDescriptor_DoubleMapWithDefault& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_DoubleMapWithDefault* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_DoubleMapWithDefault* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_DoubleMapWithDefault* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_DoubleMapWithDefault>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_DoubleMapWithDefault& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_DoubleMapWithDefault& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_DoubleMapWithDefault* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault";
  }
  protected:
  explicit FigureDescriptor_DoubleMapWithDefault(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kValuesFieldNumber = 3,
    kDefaultDoubleFieldNumber = 1,
  };
  // repeated string keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // repeated double values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  double _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_values() const;
  void _internal_add_values(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_values();
  public:
  double values(int index) const;
  void set_values(int index, double value);
  void add_values(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_values();

  // optional double default_double = 1;
  bool has_default_double() const;
  private:
  bool _internal_has_default_double() const;
  public:
  void clear_default_double();
  double default_double() const;
  void set_default_double(double value);
  private:
  double _internal_default_double() const;
  void _internal_set_default_double(double value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > values_;
  double default_double_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_BoolMapWithDefault final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault) */ {
 public:
  inline FigureDescriptor_BoolMapWithDefault() : FigureDescriptor_BoolMapWithDefault(nullptr) {}
  ~FigureDescriptor_BoolMapWithDefault() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_BoolMapWithDefault(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_BoolMapWithDefault(const FigureDescriptor_BoolMapWithDefault& from);
  FigureDescriptor_BoolMapWithDefault(FigureDescriptor_BoolMapWithDefault&& from) noexcept
    : FigureDescriptor_BoolMapWithDefault() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_BoolMapWithDefault& operator=(const FigureDescriptor_BoolMapWithDefault& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_BoolMapWithDefault& operator=(FigureDescriptor_BoolMapWithDefault&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_BoolMapWithDefault& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_BoolMapWithDefault* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_BoolMapWithDefault*>(
               &_FigureDescriptor_BoolMapWithDefault_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(FigureDescriptor_BoolMapWithDefault& a, FigureDescriptor_BoolMapWithDefault& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_BoolMapWithDefault* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_BoolMapWithDefault* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_BoolMapWithDefault* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_BoolMapWithDefault>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_BoolMapWithDefault& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_BoolMapWithDefault& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_BoolMapWithDefault* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault";
  }
  protected:
  explicit FigureDescriptor_BoolMapWithDefault(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 2,
    kValuesFieldNumber = 3,
    kDefaultBoolFieldNumber = 1,
  };
  // repeated string keys = 2;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  const std::string& keys(int index) const;
  std::string* mutable_keys(int index);
  void set_keys(int index, const std::string& value);
  void set_keys(int index, std::string&& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  std::string* add_keys();
  void add_keys(const std::string& value);
  void add_keys(std::string&& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_keys();
  private:
  const std::string& _internal_keys(int index) const;
  std::string* _internal_add_keys();
  public:

  // repeated bool values = 3;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  bool _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_values() const;
  void _internal_add_values(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_values();
  public:
  bool values(int index) const;
  void set_values(int index, bool value);
  void add_values(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_values();

  // optional bool default_bool = 1;
  bool has_default_bool() const;
  private:
  bool _internal_has_default_bool() const;
  public:
  void clear_default_bool();
  bool default_bool() const;
  void set_default_bool(bool value);
  private:
  bool _internal_default_bool() const;
  void _internal_set_default_bool(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > values_;
  bool default_bool_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_AxisDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor) */ {
 public:
  inline FigureDescriptor_AxisDescriptor() : FigureDescriptor_AxisDescriptor(nullptr) {}
  ~FigureDescriptor_AxisDescriptor() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_AxisDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_AxisDescriptor(const FigureDescriptor_AxisDescriptor& from);
  FigureDescriptor_AxisDescriptor(FigureDescriptor_AxisDescriptor&& from) noexcept
    : FigureDescriptor_AxisDescriptor() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_AxisDescriptor& operator=(const FigureDescriptor_AxisDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_AxisDescriptor& operator=(FigureDescriptor_AxisDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_AxisDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_AxisDescriptor* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_AxisDescriptor*>(
               &_FigureDescriptor_AxisDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(FigureDescriptor_AxisDescriptor& a, FigureDescriptor_AxisDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_AxisDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_AxisDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_AxisDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_AxisDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_AxisDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_AxisDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_AxisDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor";
  }
  protected:
  explicit FigureDescriptor_AxisDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FigureDescriptor_AxisDescriptor_AxisFormatType AxisFormatType;
  static constexpr AxisFormatType CATEGORY =
    FigureDescriptor_AxisDescriptor_AxisFormatType_CATEGORY;
  static constexpr AxisFormatType NUMBER =
    FigureDescriptor_AxisDescriptor_AxisFormatType_NUMBER;
  static inline bool AxisFormatType_IsValid(int value) {
    return FigureDescriptor_AxisDescriptor_AxisFormatType_IsValid(value);
  }
  static constexpr AxisFormatType AxisFormatType_MIN =
    FigureDescriptor_AxisDescriptor_AxisFormatType_AxisFormatType_MIN;
  static constexpr AxisFormatType AxisFormatType_MAX =
    FigureDescriptor_AxisDescriptor_AxisFormatType_AxisFormatType_MAX;
  static constexpr int AxisFormatType_ARRAYSIZE =
    FigureDescriptor_AxisDescriptor_AxisFormatType_AxisFormatType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AxisFormatType_descriptor() {
    return FigureDescriptor_AxisDescriptor_AxisFormatType_descriptor();
  }
  template<typename T>
  static inline const std::string& AxisFormatType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AxisFormatType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AxisFormatType_Name.");
    return FigureDescriptor_AxisDescriptor_AxisFormatType_Name(enum_t_value);
  }
  static inline bool AxisFormatType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AxisFormatType* value) {
    return FigureDescriptor_AxisDescriptor_AxisFormatType_Parse(name, value);
  }

  typedef FigureDescriptor_AxisDescriptor_AxisType AxisType;
  static constexpr AxisType X =
    FigureDescriptor_AxisDescriptor_AxisType_X;
  static constexpr AxisType Y =
    FigureDescriptor_AxisDescriptor_AxisType_Y;
  static constexpr AxisType SHAPE =
    FigureDescriptor_AxisDescriptor_AxisType_SHAPE;
  static constexpr AxisType SIZE =
    FigureDescriptor_AxisDescriptor_AxisType_SIZE;
  static constexpr AxisType LABEL =
    FigureDescriptor_AxisDescriptor_AxisType_LABEL;
  static constexpr AxisType COLOR =
    FigureDescriptor_AxisDescriptor_AxisType_COLOR;
  static inline bool AxisType_IsValid(int value) {
    return FigureDescriptor_AxisDescriptor_AxisType_IsValid(value);
  }
  static constexpr AxisType AxisType_MIN =
    FigureDescriptor_AxisDescriptor_AxisType_AxisType_MIN;
  static constexpr AxisType AxisType_MAX =
    FigureDescriptor_AxisDescriptor_AxisType_AxisType_MAX;
  static constexpr int AxisType_ARRAYSIZE =
    FigureDescriptor_AxisDescriptor_AxisType_AxisType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AxisType_descriptor() {
    return FigureDescriptor_AxisDescriptor_AxisType_descriptor();
  }
  template<typename T>
  static inline const std::string& AxisType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AxisType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AxisType_Name.");
    return FigureDescriptor_AxisDescriptor_AxisType_Name(enum_t_value);
  }
  static inline bool AxisType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AxisType* value) {
    return FigureDescriptor_AxisDescriptor_AxisType_Parse(name, value);
  }

  typedef FigureDescriptor_AxisDescriptor_AxisPosition AxisPosition;
  static constexpr AxisPosition TOP =
    FigureDescriptor_AxisDescriptor_AxisPosition_TOP;
  static constexpr AxisPosition BOTTOM =
    FigureDescriptor_AxisDescriptor_AxisPosition_BOTTOM;
  static constexpr AxisPosition LEFT =
    FigureDescriptor_AxisDescriptor_AxisPosition_LEFT;
  static constexpr AxisPosition RIGHT =
    FigureDescriptor_AxisDescriptor_AxisPosition_RIGHT;
  static constexpr AxisPosition NONE =
    FigureDescriptor_AxisDescriptor_AxisPosition_NONE;
  static inline bool AxisPosition_IsValid(int value) {
    return FigureDescriptor_AxisDescriptor_AxisPosition_IsValid(value);
  }
  static constexpr AxisPosition AxisPosition_MIN =
    FigureDescriptor_AxisDescriptor_AxisPosition_AxisPosition_MIN;
  static constexpr AxisPosition AxisPosition_MAX =
    FigureDescriptor_AxisDescriptor_AxisPosition_AxisPosition_MAX;
  static constexpr int AxisPosition_ARRAYSIZE =
    FigureDescriptor_AxisDescriptor_AxisPosition_AxisPosition_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AxisPosition_descriptor() {
    return FigureDescriptor_AxisDescriptor_AxisPosition_descriptor();
  }
  template<typename T>
  static inline const std::string& AxisPosition_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AxisPosition>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AxisPosition_Name.");
    return FigureDescriptor_AxisDescriptor_AxisPosition_Name(enum_t_value);
  }
  static inline bool AxisPosition_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AxisPosition* value) {
    return FigureDescriptor_AxisDescriptor_AxisPosition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMajorTickLocationsFieldNumber = 17,
    kIdFieldNumber = 1,
    kLabelFieldNumber = 6,
    kLabelFontFieldNumber = 7,
    kTicksFontFieldNumber = 8,
    kFormatPatternFieldNumber = 9,
    kColorFieldNumber = 10,
    kBusinessCalendarDescriptorFieldNumber = 21,
    kFormatTypeFieldNumber = 2,
    kTypeFieldNumber = 3,
    kMinRangeFieldNumber = 11,
    kPositionFieldNumber = 4,
    kLogFieldNumber = 5,
    kMinorTicksVisibleFieldNumber = 13,
    kMajorTicksVisibleFieldNumber = 14,
    kInvertFieldNumber = 19,
    kMaxRangeFieldNumber = 12,
    kGapBetweenMajorTicksFieldNumber = 16,
    kMinorTickCountFieldNumber = 15,
    kIsTimeAxisFieldNumber = 20,
    kTickLabelAngleFieldNumber = 18,
  };
  // repeated double major_tick_locations = 17;
  int major_tick_locations_size() const;
  private:
  int _internal_major_tick_locations_size() const;
  public:
  void clear_major_tick_locations();
  private:
  double _internal_major_tick_locations(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_major_tick_locations() const;
  void _internal_add_major_tick_locations(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_major_tick_locations();
  public:
  double major_tick_locations(int index) const;
  void set_major_tick_locations(int index, double value);
  void add_major_tick_locations(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      major_tick_locations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_major_tick_locations();

  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string label = 6;
  void clear_label();
  const std::string& label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label();
  PROTOBUF_NODISCARD std::string* release_label();
  void set_allocated_label(std::string* label);
  private:
  const std::string& _internal_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label(const std::string& value);
  std::string* _internal_mutable_label();
  public:

  // string label_font = 7;
  void clear_label_font();
  const std::string& label_font() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_label_font(ArgT0&& arg0, ArgT... args);
  std::string* mutable_label_font();
  PROTOBUF_NODISCARD std::string* release_label_font();
  void set_allocated_label_font(std::string* label_font);
  private:
  const std::string& _internal_label_font() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_label_font(const std::string& value);
  std::string* _internal_mutable_label_font();
  public:

  // string ticks_font = 8;
  void clear_ticks_font();
  const std::string& ticks_font() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ticks_font(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ticks_font();
  PROTOBUF_NODISCARD std::string* release_ticks_font();
  void set_allocated_ticks_font(std::string* ticks_font);
  private:
  const std::string& _internal_ticks_font() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ticks_font(const std::string& value);
  std::string* _internal_mutable_ticks_font();
  public:

  // optional string format_pattern = 9;
  bool has_format_pattern() const;
  private:
  bool _internal_has_format_pattern() const;
  public:
  void clear_format_pattern();
  const std::string& format_pattern() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_format_pattern(ArgT0&& arg0, ArgT... args);
  std::string* mutable_format_pattern();
  PROTOBUF_NODISCARD std::string* release_format_pattern();
  void set_allocated_format_pattern(std::string* format_pattern);
  private:
  const std::string& _internal_format_pattern() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_format_pattern(const std::string& value);
  std::string* _internal_mutable_format_pattern();
  public:

  // string color = 10;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor business_calendar_descriptor = 21;
  bool has_business_calendar_descriptor() const;
  private:
  bool _internal_has_business_calendar_descriptor() const;
  public:
  void clear_business_calendar_descriptor();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor& business_calendar_descriptor() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* release_business_calendar_descriptor();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* mutable_business_calendar_descriptor();
  void set_allocated_business_calendar_descriptor(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* business_calendar_descriptor);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor& _internal_business_calendar_descriptor() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* _internal_mutable_business_calendar_descriptor();
  public:
  void unsafe_arena_set_allocated_business_calendar_descriptor(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* business_calendar_descriptor);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* unsafe_arena_release_business_calendar_descriptor();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.AxisFormatType format_type = 2;
  void clear_format_type();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisFormatType format_type() const;
  void set_format_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisFormatType value);
  private:
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisFormatType _internal_format_type() const;
  void _internal_set_format_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisFormatType value);
  public:

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.AxisType type = 3;
  void clear_type();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisType type() const;
  void set_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisType value);
  private:
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisType _internal_type() const;
  void _internal_set_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisType value);
  public:

  // double min_range = 11;
  void clear_min_range();
  double min_range() const;
  void set_min_range(double value);
  private:
  double _internal_min_range() const;
  void _internal_set_min_range(double value);
  public:

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.AxisPosition position = 4;
  void clear_position();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisPosition position() const;
  void set_position(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisPosition value);
  private:
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisPosition _internal_position() const;
  void _internal_set_position(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisPosition value);
  public:

  // bool log = 5;
  void clear_log();
  bool log() const;
  void set_log(bool value);
  private:
  bool _internal_log() const;
  void _internal_set_log(bool value);
  public:

  // bool minor_ticks_visible = 13;
  void clear_minor_ticks_visible();
  bool minor_ticks_visible() const;
  void set_minor_ticks_visible(bool value);
  private:
  bool _internal_minor_ticks_visible() const;
  void _internal_set_minor_ticks_visible(bool value);
  public:

  // bool major_ticks_visible = 14;
  void clear_major_ticks_visible();
  bool major_ticks_visible() const;
  void set_major_ticks_visible(bool value);
  private:
  bool _internal_major_ticks_visible() const;
  void _internal_set_major_ticks_visible(bool value);
  public:

  // bool invert = 19;
  void clear_invert();
  bool invert() const;
  void set_invert(bool value);
  private:
  bool _internal_invert() const;
  void _internal_set_invert(bool value);
  public:

  // double max_range = 12;
  void clear_max_range();
  double max_range() const;
  void set_max_range(double value);
  private:
  double _internal_max_range() const;
  void _internal_set_max_range(double value);
  public:

  // optional double gap_between_major_ticks = 16;
  bool has_gap_between_major_ticks() const;
  private:
  bool _internal_has_gap_between_major_ticks() const;
  public:
  void clear_gap_between_major_ticks();
  double gap_between_major_ticks() const;
  void set_gap_between_major_ticks(double value);
  private:
  double _internal_gap_between_major_ticks() const;
  void _internal_set_gap_between_major_ticks(double value);
  public:

  // int32 minor_tick_count = 15;
  void clear_minor_tick_count();
  int32_t minor_tick_count() const;
  void set_minor_tick_count(int32_t value);
  private:
  int32_t _internal_minor_tick_count() const;
  void _internal_set_minor_tick_count(int32_t value);
  public:

  // bool is_time_axis = 20;
  void clear_is_time_axis();
  bool is_time_axis() const;
  void set_is_time_axis(bool value);
  private:
  bool _internal_is_time_axis() const;
  void _internal_set_is_time_axis(bool value);
  public:

  // double tick_label_angle = 18;
  void clear_tick_label_angle();
  double tick_label_angle() const;
  void set_tick_label_angle(double value);
  private:
  double _internal_tick_label_angle() const;
  void _internal_set_tick_label_angle(double value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > major_tick_locations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr label_font_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ticks_font_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr format_pattern_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* business_calendar_descriptor_;
  int format_type_;
  int type_;
  double min_range_;
  int position_;
  bool log_;
  bool minor_ticks_visible_;
  bool major_ticks_visible_;
  bool invert_;
  double max_range_;
  double gap_between_major_ticks_;
  int32_t minor_tick_count_;
  bool is_time_axis_;
  double tick_label_angle_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod) */ {
 public:
  inline FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod() : FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod(nullptr) {}
  ~FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod(const FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& from);
  FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod(FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod&& from) noexcept
    : FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& operator=(const FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& operator=(FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod*>(
               &_FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& a, FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod";
  }
  protected:
  explicit FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpenFieldNumber = 1,
    kCloseFieldNumber = 2,
  };
  // string open = 1;
  void clear_open();
  const std::string& open() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_open(ArgT0&& arg0, ArgT... args);
  std::string* mutable_open();
  PROTOBUF_NODISCARD std::string* release_open();
  void set_allocated_open(std::string* open);
  private:
  const std::string& _internal_open() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_open(const std::string& value);
  std::string* _internal_mutable_open();
  public:

  // string close = 2;
  void clear_close();
  const std::string& close() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_close(ArgT0&& arg0, ArgT... args);
  std::string* mutable_close();
  PROTOBUF_NODISCARD std::string* release_close();
  void set_allocated_close(std::string* close);
  private:
  const std::string& _internal_close() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_close(const std::string& value);
  std::string* _internal_mutable_close();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr open_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr close_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_BusinessCalendarDescriptor_Holiday final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday) */ {
 public:
  inline FigureDescriptor_BusinessCalendarDescriptor_Holiday() : FigureDescriptor_BusinessCalendarDescriptor_Holiday(nullptr) {}
  ~FigureDescriptor_BusinessCalendarDescriptor_Holiday() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_BusinessCalendarDescriptor_Holiday(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_BusinessCalendarDescriptor_Holiday(const FigureDescriptor_BusinessCalendarDescriptor_Holiday& from);
  FigureDescriptor_BusinessCalendarDescriptor_Holiday(FigureDescriptor_BusinessCalendarDescriptor_Holiday&& from) noexcept
    : FigureDescriptor_BusinessCalendarDescriptor_Holiday() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_BusinessCalendarDescriptor_Holiday& operator=(const FigureDescriptor_BusinessCalendarDescriptor_Holiday& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_BusinessCalendarDescriptor_Holiday& operator=(FigureDescriptor_BusinessCalendarDescriptor_Holiday&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_BusinessCalendarDescriptor_Holiday& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_BusinessCalendarDescriptor_Holiday* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_BusinessCalendarDescriptor_Holiday*>(
               &_FigureDescriptor_BusinessCalendarDescriptor_Holiday_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(FigureDescriptor_BusinessCalendarDescriptor_Holiday& a, FigureDescriptor_BusinessCalendarDescriptor_Holiday& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_BusinessCalendarDescriptor_Holiday* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_BusinessCalendarDescriptor_Holiday* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_BusinessCalendarDescriptor_Holiday* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_BusinessCalendarDescriptor_Holiday>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_BusinessCalendarDescriptor_Holiday& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_BusinessCalendarDescriptor_Holiday& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_BusinessCalendarDescriptor_Holiday* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday";
  }
  protected:
  explicit FigureDescriptor_BusinessCalendarDescriptor_Holiday(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBusinessPeriodsFieldNumber = 2,
    kDateFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod business_periods = 2;
  int business_periods_size() const;
  private:
  int _internal_business_periods_size() const;
  public:
  void clear_business_periods();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* mutable_business_periods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod >*
      mutable_business_periods();
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& _internal_business_periods(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* _internal_add_business_periods();
  public:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& business_periods(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* add_business_periods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod >&
      business_periods() const;

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.LocalDate date = 1;
  bool has_date() const;
  private:
  bool _internal_has_date() const;
  public:
  void clear_date();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate& date() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* release_date();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* mutable_date();
  void set_allocated_date(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* date);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate& _internal_date() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* _internal_mutable_date();
  public:
  void unsafe_arena_set_allocated_date(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* date);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* unsafe_arena_release_date();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod > business_periods_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* date_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_BusinessCalendarDescriptor_LocalDate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.LocalDate) */ {
 public:
  inline FigureDescriptor_BusinessCalendarDescriptor_LocalDate() : FigureDescriptor_BusinessCalendarDescriptor_LocalDate(nullptr) {}
  ~FigureDescriptor_BusinessCalendarDescriptor_LocalDate() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_BusinessCalendarDescriptor_LocalDate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_BusinessCalendarDescriptor_LocalDate(const FigureDescriptor_BusinessCalendarDescriptor_LocalDate& from);
  FigureDescriptor_BusinessCalendarDescriptor_LocalDate(FigureDescriptor_BusinessCalendarDescriptor_LocalDate&& from) noexcept
    : FigureDescriptor_BusinessCalendarDescriptor_LocalDate() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_BusinessCalendarDescriptor_LocalDate& operator=(const FigureDescriptor_BusinessCalendarDescriptor_LocalDate& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_BusinessCalendarDescriptor_LocalDate& operator=(FigureDescriptor_BusinessCalendarDescriptor_LocalDate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_BusinessCalendarDescriptor_LocalDate& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_BusinessCalendarDescriptor_LocalDate* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_BusinessCalendarDescriptor_LocalDate*>(
               &_FigureDescriptor_BusinessCalendarDescriptor_LocalDate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(FigureDescriptor_BusinessCalendarDescriptor_LocalDate& a, FigureDescriptor_BusinessCalendarDescriptor_LocalDate& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_BusinessCalendarDescriptor_LocalDate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_BusinessCalendarDescriptor_LocalDate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_BusinessCalendarDescriptor_LocalDate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_BusinessCalendarDescriptor_LocalDate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_BusinessCalendarDescriptor_LocalDate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_BusinessCalendarDescriptor_LocalDate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_BusinessCalendarDescriptor_LocalDate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.LocalDate";
  }
  protected:
  explicit FigureDescriptor_BusinessCalendarDescriptor_LocalDate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kYearFieldNumber = 1,
    kMonthFieldNumber = 2,
    kDayFieldNumber = 3,
  };
  // int32 year = 1;
  void clear_year();
  int32_t year() const;
  void set_year(int32_t value);
  private:
  int32_t _internal_year() const;
  void _internal_set_year(int32_t value);
  public:

  // int32 month = 2;
  void clear_month();
  int32_t month() const;
  void set_month(int32_t value);
  private:
  int32_t _internal_month() const;
  void _internal_set_month(int32_t value);
  public:

  // int32 day = 3;
  void clear_day();
  int32_t day() const;
  void set_day(int32_t value);
  private:
  int32_t _internal_day() const;
  void _internal_set_day(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.LocalDate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t year_;
  int32_t month_;
  int32_t day_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_BusinessCalendarDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor) */ {
 public:
  inline FigureDescriptor_BusinessCalendarDescriptor() : FigureDescriptor_BusinessCalendarDescriptor(nullptr) {}
  ~FigureDescriptor_BusinessCalendarDescriptor() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_BusinessCalendarDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_BusinessCalendarDescriptor(const FigureDescriptor_BusinessCalendarDescriptor& from);
  FigureDescriptor_BusinessCalendarDescriptor(FigureDescriptor_BusinessCalendarDescriptor&& from) noexcept
    : FigureDescriptor_BusinessCalendarDescriptor() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_BusinessCalendarDescriptor& operator=(const FigureDescriptor_BusinessCalendarDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_BusinessCalendarDescriptor& operator=(FigureDescriptor_BusinessCalendarDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_BusinessCalendarDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_BusinessCalendarDescriptor* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_BusinessCalendarDescriptor*>(
               &_FigureDescriptor_BusinessCalendarDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(FigureDescriptor_BusinessCalendarDescriptor& a, FigureDescriptor_BusinessCalendarDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_BusinessCalendarDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_BusinessCalendarDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_BusinessCalendarDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_BusinessCalendarDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_BusinessCalendarDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_BusinessCalendarDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_BusinessCalendarDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor";
  }
  protected:
  explicit FigureDescriptor_BusinessCalendarDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod BusinessPeriod;
  typedef FigureDescriptor_BusinessCalendarDescriptor_Holiday Holiday;
  typedef FigureDescriptor_BusinessCalendarDescriptor_LocalDate LocalDate;

  typedef FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek DayOfWeek;
  static constexpr DayOfWeek SUNDAY =
    FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_SUNDAY;
  static constexpr DayOfWeek MONDAY =
    FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_MONDAY;
  static constexpr DayOfWeek TUESDAY =
    FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_TUESDAY;
  static constexpr DayOfWeek WEDNESDAY =
    FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_WEDNESDAY;
  static constexpr DayOfWeek THURSDAY =
    FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_THURSDAY;
  static constexpr DayOfWeek FRIDAY =
    FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_FRIDAY;
  static constexpr DayOfWeek SATURDAY =
    FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_SATURDAY;
  static inline bool DayOfWeek_IsValid(int value) {
    return FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_IsValid(value);
  }
  static constexpr DayOfWeek DayOfWeek_MIN =
    FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_DayOfWeek_MIN;
  static constexpr DayOfWeek DayOfWeek_MAX =
    FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_DayOfWeek_MAX;
  static constexpr int DayOfWeek_ARRAYSIZE =
    FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_DayOfWeek_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DayOfWeek_descriptor() {
    return FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_descriptor();
  }
  template<typename T>
  static inline const std::string& DayOfWeek_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DayOfWeek>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DayOfWeek_Name.");
    return FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_Name(enum_t_value);
  }
  static inline bool DayOfWeek_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DayOfWeek* value) {
    return FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kBusinessDaysFieldNumber = 3,
    kBusinessPeriodsFieldNumber = 4,
    kHolidaysFieldNumber = 5,
    kNameFieldNumber = 1,
    kTimeZoneFieldNumber = 2,
  };
  // repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.DayOfWeek business_days = 3;
  int business_days_size() const;
  private:
  int _internal_business_days_size() const;
  public:
  void clear_business_days();
  private:
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek _internal_business_days(int index) const;
  void _internal_add_business_days(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_business_days();
  public:
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek business_days(int index) const;
  void set_business_days(int index, ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek value);
  void add_business_days(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& business_days() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_business_days();

  // repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod business_periods = 4;
  int business_periods_size() const;
  private:
  int _internal_business_periods_size() const;
  public:
  void clear_business_periods();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* mutable_business_periods(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod >*
      mutable_business_periods();
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& _internal_business_periods(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* _internal_add_business_periods();
  public:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& business_periods(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* add_business_periods();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod >&
      business_periods() const;

  // repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday holidays = 5;
  int holidays_size() const;
  private:
  int _internal_holidays_size() const;
  public:
  void clear_holidays();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday* mutable_holidays(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday >*
      mutable_holidays();
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday& _internal_holidays(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday* _internal_add_holidays();
  public:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday& holidays(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday* add_holidays();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday >&
      holidays() const;

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string time_zone = 2;
  void clear_time_zone();
  const std::string& time_zone() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_zone(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_zone();
  PROTOBUF_NODISCARD std::string* release_time_zone();
  void set_allocated_time_zone(std::string* time_zone);
  private:
  const std::string& _internal_time_zone() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_zone(const std::string& value);
  std::string* _internal_mutable_time_zone();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> business_days_;
  mutable std::atomic<int> _business_days_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod > business_periods_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday > holidays_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_zone_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_MultiSeriesSourceDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor) */ {
 public:
  inline FigureDescriptor_MultiSeriesSourceDescriptor() : FigureDescriptor_MultiSeriesSourceDescriptor(nullptr) {}
  ~FigureDescriptor_MultiSeriesSourceDescriptor() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_MultiSeriesSourceDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_MultiSeriesSourceDescriptor(const FigureDescriptor_MultiSeriesSourceDescriptor& from);
  FigureDescriptor_MultiSeriesSourceDescriptor(FigureDescriptor_MultiSeriesSourceDescriptor&& from) noexcept
    : FigureDescriptor_MultiSeriesSourceDescriptor() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_MultiSeriesSourceDescriptor& operator=(const FigureDescriptor_MultiSeriesSourceDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_MultiSeriesSourceDescriptor& operator=(FigureDescriptor_MultiSeriesSourceDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_MultiSeriesSourceDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_MultiSeriesSourceDescriptor* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_MultiSeriesSourceDescriptor*>(
               &_FigureDescriptor_MultiSeriesSourceDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(FigureDescriptor_MultiSeriesSourceDescriptor& a, FigureDescriptor_MultiSeriesSourceDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_MultiSeriesSourceDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_MultiSeriesSourceDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_MultiSeriesSourceDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_MultiSeriesSourceDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_MultiSeriesSourceDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_MultiSeriesSourceDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_MultiSeriesSourceDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor";
  }
  protected:
  explicit FigureDescriptor_MultiSeriesSourceDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAxisIdFieldNumber = 1,
    kColumnNameFieldNumber = 4,
    kTypeFieldNumber = 2,
    kPartitionedTableIdFieldNumber = 3,
  };
  // string axis_id = 1;
  void clear_axis_id();
  const std::string& axis_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_axis_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_axis_id();
  PROTOBUF_NODISCARD std::string* release_axis_id();
  void set_allocated_axis_id(std::string* axis_id);
  private:
  const std::string& _internal_axis_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_axis_id(const std::string& value);
  std::string* _internal_mutable_axis_id();
  public:

  // string column_name = 4;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceType type = 2;
  void clear_type();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType type() const;
  void set_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType value);
  private:
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType _internal_type() const;
  void _internal_set_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType value);
  public:

  // int32 partitioned_table_id = 3;
  void clear_partitioned_table_id();
  int32_t partitioned_table_id() const;
  void set_partitioned_table_id(int32_t value);
  private:
  int32_t _internal_partitioned_table_id() const;
  void _internal_set_partitioned_table_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr axis_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  int type_;
  int32_t partitioned_table_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_SourceDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor) */ {
 public:
  inline FigureDescriptor_SourceDescriptor() : FigureDescriptor_SourceDescriptor(nullptr) {}
  ~FigureDescriptor_SourceDescriptor() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_SourceDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_SourceDescriptor(const FigureDescriptor_SourceDescriptor& from);
  FigureDescriptor_SourceDescriptor(FigureDescriptor_SourceDescriptor&& from) noexcept
    : FigureDescriptor_SourceDescriptor() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_SourceDescriptor& operator=(const FigureDescriptor_SourceDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_SourceDescriptor& operator=(FigureDescriptor_SourceDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_SourceDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_SourceDescriptor* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_SourceDescriptor*>(
               &_FigureDescriptor_SourceDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(FigureDescriptor_SourceDescriptor& a, FigureDescriptor_SourceDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_SourceDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_SourceDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_SourceDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_SourceDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_SourceDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_SourceDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_SourceDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor";
  }
  protected:
  explicit FigureDescriptor_SourceDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAxisIdFieldNumber = 1,
    kColumnNameFieldNumber = 5,
    kColumnTypeFieldNumber = 6,
    kOneClickFieldNumber = 7,
    kTypeFieldNumber = 2,
    kTableIdFieldNumber = 3,
    kPartitionedTableIdFieldNumber = 4,
  };
  // string axis_id = 1;
  void clear_axis_id();
  const std::string& axis_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_axis_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_axis_id();
  PROTOBUF_NODISCARD std::string* release_axis_id();
  void set_allocated_axis_id(std::string* axis_id);
  private:
  const std::string& _internal_axis_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_axis_id(const std::string& value);
  std::string* _internal_mutable_axis_id();
  public:

  // string column_name = 5;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // string column_type = 6;
  void clear_column_type();
  const std::string& column_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_type();
  PROTOBUF_NODISCARD std::string* release_column_type();
  void set_allocated_column_type(std::string* column_type);
  private:
  const std::string& _internal_column_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_type(const std::string& value);
  std::string* _internal_mutable_column_type();
  public:

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor one_click = 7;
  bool has_one_click() const;
  private:
  bool _internal_has_one_click() const;
  public:
  void clear_one_click();
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor& one_click() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* release_one_click();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* mutable_one_click();
  void set_allocated_one_click(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* one_click);
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor& _internal_one_click() const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* _internal_mutable_one_click();
  public:
  void unsafe_arena_set_allocated_one_click(
      ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* one_click);
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* unsafe_arena_release_one_click();

  // .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceType type = 2;
  void clear_type();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType type() const;
  void set_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType value);
  private:
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType _internal_type() const;
  void _internal_set_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType value);
  public:

  // int32 table_id = 3;
  void clear_table_id();
  int32_t table_id() const;
  void set_table_id(int32_t value);
  private:
  int32_t _internal_table_id() const;
  void _internal_set_table_id(int32_t value);
  public:

  // int32 partitioned_table_id = 4;
  void clear_partitioned_table_id();
  int32_t partitioned_table_id() const;
  void set_partitioned_table_id(int32_t value);
  private:
  int32_t _internal_partitioned_table_id() const;
  void _internal_set_partitioned_table_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr axis_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_type_;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* one_click_;
  int type_;
  int32_t table_id_;
  int32_t partitioned_table_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor_OneClickDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor) */ {
 public:
  inline FigureDescriptor_OneClickDescriptor() : FigureDescriptor_OneClickDescriptor(nullptr) {}
  ~FigureDescriptor_OneClickDescriptor() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor_OneClickDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor_OneClickDescriptor(const FigureDescriptor_OneClickDescriptor& from);
  FigureDescriptor_OneClickDescriptor(FigureDescriptor_OneClickDescriptor&& from) noexcept
    : FigureDescriptor_OneClickDescriptor() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor_OneClickDescriptor& operator=(const FigureDescriptor_OneClickDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor_OneClickDescriptor& operator=(FigureDescriptor_OneClickDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor_OneClickDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor_OneClickDescriptor* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor_OneClickDescriptor*>(
               &_FigureDescriptor_OneClickDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(FigureDescriptor_OneClickDescriptor& a, FigureDescriptor_OneClickDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor_OneClickDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor_OneClickDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor_OneClickDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor_OneClickDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor_OneClickDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor_OneClickDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor_OneClickDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor";
  }
  protected:
  explicit FigureDescriptor_OneClickDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 1,
    kColumnTypesFieldNumber = 2,
    kRequireAllFiltersToDisplayFieldNumber = 3,
  };
  // repeated string columns = 1;
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  const std::string& columns(int index) const;
  std::string* mutable_columns(int index);
  void set_columns(int index, const std::string& value);
  void set_columns(int index, std::string&& value);
  void set_columns(int index, const char* value);
  void set_columns(int index, const char* value, size_t size);
  std::string* add_columns();
  void add_columns(const std::string& value);
  void add_columns(std::string&& value);
  void add_columns(const char* value);
  void add_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns();
  private:
  const std::string& _internal_columns(int index) const;
  std::string* _internal_add_columns();
  public:

  // repeated string column_types = 2;
  int column_types_size() const;
  private:
  int _internal_column_types_size() const;
  public:
  void clear_column_types();
  const std::string& column_types(int index) const;
  std::string* mutable_column_types(int index);
  void set_column_types(int index, const std::string& value);
  void set_column_types(int index, std::string&& value);
  void set_column_types(int index, const char* value);
  void set_column_types(int index, const char* value, size_t size);
  std::string* add_column_types();
  void add_column_types(const std::string& value);
  void add_column_types(std::string&& value);
  void add_column_types(const char* value);
  void add_column_types(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_types();
  private:
  const std::string& _internal_column_types(int index) const;
  std::string* _internal_add_column_types();
  public:

  // bool require_all_filters_to_display = 3;
  void clear_require_all_filters_to_display();
  bool require_all_filters_to_display() const;
  void set_require_all_filters_to_display(bool value);
  private:
  bool _internal_require_all_filters_to_display() const;
  void _internal_set_require_all_filters_to_display(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_types_;
  bool require_all_filters_to_display_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// -------------------------------------------------------------------

class FigureDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.script.grpc.FigureDescriptor) */ {
 public:
  inline FigureDescriptor() : FigureDescriptor(nullptr) {}
  ~FigureDescriptor() override;
  explicit PROTOBUF_CONSTEXPR FigureDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FigureDescriptor(const FigureDescriptor& from);
  FigureDescriptor(FigureDescriptor&& from) noexcept
    : FigureDescriptor() {
    *this = ::std::move(from);
  }

  inline FigureDescriptor& operator=(const FigureDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FigureDescriptor& operator=(FigureDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FigureDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const FigureDescriptor* internal_default_instance() {
    return reinterpret_cast<const FigureDescriptor*>(
               &_FigureDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(FigureDescriptor& a, FigureDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FigureDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FigureDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FigureDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FigureDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FigureDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FigureDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FigureDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.script.grpc.FigureDescriptor";
  }
  protected:
  explicit FigureDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FigureDescriptor_ChartDescriptor ChartDescriptor;
  typedef FigureDescriptor_SeriesDescriptor SeriesDescriptor;
  typedef FigureDescriptor_MultiSeriesDescriptor MultiSeriesDescriptor;
  typedef FigureDescriptor_StringMapWithDefault StringMapWithDefault;
  typedef FigureDescriptor_DoubleMapWithDefault DoubleMapWithDefault;
  typedef FigureDescriptor_BoolMapWithDefault BoolMapWithDefault;
  typedef FigureDescriptor_AxisDescriptor AxisDescriptor;
  typedef FigureDescriptor_BusinessCalendarDescriptor BusinessCalendarDescriptor;
  typedef FigureDescriptor_MultiSeriesSourceDescriptor MultiSeriesSourceDescriptor;
  typedef FigureDescriptor_SourceDescriptor SourceDescriptor;
  typedef FigureDescriptor_OneClickDescriptor OneClickDescriptor;

  typedef FigureDescriptor_SeriesPlotStyle SeriesPlotStyle;
  static constexpr SeriesPlotStyle BAR =
    FigureDescriptor_SeriesPlotStyle_BAR;
  static constexpr SeriesPlotStyle STACKED_BAR =
    FigureDescriptor_SeriesPlotStyle_STACKED_BAR;
  static constexpr SeriesPlotStyle LINE =
    FigureDescriptor_SeriesPlotStyle_LINE;
  static constexpr SeriesPlotStyle AREA =
    FigureDescriptor_SeriesPlotStyle_AREA;
  static constexpr SeriesPlotStyle STACKED_AREA =
    FigureDescriptor_SeriesPlotStyle_STACKED_AREA;
  static constexpr SeriesPlotStyle PIE =
    FigureDescriptor_SeriesPlotStyle_PIE;
  static constexpr SeriesPlotStyle HISTOGRAM =
    FigureDescriptor_SeriesPlotStyle_HISTOGRAM;
  static constexpr SeriesPlotStyle OHLC =
    FigureDescriptor_SeriesPlotStyle_OHLC;
  static constexpr SeriesPlotStyle SCATTER =
    FigureDescriptor_SeriesPlotStyle_SCATTER;
  static constexpr SeriesPlotStyle STEP =
    FigureDescriptor_SeriesPlotStyle_STEP;
  static constexpr SeriesPlotStyle ERROR_BAR =
    FigureDescriptor_SeriesPlotStyle_ERROR_BAR;
  static constexpr SeriesPlotStyle TREEMAP =
    FigureDescriptor_SeriesPlotStyle_TREEMAP;
  static inline bool SeriesPlotStyle_IsValid(int value) {
    return FigureDescriptor_SeriesPlotStyle_IsValid(value);
  }
  static constexpr SeriesPlotStyle SeriesPlotStyle_MIN =
    FigureDescriptor_SeriesPlotStyle_SeriesPlotStyle_MIN;
  static constexpr SeriesPlotStyle SeriesPlotStyle_MAX =
    FigureDescriptor_SeriesPlotStyle_SeriesPlotStyle_MAX;
  static constexpr int SeriesPlotStyle_ARRAYSIZE =
    FigureDescriptor_SeriesPlotStyle_SeriesPlotStyle_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SeriesPlotStyle_descriptor() {
    return FigureDescriptor_SeriesPlotStyle_descriptor();
  }
  template<typename T>
  static inline const std::string& SeriesPlotStyle_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SeriesPlotStyle>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SeriesPlotStyle_Name.");
    return FigureDescriptor_SeriesPlotStyle_Name(enum_t_value);
  }
  static inline bool SeriesPlotStyle_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SeriesPlotStyle* value) {
    return FigureDescriptor_SeriesPlotStyle_Parse(name, value);
  }

  typedef FigureDescriptor_SourceType SourceType;
  static constexpr SourceType X =
    FigureDescriptor_SourceType_X;
  static constexpr SourceType Y =
    FigureDescriptor_SourceType_Y;
  static constexpr SourceType Z =
    FigureDescriptor_SourceType_Z;
  static constexpr SourceType X_LOW =
    FigureDescriptor_SourceType_X_LOW;
  static constexpr SourceType X_HIGH =
    FigureDescriptor_SourceType_X_HIGH;
  static constexpr SourceType Y_LOW =
    FigureDescriptor_SourceType_Y_LOW;
  static constexpr SourceType Y_HIGH =
    FigureDescriptor_SourceType_Y_HIGH;
  static constexpr SourceType TIME =
    FigureDescriptor_SourceType_TIME;
  static constexpr SourceType OPEN =
    FigureDescriptor_SourceType_OPEN;
  static constexpr SourceType HIGH =
    FigureDescriptor_SourceType_HIGH;
  static constexpr SourceType LOW =
    FigureDescriptor_SourceType_LOW;
  static constexpr SourceType CLOSE =
    FigureDescriptor_SourceType_CLOSE;
  static constexpr SourceType SHAPE =
    FigureDescriptor_SourceType_SHAPE;
  static constexpr SourceType SIZE =
    FigureDescriptor_SourceType_SIZE;
  static constexpr SourceType LABEL =
    FigureDescriptor_SourceType_LABEL;
  static constexpr SourceType COLOR =
    FigureDescriptor_SourceType_COLOR;
  static constexpr SourceType PARENT =
    FigureDescriptor_SourceType_PARENT;
  static constexpr SourceType HOVER_TEXT =
    FigureDescriptor_SourceType_HOVER_TEXT;
  static constexpr SourceType TEXT =
    FigureDescriptor_SourceType_TEXT;
  static inline bool SourceType_IsValid(int value) {
    return FigureDescriptor_SourceType_IsValid(value);
  }
  static constexpr SourceType SourceType_MIN =
    FigureDescriptor_SourceType_SourceType_MIN;
  static constexpr SourceType SourceType_MAX =
    FigureDescriptor_SourceType_SourceType_MAX;
  static constexpr int SourceType_ARRAYSIZE =
    FigureDescriptor_SourceType_SourceType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SourceType_descriptor() {
    return FigureDescriptor_SourceType_descriptor();
  }
  template<typename T>
  static inline const std::string& SourceType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SourceType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SourceType_Name.");
    return FigureDescriptor_SourceType_Name(enum_t_value);
  }
  static inline bool SourceType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SourceType* value) {
    return FigureDescriptor_SourceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kChartsFieldNumber = 10,
    kErrorsFieldNumber = 13,
    kTitleFieldNumber = 1,
    kTitleFontFieldNumber = 2,
    kTitleColorFieldNumber = 3,
    kUpdateIntervalFieldNumber = 7,
    kColsFieldNumber = 8,
    kRowsFieldNumber = 9,
  };
  // repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor charts = 10;
  int charts_size() const;
  private:
  int _internal_charts_size() const;
  public:
  void clear_charts();
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor* mutable_charts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor >*
      mutable_charts();
  private:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor& _internal_charts(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor* _internal_add_charts();
  public:
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor& charts(int index) const;
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor* add_charts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor >&
      charts() const;

  // repeated string errors = 13;
  int errors_size() const;
  private:
  int _internal_errors_size() const;
  public:
  void clear_errors();
  const std::string& errors(int index) const;
  std::string* mutable_errors(int index);
  void set_errors(int index, const std::string& value);
  void set_errors(int index, std::string&& value);
  void set_errors(int index, const char* value);
  void set_errors(int index, const char* value, size_t size);
  std::string* add_errors();
  void add_errors(const std::string& value);
  void add_errors(std::string&& value);
  void add_errors(const char* value);
  void add_errors(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& errors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_errors();
  private:
  const std::string& _internal_errors(int index) const;
  std::string* _internal_add_errors();
  public:

  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string title_font = 2;
  void clear_title_font();
  const std::string& title_font() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title_font(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title_font();
  PROTOBUF_NODISCARD std::string* release_title_font();
  void set_allocated_title_font(std::string* title_font);
  private:
  const std::string& _internal_title_font() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title_font(const std::string& value);
  std::string* _internal_mutable_title_font();
  public:

  // string title_color = 3;
  void clear_title_color();
  const std::string& title_color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title_color();
  PROTOBUF_NODISCARD std::string* release_title_color();
  void set_allocated_title_color(std::string* title_color);
  private:
  const std::string& _internal_title_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title_color(const std::string& value);
  std::string* _internal_mutable_title_color();
  public:

  // int64 update_interval = 7 [jstype = JS_STRING];
  void clear_update_interval();
  int64_t update_interval() const;
  void set_update_interval(int64_t value);
  private:
  int64_t _internal_update_interval() const;
  void _internal_set_update_interval(int64_t value);
  public:

  // int32 cols = 8;
  void clear_cols();
  int32_t cols() const;
  void set_cols(int32_t value);
  private:
  int32_t _internal_cols() const;
  void _internal_set_cols(int32_t value);
  public:

  // int32 rows = 9;
  void clear_rows();
  int32_t rows() const;
  void set_rows(int32_t value);
  private:
  int32_t _internal_rows() const;
  void _internal_set_rows(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.script.grpc.FigureDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor > charts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> errors_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_font_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_color_;
  int64_t update_interval_;
  int32_t cols_;
  int32_t rows_;
  friend struct ::TableStruct_deephaven_2fproto_2fconsole_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetConsoleTypesRequest

// -------------------------------------------------------------------

// GetConsoleTypesResponse

// repeated string console_types = 1;
inline int GetConsoleTypesResponse::_internal_console_types_size() const {
  return console_types_.size();
}
inline int GetConsoleTypesResponse::console_types_size() const {
  return _internal_console_types_size();
}
inline void GetConsoleTypesResponse::clear_console_types() {
  console_types_.Clear();
}
inline std::string* GetConsoleTypesResponse::add_console_types() {
  std::string* _s = _internal_add_console_types();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
  return _s;
}
inline const std::string& GetConsoleTypesResponse::_internal_console_types(int index) const {
  return console_types_.Get(index);
}
inline const std::string& GetConsoleTypesResponse::console_types(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
  return _internal_console_types(index);
}
inline std::string* GetConsoleTypesResponse::mutable_console_types(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
  return console_types_.Mutable(index);
}
inline void GetConsoleTypesResponse::set_console_types(int index, const std::string& value) {
  console_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
}
inline void GetConsoleTypesResponse::set_console_types(int index, std::string&& value) {
  console_types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
}
inline void GetConsoleTypesResponse::set_console_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  console_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
}
inline void GetConsoleTypesResponse::set_console_types(int index, const char* value, size_t size) {
  console_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
}
inline std::string* GetConsoleTypesResponse::_internal_add_console_types() {
  return console_types_.Add();
}
inline void GetConsoleTypesResponse::add_console_types(const std::string& value) {
  console_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
}
inline void GetConsoleTypesResponse::add_console_types(std::string&& value) {
  console_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
}
inline void GetConsoleTypesResponse::add_console_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  console_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
}
inline void GetConsoleTypesResponse::add_console_types(const char* value, size_t size) {
  console_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetConsoleTypesResponse::console_types() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
  return console_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetConsoleTypesResponse::mutable_console_types() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.GetConsoleTypesResponse.console_types)
  return &console_types_;
}

// -------------------------------------------------------------------

// StartConsoleRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool StartConsoleRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool StartConsoleRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& StartConsoleRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& StartConsoleRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.StartConsoleRequest.result_id)
  return _internal_result_id();
}
inline void StartConsoleRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.StartConsoleRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* StartConsoleRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* StartConsoleRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.StartConsoleRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* StartConsoleRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* StartConsoleRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.StartConsoleRequest.result_id)
  return _msg;
}
inline void StartConsoleRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.StartConsoleRequest.result_id)
}

// string session_type = 2;
inline void StartConsoleRequest::clear_session_type() {
  session_type_.ClearToEmpty();
}
inline const std::string& StartConsoleRequest::session_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.StartConsoleRequest.session_type)
  return _internal_session_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartConsoleRequest::set_session_type(ArgT0&& arg0, ArgT... args) {
 
 session_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.StartConsoleRequest.session_type)
}
inline std::string* StartConsoleRequest::mutable_session_type() {
  std::string* _s = _internal_mutable_session_type();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.StartConsoleRequest.session_type)
  return _s;
}
inline const std::string& StartConsoleRequest::_internal_session_type() const {
  return session_type_.Get();
}
inline void StartConsoleRequest::_internal_set_session_type(const std::string& value) {
  
  session_type_.Set(value, GetArenaForAllocation());
}
inline std::string* StartConsoleRequest::_internal_mutable_session_type() {
  
  return session_type_.Mutable(GetArenaForAllocation());
}
inline std::string* StartConsoleRequest::release_session_type() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.StartConsoleRequest.session_type)
  return session_type_.Release();
}
inline void StartConsoleRequest::set_allocated_session_type(std::string* session_type) {
  if (session_type != nullptr) {
    
  } else {
    
  }
  session_type_.SetAllocated(session_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (session_type_.IsDefault()) {
    session_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.StartConsoleRequest.session_type)
}

// -------------------------------------------------------------------

// StartConsoleResponse

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool StartConsoleResponse::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool StartConsoleResponse::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& StartConsoleResponse::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& StartConsoleResponse::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.StartConsoleResponse.result_id)
  return _internal_result_id();
}
inline void StartConsoleResponse::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.StartConsoleResponse.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* StartConsoleResponse::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* StartConsoleResponse::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.StartConsoleResponse.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* StartConsoleResponse::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* StartConsoleResponse::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.StartConsoleResponse.result_id)
  return _msg;
}
inline void StartConsoleResponse::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.StartConsoleResponse.result_id)
}

// -------------------------------------------------------------------

// LogSubscriptionRequest

// int64 last_seen_log_timestamp = 1 [jstype = JS_STRING];
inline void LogSubscriptionRequest::clear_last_seen_log_timestamp() {
  last_seen_log_timestamp_ = int64_t{0};
}
inline int64_t LogSubscriptionRequest::_internal_last_seen_log_timestamp() const {
  return last_seen_log_timestamp_;
}
inline int64_t LogSubscriptionRequest::last_seen_log_timestamp() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.last_seen_log_timestamp)
  return _internal_last_seen_log_timestamp();
}
inline void LogSubscriptionRequest::_internal_set_last_seen_log_timestamp(int64_t value) {
  
  last_seen_log_timestamp_ = value;
}
inline void LogSubscriptionRequest::set_last_seen_log_timestamp(int64_t value) {
  _internal_set_last_seen_log_timestamp(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.last_seen_log_timestamp)
}

// repeated string levels = 2;
inline int LogSubscriptionRequest::_internal_levels_size() const {
  return levels_.size();
}
inline int LogSubscriptionRequest::levels_size() const {
  return _internal_levels_size();
}
inline void LogSubscriptionRequest::clear_levels() {
  levels_.Clear();
}
inline std::string* LogSubscriptionRequest::add_levels() {
  std::string* _s = _internal_add_levels();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
  return _s;
}
inline const std::string& LogSubscriptionRequest::_internal_levels(int index) const {
  return levels_.Get(index);
}
inline const std::string& LogSubscriptionRequest::levels(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
  return _internal_levels(index);
}
inline std::string* LogSubscriptionRequest::mutable_levels(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
  return levels_.Mutable(index);
}
inline void LogSubscriptionRequest::set_levels(int index, const std::string& value) {
  levels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
}
inline void LogSubscriptionRequest::set_levels(int index, std::string&& value) {
  levels_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
}
inline void LogSubscriptionRequest::set_levels(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  levels_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
}
inline void LogSubscriptionRequest::set_levels(int index, const char* value, size_t size) {
  levels_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
}
inline std::string* LogSubscriptionRequest::_internal_add_levels() {
  return levels_.Add();
}
inline void LogSubscriptionRequest::add_levels(const std::string& value) {
  levels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
}
inline void LogSubscriptionRequest::add_levels(std::string&& value) {
  levels_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
}
inline void LogSubscriptionRequest::add_levels(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  levels_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
}
inline void LogSubscriptionRequest::add_levels(const char* value, size_t size) {
  levels_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LogSubscriptionRequest::levels() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
  return levels_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LogSubscriptionRequest::mutable_levels() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.LogSubscriptionRequest.levels)
  return &levels_;
}

// -------------------------------------------------------------------

// LogSubscriptionData

// int64 micros = 1 [jstype = JS_STRING];
inline void LogSubscriptionData::clear_micros() {
  micros_ = int64_t{0};
}
inline int64_t LogSubscriptionData::_internal_micros() const {
  return micros_;
}
inline int64_t LogSubscriptionData::micros() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData.micros)
  return _internal_micros();
}
inline void LogSubscriptionData::_internal_set_micros(int64_t value) {
  
  micros_ = value;
}
inline void LogSubscriptionData::set_micros(int64_t value) {
  _internal_set_micros(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData.micros)
}

// string log_level = 2;
inline void LogSubscriptionData::clear_log_level() {
  log_level_.ClearToEmpty();
}
inline const std::string& LogSubscriptionData::log_level() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData.log_level)
  return _internal_log_level();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogSubscriptionData::set_log_level(ArgT0&& arg0, ArgT... args) {
 
 log_level_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData.log_level)
}
inline std::string* LogSubscriptionData::mutable_log_level() {
  std::string* _s = _internal_mutable_log_level();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData.log_level)
  return _s;
}
inline const std::string& LogSubscriptionData::_internal_log_level() const {
  return log_level_.Get();
}
inline void LogSubscriptionData::_internal_set_log_level(const std::string& value) {
  
  log_level_.Set(value, GetArenaForAllocation());
}
inline std::string* LogSubscriptionData::_internal_mutable_log_level() {
  
  return log_level_.Mutable(GetArenaForAllocation());
}
inline std::string* LogSubscriptionData::release_log_level() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData.log_level)
  return log_level_.Release();
}
inline void LogSubscriptionData::set_allocated_log_level(std::string* log_level) {
  if (log_level != nullptr) {
    
  } else {
    
  }
  log_level_.SetAllocated(log_level, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (log_level_.IsDefault()) {
    log_level_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData.log_level)
}

// string message = 3;
inline void LogSubscriptionData::clear_message() {
  message_.ClearToEmpty();
}
inline const std::string& LogSubscriptionData::message() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogSubscriptionData::set_message(ArgT0&& arg0, ArgT... args) {
 
 message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData.message)
}
inline std::string* LogSubscriptionData::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData.message)
  return _s;
}
inline const std::string& LogSubscriptionData::_internal_message() const {
  return message_.Get();
}
inline void LogSubscriptionData::_internal_set_message(const std::string& value) {
  
  message_.Set(value, GetArenaForAllocation());
}
inline std::string* LogSubscriptionData::_internal_mutable_message() {
  
  return message_.Mutable(GetArenaForAllocation());
}
inline std::string* LogSubscriptionData::release_message() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData.message)
  return message_.Release();
}
inline void LogSubscriptionData::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault()) {
    message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.LogSubscriptionData.message)
}

// -------------------------------------------------------------------

// ExecuteCommandRequest

// .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
inline bool ExecuteCommandRequest::_internal_has_console_id() const {
  return this != internal_default_instance() && console_id_ != nullptr;
}
inline bool ExecuteCommandRequest::has_console_id() const {
  return _internal_has_console_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExecuteCommandRequest::_internal_console_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = console_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExecuteCommandRequest::console_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest.console_id)
  return _internal_console_id();
}
inline void ExecuteCommandRequest::unsafe_arena_set_allocated_console_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  console_id_ = console_id;
  if (console_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest.console_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExecuteCommandRequest::release_console_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExecuteCommandRequest::unsafe_arena_release_console_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest.console_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExecuteCommandRequest::_internal_mutable_console_id() {
  
  if (console_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    console_id_ = p;
  }
  return console_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExecuteCommandRequest::mutable_console_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_console_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest.console_id)
  return _msg;
}
inline void ExecuteCommandRequest::set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  if (console_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id));
    if (message_arena != submessage_arena) {
      console_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, console_id, submessage_arena);
    }
    
  } else {
    
  }
  console_id_ = console_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest.console_id)
}

// string code = 3;
inline void ExecuteCommandRequest::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& ExecuteCommandRequest::code() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteCommandRequest::set_code(ArgT0&& arg0, ArgT... args) {
 
 code_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest.code)
}
inline std::string* ExecuteCommandRequest::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest.code)
  return _s;
}
inline const std::string& ExecuteCommandRequest::_internal_code() const {
  return code_.Get();
}
inline void ExecuteCommandRequest::_internal_set_code(const std::string& value) {
  
  code_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteCommandRequest::_internal_mutable_code() {
  
  return code_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteCommandRequest::release_code() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest.code)
  return code_.Release();
}
inline void ExecuteCommandRequest::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocated(code, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (code_.IsDefault()) {
    code_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.ExecuteCommandRequest.code)
}

// -------------------------------------------------------------------

// ExecuteCommandResponse

// string error_message = 1;
inline void ExecuteCommandResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& ExecuteCommandResponse::error_message() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteCommandResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse.error_message)
}
inline std::string* ExecuteCommandResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse.error_message)
  return _s;
}
inline const std::string& ExecuteCommandResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void ExecuteCommandResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ExecuteCommandResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ExecuteCommandResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse.error_message)
  return error_message_.Release();
}
inline void ExecuteCommandResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault()) {
    error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse.error_message)
}

// .io.deephaven.proto.backplane.grpc.FieldsChangeUpdate changes = 2;
inline bool ExecuteCommandResponse::_internal_has_changes() const {
  return this != internal_default_instance() && changes_ != nullptr;
}
inline bool ExecuteCommandResponse::has_changes() const {
  return _internal_has_changes();
}
inline const ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate& ExecuteCommandResponse::_internal_changes() const {
  const ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* p = changes_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate&>(
      ::io::deephaven::proto::backplane::grpc::_FieldsChangeUpdate_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate& ExecuteCommandResponse::changes() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse.changes)
  return _internal_changes();
}
inline void ExecuteCommandResponse::unsafe_arena_set_allocated_changes(
    ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* changes) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes_);
  }
  changes_ = changes;
  if (changes) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse.changes)
}
inline ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* ExecuteCommandResponse::release_changes() {
  
  ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* temp = changes_;
  changes_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* ExecuteCommandResponse::unsafe_arena_release_changes() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse.changes)
  
  ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* temp = changes_;
  changes_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* ExecuteCommandResponse::_internal_mutable_changes() {
  
  if (changes_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate>(GetArenaForAllocation());
    changes_ = p;
  }
  return changes_;
}
inline ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* ExecuteCommandResponse::mutable_changes() {
  ::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* _msg = _internal_mutable_changes();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse.changes)
  return _msg;
}
inline void ExecuteCommandResponse::set_allocated_changes(::io::deephaven::proto::backplane::grpc::FieldsChangeUpdate* changes) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes_);
  }
  if (changes) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(changes));
    if (message_arena != submessage_arena) {
      changes = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, changes, submessage_arena);
    }
    
  } else {
    
  }
  changes_ = changes;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.ExecuteCommandResponse.changes)
}

// -------------------------------------------------------------------

// BindTableToVariableRequest

// .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
inline bool BindTableToVariableRequest::_internal_has_console_id() const {
  return this != internal_default_instance() && console_id_ != nullptr;
}
inline bool BindTableToVariableRequest::has_console_id() const {
  return _internal_has_console_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& BindTableToVariableRequest::_internal_console_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = console_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& BindTableToVariableRequest::console_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.console_id)
  return _internal_console_id();
}
inline void BindTableToVariableRequest::unsafe_arena_set_allocated_console_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  console_id_ = console_id;
  if (console_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.console_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* BindTableToVariableRequest::release_console_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* BindTableToVariableRequest::unsafe_arena_release_console_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.console_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* BindTableToVariableRequest::_internal_mutable_console_id() {
  
  if (console_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    console_id_ = p;
  }
  return console_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* BindTableToVariableRequest::mutable_console_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_console_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.console_id)
  return _msg;
}
inline void BindTableToVariableRequest::set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  if (console_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id));
    if (message_arena != submessage_arena) {
      console_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, console_id, submessage_arena);
    }
    
  } else {
    
  }
  console_id_ = console_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.console_id)
}

// string variable_name = 3;
inline void BindTableToVariableRequest::clear_variable_name() {
  variable_name_.ClearToEmpty();
}
inline const std::string& BindTableToVariableRequest::variable_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.variable_name)
  return _internal_variable_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BindTableToVariableRequest::set_variable_name(ArgT0&& arg0, ArgT... args) {
 
 variable_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.variable_name)
}
inline std::string* BindTableToVariableRequest::mutable_variable_name() {
  std::string* _s = _internal_mutable_variable_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.variable_name)
  return _s;
}
inline const std::string& BindTableToVariableRequest::_internal_variable_name() const {
  return variable_name_.Get();
}
inline void BindTableToVariableRequest::_internal_set_variable_name(const std::string& value) {
  
  variable_name_.Set(value, GetArenaForAllocation());
}
inline std::string* BindTableToVariableRequest::_internal_mutable_variable_name() {
  
  return variable_name_.Mutable(GetArenaForAllocation());
}
inline std::string* BindTableToVariableRequest::release_variable_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.variable_name)
  return variable_name_.Release();
}
inline void BindTableToVariableRequest::set_allocated_variable_name(std::string* variable_name) {
  if (variable_name != nullptr) {
    
  } else {
    
  }
  variable_name_.SetAllocated(variable_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (variable_name_.IsDefault()) {
    variable_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.variable_name)
}

// .io.deephaven.proto.backplane.grpc.Ticket table_id = 4;
inline bool BindTableToVariableRequest::_internal_has_table_id() const {
  return this != internal_default_instance() && table_id_ != nullptr;
}
inline bool BindTableToVariableRequest::has_table_id() const {
  return _internal_has_table_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& BindTableToVariableRequest::_internal_table_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = table_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& BindTableToVariableRequest::table_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.table_id)
  return _internal_table_id();
}
inline void BindTableToVariableRequest::unsafe_arena_set_allocated_table_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* table_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_id_);
  }
  table_id_ = table_id;
  if (table_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.table_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* BindTableToVariableRequest::release_table_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = table_id_;
  table_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* BindTableToVariableRequest::unsafe_arena_release_table_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.table_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = table_id_;
  table_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* BindTableToVariableRequest::_internal_mutable_table_id() {
  
  if (table_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    table_id_ = p;
  }
  return table_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* BindTableToVariableRequest::mutable_table_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_table_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.table_id)
  return _msg;
}
inline void BindTableToVariableRequest::set_allocated_table_id(::io::deephaven::proto::backplane::grpc::Ticket* table_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_id_);
  }
  if (table_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_id));
    if (message_arena != submessage_arena) {
      table_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_id, submessage_arena);
    }
    
  } else {
    
  }
  table_id_ = table_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.BindTableToVariableRequest.table_id)
}

// -------------------------------------------------------------------

// BindTableToVariableResponse

// -------------------------------------------------------------------

// CancelCommandRequest

// .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
inline bool CancelCommandRequest::_internal_has_console_id() const {
  return this != internal_default_instance() && console_id_ != nullptr;
}
inline bool CancelCommandRequest::has_console_id() const {
  return _internal_has_console_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CancelCommandRequest::_internal_console_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = console_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CancelCommandRequest::console_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CancelCommandRequest.console_id)
  return _internal_console_id();
}
inline void CancelCommandRequest::unsafe_arena_set_allocated_console_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  console_id_ = console_id;
  if (console_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.CancelCommandRequest.console_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CancelCommandRequest::release_console_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CancelCommandRequest::unsafe_arena_release_console_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.CancelCommandRequest.console_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CancelCommandRequest::_internal_mutable_console_id() {
  
  if (console_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    console_id_ = p;
  }
  return console_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CancelCommandRequest::mutable_console_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_console_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CancelCommandRequest.console_id)
  return _msg;
}
inline void CancelCommandRequest::set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  if (console_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id));
    if (message_arena != submessage_arena) {
      console_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, console_id, submessage_arena);
    }
    
  } else {
    
  }
  console_id_ = console_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.CancelCommandRequest.console_id)
}

// .io.deephaven.proto.backplane.grpc.Ticket command_id = 2;
inline bool CancelCommandRequest::_internal_has_command_id() const {
  return this != internal_default_instance() && command_id_ != nullptr;
}
inline bool CancelCommandRequest::has_command_id() const {
  return _internal_has_command_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CancelCommandRequest::_internal_command_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = command_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CancelCommandRequest::command_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CancelCommandRequest.command_id)
  return _internal_command_id();
}
inline void CancelCommandRequest::unsafe_arena_set_allocated_command_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* command_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_id_);
  }
  command_id_ = command_id;
  if (command_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.CancelCommandRequest.command_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CancelCommandRequest::release_command_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = command_id_;
  command_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CancelCommandRequest::unsafe_arena_release_command_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.CancelCommandRequest.command_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = command_id_;
  command_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CancelCommandRequest::_internal_mutable_command_id() {
  
  if (command_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    command_id_ = p;
  }
  return command_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CancelCommandRequest::mutable_command_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_command_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CancelCommandRequest.command_id)
  return _msg;
}
inline void CancelCommandRequest::set_allocated_command_id(::io::deephaven::proto::backplane::grpc::Ticket* command_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_id_);
  }
  if (command_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_id));
    if (message_arena != submessage_arena) {
      command_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command_id, submessage_arena);
    }
    
  } else {
    
  }
  command_id_ = command_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.CancelCommandRequest.command_id)
}

// -------------------------------------------------------------------

// CancelCommandResponse

// -------------------------------------------------------------------

// AutoCompleteRequest

// .io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest open_document = 1;
inline bool AutoCompleteRequest::_internal_has_open_document() const {
  return request_case() == kOpenDocument;
}
inline bool AutoCompleteRequest::has_open_document() const {
  return _internal_has_open_document();
}
inline void AutoCompleteRequest::set_has_open_document() {
  _oneof_case_[0] = kOpenDocument;
}
inline void AutoCompleteRequest::clear_open_document() {
  if (_internal_has_open_document()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_.open_document_;
    }
    clear_has_request();
  }
}
inline ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* AutoCompleteRequest::release_open_document() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.open_document)
  if (_internal_has_open_document()) {
    clear_has_request();
    ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* temp = request_.open_document_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.open_document_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& AutoCompleteRequest::_internal_open_document() const {
  return _internal_has_open_document()
      ? *request_.open_document_
      : reinterpret_cast< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest&>(::io::deephaven::proto::backplane::script::grpc::_OpenDocumentRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest& AutoCompleteRequest::open_document() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.open_document)
  return _internal_open_document();
}
inline ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* AutoCompleteRequest::unsafe_arena_release_open_document() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.open_document)
  if (_internal_has_open_document()) {
    clear_has_request();
    ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* temp = request_.open_document_;
    request_.open_document_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoCompleteRequest::unsafe_arena_set_allocated_open_document(::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* open_document) {
  clear_request();
  if (open_document) {
    set_has_open_document();
    request_.open_document_ = open_document;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.open_document)
}
inline ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* AutoCompleteRequest::_internal_mutable_open_document() {
  if (!_internal_has_open_document()) {
    clear_request();
    set_has_open_document();
    request_.open_document_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest >(GetArenaForAllocation());
  }
  return request_.open_document_;
}
inline ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* AutoCompleteRequest::mutable_open_document() {
  ::io::deephaven::proto::backplane::script::grpc::OpenDocumentRequest* _msg = _internal_mutable_open_document();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.open_document)
  return _msg;
}

// .io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest change_document = 2;
inline bool AutoCompleteRequest::_internal_has_change_document() const {
  return request_case() == kChangeDocument;
}
inline bool AutoCompleteRequest::has_change_document() const {
  return _internal_has_change_document();
}
inline void AutoCompleteRequest::set_has_change_document() {
  _oneof_case_[0] = kChangeDocument;
}
inline void AutoCompleteRequest::clear_change_document() {
  if (_internal_has_change_document()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_.change_document_;
    }
    clear_has_request();
  }
}
inline ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* AutoCompleteRequest::release_change_document() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.change_document)
  if (_internal_has_change_document()) {
    clear_has_request();
    ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* temp = request_.change_document_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.change_document_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& AutoCompleteRequest::_internal_change_document() const {
  return _internal_has_change_document()
      ? *request_.change_document_
      : reinterpret_cast< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest&>(::io::deephaven::proto::backplane::script::grpc::_ChangeDocumentRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest& AutoCompleteRequest::change_document() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.change_document)
  return _internal_change_document();
}
inline ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* AutoCompleteRequest::unsafe_arena_release_change_document() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.change_document)
  if (_internal_has_change_document()) {
    clear_has_request();
    ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* temp = request_.change_document_;
    request_.change_document_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoCompleteRequest::unsafe_arena_set_allocated_change_document(::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* change_document) {
  clear_request();
  if (change_document) {
    set_has_change_document();
    request_.change_document_ = change_document;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.change_document)
}
inline ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* AutoCompleteRequest::_internal_mutable_change_document() {
  if (!_internal_has_change_document()) {
    clear_request();
    set_has_change_document();
    request_.change_document_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest >(GetArenaForAllocation());
  }
  return request_.change_document_;
}
inline ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* AutoCompleteRequest::mutable_change_document() {
  ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest* _msg = _internal_mutable_change_document();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.change_document)
  return _msg;
}

// .io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest get_completion_items = 3;
inline bool AutoCompleteRequest::_internal_has_get_completion_items() const {
  return request_case() == kGetCompletionItems;
}
inline bool AutoCompleteRequest::has_get_completion_items() const {
  return _internal_has_get_completion_items();
}
inline void AutoCompleteRequest::set_has_get_completion_items() {
  _oneof_case_[0] = kGetCompletionItems;
}
inline void AutoCompleteRequest::clear_get_completion_items() {
  if (_internal_has_get_completion_items()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_.get_completion_items_;
    }
    clear_has_request();
  }
}
inline ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* AutoCompleteRequest::release_get_completion_items() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.get_completion_items)
  if (_internal_has_get_completion_items()) {
    clear_has_request();
    ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* temp = request_.get_completion_items_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.get_completion_items_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& AutoCompleteRequest::_internal_get_completion_items() const {
  return _internal_has_get_completion_items()
      ? *request_.get_completion_items_
      : reinterpret_cast< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest&>(::io::deephaven::proto::backplane::script::grpc::_GetCompletionItemsRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest& AutoCompleteRequest::get_completion_items() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.get_completion_items)
  return _internal_get_completion_items();
}
inline ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* AutoCompleteRequest::unsafe_arena_release_get_completion_items() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.get_completion_items)
  if (_internal_has_get_completion_items()) {
    clear_has_request();
    ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* temp = request_.get_completion_items_;
    request_.get_completion_items_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoCompleteRequest::unsafe_arena_set_allocated_get_completion_items(::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* get_completion_items) {
  clear_request();
  if (get_completion_items) {
    set_has_get_completion_items();
    request_.get_completion_items_ = get_completion_items;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.get_completion_items)
}
inline ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* AutoCompleteRequest::_internal_mutable_get_completion_items() {
  if (!_internal_has_get_completion_items()) {
    clear_request();
    set_has_get_completion_items();
    request_.get_completion_items_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest >(GetArenaForAllocation());
  }
  return request_.get_completion_items_;
}
inline ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* AutoCompleteRequest::mutable_get_completion_items() {
  ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsRequest* _msg = _internal_mutable_get_completion_items();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.get_completion_items)
  return _msg;
}

// .io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest close_document = 4;
inline bool AutoCompleteRequest::_internal_has_close_document() const {
  return request_case() == kCloseDocument;
}
inline bool AutoCompleteRequest::has_close_document() const {
  return _internal_has_close_document();
}
inline void AutoCompleteRequest::set_has_close_document() {
  _oneof_case_[0] = kCloseDocument;
}
inline void AutoCompleteRequest::clear_close_document() {
  if (_internal_has_close_document()) {
    if (GetArenaForAllocation() == nullptr) {
      delete request_.close_document_;
    }
    clear_has_request();
  }
}
inline ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* AutoCompleteRequest::release_close_document() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.close_document)
  if (_internal_has_close_document()) {
    clear_has_request();
    ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* temp = request_.close_document_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    request_.close_document_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& AutoCompleteRequest::_internal_close_document() const {
  return _internal_has_close_document()
      ? *request_.close_document_
      : reinterpret_cast< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest&>(::io::deephaven::proto::backplane::script::grpc::_CloseDocumentRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest& AutoCompleteRequest::close_document() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.close_document)
  return _internal_close_document();
}
inline ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* AutoCompleteRequest::unsafe_arena_release_close_document() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.close_document)
  if (_internal_has_close_document()) {
    clear_has_request();
    ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* temp = request_.close_document_;
    request_.close_document_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoCompleteRequest::unsafe_arena_set_allocated_close_document(::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* close_document) {
  clear_request();
  if (close_document) {
    set_has_close_document();
    request_.close_document_ = close_document;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.close_document)
}
inline ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* AutoCompleteRequest::_internal_mutable_close_document() {
  if (!_internal_has_close_document()) {
    clear_request();
    set_has_close_document();
    request_.close_document_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest >(GetArenaForAllocation());
  }
  return request_.close_document_;
}
inline ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* AutoCompleteRequest::mutable_close_document() {
  ::io::deephaven::proto::backplane::script::grpc::CloseDocumentRequest* _msg = _internal_mutable_close_document();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.AutoCompleteRequest.close_document)
  return _msg;
}

inline bool AutoCompleteRequest::has_request() const {
  return request_case() != REQUEST_NOT_SET;
}
inline void AutoCompleteRequest::clear_has_request() {
  _oneof_case_[0] = REQUEST_NOT_SET;
}
inline AutoCompleteRequest::RequestCase AutoCompleteRequest::request_case() const {
  return AutoCompleteRequest::RequestCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AutoCompleteResponse

// .io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse completion_items = 1;
inline bool AutoCompleteResponse::_internal_has_completion_items() const {
  return response_case() == kCompletionItems;
}
inline bool AutoCompleteResponse::has_completion_items() const {
  return _internal_has_completion_items();
}
inline void AutoCompleteResponse::set_has_completion_items() {
  _oneof_case_[0] = kCompletionItems;
}
inline void AutoCompleteResponse::clear_completion_items() {
  if (_internal_has_completion_items()) {
    if (GetArenaForAllocation() == nullptr) {
      delete response_.completion_items_;
    }
    clear_has_response();
  }
}
inline ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* AutoCompleteResponse::release_completion_items() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.AutoCompleteResponse.completion_items)
  if (_internal_has_completion_items()) {
    clear_has_response();
    ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* temp = response_.completion_items_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    response_.completion_items_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse& AutoCompleteResponse::_internal_completion_items() const {
  return _internal_has_completion_items()
      ? *response_.completion_items_
      : reinterpret_cast< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse&>(::io::deephaven::proto::backplane::script::grpc::_GetCompletionItemsResponse_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse& AutoCompleteResponse::completion_items() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.AutoCompleteResponse.completion_items)
  return _internal_completion_items();
}
inline ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* AutoCompleteResponse::unsafe_arena_release_completion_items() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.script.grpc.AutoCompleteResponse.completion_items)
  if (_internal_has_completion_items()) {
    clear_has_response();
    ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* temp = response_.completion_items_;
    response_.completion_items_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AutoCompleteResponse::unsafe_arena_set_allocated_completion_items(::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* completion_items) {
  clear_response();
  if (completion_items) {
    set_has_completion_items();
    response_.completion_items_ = completion_items;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.AutoCompleteResponse.completion_items)
}
inline ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* AutoCompleteResponse::_internal_mutable_completion_items() {
  if (!_internal_has_completion_items()) {
    clear_response();
    set_has_completion_items();
    response_.completion_items_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse >(GetArenaForAllocation());
  }
  return response_.completion_items_;
}
inline ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* AutoCompleteResponse::mutable_completion_items() {
  ::io::deephaven::proto::backplane::script::grpc::GetCompletionItemsResponse* _msg = _internal_mutable_completion_items();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.AutoCompleteResponse.completion_items)
  return _msg;
}

inline bool AutoCompleteResponse::has_response() const {
  return response_case() != RESPONSE_NOT_SET;
}
inline void AutoCompleteResponse::clear_has_response() {
  _oneof_case_[0] = RESPONSE_NOT_SET;
}
inline AutoCompleteResponse::ResponseCase AutoCompleteResponse::response_case() const {
  return AutoCompleteResponse::ResponseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BrowserNextResponse

// -------------------------------------------------------------------

// OpenDocumentRequest

// .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
inline bool OpenDocumentRequest::_internal_has_console_id() const {
  return this != internal_default_instance() && console_id_ != nullptr;
}
inline bool OpenDocumentRequest::has_console_id() const {
  return _internal_has_console_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& OpenDocumentRequest::_internal_console_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = console_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& OpenDocumentRequest::console_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest.console_id)
  return _internal_console_id();
}
inline void OpenDocumentRequest::unsafe_arena_set_allocated_console_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  console_id_ = console_id;
  if (console_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest.console_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* OpenDocumentRequest::release_console_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* OpenDocumentRequest::unsafe_arena_release_console_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest.console_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* OpenDocumentRequest::_internal_mutable_console_id() {
  
  if (console_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    console_id_ = p;
  }
  return console_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* OpenDocumentRequest::mutable_console_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_console_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest.console_id)
  return _msg;
}
inline void OpenDocumentRequest::set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  if (console_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id));
    if (message_arena != submessage_arena) {
      console_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, console_id, submessage_arena);
    }
    
  } else {
    
  }
  console_id_ = console_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest.console_id)
}

// .io.deephaven.proto.backplane.script.grpc.TextDocumentItem text_document = 2;
inline bool OpenDocumentRequest::_internal_has_text_document() const {
  return this != internal_default_instance() && text_document_ != nullptr;
}
inline bool OpenDocumentRequest::has_text_document() const {
  return _internal_has_text_document();
}
inline void OpenDocumentRequest::clear_text_document() {
  if (GetArenaForAllocation() == nullptr && text_document_ != nullptr) {
    delete text_document_;
  }
  text_document_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem& OpenDocumentRequest::_internal_text_document() const {
  const ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* p = text_document_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem&>(
      ::io::deephaven::proto::backplane::script::grpc::_TextDocumentItem_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem& OpenDocumentRequest::text_document() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest.text_document)
  return _internal_text_document();
}
inline void OpenDocumentRequest::unsafe_arena_set_allocated_text_document(
    ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* text_document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_document_);
  }
  text_document_ = text_document;
  if (text_document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest.text_document)
}
inline ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* OpenDocumentRequest::release_text_document() {
  
  ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* temp = text_document_;
  text_document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* OpenDocumentRequest::unsafe_arena_release_text_document() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest.text_document)
  
  ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* temp = text_document_;
  text_document_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* OpenDocumentRequest::_internal_mutable_text_document() {
  
  if (text_document_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::TextDocumentItem>(GetArenaForAllocation());
    text_document_ = p;
  }
  return text_document_;
}
inline ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* OpenDocumentRequest::mutable_text_document() {
  ::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* _msg = _internal_mutable_text_document();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest.text_document)
  return _msg;
}
inline void OpenDocumentRequest::set_allocated_text_document(::io::deephaven::proto::backplane::script::grpc::TextDocumentItem* text_document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete text_document_;
  }
  if (text_document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_document);
    if (message_arena != submessage_arena) {
      text_document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_document, submessage_arena);
    }
    
  } else {
    
  }
  text_document_ = text_document;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.OpenDocumentRequest.text_document)
}

// -------------------------------------------------------------------

// TextDocumentItem

// string uri = 1;
inline void TextDocumentItem::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& TextDocumentItem::uri() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextDocumentItem::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.uri)
}
inline std::string* TextDocumentItem::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.uri)
  return _s;
}
inline const std::string& TextDocumentItem::_internal_uri() const {
  return uri_.Get();
}
inline void TextDocumentItem::_internal_set_uri(const std::string& value) {
  
  uri_.Set(value, GetArenaForAllocation());
}
inline std::string* TextDocumentItem::_internal_mutable_uri() {
  
  return uri_.Mutable(GetArenaForAllocation());
}
inline std::string* TextDocumentItem::release_uri() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.uri)
  return uri_.Release();
}
inline void TextDocumentItem::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault()) {
    uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.uri)
}

// string language_id = 2;
inline void TextDocumentItem::clear_language_id() {
  language_id_.ClearToEmpty();
}
inline const std::string& TextDocumentItem::language_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.language_id)
  return _internal_language_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextDocumentItem::set_language_id(ArgT0&& arg0, ArgT... args) {
 
 language_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.language_id)
}
inline std::string* TextDocumentItem::mutable_language_id() {
  std::string* _s = _internal_mutable_language_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.language_id)
  return _s;
}
inline const std::string& TextDocumentItem::_internal_language_id() const {
  return language_id_.Get();
}
inline void TextDocumentItem::_internal_set_language_id(const std::string& value) {
  
  language_id_.Set(value, GetArenaForAllocation());
}
inline std::string* TextDocumentItem::_internal_mutable_language_id() {
  
  return language_id_.Mutable(GetArenaForAllocation());
}
inline std::string* TextDocumentItem::release_language_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.language_id)
  return language_id_.Release();
}
inline void TextDocumentItem::set_allocated_language_id(std::string* language_id) {
  if (language_id != nullptr) {
    
  } else {
    
  }
  language_id_.SetAllocated(language_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_id_.IsDefault()) {
    language_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.language_id)
}

// int32 version = 3;
inline void TextDocumentItem::clear_version() {
  version_ = 0;
}
inline int32_t TextDocumentItem::_internal_version() const {
  return version_;
}
inline int32_t TextDocumentItem::version() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.version)
  return _internal_version();
}
inline void TextDocumentItem::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void TextDocumentItem::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.version)
}

// string text = 4;
inline void TextDocumentItem::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& TextDocumentItem::text() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextDocumentItem::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.text)
}
inline std::string* TextDocumentItem::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.text)
  return _s;
}
inline const std::string& TextDocumentItem::_internal_text() const {
  return text_.Get();
}
inline void TextDocumentItem::_internal_set_text(const std::string& value) {
  
  text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextDocumentItem::_internal_mutable_text() {
  
  return text_.Mutable(GetArenaForAllocation());
}
inline std::string* TextDocumentItem::release_text() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.text)
  return text_.Release();
}
inline void TextDocumentItem::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.TextDocumentItem.text)
}

// -------------------------------------------------------------------

// CloseDocumentRequest

// .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
inline bool CloseDocumentRequest::_internal_has_console_id() const {
  return this != internal_default_instance() && console_id_ != nullptr;
}
inline bool CloseDocumentRequest::has_console_id() const {
  return _internal_has_console_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CloseDocumentRequest::_internal_console_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = console_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CloseDocumentRequest::console_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest.console_id)
  return _internal_console_id();
}
inline void CloseDocumentRequest::unsafe_arena_set_allocated_console_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  console_id_ = console_id;
  if (console_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest.console_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CloseDocumentRequest::release_console_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CloseDocumentRequest::unsafe_arena_release_console_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest.console_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CloseDocumentRequest::_internal_mutable_console_id() {
  
  if (console_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    console_id_ = p;
  }
  return console_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CloseDocumentRequest::mutable_console_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_console_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest.console_id)
  return _msg;
}
inline void CloseDocumentRequest::set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  if (console_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id));
    if (message_arena != submessage_arena) {
      console_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, console_id, submessage_arena);
    }
    
  } else {
    
  }
  console_id_ = console_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest.console_id)
}

// .io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier text_document = 2;
inline bool CloseDocumentRequest::_internal_has_text_document() const {
  return this != internal_default_instance() && text_document_ != nullptr;
}
inline bool CloseDocumentRequest::has_text_document() const {
  return _internal_has_text_document();
}
inline void CloseDocumentRequest::clear_text_document() {
  if (GetArenaForAllocation() == nullptr && text_document_ != nullptr) {
    delete text_document_;
  }
  text_document_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier& CloseDocumentRequest::_internal_text_document() const {
  const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* p = text_document_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier&>(
      ::io::deephaven::proto::backplane::script::grpc::_VersionedTextDocumentIdentifier_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier& CloseDocumentRequest::text_document() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest.text_document)
  return _internal_text_document();
}
inline void CloseDocumentRequest::unsafe_arena_set_allocated_text_document(
    ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_document_);
  }
  text_document_ = text_document;
  if (text_document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest.text_document)
}
inline ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* CloseDocumentRequest::release_text_document() {
  
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* temp = text_document_;
  text_document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* CloseDocumentRequest::unsafe_arena_release_text_document() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest.text_document)
  
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* temp = text_document_;
  text_document_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* CloseDocumentRequest::_internal_mutable_text_document() {
  
  if (text_document_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier>(GetArenaForAllocation());
    text_document_ = p;
  }
  return text_document_;
}
inline ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* CloseDocumentRequest::mutable_text_document() {
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* _msg = _internal_mutable_text_document();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest.text_document)
  return _msg;
}
inline void CloseDocumentRequest::set_allocated_text_document(::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete text_document_;
  }
  if (text_document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_document);
    if (message_arena != submessage_arena) {
      text_document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_document, submessage_arena);
    }
    
  } else {
    
  }
  text_document_ = text_document;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.CloseDocumentRequest.text_document)
}

// -------------------------------------------------------------------

// ChangeDocumentRequest_TextDocumentContentChangeEvent

// .io.deephaven.proto.backplane.script.grpc.DocumentRange range = 1;
inline bool ChangeDocumentRequest_TextDocumentContentChangeEvent::_internal_has_range() const {
  return this != internal_default_instance() && range_ != nullptr;
}
inline bool ChangeDocumentRequest_TextDocumentContentChangeEvent::has_range() const {
  return _internal_has_range();
}
inline void ChangeDocumentRequest_TextDocumentContentChangeEvent::clear_range() {
  if (GetArenaForAllocation() == nullptr && range_ != nullptr) {
    delete range_;
  }
  range_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::DocumentRange& ChangeDocumentRequest_TextDocumentContentChangeEvent::_internal_range() const {
  const ::io::deephaven::proto::backplane::script::grpc::DocumentRange* p = range_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::DocumentRange&>(
      ::io::deephaven::proto::backplane::script::grpc::_DocumentRange_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::DocumentRange& ChangeDocumentRequest_TextDocumentContentChangeEvent::range() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent.range)
  return _internal_range();
}
inline void ChangeDocumentRequest_TextDocumentContentChangeEvent::unsafe_arena_set_allocated_range(
    ::io::deephaven::proto::backplane::script::grpc::DocumentRange* range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_);
  }
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent.range)
}
inline ::io::deephaven::proto::backplane::script::grpc::DocumentRange* ChangeDocumentRequest_TextDocumentContentChangeEvent::release_range() {
  
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* temp = range_;
  range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::DocumentRange* ChangeDocumentRequest_TextDocumentContentChangeEvent::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent.range)
  
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* temp = range_;
  range_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::DocumentRange* ChangeDocumentRequest_TextDocumentContentChangeEvent::_internal_mutable_range() {
  
  if (range_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::DocumentRange>(GetArenaForAllocation());
    range_ = p;
  }
  return range_;
}
inline ::io::deephaven::proto::backplane::script::grpc::DocumentRange* ChangeDocumentRequest_TextDocumentContentChangeEvent::mutable_range() {
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent.range)
  return _msg;
}
inline void ChangeDocumentRequest_TextDocumentContentChangeEvent::set_allocated_range(::io::deephaven::proto::backplane::script::grpc::DocumentRange* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete range_;
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(range);
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    
  } else {
    
  }
  range_ = range;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent.range)
}

// int32 range_length = 2;
inline void ChangeDocumentRequest_TextDocumentContentChangeEvent::clear_range_length() {
  range_length_ = 0;
}
inline int32_t ChangeDocumentRequest_TextDocumentContentChangeEvent::_internal_range_length() const {
  return range_length_;
}
inline int32_t ChangeDocumentRequest_TextDocumentContentChangeEvent::range_length() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent.range_length)
  return _internal_range_length();
}
inline void ChangeDocumentRequest_TextDocumentContentChangeEvent::_internal_set_range_length(int32_t value) {
  
  range_length_ = value;
}
inline void ChangeDocumentRequest_TextDocumentContentChangeEvent::set_range_length(int32_t value) {
  _internal_set_range_length(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent.range_length)
}

// string text = 3;
inline void ChangeDocumentRequest_TextDocumentContentChangeEvent::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& ChangeDocumentRequest_TextDocumentContentChangeEvent::text() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChangeDocumentRequest_TextDocumentContentChangeEvent::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent.text)
}
inline std::string* ChangeDocumentRequest_TextDocumentContentChangeEvent::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent.text)
  return _s;
}
inline const std::string& ChangeDocumentRequest_TextDocumentContentChangeEvent::_internal_text() const {
  return text_.Get();
}
inline void ChangeDocumentRequest_TextDocumentContentChangeEvent::_internal_set_text(const std::string& value) {
  
  text_.Set(value, GetArenaForAllocation());
}
inline std::string* ChangeDocumentRequest_TextDocumentContentChangeEvent::_internal_mutable_text() {
  
  return text_.Mutable(GetArenaForAllocation());
}
inline std::string* ChangeDocumentRequest_TextDocumentContentChangeEvent::release_text() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent.text)
  return text_.Release();
}
inline void ChangeDocumentRequest_TextDocumentContentChangeEvent::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent.text)
}

// -------------------------------------------------------------------

// ChangeDocumentRequest

// .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
inline bool ChangeDocumentRequest::_internal_has_console_id() const {
  return this != internal_default_instance() && console_id_ != nullptr;
}
inline bool ChangeDocumentRequest::has_console_id() const {
  return _internal_has_console_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ChangeDocumentRequest::_internal_console_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = console_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ChangeDocumentRequest::console_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.console_id)
  return _internal_console_id();
}
inline void ChangeDocumentRequest::unsafe_arena_set_allocated_console_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  console_id_ = console_id;
  if (console_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.console_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ChangeDocumentRequest::release_console_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ChangeDocumentRequest::unsafe_arena_release_console_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.console_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ChangeDocumentRequest::_internal_mutable_console_id() {
  
  if (console_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    console_id_ = p;
  }
  return console_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ChangeDocumentRequest::mutable_console_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_console_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.console_id)
  return _msg;
}
inline void ChangeDocumentRequest::set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  if (console_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id));
    if (message_arena != submessage_arena) {
      console_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, console_id, submessage_arena);
    }
    
  } else {
    
  }
  console_id_ = console_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.console_id)
}

// .io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier text_document = 2;
inline bool ChangeDocumentRequest::_internal_has_text_document() const {
  return this != internal_default_instance() && text_document_ != nullptr;
}
inline bool ChangeDocumentRequest::has_text_document() const {
  return _internal_has_text_document();
}
inline void ChangeDocumentRequest::clear_text_document() {
  if (GetArenaForAllocation() == nullptr && text_document_ != nullptr) {
    delete text_document_;
  }
  text_document_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier& ChangeDocumentRequest::_internal_text_document() const {
  const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* p = text_document_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier&>(
      ::io::deephaven::proto::backplane::script::grpc::_VersionedTextDocumentIdentifier_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier& ChangeDocumentRequest::text_document() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.text_document)
  return _internal_text_document();
}
inline void ChangeDocumentRequest::unsafe_arena_set_allocated_text_document(
    ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_document_);
  }
  text_document_ = text_document;
  if (text_document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.text_document)
}
inline ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* ChangeDocumentRequest::release_text_document() {
  
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* temp = text_document_;
  text_document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* ChangeDocumentRequest::unsafe_arena_release_text_document() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.text_document)
  
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* temp = text_document_;
  text_document_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* ChangeDocumentRequest::_internal_mutable_text_document() {
  
  if (text_document_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier>(GetArenaForAllocation());
    text_document_ = p;
  }
  return text_document_;
}
inline ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* ChangeDocumentRequest::mutable_text_document() {
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* _msg = _internal_mutable_text_document();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.text_document)
  return _msg;
}
inline void ChangeDocumentRequest::set_allocated_text_document(::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete text_document_;
  }
  if (text_document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_document);
    if (message_arena != submessage_arena) {
      text_document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_document, submessage_arena);
    }
    
  } else {
    
  }
  text_document_ = text_document;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.text_document)
}

// repeated .io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.TextDocumentContentChangeEvent content_changes = 3;
inline int ChangeDocumentRequest::_internal_content_changes_size() const {
  return content_changes_.size();
}
inline int ChangeDocumentRequest::content_changes_size() const {
  return _internal_content_changes_size();
}
inline void ChangeDocumentRequest::clear_content_changes() {
  content_changes_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent* ChangeDocumentRequest::mutable_content_changes(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.content_changes)
  return content_changes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent >*
ChangeDocumentRequest::mutable_content_changes() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.content_changes)
  return &content_changes_;
}
inline const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent& ChangeDocumentRequest::_internal_content_changes(int index) const {
  return content_changes_.Get(index);
}
inline const ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent& ChangeDocumentRequest::content_changes(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.content_changes)
  return _internal_content_changes(index);
}
inline ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent* ChangeDocumentRequest::_internal_add_content_changes() {
  return content_changes_.Add();
}
inline ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent* ChangeDocumentRequest::add_content_changes() {
  ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent* _add = _internal_add_content_changes();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.content_changes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::ChangeDocumentRequest_TextDocumentContentChangeEvent >&
ChangeDocumentRequest::content_changes() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.ChangeDocumentRequest.content_changes)
  return content_changes_;
}

// -------------------------------------------------------------------

// DocumentRange

// .io.deephaven.proto.backplane.script.grpc.Position start = 1;
inline bool DocumentRange::_internal_has_start() const {
  return this != internal_default_instance() && start_ != nullptr;
}
inline bool DocumentRange::has_start() const {
  return _internal_has_start();
}
inline void DocumentRange::clear_start() {
  if (GetArenaForAllocation() == nullptr && start_ != nullptr) {
    delete start_;
  }
  start_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::Position& DocumentRange::_internal_start() const {
  const ::io::deephaven::proto::backplane::script::grpc::Position* p = start_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::Position&>(
      ::io::deephaven::proto::backplane::script::grpc::_Position_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::Position& DocumentRange::start() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.DocumentRange.start)
  return _internal_start();
}
inline void DocumentRange::unsafe_arena_set_allocated_start(
    ::io::deephaven::proto::backplane::script::grpc::Position* start) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.DocumentRange.start)
}
inline ::io::deephaven::proto::backplane::script::grpc::Position* DocumentRange::release_start() {
  
  ::io::deephaven::proto::backplane::script::grpc::Position* temp = start_;
  start_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::Position* DocumentRange::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.DocumentRange.start)
  
  ::io::deephaven::proto::backplane::script::grpc::Position* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::Position* DocumentRange::_internal_mutable_start() {
  
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::Position>(GetArenaForAllocation());
    start_ = p;
  }
  return start_;
}
inline ::io::deephaven::proto::backplane::script::grpc::Position* DocumentRange::mutable_start() {
  ::io::deephaven::proto::backplane::script::grpc::Position* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.DocumentRange.start)
  return _msg;
}
inline void DocumentRange::set_allocated_start(::io::deephaven::proto::backplane::script::grpc::Position* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete start_;
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start);
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.DocumentRange.start)
}

// .io.deephaven.proto.backplane.script.grpc.Position end = 2;
inline bool DocumentRange::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool DocumentRange::has_end() const {
  return _internal_has_end();
}
inline void DocumentRange::clear_end() {
  if (GetArenaForAllocation() == nullptr && end_ != nullptr) {
    delete end_;
  }
  end_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::Position& DocumentRange::_internal_end() const {
  const ::io::deephaven::proto::backplane::script::grpc::Position* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::Position&>(
      ::io::deephaven::proto::backplane::script::grpc::_Position_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::Position& DocumentRange::end() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.DocumentRange.end)
  return _internal_end();
}
inline void DocumentRange::unsafe_arena_set_allocated_end(
    ::io::deephaven::proto::backplane::script::grpc::Position* end) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.DocumentRange.end)
}
inline ::io::deephaven::proto::backplane::script::grpc::Position* DocumentRange::release_end() {
  
  ::io::deephaven::proto::backplane::script::grpc::Position* temp = end_;
  end_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::Position* DocumentRange::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.DocumentRange.end)
  
  ::io::deephaven::proto::backplane::script::grpc::Position* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::Position* DocumentRange::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::Position>(GetArenaForAllocation());
    end_ = p;
  }
  return end_;
}
inline ::io::deephaven::proto::backplane::script::grpc::Position* DocumentRange::mutable_end() {
  ::io::deephaven::proto::backplane::script::grpc::Position* _msg = _internal_mutable_end();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.DocumentRange.end)
  return _msg;
}
inline void DocumentRange::set_allocated_end(::io::deephaven::proto::backplane::script::grpc::Position* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete end_;
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(end);
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.DocumentRange.end)
}

// -------------------------------------------------------------------

// VersionedTextDocumentIdentifier

// string uri = 1;
inline void VersionedTextDocumentIdentifier::clear_uri() {
  uri_.ClearToEmpty();
}
inline const std::string& VersionedTextDocumentIdentifier::uri() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier.uri)
  return _internal_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VersionedTextDocumentIdentifier::set_uri(ArgT0&& arg0, ArgT... args) {
 
 uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier.uri)
}
inline std::string* VersionedTextDocumentIdentifier::mutable_uri() {
  std::string* _s = _internal_mutable_uri();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier.uri)
  return _s;
}
inline const std::string& VersionedTextDocumentIdentifier::_internal_uri() const {
  return uri_.Get();
}
inline void VersionedTextDocumentIdentifier::_internal_set_uri(const std::string& value) {
  
  uri_.Set(value, GetArenaForAllocation());
}
inline std::string* VersionedTextDocumentIdentifier::_internal_mutable_uri() {
  
  return uri_.Mutable(GetArenaForAllocation());
}
inline std::string* VersionedTextDocumentIdentifier::release_uri() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier.uri)
  return uri_.Release();
}
inline void VersionedTextDocumentIdentifier::set_allocated_uri(std::string* uri) {
  if (uri != nullptr) {
    
  } else {
    
  }
  uri_.SetAllocated(uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uri_.IsDefault()) {
    uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier.uri)
}

// int32 version = 2;
inline void VersionedTextDocumentIdentifier::clear_version() {
  version_ = 0;
}
inline int32_t VersionedTextDocumentIdentifier::_internal_version() const {
  return version_;
}
inline int32_t VersionedTextDocumentIdentifier::version() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier.version)
  return _internal_version();
}
inline void VersionedTextDocumentIdentifier::_internal_set_version(int32_t value) {
  
  version_ = value;
}
inline void VersionedTextDocumentIdentifier::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier.version)
}

// -------------------------------------------------------------------

// Position

// int32 line = 1;
inline void Position::clear_line() {
  line_ = 0;
}
inline int32_t Position::_internal_line() const {
  return line_;
}
inline int32_t Position::line() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.Position.line)
  return _internal_line();
}
inline void Position::_internal_set_line(int32_t value) {
  
  line_ = value;
}
inline void Position::set_line(int32_t value) {
  _internal_set_line(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.Position.line)
}

// int32 character = 2;
inline void Position::clear_character() {
  character_ = 0;
}
inline int32_t Position::_internal_character() const {
  return character_;
}
inline int32_t Position::character() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.Position.character)
  return _internal_character();
}
inline void Position::_internal_set_character(int32_t value) {
  
  character_ = value;
}
inline void Position::set_character(int32_t value) {
  _internal_set_character(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.Position.character)
}

// -------------------------------------------------------------------

// GetCompletionItemsRequest

// .io.deephaven.proto.backplane.grpc.Ticket console_id = 1;
inline bool GetCompletionItemsRequest::_internal_has_console_id() const {
  return this != internal_default_instance() && console_id_ != nullptr;
}
inline bool GetCompletionItemsRequest::has_console_id() const {
  return _internal_has_console_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& GetCompletionItemsRequest::_internal_console_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = console_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& GetCompletionItemsRequest::console_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.console_id)
  return _internal_console_id();
}
inline void GetCompletionItemsRequest::unsafe_arena_set_allocated_console_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  console_id_ = console_id;
  if (console_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.console_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* GetCompletionItemsRequest::release_console_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* GetCompletionItemsRequest::unsafe_arena_release_console_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.console_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = console_id_;
  console_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* GetCompletionItemsRequest::_internal_mutable_console_id() {
  
  if (console_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    console_id_ = p;
  }
  return console_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* GetCompletionItemsRequest::mutable_console_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_console_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.console_id)
  return _msg;
}
inline void GetCompletionItemsRequest::set_allocated_console_id(::io::deephaven::proto::backplane::grpc::Ticket* console_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id_);
  }
  if (console_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(console_id));
    if (message_arena != submessage_arena) {
      console_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, console_id, submessage_arena);
    }
    
  } else {
    
  }
  console_id_ = console_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.console_id)
}

// .io.deephaven.proto.backplane.script.grpc.CompletionContext context = 2;
inline bool GetCompletionItemsRequest::_internal_has_context() const {
  return this != internal_default_instance() && context_ != nullptr;
}
inline bool GetCompletionItemsRequest::has_context() const {
  return _internal_has_context();
}
inline void GetCompletionItemsRequest::clear_context() {
  if (GetArenaForAllocation() == nullptr && context_ != nullptr) {
    delete context_;
  }
  context_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::CompletionContext& GetCompletionItemsRequest::_internal_context() const {
  const ::io::deephaven::proto::backplane::script::grpc::CompletionContext* p = context_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::CompletionContext&>(
      ::io::deephaven::proto::backplane::script::grpc::_CompletionContext_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::CompletionContext& GetCompletionItemsRequest::context() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.context)
  return _internal_context();
}
inline void GetCompletionItemsRequest::unsafe_arena_set_allocated_context(
    ::io::deephaven::proto::backplane::script::grpc::CompletionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context_);
  }
  context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.context)
}
inline ::io::deephaven::proto::backplane::script::grpc::CompletionContext* GetCompletionItemsRequest::release_context() {
  
  ::io::deephaven::proto::backplane::script::grpc::CompletionContext* temp = context_;
  context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::CompletionContext* GetCompletionItemsRequest::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.context)
  
  ::io::deephaven::proto::backplane::script::grpc::CompletionContext* temp = context_;
  context_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::CompletionContext* GetCompletionItemsRequest::_internal_mutable_context() {
  
  if (context_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::CompletionContext>(GetArenaForAllocation());
    context_ = p;
  }
  return context_;
}
inline ::io::deephaven::proto::backplane::script::grpc::CompletionContext* GetCompletionItemsRequest::mutable_context() {
  ::io::deephaven::proto::backplane::script::grpc::CompletionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.context)
  return _msg;
}
inline void GetCompletionItemsRequest::set_allocated_context(::io::deephaven::proto::backplane::script::grpc::CompletionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.context)
}

// .io.deephaven.proto.backplane.script.grpc.VersionedTextDocumentIdentifier text_document = 3;
inline bool GetCompletionItemsRequest::_internal_has_text_document() const {
  return this != internal_default_instance() && text_document_ != nullptr;
}
inline bool GetCompletionItemsRequest::has_text_document() const {
  return _internal_has_text_document();
}
inline void GetCompletionItemsRequest::clear_text_document() {
  if (GetArenaForAllocation() == nullptr && text_document_ != nullptr) {
    delete text_document_;
  }
  text_document_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier& GetCompletionItemsRequest::_internal_text_document() const {
  const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* p = text_document_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier&>(
      ::io::deephaven::proto::backplane::script::grpc::_VersionedTextDocumentIdentifier_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier& GetCompletionItemsRequest::text_document() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.text_document)
  return _internal_text_document();
}
inline void GetCompletionItemsRequest::unsafe_arena_set_allocated_text_document(
    ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_document_);
  }
  text_document_ = text_document;
  if (text_document) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.text_document)
}
inline ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* GetCompletionItemsRequest::release_text_document() {
  
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* temp = text_document_;
  text_document_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* GetCompletionItemsRequest::unsafe_arena_release_text_document() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.text_document)
  
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* temp = text_document_;
  text_document_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* GetCompletionItemsRequest::_internal_mutable_text_document() {
  
  if (text_document_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier>(GetArenaForAllocation());
    text_document_ = p;
  }
  return text_document_;
}
inline ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* GetCompletionItemsRequest::mutable_text_document() {
  ::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* _msg = _internal_mutable_text_document();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.text_document)
  return _msg;
}
inline void GetCompletionItemsRequest::set_allocated_text_document(::io::deephaven::proto::backplane::script::grpc::VersionedTextDocumentIdentifier* text_document) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete text_document_;
  }
  if (text_document) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_document);
    if (message_arena != submessage_arena) {
      text_document = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_document, submessage_arena);
    }
    
  } else {
    
  }
  text_document_ = text_document;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.text_document)
}

// .io.deephaven.proto.backplane.script.grpc.Position position = 4;
inline bool GetCompletionItemsRequest::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool GetCompletionItemsRequest::has_position() const {
  return _internal_has_position();
}
inline void GetCompletionItemsRequest::clear_position() {
  if (GetArenaForAllocation() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::Position& GetCompletionItemsRequest::_internal_position() const {
  const ::io::deephaven::proto::backplane::script::grpc::Position* p = position_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::Position&>(
      ::io::deephaven::proto::backplane::script::grpc::_Position_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::Position& GetCompletionItemsRequest::position() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.position)
  return _internal_position();
}
inline void GetCompletionItemsRequest::unsafe_arena_set_allocated_position(
    ::io::deephaven::proto::backplane::script::grpc::Position* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position_);
  }
  position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.position)
}
inline ::io::deephaven::proto::backplane::script::grpc::Position* GetCompletionItemsRequest::release_position() {
  
  ::io::deephaven::proto::backplane::script::grpc::Position* temp = position_;
  position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::Position* GetCompletionItemsRequest::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.position)
  
  ::io::deephaven::proto::backplane::script::grpc::Position* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::Position* GetCompletionItemsRequest::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::Position>(GetArenaForAllocation());
    position_ = p;
  }
  return position_;
}
inline ::io::deephaven::proto::backplane::script::grpc::Position* GetCompletionItemsRequest::mutable_position() {
  ::io::deephaven::proto::backplane::script::grpc::Position* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.position)
  return _msg;
}
inline void GetCompletionItemsRequest::set_allocated_position(::io::deephaven::proto::backplane::script::grpc::Position* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(position);
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.position)
}

// int32 request_id = 5;
inline void GetCompletionItemsRequest::clear_request_id() {
  request_id_ = 0;
}
inline int32_t GetCompletionItemsRequest::_internal_request_id() const {
  return request_id_;
}
inline int32_t GetCompletionItemsRequest::request_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.request_id)
  return _internal_request_id();
}
inline void GetCompletionItemsRequest::_internal_set_request_id(int32_t value) {
  
  request_id_ = value;
}
inline void GetCompletionItemsRequest::set_request_id(int32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsRequest.request_id)
}

// -------------------------------------------------------------------

// CompletionContext

// int32 trigger_kind = 1;
inline void CompletionContext::clear_trigger_kind() {
  trigger_kind_ = 0;
}
inline int32_t CompletionContext::_internal_trigger_kind() const {
  return trigger_kind_;
}
inline int32_t CompletionContext::trigger_kind() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionContext.trigger_kind)
  return _internal_trigger_kind();
}
inline void CompletionContext::_internal_set_trigger_kind(int32_t value) {
  
  trigger_kind_ = value;
}
inline void CompletionContext::set_trigger_kind(int32_t value) {
  _internal_set_trigger_kind(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionContext.trigger_kind)
}

// string trigger_character = 2;
inline void CompletionContext::clear_trigger_character() {
  trigger_character_.ClearToEmpty();
}
inline const std::string& CompletionContext::trigger_character() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionContext.trigger_character)
  return _internal_trigger_character();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionContext::set_trigger_character(ArgT0&& arg0, ArgT... args) {
 
 trigger_character_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionContext.trigger_character)
}
inline std::string* CompletionContext::mutable_trigger_character() {
  std::string* _s = _internal_mutable_trigger_character();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CompletionContext.trigger_character)
  return _s;
}
inline const std::string& CompletionContext::_internal_trigger_character() const {
  return trigger_character_.Get();
}
inline void CompletionContext::_internal_set_trigger_character(const std::string& value) {
  
  trigger_character_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionContext::_internal_mutable_trigger_character() {
  
  return trigger_character_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionContext::release_trigger_character() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.CompletionContext.trigger_character)
  return trigger_character_.Release();
}
inline void CompletionContext::set_allocated_trigger_character(std::string* trigger_character) {
  if (trigger_character != nullptr) {
    
  } else {
    
  }
  trigger_character_.SetAllocated(trigger_character, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trigger_character_.IsDefault()) {
    trigger_character_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.CompletionContext.trigger_character)
}

// -------------------------------------------------------------------

// GetCompletionItemsResponse

// repeated .io.deephaven.proto.backplane.script.grpc.CompletionItem items = 1;
inline int GetCompletionItemsResponse::_internal_items_size() const {
  return items_.size();
}
inline int GetCompletionItemsResponse::items_size() const {
  return _internal_items_size();
}
inline void GetCompletionItemsResponse::clear_items() {
  items_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::CompletionItem* GetCompletionItemsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::CompletionItem >*
GetCompletionItemsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse.items)
  return &items_;
}
inline const ::io::deephaven::proto::backplane::script::grpc::CompletionItem& GetCompletionItemsResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::io::deephaven::proto::backplane::script::grpc::CompletionItem& GetCompletionItemsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse.items)
  return _internal_items(index);
}
inline ::io::deephaven::proto::backplane::script::grpc::CompletionItem* GetCompletionItemsResponse::_internal_add_items() {
  return items_.Add();
}
inline ::io::deephaven::proto::backplane::script::grpc::CompletionItem* GetCompletionItemsResponse::add_items() {
  ::io::deephaven::proto::backplane::script::grpc::CompletionItem* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::CompletionItem >&
GetCompletionItemsResponse::items() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse.items)
  return items_;
}

// int32 request_id = 2;
inline void GetCompletionItemsResponse::clear_request_id() {
  request_id_ = 0;
}
inline int32_t GetCompletionItemsResponse::_internal_request_id() const {
  return request_id_;
}
inline int32_t GetCompletionItemsResponse::request_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse.request_id)
  return _internal_request_id();
}
inline void GetCompletionItemsResponse::_internal_set_request_id(int32_t value) {
  
  request_id_ = value;
}
inline void GetCompletionItemsResponse::set_request_id(int32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse.request_id)
}

// bool success = 3;
inline void GetCompletionItemsResponse::clear_success() {
  success_ = false;
}
inline bool GetCompletionItemsResponse::_internal_success() const {
  return success_;
}
inline bool GetCompletionItemsResponse::success() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse.success)
  return _internal_success();
}
inline void GetCompletionItemsResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void GetCompletionItemsResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.GetCompletionItemsResponse.success)
}

// -------------------------------------------------------------------

// CompletionItem

// int32 start = 1;
inline void CompletionItem::clear_start() {
  start_ = 0;
}
inline int32_t CompletionItem::_internal_start() const {
  return start_;
}
inline int32_t CompletionItem::start() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.start)
  return _internal_start();
}
inline void CompletionItem::_internal_set_start(int32_t value) {
  
  start_ = value;
}
inline void CompletionItem::set_start(int32_t value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.start)
}

// int32 length = 2;
inline void CompletionItem::clear_length() {
  length_ = 0;
}
inline int32_t CompletionItem::_internal_length() const {
  return length_;
}
inline int32_t CompletionItem::length() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.length)
  return _internal_length();
}
inline void CompletionItem::_internal_set_length(int32_t value) {
  
  length_ = value;
}
inline void CompletionItem::set_length(int32_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.length)
}

// string label = 3;
inline void CompletionItem::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& CompletionItem::label() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionItem::set_label(ArgT0&& arg0, ArgT... args) {
 
 label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.label)
}
inline std::string* CompletionItem::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CompletionItem.label)
  return _s;
}
inline const std::string& CompletionItem::_internal_label() const {
  return label_.Get();
}
inline void CompletionItem::_internal_set_label(const std::string& value) {
  
  label_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionItem::_internal_mutable_label() {
  
  return label_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionItem::release_label() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.CompletionItem.label)
  return label_.Release();
}
inline void CompletionItem::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.CompletionItem.label)
}

// int32 kind = 4;
inline void CompletionItem::clear_kind() {
  kind_ = 0;
}
inline int32_t CompletionItem::_internal_kind() const {
  return kind_;
}
inline int32_t CompletionItem::kind() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.kind)
  return _internal_kind();
}
inline void CompletionItem::_internal_set_kind(int32_t value) {
  
  kind_ = value;
}
inline void CompletionItem::set_kind(int32_t value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.kind)
}

// string detail = 5;
inline void CompletionItem::clear_detail() {
  detail_.ClearToEmpty();
}
inline const std::string& CompletionItem::detail() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.detail)
  return _internal_detail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionItem::set_detail(ArgT0&& arg0, ArgT... args) {
 
 detail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.detail)
}
inline std::string* CompletionItem::mutable_detail() {
  std::string* _s = _internal_mutable_detail();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CompletionItem.detail)
  return _s;
}
inline const std::string& CompletionItem::_internal_detail() const {
  return detail_.Get();
}
inline void CompletionItem::_internal_set_detail(const std::string& value) {
  
  detail_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionItem::_internal_mutable_detail() {
  
  return detail_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionItem::release_detail() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.CompletionItem.detail)
  return detail_.Release();
}
inline void CompletionItem::set_allocated_detail(std::string* detail) {
  if (detail != nullptr) {
    
  } else {
    
  }
  detail_.SetAllocated(detail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (detail_.IsDefault()) {
    detail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.CompletionItem.detail)
}

// string documentation = 6;
inline void CompletionItem::clear_documentation() {
  documentation_.ClearToEmpty();
}
inline const std::string& CompletionItem::documentation() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.documentation)
  return _internal_documentation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionItem::set_documentation(ArgT0&& arg0, ArgT... args) {
 
 documentation_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.documentation)
}
inline std::string* CompletionItem::mutable_documentation() {
  std::string* _s = _internal_mutable_documentation();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CompletionItem.documentation)
  return _s;
}
inline const std::string& CompletionItem::_internal_documentation() const {
  return documentation_.Get();
}
inline void CompletionItem::_internal_set_documentation(const std::string& value) {
  
  documentation_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionItem::_internal_mutable_documentation() {
  
  return documentation_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionItem::release_documentation() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.CompletionItem.documentation)
  return documentation_.Release();
}
inline void CompletionItem::set_allocated_documentation(std::string* documentation) {
  if (documentation != nullptr) {
    
  } else {
    
  }
  documentation_.SetAllocated(documentation, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (documentation_.IsDefault()) {
    documentation_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.CompletionItem.documentation)
}

// bool deprecated = 7;
inline void CompletionItem::clear_deprecated() {
  deprecated_ = false;
}
inline bool CompletionItem::_internal_deprecated() const {
  return deprecated_;
}
inline bool CompletionItem::deprecated() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.deprecated)
  return _internal_deprecated();
}
inline void CompletionItem::_internal_set_deprecated(bool value) {
  
  deprecated_ = value;
}
inline void CompletionItem::set_deprecated(bool value) {
  _internal_set_deprecated(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.deprecated)
}

// bool preselect = 8;
inline void CompletionItem::clear_preselect() {
  preselect_ = false;
}
inline bool CompletionItem::_internal_preselect() const {
  return preselect_;
}
inline bool CompletionItem::preselect() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.preselect)
  return _internal_preselect();
}
inline void CompletionItem::_internal_set_preselect(bool value) {
  
  preselect_ = value;
}
inline void CompletionItem::set_preselect(bool value) {
  _internal_set_preselect(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.preselect)
}

// .io.deephaven.proto.backplane.script.grpc.TextEdit text_edit = 9;
inline bool CompletionItem::_internal_has_text_edit() const {
  return this != internal_default_instance() && text_edit_ != nullptr;
}
inline bool CompletionItem::has_text_edit() const {
  return _internal_has_text_edit();
}
inline void CompletionItem::clear_text_edit() {
  if (GetArenaForAllocation() == nullptr && text_edit_ != nullptr) {
    delete text_edit_;
  }
  text_edit_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::TextEdit& CompletionItem::_internal_text_edit() const {
  const ::io::deephaven::proto::backplane::script::grpc::TextEdit* p = text_edit_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::TextEdit&>(
      ::io::deephaven::proto::backplane::script::grpc::_TextEdit_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::TextEdit& CompletionItem::text_edit() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.text_edit)
  return _internal_text_edit();
}
inline void CompletionItem::unsafe_arena_set_allocated_text_edit(
    ::io::deephaven::proto::backplane::script::grpc::TextEdit* text_edit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(text_edit_);
  }
  text_edit_ = text_edit;
  if (text_edit) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.CompletionItem.text_edit)
}
inline ::io::deephaven::proto::backplane::script::grpc::TextEdit* CompletionItem::release_text_edit() {
  
  ::io::deephaven::proto::backplane::script::grpc::TextEdit* temp = text_edit_;
  text_edit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::TextEdit* CompletionItem::unsafe_arena_release_text_edit() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.CompletionItem.text_edit)
  
  ::io::deephaven::proto::backplane::script::grpc::TextEdit* temp = text_edit_;
  text_edit_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::TextEdit* CompletionItem::_internal_mutable_text_edit() {
  
  if (text_edit_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::TextEdit>(GetArenaForAllocation());
    text_edit_ = p;
  }
  return text_edit_;
}
inline ::io::deephaven::proto::backplane::script::grpc::TextEdit* CompletionItem::mutable_text_edit() {
  ::io::deephaven::proto::backplane::script::grpc::TextEdit* _msg = _internal_mutable_text_edit();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CompletionItem.text_edit)
  return _msg;
}
inline void CompletionItem::set_allocated_text_edit(::io::deephaven::proto::backplane::script::grpc::TextEdit* text_edit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete text_edit_;
  }
  if (text_edit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(text_edit);
    if (message_arena != submessage_arena) {
      text_edit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text_edit, submessage_arena);
    }
    
  } else {
    
  }
  text_edit_ = text_edit;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.CompletionItem.text_edit)
}

// string sort_text = 10;
inline void CompletionItem::clear_sort_text() {
  sort_text_.ClearToEmpty();
}
inline const std::string& CompletionItem::sort_text() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.sort_text)
  return _internal_sort_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionItem::set_sort_text(ArgT0&& arg0, ArgT... args) {
 
 sort_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.sort_text)
}
inline std::string* CompletionItem::mutable_sort_text() {
  std::string* _s = _internal_mutable_sort_text();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CompletionItem.sort_text)
  return _s;
}
inline const std::string& CompletionItem::_internal_sort_text() const {
  return sort_text_.Get();
}
inline void CompletionItem::_internal_set_sort_text(const std::string& value) {
  
  sort_text_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionItem::_internal_mutable_sort_text() {
  
  return sort_text_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionItem::release_sort_text() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.CompletionItem.sort_text)
  return sort_text_.Release();
}
inline void CompletionItem::set_allocated_sort_text(std::string* sort_text) {
  if (sort_text != nullptr) {
    
  } else {
    
  }
  sort_text_.SetAllocated(sort_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sort_text_.IsDefault()) {
    sort_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.CompletionItem.sort_text)
}

// string filter_text = 11;
inline void CompletionItem::clear_filter_text() {
  filter_text_.ClearToEmpty();
}
inline const std::string& CompletionItem::filter_text() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.filter_text)
  return _internal_filter_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CompletionItem::set_filter_text(ArgT0&& arg0, ArgT... args) {
 
 filter_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.filter_text)
}
inline std::string* CompletionItem::mutable_filter_text() {
  std::string* _s = _internal_mutable_filter_text();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CompletionItem.filter_text)
  return _s;
}
inline const std::string& CompletionItem::_internal_filter_text() const {
  return filter_text_.Get();
}
inline void CompletionItem::_internal_set_filter_text(const std::string& value) {
  
  filter_text_.Set(value, GetArenaForAllocation());
}
inline std::string* CompletionItem::_internal_mutable_filter_text() {
  
  return filter_text_.Mutable(GetArenaForAllocation());
}
inline std::string* CompletionItem::release_filter_text() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.CompletionItem.filter_text)
  return filter_text_.Release();
}
inline void CompletionItem::set_allocated_filter_text(std::string* filter_text) {
  if (filter_text != nullptr) {
    
  } else {
    
  }
  filter_text_.SetAllocated(filter_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_text_.IsDefault()) {
    filter_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.CompletionItem.filter_text)
}

// int32 insert_text_format = 12;
inline void CompletionItem::clear_insert_text_format() {
  insert_text_format_ = 0;
}
inline int32_t CompletionItem::_internal_insert_text_format() const {
  return insert_text_format_;
}
inline int32_t CompletionItem::insert_text_format() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.insert_text_format)
  return _internal_insert_text_format();
}
inline void CompletionItem::_internal_set_insert_text_format(int32_t value) {
  
  insert_text_format_ = value;
}
inline void CompletionItem::set_insert_text_format(int32_t value) {
  _internal_set_insert_text_format(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.insert_text_format)
}

// repeated .io.deephaven.proto.backplane.script.grpc.TextEdit additional_text_edits = 13;
inline int CompletionItem::_internal_additional_text_edits_size() const {
  return additional_text_edits_.size();
}
inline int CompletionItem::additional_text_edits_size() const {
  return _internal_additional_text_edits_size();
}
inline void CompletionItem::clear_additional_text_edits() {
  additional_text_edits_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::TextEdit* CompletionItem::mutable_additional_text_edits(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CompletionItem.additional_text_edits)
  return additional_text_edits_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::TextEdit >*
CompletionItem::mutable_additional_text_edits() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.CompletionItem.additional_text_edits)
  return &additional_text_edits_;
}
inline const ::io::deephaven::proto::backplane::script::grpc::TextEdit& CompletionItem::_internal_additional_text_edits(int index) const {
  return additional_text_edits_.Get(index);
}
inline const ::io::deephaven::proto::backplane::script::grpc::TextEdit& CompletionItem::additional_text_edits(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.additional_text_edits)
  return _internal_additional_text_edits(index);
}
inline ::io::deephaven::proto::backplane::script::grpc::TextEdit* CompletionItem::_internal_add_additional_text_edits() {
  return additional_text_edits_.Add();
}
inline ::io::deephaven::proto::backplane::script::grpc::TextEdit* CompletionItem::add_additional_text_edits() {
  ::io::deephaven::proto::backplane::script::grpc::TextEdit* _add = _internal_add_additional_text_edits();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.CompletionItem.additional_text_edits)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::TextEdit >&
CompletionItem::additional_text_edits() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.CompletionItem.additional_text_edits)
  return additional_text_edits_;
}

// repeated string commit_characters = 14;
inline int CompletionItem::_internal_commit_characters_size() const {
  return commit_characters_.size();
}
inline int CompletionItem::commit_characters_size() const {
  return _internal_commit_characters_size();
}
inline void CompletionItem::clear_commit_characters() {
  commit_characters_.Clear();
}
inline std::string* CompletionItem::add_commit_characters() {
  std::string* _s = _internal_add_commit_characters();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
  return _s;
}
inline const std::string& CompletionItem::_internal_commit_characters(int index) const {
  return commit_characters_.Get(index);
}
inline const std::string& CompletionItem::commit_characters(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
  return _internal_commit_characters(index);
}
inline std::string* CompletionItem::mutable_commit_characters(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
  return commit_characters_.Mutable(index);
}
inline void CompletionItem::set_commit_characters(int index, const std::string& value) {
  commit_characters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
}
inline void CompletionItem::set_commit_characters(int index, std::string&& value) {
  commit_characters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
}
inline void CompletionItem::set_commit_characters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  commit_characters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
}
inline void CompletionItem::set_commit_characters(int index, const char* value, size_t size) {
  commit_characters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
}
inline std::string* CompletionItem::_internal_add_commit_characters() {
  return commit_characters_.Add();
}
inline void CompletionItem::add_commit_characters(const std::string& value) {
  commit_characters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
}
inline void CompletionItem::add_commit_characters(std::string&& value) {
  commit_characters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
}
inline void CompletionItem::add_commit_characters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  commit_characters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
}
inline void CompletionItem::add_commit_characters(const char* value, size_t size) {
  commit_characters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CompletionItem::commit_characters() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
  return commit_characters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CompletionItem::mutable_commit_characters() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.CompletionItem.commit_characters)
  return &commit_characters_;
}

// -------------------------------------------------------------------

// TextEdit

// .io.deephaven.proto.backplane.script.grpc.DocumentRange range = 1;
inline bool TextEdit::_internal_has_range() const {
  return this != internal_default_instance() && range_ != nullptr;
}
inline bool TextEdit::has_range() const {
  return _internal_has_range();
}
inline void TextEdit::clear_range() {
  if (GetArenaForAllocation() == nullptr && range_ != nullptr) {
    delete range_;
  }
  range_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::DocumentRange& TextEdit::_internal_range() const {
  const ::io::deephaven::proto::backplane::script::grpc::DocumentRange* p = range_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::DocumentRange&>(
      ::io::deephaven::proto::backplane::script::grpc::_DocumentRange_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::DocumentRange& TextEdit::range() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.TextEdit.range)
  return _internal_range();
}
inline void TextEdit::unsafe_arena_set_allocated_range(
    ::io::deephaven::proto::backplane::script::grpc::DocumentRange* range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(range_);
  }
  range_ = range;
  if (range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.TextEdit.range)
}
inline ::io::deephaven::proto::backplane::script::grpc::DocumentRange* TextEdit::release_range() {
  
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* temp = range_;
  range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::DocumentRange* TextEdit::unsafe_arena_release_range() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.TextEdit.range)
  
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* temp = range_;
  range_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::DocumentRange* TextEdit::_internal_mutable_range() {
  
  if (range_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::DocumentRange>(GetArenaForAllocation());
    range_ = p;
  }
  return range_;
}
inline ::io::deephaven::proto::backplane::script::grpc::DocumentRange* TextEdit::mutable_range() {
  ::io::deephaven::proto::backplane::script::grpc::DocumentRange* _msg = _internal_mutable_range();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.TextEdit.range)
  return _msg;
}
inline void TextEdit::set_allocated_range(::io::deephaven::proto::backplane::script::grpc::DocumentRange* range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete range_;
  }
  if (range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(range);
    if (message_arena != submessage_arena) {
      range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, range, submessage_arena);
    }
    
  } else {
    
  }
  range_ = range;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.TextEdit.range)
}

// string text = 2;
inline void TextEdit::clear_text() {
  text_.ClearToEmpty();
}
inline const std::string& TextEdit::text() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.TextEdit.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TextEdit::set_text(ArgT0&& arg0, ArgT... args) {
 
 text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.TextEdit.text)
}
inline std::string* TextEdit::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.TextEdit.text)
  return _s;
}
inline const std::string& TextEdit::_internal_text() const {
  return text_.Get();
}
inline void TextEdit::_internal_set_text(const std::string& value) {
  
  text_.Set(value, GetArenaForAllocation());
}
inline std::string* TextEdit::_internal_mutable_text() {
  
  return text_.Mutable(GetArenaForAllocation());
}
inline std::string* TextEdit::release_text() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.TextEdit.text)
  return text_.Release();
}
inline void TextEdit::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    
  } else {
    
  }
  text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.TextEdit.text)
}

// -------------------------------------------------------------------

// FigureDescriptor_ChartDescriptor

// int32 colspan = 1;
inline void FigureDescriptor_ChartDescriptor::clear_colspan() {
  colspan_ = 0;
}
inline int32_t FigureDescriptor_ChartDescriptor::_internal_colspan() const {
  return colspan_;
}
inline int32_t FigureDescriptor_ChartDescriptor::colspan() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.colspan)
  return _internal_colspan();
}
inline void FigureDescriptor_ChartDescriptor::_internal_set_colspan(int32_t value) {
  
  colspan_ = value;
}
inline void FigureDescriptor_ChartDescriptor::set_colspan(int32_t value) {
  _internal_set_colspan(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.colspan)
}

// int32 rowspan = 2;
inline void FigureDescriptor_ChartDescriptor::clear_rowspan() {
  rowspan_ = 0;
}
inline int32_t FigureDescriptor_ChartDescriptor::_internal_rowspan() const {
  return rowspan_;
}
inline int32_t FigureDescriptor_ChartDescriptor::rowspan() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.rowspan)
  return _internal_rowspan();
}
inline void FigureDescriptor_ChartDescriptor::_internal_set_rowspan(int32_t value) {
  
  rowspan_ = value;
}
inline void FigureDescriptor_ChartDescriptor::set_rowspan(int32_t value) {
  _internal_set_rowspan(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.rowspan)
}

// repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor series = 3;
inline int FigureDescriptor_ChartDescriptor::_internal_series_size() const {
  return series_.size();
}
inline int FigureDescriptor_ChartDescriptor::series_size() const {
  return _internal_series_size();
}
inline void FigureDescriptor_ChartDescriptor::clear_series() {
  series_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor* FigureDescriptor_ChartDescriptor::mutable_series(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.series)
  return series_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor >*
FigureDescriptor_ChartDescriptor::mutable_series() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.series)
  return &series_;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor& FigureDescriptor_ChartDescriptor::_internal_series(int index) const {
  return series_.Get(index);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor& FigureDescriptor_ChartDescriptor::series(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.series)
  return _internal_series(index);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor* FigureDescriptor_ChartDescriptor::_internal_add_series() {
  return series_.Add();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor* FigureDescriptor_ChartDescriptor::add_series() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor* _add = _internal_add_series();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.series)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesDescriptor >&
FigureDescriptor_ChartDescriptor::series() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.series)
  return series_;
}

// repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor multi_series = 4;
inline int FigureDescriptor_ChartDescriptor::_internal_multi_series_size() const {
  return multi_series_.size();
}
inline int FigureDescriptor_ChartDescriptor::multi_series_size() const {
  return _internal_multi_series_size();
}
inline void FigureDescriptor_ChartDescriptor::clear_multi_series() {
  multi_series_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor* FigureDescriptor_ChartDescriptor::mutable_multi_series(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.multi_series)
  return multi_series_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor >*
FigureDescriptor_ChartDescriptor::mutable_multi_series() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.multi_series)
  return &multi_series_;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor& FigureDescriptor_ChartDescriptor::_internal_multi_series(int index) const {
  return multi_series_.Get(index);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor& FigureDescriptor_ChartDescriptor::multi_series(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.multi_series)
  return _internal_multi_series(index);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor* FigureDescriptor_ChartDescriptor::_internal_add_multi_series() {
  return multi_series_.Add();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor* FigureDescriptor_ChartDescriptor::add_multi_series() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor* _add = _internal_add_multi_series();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.multi_series)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesDescriptor >&
FigureDescriptor_ChartDescriptor::multi_series() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.multi_series)
  return multi_series_;
}

// repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor axes = 5;
inline int FigureDescriptor_ChartDescriptor::_internal_axes_size() const {
  return axes_.size();
}
inline int FigureDescriptor_ChartDescriptor::axes_size() const {
  return _internal_axes_size();
}
inline void FigureDescriptor_ChartDescriptor::clear_axes() {
  axes_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor* FigureDescriptor_ChartDescriptor::mutable_axes(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.axes)
  return axes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor >*
FigureDescriptor_ChartDescriptor::mutable_axes() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.axes)
  return &axes_;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor& FigureDescriptor_ChartDescriptor::_internal_axes(int index) const {
  return axes_.Get(index);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor& FigureDescriptor_ChartDescriptor::axes(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.axes)
  return _internal_axes(index);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor* FigureDescriptor_ChartDescriptor::_internal_add_axes() {
  return axes_.Add();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor* FigureDescriptor_ChartDescriptor::add_axes() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor* _add = _internal_add_axes();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.axes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor >&
FigureDescriptor_ChartDescriptor::axes() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.axes)
  return axes_;
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.ChartType chart_type = 6;
inline void FigureDescriptor_ChartDescriptor::clear_chart_type() {
  chart_type_ = 0;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor_ChartType FigureDescriptor_ChartDescriptor::_internal_chart_type() const {
  return static_cast< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor_ChartType >(chart_type_);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor_ChartType FigureDescriptor_ChartDescriptor::chart_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.chart_type)
  return _internal_chart_type();
}
inline void FigureDescriptor_ChartDescriptor::_internal_set_chart_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor_ChartType value) {
  
  chart_type_ = value;
}
inline void FigureDescriptor_ChartDescriptor::set_chart_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor_ChartType value) {
  _internal_set_chart_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.chart_type)
}

// optional string title = 7;
inline bool FigureDescriptor_ChartDescriptor::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FigureDescriptor_ChartDescriptor::has_title() const {
  return _internal_has_title();
}
inline void FigureDescriptor_ChartDescriptor::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FigureDescriptor_ChartDescriptor::title() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_ChartDescriptor::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title)
}
inline std::string* FigureDescriptor_ChartDescriptor::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title)
  return _s;
}
inline const std::string& FigureDescriptor_ChartDescriptor::_internal_title() const {
  return title_.Get();
}
inline void FigureDescriptor_ChartDescriptor::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_ChartDescriptor::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_ChartDescriptor::release_title() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FigureDescriptor_ChartDescriptor::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title)
}

// string title_font = 8;
inline void FigureDescriptor_ChartDescriptor::clear_title_font() {
  title_font_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_ChartDescriptor::title_font() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title_font)
  return _internal_title_font();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_ChartDescriptor::set_title_font(ArgT0&& arg0, ArgT... args) {
 
 title_font_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title_font)
}
inline std::string* FigureDescriptor_ChartDescriptor::mutable_title_font() {
  std::string* _s = _internal_mutable_title_font();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title_font)
  return _s;
}
inline const std::string& FigureDescriptor_ChartDescriptor::_internal_title_font() const {
  return title_font_.Get();
}
inline void FigureDescriptor_ChartDescriptor::_internal_set_title_font(const std::string& value) {
  
  title_font_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_ChartDescriptor::_internal_mutable_title_font() {
  
  return title_font_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_ChartDescriptor::release_title_font() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title_font)
  return title_font_.Release();
}
inline void FigureDescriptor_ChartDescriptor::set_allocated_title_font(std::string* title_font) {
  if (title_font != nullptr) {
    
  } else {
    
  }
  title_font_.SetAllocated(title_font, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_font_.IsDefault()) {
    title_font_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title_font)
}

// string title_color = 9;
inline void FigureDescriptor_ChartDescriptor::clear_title_color() {
  title_color_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_ChartDescriptor::title_color() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title_color)
  return _internal_title_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_ChartDescriptor::set_title_color(ArgT0&& arg0, ArgT... args) {
 
 title_color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title_color)
}
inline std::string* FigureDescriptor_ChartDescriptor::mutable_title_color() {
  std::string* _s = _internal_mutable_title_color();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title_color)
  return _s;
}
inline const std::string& FigureDescriptor_ChartDescriptor::_internal_title_color() const {
  return title_color_.Get();
}
inline void FigureDescriptor_ChartDescriptor::_internal_set_title_color(const std::string& value) {
  
  title_color_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_ChartDescriptor::_internal_mutable_title_color() {
  
  return title_color_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_ChartDescriptor::release_title_color() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title_color)
  return title_color_.Release();
}
inline void FigureDescriptor_ChartDescriptor::set_allocated_title_color(std::string* title_color) {
  if (title_color != nullptr) {
    
  } else {
    
  }
  title_color_.SetAllocated(title_color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_color_.IsDefault()) {
    title_color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.title_color)
}

// bool show_legend = 10;
inline void FigureDescriptor_ChartDescriptor::clear_show_legend() {
  show_legend_ = false;
}
inline bool FigureDescriptor_ChartDescriptor::_internal_show_legend() const {
  return show_legend_;
}
inline bool FigureDescriptor_ChartDescriptor::show_legend() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.show_legend)
  return _internal_show_legend();
}
inline void FigureDescriptor_ChartDescriptor::_internal_set_show_legend(bool value) {
  
  show_legend_ = value;
}
inline void FigureDescriptor_ChartDescriptor::set_show_legend(bool value) {
  _internal_set_show_legend(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.show_legend)
}

// string legend_font = 11;
inline void FigureDescriptor_ChartDescriptor::clear_legend_font() {
  legend_font_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_ChartDescriptor::legend_font() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.legend_font)
  return _internal_legend_font();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_ChartDescriptor::set_legend_font(ArgT0&& arg0, ArgT... args) {
 
 legend_font_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.legend_font)
}
inline std::string* FigureDescriptor_ChartDescriptor::mutable_legend_font() {
  std::string* _s = _internal_mutable_legend_font();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.legend_font)
  return _s;
}
inline const std::string& FigureDescriptor_ChartDescriptor::_internal_legend_font() const {
  return legend_font_.Get();
}
inline void FigureDescriptor_ChartDescriptor::_internal_set_legend_font(const std::string& value) {
  
  legend_font_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_ChartDescriptor::_internal_mutable_legend_font() {
  
  return legend_font_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_ChartDescriptor::release_legend_font() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.legend_font)
  return legend_font_.Release();
}
inline void FigureDescriptor_ChartDescriptor::set_allocated_legend_font(std::string* legend_font) {
  if (legend_font != nullptr) {
    
  } else {
    
  }
  legend_font_.SetAllocated(legend_font, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (legend_font_.IsDefault()) {
    legend_font_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.legend_font)
}

// string legend_color = 12;
inline void FigureDescriptor_ChartDescriptor::clear_legend_color() {
  legend_color_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_ChartDescriptor::legend_color() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.legend_color)
  return _internal_legend_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_ChartDescriptor::set_legend_color(ArgT0&& arg0, ArgT... args) {
 
 legend_color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.legend_color)
}
inline std::string* FigureDescriptor_ChartDescriptor::mutable_legend_color() {
  std::string* _s = _internal_mutable_legend_color();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.legend_color)
  return _s;
}
inline const std::string& FigureDescriptor_ChartDescriptor::_internal_legend_color() const {
  return legend_color_.Get();
}
inline void FigureDescriptor_ChartDescriptor::_internal_set_legend_color(const std::string& value) {
  
  legend_color_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_ChartDescriptor::_internal_mutable_legend_color() {
  
  return legend_color_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_ChartDescriptor::release_legend_color() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.legend_color)
  return legend_color_.Release();
}
inline void FigureDescriptor_ChartDescriptor::set_allocated_legend_color(std::string* legend_color) {
  if (legend_color != nullptr) {
    
  } else {
    
  }
  legend_color_.SetAllocated(legend_color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (legend_color_.IsDefault()) {
    legend_color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.legend_color)
}

// bool is3d = 13;
inline void FigureDescriptor_ChartDescriptor::clear_is3d() {
  is3d_ = false;
}
inline bool FigureDescriptor_ChartDescriptor::_internal_is3d() const {
  return is3d_;
}
inline bool FigureDescriptor_ChartDescriptor::is3d() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.is3d)
  return _internal_is3d();
}
inline void FigureDescriptor_ChartDescriptor::_internal_set_is3d(bool value) {
  
  is3d_ = value;
}
inline void FigureDescriptor_ChartDescriptor::set_is3d(bool value) {
  _internal_set_is3d(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor.is3d)
}

// -------------------------------------------------------------------

// FigureDescriptor_SeriesDescriptor

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesPlotStyle plot_style = 1;
inline void FigureDescriptor_SeriesDescriptor::clear_plot_style() {
  plot_style_ = 0;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle FigureDescriptor_SeriesDescriptor::_internal_plot_style() const {
  return static_cast< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle >(plot_style_);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle FigureDescriptor_SeriesDescriptor::plot_style() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.plot_style)
  return _internal_plot_style();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_plot_style(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle value) {
  
  plot_style_ = value;
}
inline void FigureDescriptor_SeriesDescriptor::set_plot_style(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle value) {
  _internal_set_plot_style(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.plot_style)
}

// string name = 2;
inline void FigureDescriptor_SeriesDescriptor::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_SeriesDescriptor::name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_SeriesDescriptor::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.name)
}
inline std::string* FigureDescriptor_SeriesDescriptor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.name)
  return _s;
}
inline const std::string& FigureDescriptor_SeriesDescriptor::_internal_name() const {
  return name_.Get();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::release_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.name)
  return name_.Release();
}
inline void FigureDescriptor_SeriesDescriptor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.name)
}

// optional bool lines_visible = 3;
inline bool FigureDescriptor_SeriesDescriptor::_internal_has_lines_visible() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FigureDescriptor_SeriesDescriptor::has_lines_visible() const {
  return _internal_has_lines_visible();
}
inline void FigureDescriptor_SeriesDescriptor::clear_lines_visible() {
  lines_visible_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool FigureDescriptor_SeriesDescriptor::_internal_lines_visible() const {
  return lines_visible_;
}
inline bool FigureDescriptor_SeriesDescriptor::lines_visible() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.lines_visible)
  return _internal_lines_visible();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_lines_visible(bool value) {
  _has_bits_[0] |= 0x00000008u;
  lines_visible_ = value;
}
inline void FigureDescriptor_SeriesDescriptor::set_lines_visible(bool value) {
  _internal_set_lines_visible(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.lines_visible)
}

// optional bool shapes_visible = 4;
inline bool FigureDescriptor_SeriesDescriptor::_internal_has_shapes_visible() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FigureDescriptor_SeriesDescriptor::has_shapes_visible() const {
  return _internal_has_shapes_visible();
}
inline void FigureDescriptor_SeriesDescriptor::clear_shapes_visible() {
  shapes_visible_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool FigureDescriptor_SeriesDescriptor::_internal_shapes_visible() const {
  return shapes_visible_;
}
inline bool FigureDescriptor_SeriesDescriptor::shapes_visible() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shapes_visible)
  return _internal_shapes_visible();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_shapes_visible(bool value) {
  _has_bits_[0] |= 0x00000010u;
  shapes_visible_ = value;
}
inline void FigureDescriptor_SeriesDescriptor::set_shapes_visible(bool value) {
  _internal_set_shapes_visible(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shapes_visible)
}

// bool gradient_visible = 5;
inline void FigureDescriptor_SeriesDescriptor::clear_gradient_visible() {
  gradient_visible_ = false;
}
inline bool FigureDescriptor_SeriesDescriptor::_internal_gradient_visible() const {
  return gradient_visible_;
}
inline bool FigureDescriptor_SeriesDescriptor::gradient_visible() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.gradient_visible)
  return _internal_gradient_visible();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_gradient_visible(bool value) {
  
  gradient_visible_ = value;
}
inline void FigureDescriptor_SeriesDescriptor::set_gradient_visible(bool value) {
  _internal_set_gradient_visible(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.gradient_visible)
}

// string line_color = 6;
inline void FigureDescriptor_SeriesDescriptor::clear_line_color() {
  line_color_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_SeriesDescriptor::line_color() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.line_color)
  return _internal_line_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_SeriesDescriptor::set_line_color(ArgT0&& arg0, ArgT... args) {
 
 line_color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.line_color)
}
inline std::string* FigureDescriptor_SeriesDescriptor::mutable_line_color() {
  std::string* _s = _internal_mutable_line_color();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.line_color)
  return _s;
}
inline const std::string& FigureDescriptor_SeriesDescriptor::_internal_line_color() const {
  return line_color_.Get();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_line_color(const std::string& value) {
  
  line_color_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::_internal_mutable_line_color() {
  
  return line_color_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::release_line_color() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.line_color)
  return line_color_.Release();
}
inline void FigureDescriptor_SeriesDescriptor::set_allocated_line_color(std::string* line_color) {
  if (line_color != nullptr) {
    
  } else {
    
  }
  line_color_.SetAllocated(line_color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (line_color_.IsDefault()) {
    line_color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.line_color)
}

// optional string point_label_format = 8;
inline bool FigureDescriptor_SeriesDescriptor::_internal_has_point_label_format() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FigureDescriptor_SeriesDescriptor::has_point_label_format() const {
  return _internal_has_point_label_format();
}
inline void FigureDescriptor_SeriesDescriptor::clear_point_label_format() {
  point_label_format_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FigureDescriptor_SeriesDescriptor::point_label_format() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.point_label_format)
  return _internal_point_label_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_SeriesDescriptor::set_point_label_format(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 point_label_format_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.point_label_format)
}
inline std::string* FigureDescriptor_SeriesDescriptor::mutable_point_label_format() {
  std::string* _s = _internal_mutable_point_label_format();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.point_label_format)
  return _s;
}
inline const std::string& FigureDescriptor_SeriesDescriptor::_internal_point_label_format() const {
  return point_label_format_.Get();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_point_label_format(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  point_label_format_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::_internal_mutable_point_label_format() {
  _has_bits_[0] |= 0x00000001u;
  return point_label_format_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::release_point_label_format() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.point_label_format)
  if (!_internal_has_point_label_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = point_label_format_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (point_label_format_.IsDefault()) {
    point_label_format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FigureDescriptor_SeriesDescriptor::set_allocated_point_label_format(std::string* point_label_format) {
  if (point_label_format != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  point_label_format_.SetAllocated(point_label_format, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (point_label_format_.IsDefault()) {
    point_label_format_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.point_label_format)
}

// optional string x_tool_tip_pattern = 9;
inline bool FigureDescriptor_SeriesDescriptor::_internal_has_x_tool_tip_pattern() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FigureDescriptor_SeriesDescriptor::has_x_tool_tip_pattern() const {
  return _internal_has_x_tool_tip_pattern();
}
inline void FigureDescriptor_SeriesDescriptor::clear_x_tool_tip_pattern() {
  x_tool_tip_pattern_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FigureDescriptor_SeriesDescriptor::x_tool_tip_pattern() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.x_tool_tip_pattern)
  return _internal_x_tool_tip_pattern();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_SeriesDescriptor::set_x_tool_tip_pattern(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 x_tool_tip_pattern_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.x_tool_tip_pattern)
}
inline std::string* FigureDescriptor_SeriesDescriptor::mutable_x_tool_tip_pattern() {
  std::string* _s = _internal_mutable_x_tool_tip_pattern();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.x_tool_tip_pattern)
  return _s;
}
inline const std::string& FigureDescriptor_SeriesDescriptor::_internal_x_tool_tip_pattern() const {
  return x_tool_tip_pattern_.Get();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_x_tool_tip_pattern(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  x_tool_tip_pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::_internal_mutable_x_tool_tip_pattern() {
  _has_bits_[0] |= 0x00000002u;
  return x_tool_tip_pattern_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::release_x_tool_tip_pattern() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.x_tool_tip_pattern)
  if (!_internal_has_x_tool_tip_pattern()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = x_tool_tip_pattern_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (x_tool_tip_pattern_.IsDefault()) {
    x_tool_tip_pattern_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FigureDescriptor_SeriesDescriptor::set_allocated_x_tool_tip_pattern(std::string* x_tool_tip_pattern) {
  if (x_tool_tip_pattern != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  x_tool_tip_pattern_.SetAllocated(x_tool_tip_pattern, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (x_tool_tip_pattern_.IsDefault()) {
    x_tool_tip_pattern_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.x_tool_tip_pattern)
}

// optional string y_tool_tip_pattern = 10;
inline bool FigureDescriptor_SeriesDescriptor::_internal_has_y_tool_tip_pattern() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FigureDescriptor_SeriesDescriptor::has_y_tool_tip_pattern() const {
  return _internal_has_y_tool_tip_pattern();
}
inline void FigureDescriptor_SeriesDescriptor::clear_y_tool_tip_pattern() {
  y_tool_tip_pattern_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FigureDescriptor_SeriesDescriptor::y_tool_tip_pattern() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.y_tool_tip_pattern)
  return _internal_y_tool_tip_pattern();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_SeriesDescriptor::set_y_tool_tip_pattern(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 y_tool_tip_pattern_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.y_tool_tip_pattern)
}
inline std::string* FigureDescriptor_SeriesDescriptor::mutable_y_tool_tip_pattern() {
  std::string* _s = _internal_mutable_y_tool_tip_pattern();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.y_tool_tip_pattern)
  return _s;
}
inline const std::string& FigureDescriptor_SeriesDescriptor::_internal_y_tool_tip_pattern() const {
  return y_tool_tip_pattern_.Get();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_y_tool_tip_pattern(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  y_tool_tip_pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::_internal_mutable_y_tool_tip_pattern() {
  _has_bits_[0] |= 0x00000004u;
  return y_tool_tip_pattern_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::release_y_tool_tip_pattern() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.y_tool_tip_pattern)
  if (!_internal_has_y_tool_tip_pattern()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = y_tool_tip_pattern_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (y_tool_tip_pattern_.IsDefault()) {
    y_tool_tip_pattern_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FigureDescriptor_SeriesDescriptor::set_allocated_y_tool_tip_pattern(std::string* y_tool_tip_pattern) {
  if (y_tool_tip_pattern != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  y_tool_tip_pattern_.SetAllocated(y_tool_tip_pattern, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (y_tool_tip_pattern_.IsDefault()) {
    y_tool_tip_pattern_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.y_tool_tip_pattern)
}

// string shape_label = 11;
inline void FigureDescriptor_SeriesDescriptor::clear_shape_label() {
  shape_label_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_SeriesDescriptor::shape_label() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape_label)
  return _internal_shape_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_SeriesDescriptor::set_shape_label(ArgT0&& arg0, ArgT... args) {
 
 shape_label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape_label)
}
inline std::string* FigureDescriptor_SeriesDescriptor::mutable_shape_label() {
  std::string* _s = _internal_mutable_shape_label();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape_label)
  return _s;
}
inline const std::string& FigureDescriptor_SeriesDescriptor::_internal_shape_label() const {
  return shape_label_.Get();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_shape_label(const std::string& value) {
  
  shape_label_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::_internal_mutable_shape_label() {
  
  return shape_label_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::release_shape_label() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape_label)
  return shape_label_.Release();
}
inline void FigureDescriptor_SeriesDescriptor::set_allocated_shape_label(std::string* shape_label) {
  if (shape_label != nullptr) {
    
  } else {
    
  }
  shape_label_.SetAllocated(shape_label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shape_label_.IsDefault()) {
    shape_label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape_label)
}

// optional double shape_size = 12;
inline bool FigureDescriptor_SeriesDescriptor::_internal_has_shape_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FigureDescriptor_SeriesDescriptor::has_shape_size() const {
  return _internal_has_shape_size();
}
inline void FigureDescriptor_SeriesDescriptor::clear_shape_size() {
  shape_size_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline double FigureDescriptor_SeriesDescriptor::_internal_shape_size() const {
  return shape_size_;
}
inline double FigureDescriptor_SeriesDescriptor::shape_size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape_size)
  return _internal_shape_size();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_shape_size(double value) {
  _has_bits_[0] |= 0x00000020u;
  shape_size_ = value;
}
inline void FigureDescriptor_SeriesDescriptor::set_shape_size(double value) {
  _internal_set_shape_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape_size)
}

// string shape_color = 13;
inline void FigureDescriptor_SeriesDescriptor::clear_shape_color() {
  shape_color_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_SeriesDescriptor::shape_color() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape_color)
  return _internal_shape_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_SeriesDescriptor::set_shape_color(ArgT0&& arg0, ArgT... args) {
 
 shape_color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape_color)
}
inline std::string* FigureDescriptor_SeriesDescriptor::mutable_shape_color() {
  std::string* _s = _internal_mutable_shape_color();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape_color)
  return _s;
}
inline const std::string& FigureDescriptor_SeriesDescriptor::_internal_shape_color() const {
  return shape_color_.Get();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_shape_color(const std::string& value) {
  
  shape_color_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::_internal_mutable_shape_color() {
  
  return shape_color_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::release_shape_color() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape_color)
  return shape_color_.Release();
}
inline void FigureDescriptor_SeriesDescriptor::set_allocated_shape_color(std::string* shape_color) {
  if (shape_color != nullptr) {
    
  } else {
    
  }
  shape_color_.SetAllocated(shape_color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shape_color_.IsDefault()) {
    shape_color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape_color)
}

// string shape = 14;
inline void FigureDescriptor_SeriesDescriptor::clear_shape() {
  shape_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_SeriesDescriptor::shape() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape)
  return _internal_shape();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_SeriesDescriptor::set_shape(ArgT0&& arg0, ArgT... args) {
 
 shape_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape)
}
inline std::string* FigureDescriptor_SeriesDescriptor::mutable_shape() {
  std::string* _s = _internal_mutable_shape();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape)
  return _s;
}
inline const std::string& FigureDescriptor_SeriesDescriptor::_internal_shape() const {
  return shape_.Get();
}
inline void FigureDescriptor_SeriesDescriptor::_internal_set_shape(const std::string& value) {
  
  shape_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::_internal_mutable_shape() {
  
  return shape_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SeriesDescriptor::release_shape() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape)
  return shape_.Release();
}
inline void FigureDescriptor_SeriesDescriptor::set_allocated_shape(std::string* shape) {
  if (shape != nullptr) {
    
  } else {
    
  }
  shape_.SetAllocated(shape, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shape_.IsDefault()) {
    shape_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.shape)
}

// repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor data_sources = 15;
inline int FigureDescriptor_SeriesDescriptor::_internal_data_sources_size() const {
  return data_sources_.size();
}
inline int FigureDescriptor_SeriesDescriptor::data_sources_size() const {
  return _internal_data_sources_size();
}
inline void FigureDescriptor_SeriesDescriptor::clear_data_sources() {
  data_sources_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor* FigureDescriptor_SeriesDescriptor::mutable_data_sources(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.data_sources)
  return data_sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor >*
FigureDescriptor_SeriesDescriptor::mutable_data_sources() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.data_sources)
  return &data_sources_;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor& FigureDescriptor_SeriesDescriptor::_internal_data_sources(int index) const {
  return data_sources_.Get(index);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor& FigureDescriptor_SeriesDescriptor::data_sources(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.data_sources)
  return _internal_data_sources(index);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor* FigureDescriptor_SeriesDescriptor::_internal_add_data_sources() {
  return data_sources_.Add();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor* FigureDescriptor_SeriesDescriptor::add_data_sources() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor* _add = _internal_add_data_sources();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.data_sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceDescriptor >&
FigureDescriptor_SeriesDescriptor::data_sources() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesDescriptor.data_sources)
  return data_sources_;
}

// -------------------------------------------------------------------

// FigureDescriptor_MultiSeriesDescriptor

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SeriesPlotStyle plot_style = 1;
inline void FigureDescriptor_MultiSeriesDescriptor::clear_plot_style() {
  plot_style_ = 0;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle FigureDescriptor_MultiSeriesDescriptor::_internal_plot_style() const {
  return static_cast< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle >(plot_style_);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle FigureDescriptor_MultiSeriesDescriptor::plot_style() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.plot_style)
  return _internal_plot_style();
}
inline void FigureDescriptor_MultiSeriesDescriptor::_internal_set_plot_style(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle value) {
  
  plot_style_ = value;
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_plot_style(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle value) {
  _internal_set_plot_style(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.plot_style)
}

// string name = 2;
inline void FigureDescriptor_MultiSeriesDescriptor::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_MultiSeriesDescriptor::name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_MultiSeriesDescriptor::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.name)
}
inline std::string* FigureDescriptor_MultiSeriesDescriptor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.name)
  return _s;
}
inline const std::string& FigureDescriptor_MultiSeriesDescriptor::_internal_name() const {
  return name_.Get();
}
inline void FigureDescriptor_MultiSeriesDescriptor::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_MultiSeriesDescriptor::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_MultiSeriesDescriptor::release_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.name)
  return name_.Release();
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.name)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault line_color = 3;
inline bool FigureDescriptor_MultiSeriesDescriptor::_internal_has_line_color() const {
  return this != internal_default_instance() && line_color_ != nullptr;
}
inline bool FigureDescriptor_MultiSeriesDescriptor::has_line_color() const {
  return _internal_has_line_color();
}
inline void FigureDescriptor_MultiSeriesDescriptor::clear_line_color() {
  if (GetArenaForAllocation() == nullptr && line_color_ != nullptr) {
    delete line_color_;
  }
  line_color_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::_internal_line_color() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* p = line_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_StringMapWithDefault_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::line_color() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.line_color)
  return _internal_line_color();
}
inline void FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_set_allocated_line_color(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* line_color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(line_color_);
  }
  line_color_ = line_color;
  if (line_color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.line_color)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::release_line_color() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = line_color_;
  line_color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_release_line_color() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.line_color)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = line_color_;
  line_color_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::_internal_mutable_line_color() {
  
  if (line_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault>(GetArenaForAllocation());
    line_color_ = p;
  }
  return line_color_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::mutable_line_color() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _msg = _internal_mutable_line_color();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.line_color)
  return _msg;
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_allocated_line_color(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* line_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete line_color_;
  }
  if (line_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(line_color);
    if (message_arena != submessage_arena) {
      line_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, line_color, submessage_arena);
    }
    
  } else {
    
  }
  line_color_ = line_color;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.line_color)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault point_color = 4;
inline bool FigureDescriptor_MultiSeriesDescriptor::_internal_has_point_color() const {
  return this != internal_default_instance() && point_color_ != nullptr;
}
inline bool FigureDescriptor_MultiSeriesDescriptor::has_point_color() const {
  return _internal_has_point_color();
}
inline void FigureDescriptor_MultiSeriesDescriptor::clear_point_color() {
  if (GetArenaForAllocation() == nullptr && point_color_ != nullptr) {
    delete point_color_;
  }
  point_color_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::_internal_point_color() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* p = point_color_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_StringMapWithDefault_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::point_color() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_color)
  return _internal_point_color();
}
inline void FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_set_allocated_point_color(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_color_);
  }
  point_color_ = point_color;
  if (point_color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_color)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::release_point_color() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = point_color_;
  point_color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_release_point_color() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_color)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = point_color_;
  point_color_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::_internal_mutable_point_color() {
  
  if (point_color_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault>(GetArenaForAllocation());
    point_color_ = p;
  }
  return point_color_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::mutable_point_color() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _msg = _internal_mutable_point_color();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_color)
  return _msg;
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_allocated_point_color(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete point_color_;
  }
  if (point_color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point_color);
    if (message_arena != submessage_arena) {
      point_color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_color, submessage_arena);
    }
    
  } else {
    
  }
  point_color_ = point_color;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_color)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault lines_visible = 5;
inline bool FigureDescriptor_MultiSeriesDescriptor::_internal_has_lines_visible() const {
  return this != internal_default_instance() && lines_visible_ != nullptr;
}
inline bool FigureDescriptor_MultiSeriesDescriptor::has_lines_visible() const {
  return _internal_has_lines_visible();
}
inline void FigureDescriptor_MultiSeriesDescriptor::clear_lines_visible() {
  if (GetArenaForAllocation() == nullptr && lines_visible_ != nullptr) {
    delete lines_visible_;
  }
  lines_visible_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::_internal_lines_visible() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* p = lines_visible_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_BoolMapWithDefault_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::lines_visible() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.lines_visible)
  return _internal_lines_visible();
}
inline void FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_set_allocated_lines_visible(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* lines_visible) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lines_visible_);
  }
  lines_visible_ = lines_visible;
  if (lines_visible) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.lines_visible)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::release_lines_visible() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* temp = lines_visible_;
  lines_visible_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_release_lines_visible() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.lines_visible)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* temp = lines_visible_;
  lines_visible_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::_internal_mutable_lines_visible() {
  
  if (lines_visible_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault>(GetArenaForAllocation());
    lines_visible_ = p;
  }
  return lines_visible_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::mutable_lines_visible() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* _msg = _internal_mutable_lines_visible();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.lines_visible)
  return _msg;
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_allocated_lines_visible(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* lines_visible) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lines_visible_;
  }
  if (lines_visible) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lines_visible);
    if (message_arena != submessage_arena) {
      lines_visible = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lines_visible, submessage_arena);
    }
    
  } else {
    
  }
  lines_visible_ = lines_visible;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.lines_visible)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault points_visible = 6;
inline bool FigureDescriptor_MultiSeriesDescriptor::_internal_has_points_visible() const {
  return this != internal_default_instance() && points_visible_ != nullptr;
}
inline bool FigureDescriptor_MultiSeriesDescriptor::has_points_visible() const {
  return _internal_has_points_visible();
}
inline void FigureDescriptor_MultiSeriesDescriptor::clear_points_visible() {
  if (GetArenaForAllocation() == nullptr && points_visible_ != nullptr) {
    delete points_visible_;
  }
  points_visible_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::_internal_points_visible() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* p = points_visible_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_BoolMapWithDefault_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::points_visible() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.points_visible)
  return _internal_points_visible();
}
inline void FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_set_allocated_points_visible(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* points_visible) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(points_visible_);
  }
  points_visible_ = points_visible;
  if (points_visible) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.points_visible)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::release_points_visible() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* temp = points_visible_;
  points_visible_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_release_points_visible() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.points_visible)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* temp = points_visible_;
  points_visible_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::_internal_mutable_points_visible() {
  
  if (points_visible_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault>(GetArenaForAllocation());
    points_visible_ = p;
  }
  return points_visible_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::mutable_points_visible() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* _msg = _internal_mutable_points_visible();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.points_visible)
  return _msg;
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_allocated_points_visible(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* points_visible) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete points_visible_;
  }
  if (points_visible) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(points_visible);
    if (message_arena != submessage_arena) {
      points_visible = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, points_visible, submessage_arena);
    }
    
  } else {
    
  }
  points_visible_ = points_visible;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.points_visible)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault gradient_visible = 7;
inline bool FigureDescriptor_MultiSeriesDescriptor::_internal_has_gradient_visible() const {
  return this != internal_default_instance() && gradient_visible_ != nullptr;
}
inline bool FigureDescriptor_MultiSeriesDescriptor::has_gradient_visible() const {
  return _internal_has_gradient_visible();
}
inline void FigureDescriptor_MultiSeriesDescriptor::clear_gradient_visible() {
  if (GetArenaForAllocation() == nullptr && gradient_visible_ != nullptr) {
    delete gradient_visible_;
  }
  gradient_visible_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::_internal_gradient_visible() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* p = gradient_visible_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_BoolMapWithDefault_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::gradient_visible() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.gradient_visible)
  return _internal_gradient_visible();
}
inline void FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_set_allocated_gradient_visible(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* gradient_visible) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gradient_visible_);
  }
  gradient_visible_ = gradient_visible;
  if (gradient_visible) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.gradient_visible)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::release_gradient_visible() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* temp = gradient_visible_;
  gradient_visible_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_release_gradient_visible() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.gradient_visible)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* temp = gradient_visible_;
  gradient_visible_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::_internal_mutable_gradient_visible() {
  
  if (gradient_visible_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault>(GetArenaForAllocation());
    gradient_visible_ = p;
  }
  return gradient_visible_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::mutable_gradient_visible() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* _msg = _internal_mutable_gradient_visible();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.gradient_visible)
  return _msg;
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_allocated_gradient_visible(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BoolMapWithDefault* gradient_visible) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gradient_visible_;
  }
  if (gradient_visible) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gradient_visible);
    if (message_arena != submessage_arena) {
      gradient_visible = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gradient_visible, submessage_arena);
    }
    
  } else {
    
  }
  gradient_visible_ = gradient_visible;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.gradient_visible)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault point_label_format = 8;
inline bool FigureDescriptor_MultiSeriesDescriptor::_internal_has_point_label_format() const {
  return this != internal_default_instance() && point_label_format_ != nullptr;
}
inline bool FigureDescriptor_MultiSeriesDescriptor::has_point_label_format() const {
  return _internal_has_point_label_format();
}
inline void FigureDescriptor_MultiSeriesDescriptor::clear_point_label_format() {
  if (GetArenaForAllocation() == nullptr && point_label_format_ != nullptr) {
    delete point_label_format_;
  }
  point_label_format_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::_internal_point_label_format() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* p = point_label_format_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_StringMapWithDefault_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::point_label_format() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_label_format)
  return _internal_point_label_format();
}
inline void FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_set_allocated_point_label_format(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_label_format) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_label_format_);
  }
  point_label_format_ = point_label_format;
  if (point_label_format) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_label_format)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::release_point_label_format() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = point_label_format_;
  point_label_format_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_release_point_label_format() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_label_format)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = point_label_format_;
  point_label_format_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::_internal_mutable_point_label_format() {
  
  if (point_label_format_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault>(GetArenaForAllocation());
    point_label_format_ = p;
  }
  return point_label_format_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::mutable_point_label_format() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _msg = _internal_mutable_point_label_format();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_label_format)
  return _msg;
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_allocated_point_label_format(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_label_format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete point_label_format_;
  }
  if (point_label_format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point_label_format);
    if (message_arena != submessage_arena) {
      point_label_format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_label_format, submessage_arena);
    }
    
  } else {
    
  }
  point_label_format_ = point_label_format;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_label_format)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault x_tool_tip_pattern = 9;
inline bool FigureDescriptor_MultiSeriesDescriptor::_internal_has_x_tool_tip_pattern() const {
  return this != internal_default_instance() && x_tool_tip_pattern_ != nullptr;
}
inline bool FigureDescriptor_MultiSeriesDescriptor::has_x_tool_tip_pattern() const {
  return _internal_has_x_tool_tip_pattern();
}
inline void FigureDescriptor_MultiSeriesDescriptor::clear_x_tool_tip_pattern() {
  if (GetArenaForAllocation() == nullptr && x_tool_tip_pattern_ != nullptr) {
    delete x_tool_tip_pattern_;
  }
  x_tool_tip_pattern_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::_internal_x_tool_tip_pattern() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* p = x_tool_tip_pattern_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_StringMapWithDefault_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::x_tool_tip_pattern() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.x_tool_tip_pattern)
  return _internal_x_tool_tip_pattern();
}
inline void FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_set_allocated_x_tool_tip_pattern(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* x_tool_tip_pattern) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(x_tool_tip_pattern_);
  }
  x_tool_tip_pattern_ = x_tool_tip_pattern;
  if (x_tool_tip_pattern) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.x_tool_tip_pattern)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::release_x_tool_tip_pattern() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = x_tool_tip_pattern_;
  x_tool_tip_pattern_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_release_x_tool_tip_pattern() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.x_tool_tip_pattern)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = x_tool_tip_pattern_;
  x_tool_tip_pattern_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::_internal_mutable_x_tool_tip_pattern() {
  
  if (x_tool_tip_pattern_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault>(GetArenaForAllocation());
    x_tool_tip_pattern_ = p;
  }
  return x_tool_tip_pattern_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::mutable_x_tool_tip_pattern() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _msg = _internal_mutable_x_tool_tip_pattern();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.x_tool_tip_pattern)
  return _msg;
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_allocated_x_tool_tip_pattern(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* x_tool_tip_pattern) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete x_tool_tip_pattern_;
  }
  if (x_tool_tip_pattern) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(x_tool_tip_pattern);
    if (message_arena != submessage_arena) {
      x_tool_tip_pattern = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, x_tool_tip_pattern, submessage_arena);
    }
    
  } else {
    
  }
  x_tool_tip_pattern_ = x_tool_tip_pattern;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.x_tool_tip_pattern)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault y_tool_tip_pattern = 10;
inline bool FigureDescriptor_MultiSeriesDescriptor::_internal_has_y_tool_tip_pattern() const {
  return this != internal_default_instance() && y_tool_tip_pattern_ != nullptr;
}
inline bool FigureDescriptor_MultiSeriesDescriptor::has_y_tool_tip_pattern() const {
  return _internal_has_y_tool_tip_pattern();
}
inline void FigureDescriptor_MultiSeriesDescriptor::clear_y_tool_tip_pattern() {
  if (GetArenaForAllocation() == nullptr && y_tool_tip_pattern_ != nullptr) {
    delete y_tool_tip_pattern_;
  }
  y_tool_tip_pattern_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::_internal_y_tool_tip_pattern() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* p = y_tool_tip_pattern_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_StringMapWithDefault_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::y_tool_tip_pattern() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.y_tool_tip_pattern)
  return _internal_y_tool_tip_pattern();
}
inline void FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_set_allocated_y_tool_tip_pattern(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* y_tool_tip_pattern) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(y_tool_tip_pattern_);
  }
  y_tool_tip_pattern_ = y_tool_tip_pattern;
  if (y_tool_tip_pattern) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.y_tool_tip_pattern)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::release_y_tool_tip_pattern() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = y_tool_tip_pattern_;
  y_tool_tip_pattern_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_release_y_tool_tip_pattern() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.y_tool_tip_pattern)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = y_tool_tip_pattern_;
  y_tool_tip_pattern_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::_internal_mutable_y_tool_tip_pattern() {
  
  if (y_tool_tip_pattern_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault>(GetArenaForAllocation());
    y_tool_tip_pattern_ = p;
  }
  return y_tool_tip_pattern_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::mutable_y_tool_tip_pattern() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _msg = _internal_mutable_y_tool_tip_pattern();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.y_tool_tip_pattern)
  return _msg;
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_allocated_y_tool_tip_pattern(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* y_tool_tip_pattern) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete y_tool_tip_pattern_;
  }
  if (y_tool_tip_pattern) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(y_tool_tip_pattern);
    if (message_arena != submessage_arena) {
      y_tool_tip_pattern = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, y_tool_tip_pattern, submessage_arena);
    }
    
  } else {
    
  }
  y_tool_tip_pattern_ = y_tool_tip_pattern;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.y_tool_tip_pattern)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault point_label = 11;
inline bool FigureDescriptor_MultiSeriesDescriptor::_internal_has_point_label() const {
  return this != internal_default_instance() && point_label_ != nullptr;
}
inline bool FigureDescriptor_MultiSeriesDescriptor::has_point_label() const {
  return _internal_has_point_label();
}
inline void FigureDescriptor_MultiSeriesDescriptor::clear_point_label() {
  if (GetArenaForAllocation() == nullptr && point_label_ != nullptr) {
    delete point_label_;
  }
  point_label_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::_internal_point_label() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* p = point_label_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_StringMapWithDefault_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::point_label() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_label)
  return _internal_point_label();
}
inline void FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_set_allocated_point_label(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_label) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_label_);
  }
  point_label_ = point_label;
  if (point_label) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_label)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::release_point_label() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = point_label_;
  point_label_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_release_point_label() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_label)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = point_label_;
  point_label_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::_internal_mutable_point_label() {
  
  if (point_label_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault>(GetArenaForAllocation());
    point_label_ = p;
  }
  return point_label_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::mutable_point_label() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _msg = _internal_mutable_point_label();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_label)
  return _msg;
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_allocated_point_label(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_label) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete point_label_;
  }
  if (point_label) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point_label);
    if (message_arena != submessage_arena) {
      point_label = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_label, submessage_arena);
    }
    
  } else {
    
  }
  point_label_ = point_label;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_label)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault point_size = 12;
inline bool FigureDescriptor_MultiSeriesDescriptor::_internal_has_point_size() const {
  return this != internal_default_instance() && point_size_ != nullptr;
}
inline bool FigureDescriptor_MultiSeriesDescriptor::has_point_size() const {
  return _internal_has_point_size();
}
inline void FigureDescriptor_MultiSeriesDescriptor::clear_point_size() {
  if (GetArenaForAllocation() == nullptr && point_size_ != nullptr) {
    delete point_size_;
  }
  point_size_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::_internal_point_size() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* p = point_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_DoubleMapWithDefault_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::point_size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_size)
  return _internal_point_size();
}
inline void FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_set_allocated_point_size(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* point_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_size_);
  }
  point_size_ = point_size;
  if (point_size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_size)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::release_point_size() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* temp = point_size_;
  point_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_release_point_size() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_size)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* temp = point_size_;
  point_size_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::_internal_mutable_point_size() {
  
  if (point_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault>(GetArenaForAllocation());
    point_size_ = p;
  }
  return point_size_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::mutable_point_size() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* _msg = _internal_mutable_point_size();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_size)
  return _msg;
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_allocated_point_size(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_DoubleMapWithDefault* point_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete point_size_;
  }
  if (point_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point_size);
    if (message_arena != submessage_arena) {
      point_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_size, submessage_arena);
    }
    
  } else {
    
  }
  point_size_ = point_size;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_size)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault point_shape = 13;
inline bool FigureDescriptor_MultiSeriesDescriptor::_internal_has_point_shape() const {
  return this != internal_default_instance() && point_shape_ != nullptr;
}
inline bool FigureDescriptor_MultiSeriesDescriptor::has_point_shape() const {
  return _internal_has_point_shape();
}
inline void FigureDescriptor_MultiSeriesDescriptor::clear_point_shape() {
  if (GetArenaForAllocation() == nullptr && point_shape_ != nullptr) {
    delete point_shape_;
  }
  point_shape_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::_internal_point_shape() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* p = point_shape_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_StringMapWithDefault_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault& FigureDescriptor_MultiSeriesDescriptor::point_shape() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_shape)
  return _internal_point_shape();
}
inline void FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_set_allocated_point_shape(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_shape) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(point_shape_);
  }
  point_shape_ = point_shape;
  if (point_shape) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_shape)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::release_point_shape() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = point_shape_;
  point_shape_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::unsafe_arena_release_point_shape() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_shape)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* temp = point_shape_;
  point_shape_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::_internal_mutable_point_shape() {
  
  if (point_shape_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault>(GetArenaForAllocation());
    point_shape_ = p;
  }
  return point_shape_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* FigureDescriptor_MultiSeriesDescriptor::mutable_point_shape() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* _msg = _internal_mutable_point_shape();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_shape)
  return _msg;
}
inline void FigureDescriptor_MultiSeriesDescriptor::set_allocated_point_shape(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_StringMapWithDefault* point_shape) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete point_shape_;
  }
  if (point_shape) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(point_shape);
    if (message_arena != submessage_arena) {
      point_shape = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, point_shape, submessage_arena);
    }
    
  } else {
    
  }
  point_shape_ = point_shape;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.point_shape)
}

// repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor data_sources = 14;
inline int FigureDescriptor_MultiSeriesDescriptor::_internal_data_sources_size() const {
  return data_sources_.size();
}
inline int FigureDescriptor_MultiSeriesDescriptor::data_sources_size() const {
  return _internal_data_sources_size();
}
inline void FigureDescriptor_MultiSeriesDescriptor::clear_data_sources() {
  data_sources_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor* FigureDescriptor_MultiSeriesDescriptor::mutable_data_sources(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.data_sources)
  return data_sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor >*
FigureDescriptor_MultiSeriesDescriptor::mutable_data_sources() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.data_sources)
  return &data_sources_;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor& FigureDescriptor_MultiSeriesDescriptor::_internal_data_sources(int index) const {
  return data_sources_.Get(index);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor& FigureDescriptor_MultiSeriesDescriptor::data_sources(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.data_sources)
  return _internal_data_sources(index);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor* FigureDescriptor_MultiSeriesDescriptor::_internal_add_data_sources() {
  return data_sources_.Add();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor* FigureDescriptor_MultiSeriesDescriptor::add_data_sources() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor* _add = _internal_add_data_sources();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.data_sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_MultiSeriesSourceDescriptor >&
FigureDescriptor_MultiSeriesDescriptor::data_sources() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesDescriptor.data_sources)
  return data_sources_;
}

// -------------------------------------------------------------------

// FigureDescriptor_StringMapWithDefault

// optional string default_string = 1;
inline bool FigureDescriptor_StringMapWithDefault::_internal_has_default_string() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FigureDescriptor_StringMapWithDefault::has_default_string() const {
  return _internal_has_default_string();
}
inline void FigureDescriptor_StringMapWithDefault::clear_default_string() {
  default_string_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FigureDescriptor_StringMapWithDefault::default_string() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.default_string)
  return _internal_default_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_StringMapWithDefault::set_default_string(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 default_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.default_string)
}
inline std::string* FigureDescriptor_StringMapWithDefault::mutable_default_string() {
  std::string* _s = _internal_mutable_default_string();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.default_string)
  return _s;
}
inline const std::string& FigureDescriptor_StringMapWithDefault::_internal_default_string() const {
  return default_string_.Get();
}
inline void FigureDescriptor_StringMapWithDefault::_internal_set_default_string(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  default_string_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_StringMapWithDefault::_internal_mutable_default_string() {
  _has_bits_[0] |= 0x00000001u;
  return default_string_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_StringMapWithDefault::release_default_string() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.default_string)
  if (!_internal_has_default_string()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = default_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (default_string_.IsDefault()) {
    default_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FigureDescriptor_StringMapWithDefault::set_allocated_default_string(std::string* default_string) {
  if (default_string != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  default_string_.SetAllocated(default_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (default_string_.IsDefault()) {
    default_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.default_string)
}

// repeated string keys = 2;
inline int FigureDescriptor_StringMapWithDefault::_internal_keys_size() const {
  return keys_.size();
}
inline int FigureDescriptor_StringMapWithDefault::keys_size() const {
  return _internal_keys_size();
}
inline void FigureDescriptor_StringMapWithDefault::clear_keys() {
  keys_.Clear();
}
inline std::string* FigureDescriptor_StringMapWithDefault::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
  return _s;
}
inline const std::string& FigureDescriptor_StringMapWithDefault::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& FigureDescriptor_StringMapWithDefault::keys(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
  return _internal_keys(index);
}
inline std::string* FigureDescriptor_StringMapWithDefault::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
  return keys_.Mutable(index);
}
inline void FigureDescriptor_StringMapWithDefault::set_keys(int index, const std::string& value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
}
inline void FigureDescriptor_StringMapWithDefault::set_keys(int index, std::string&& value) {
  keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
}
inline void FigureDescriptor_StringMapWithDefault::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
}
inline void FigureDescriptor_StringMapWithDefault::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
}
inline std::string* FigureDescriptor_StringMapWithDefault::_internal_add_keys() {
  return keys_.Add();
}
inline void FigureDescriptor_StringMapWithDefault::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
}
inline void FigureDescriptor_StringMapWithDefault::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
}
inline void FigureDescriptor_StringMapWithDefault::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
}
inline void FigureDescriptor_StringMapWithDefault::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FigureDescriptor_StringMapWithDefault::keys() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FigureDescriptor_StringMapWithDefault::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.keys)
  return &keys_;
}

// repeated string values = 3;
inline int FigureDescriptor_StringMapWithDefault::_internal_values_size() const {
  return values_.size();
}
inline int FigureDescriptor_StringMapWithDefault::values_size() const {
  return _internal_values_size();
}
inline void FigureDescriptor_StringMapWithDefault::clear_values() {
  values_.Clear();
}
inline std::string* FigureDescriptor_StringMapWithDefault::add_values() {
  std::string* _s = _internal_add_values();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
  return _s;
}
inline const std::string& FigureDescriptor_StringMapWithDefault::_internal_values(int index) const {
  return values_.Get(index);
}
inline const std::string& FigureDescriptor_StringMapWithDefault::values(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
  return _internal_values(index);
}
inline std::string* FigureDescriptor_StringMapWithDefault::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
  return values_.Mutable(index);
}
inline void FigureDescriptor_StringMapWithDefault::set_values(int index, const std::string& value) {
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
}
inline void FigureDescriptor_StringMapWithDefault::set_values(int index, std::string&& value) {
  values_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
}
inline void FigureDescriptor_StringMapWithDefault::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
}
inline void FigureDescriptor_StringMapWithDefault::set_values(int index, const char* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
}
inline std::string* FigureDescriptor_StringMapWithDefault::_internal_add_values() {
  return values_.Add();
}
inline void FigureDescriptor_StringMapWithDefault::add_values(const std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
}
inline void FigureDescriptor_StringMapWithDefault::add_values(std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
}
inline void FigureDescriptor_StringMapWithDefault::add_values(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
}
inline void FigureDescriptor_StringMapWithDefault::add_values(const char* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FigureDescriptor_StringMapWithDefault::values() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
  return values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FigureDescriptor_StringMapWithDefault::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.StringMapWithDefault.values)
  return &values_;
}

// -------------------------------------------------------------------

// FigureDescriptor_DoubleMapWithDefault

// optional double default_double = 1;
inline bool FigureDescriptor_DoubleMapWithDefault::_internal_has_default_double() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FigureDescriptor_DoubleMapWithDefault::has_default_double() const {
  return _internal_has_default_double();
}
inline void FigureDescriptor_DoubleMapWithDefault::clear_default_double() {
  default_double_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double FigureDescriptor_DoubleMapWithDefault::_internal_default_double() const {
  return default_double_;
}
inline double FigureDescriptor_DoubleMapWithDefault::default_double() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.default_double)
  return _internal_default_double();
}
inline void FigureDescriptor_DoubleMapWithDefault::_internal_set_default_double(double value) {
  _has_bits_[0] |= 0x00000001u;
  default_double_ = value;
}
inline void FigureDescriptor_DoubleMapWithDefault::set_default_double(double value) {
  _internal_set_default_double(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.default_double)
}

// repeated string keys = 2;
inline int FigureDescriptor_DoubleMapWithDefault::_internal_keys_size() const {
  return keys_.size();
}
inline int FigureDescriptor_DoubleMapWithDefault::keys_size() const {
  return _internal_keys_size();
}
inline void FigureDescriptor_DoubleMapWithDefault::clear_keys() {
  keys_.Clear();
}
inline std::string* FigureDescriptor_DoubleMapWithDefault::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
  return _s;
}
inline const std::string& FigureDescriptor_DoubleMapWithDefault::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& FigureDescriptor_DoubleMapWithDefault::keys(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
  return _internal_keys(index);
}
inline std::string* FigureDescriptor_DoubleMapWithDefault::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
  return keys_.Mutable(index);
}
inline void FigureDescriptor_DoubleMapWithDefault::set_keys(int index, const std::string& value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
}
inline void FigureDescriptor_DoubleMapWithDefault::set_keys(int index, std::string&& value) {
  keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
}
inline void FigureDescriptor_DoubleMapWithDefault::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
}
inline void FigureDescriptor_DoubleMapWithDefault::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
}
inline std::string* FigureDescriptor_DoubleMapWithDefault::_internal_add_keys() {
  return keys_.Add();
}
inline void FigureDescriptor_DoubleMapWithDefault::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
}
inline void FigureDescriptor_DoubleMapWithDefault::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
}
inline void FigureDescriptor_DoubleMapWithDefault::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
}
inline void FigureDescriptor_DoubleMapWithDefault::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FigureDescriptor_DoubleMapWithDefault::keys() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FigureDescriptor_DoubleMapWithDefault::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.keys)
  return &keys_;
}

// repeated double values = 3;
inline int FigureDescriptor_DoubleMapWithDefault::_internal_values_size() const {
  return values_.size();
}
inline int FigureDescriptor_DoubleMapWithDefault::values_size() const {
  return _internal_values_size();
}
inline void FigureDescriptor_DoubleMapWithDefault::clear_values() {
  values_.Clear();
}
inline double FigureDescriptor_DoubleMapWithDefault::_internal_values(int index) const {
  return values_.Get(index);
}
inline double FigureDescriptor_DoubleMapWithDefault::values(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.values)
  return _internal_values(index);
}
inline void FigureDescriptor_DoubleMapWithDefault::set_values(int index, double value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.values)
}
inline void FigureDescriptor_DoubleMapWithDefault::_internal_add_values(double value) {
  values_.Add(value);
}
inline void FigureDescriptor_DoubleMapWithDefault::add_values(double value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
FigureDescriptor_DoubleMapWithDefault::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
FigureDescriptor_DoubleMapWithDefault::values() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
FigureDescriptor_DoubleMapWithDefault::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
FigureDescriptor_DoubleMapWithDefault::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.DoubleMapWithDefault.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// FigureDescriptor_BoolMapWithDefault

// optional bool default_bool = 1;
inline bool FigureDescriptor_BoolMapWithDefault::_internal_has_default_bool() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FigureDescriptor_BoolMapWithDefault::has_default_bool() const {
  return _internal_has_default_bool();
}
inline void FigureDescriptor_BoolMapWithDefault::clear_default_bool() {
  default_bool_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool FigureDescriptor_BoolMapWithDefault::_internal_default_bool() const {
  return default_bool_;
}
inline bool FigureDescriptor_BoolMapWithDefault::default_bool() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.default_bool)
  return _internal_default_bool();
}
inline void FigureDescriptor_BoolMapWithDefault::_internal_set_default_bool(bool value) {
  _has_bits_[0] |= 0x00000001u;
  default_bool_ = value;
}
inline void FigureDescriptor_BoolMapWithDefault::set_default_bool(bool value) {
  _internal_set_default_bool(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.default_bool)
}

// repeated string keys = 2;
inline int FigureDescriptor_BoolMapWithDefault::_internal_keys_size() const {
  return keys_.size();
}
inline int FigureDescriptor_BoolMapWithDefault::keys_size() const {
  return _internal_keys_size();
}
inline void FigureDescriptor_BoolMapWithDefault::clear_keys() {
  keys_.Clear();
}
inline std::string* FigureDescriptor_BoolMapWithDefault::add_keys() {
  std::string* _s = _internal_add_keys();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
  return _s;
}
inline const std::string& FigureDescriptor_BoolMapWithDefault::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const std::string& FigureDescriptor_BoolMapWithDefault::keys(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
  return _internal_keys(index);
}
inline std::string* FigureDescriptor_BoolMapWithDefault::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
  return keys_.Mutable(index);
}
inline void FigureDescriptor_BoolMapWithDefault::set_keys(int index, const std::string& value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
}
inline void FigureDescriptor_BoolMapWithDefault::set_keys(int index, std::string&& value) {
  keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
}
inline void FigureDescriptor_BoolMapWithDefault::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
}
inline void FigureDescriptor_BoolMapWithDefault::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
}
inline std::string* FigureDescriptor_BoolMapWithDefault::_internal_add_keys() {
  return keys_.Add();
}
inline void FigureDescriptor_BoolMapWithDefault::add_keys(const std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
}
inline void FigureDescriptor_BoolMapWithDefault::add_keys(std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
}
inline void FigureDescriptor_BoolMapWithDefault::add_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
}
inline void FigureDescriptor_BoolMapWithDefault::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FigureDescriptor_BoolMapWithDefault::keys() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
  return keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FigureDescriptor_BoolMapWithDefault::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.keys)
  return &keys_;
}

// repeated bool values = 3;
inline int FigureDescriptor_BoolMapWithDefault::_internal_values_size() const {
  return values_.size();
}
inline int FigureDescriptor_BoolMapWithDefault::values_size() const {
  return _internal_values_size();
}
inline void FigureDescriptor_BoolMapWithDefault::clear_values() {
  values_.Clear();
}
inline bool FigureDescriptor_BoolMapWithDefault::_internal_values(int index) const {
  return values_.Get(index);
}
inline bool FigureDescriptor_BoolMapWithDefault::values(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.values)
  return _internal_values(index);
}
inline void FigureDescriptor_BoolMapWithDefault::set_values(int index, bool value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.values)
}
inline void FigureDescriptor_BoolMapWithDefault::_internal_add_values(bool value) {
  values_.Add(value);
}
inline void FigureDescriptor_BoolMapWithDefault::add_values(bool value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
FigureDescriptor_BoolMapWithDefault::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
FigureDescriptor_BoolMapWithDefault::values() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
FigureDescriptor_BoolMapWithDefault::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
FigureDescriptor_BoolMapWithDefault::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BoolMapWithDefault.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// FigureDescriptor_AxisDescriptor

// string id = 1;
inline void FigureDescriptor_AxisDescriptor::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_AxisDescriptor::id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_AxisDescriptor::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.id)
}
inline std::string* FigureDescriptor_AxisDescriptor::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.id)
  return _s;
}
inline const std::string& FigureDescriptor_AxisDescriptor::_internal_id() const {
  return id_.Get();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_id(const std::string& value) {
  
  id_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_AxisDescriptor::_internal_mutable_id() {
  
  return id_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_AxisDescriptor::release_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.id)
  return id_.Release();
}
inline void FigureDescriptor_AxisDescriptor::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_.IsDefault()) {
    id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.id)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.AxisFormatType format_type = 2;
inline void FigureDescriptor_AxisDescriptor::clear_format_type() {
  format_type_ = 0;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisFormatType FigureDescriptor_AxisDescriptor::_internal_format_type() const {
  return static_cast< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisFormatType >(format_type_);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisFormatType FigureDescriptor_AxisDescriptor::format_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.format_type)
  return _internal_format_type();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_format_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisFormatType value) {
  
  format_type_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_format_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisFormatType value) {
  _internal_set_format_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.format_type)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.AxisType type = 3;
inline void FigureDescriptor_AxisDescriptor::clear_type() {
  type_ = 0;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisType FigureDescriptor_AxisDescriptor::_internal_type() const {
  return static_cast< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisType >(type_);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisType FigureDescriptor_AxisDescriptor::type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.type)
  return _internal_type();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisType value) {
  
  type_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.type)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.AxisPosition position = 4;
inline void FigureDescriptor_AxisDescriptor::clear_position() {
  position_ = 0;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisPosition FigureDescriptor_AxisDescriptor::_internal_position() const {
  return static_cast< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisPosition >(position_);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisPosition FigureDescriptor_AxisDescriptor::position() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.position)
  return _internal_position();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_position(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisPosition value) {
  
  position_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_position(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisPosition value) {
  _internal_set_position(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.position)
}

// bool log = 5;
inline void FigureDescriptor_AxisDescriptor::clear_log() {
  log_ = false;
}
inline bool FigureDescriptor_AxisDescriptor::_internal_log() const {
  return log_;
}
inline bool FigureDescriptor_AxisDescriptor::log() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.log)
  return _internal_log();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_log(bool value) {
  
  log_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_log(bool value) {
  _internal_set_log(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.log)
}

// string label = 6;
inline void FigureDescriptor_AxisDescriptor::clear_label() {
  label_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_AxisDescriptor::label() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.label)
  return _internal_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_AxisDescriptor::set_label(ArgT0&& arg0, ArgT... args) {
 
 label_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.label)
}
inline std::string* FigureDescriptor_AxisDescriptor::mutable_label() {
  std::string* _s = _internal_mutable_label();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.label)
  return _s;
}
inline const std::string& FigureDescriptor_AxisDescriptor::_internal_label() const {
  return label_.Get();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_label(const std::string& value) {
  
  label_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_AxisDescriptor::_internal_mutable_label() {
  
  return label_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_AxisDescriptor::release_label() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.label)
  return label_.Release();
}
inline void FigureDescriptor_AxisDescriptor::set_allocated_label(std::string* label) {
  if (label != nullptr) {
    
  } else {
    
  }
  label_.SetAllocated(label, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_.IsDefault()) {
    label_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.label)
}

// string label_font = 7;
inline void FigureDescriptor_AxisDescriptor::clear_label_font() {
  label_font_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_AxisDescriptor::label_font() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.label_font)
  return _internal_label_font();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_AxisDescriptor::set_label_font(ArgT0&& arg0, ArgT... args) {
 
 label_font_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.label_font)
}
inline std::string* FigureDescriptor_AxisDescriptor::mutable_label_font() {
  std::string* _s = _internal_mutable_label_font();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.label_font)
  return _s;
}
inline const std::string& FigureDescriptor_AxisDescriptor::_internal_label_font() const {
  return label_font_.Get();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_label_font(const std::string& value) {
  
  label_font_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_AxisDescriptor::_internal_mutable_label_font() {
  
  return label_font_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_AxisDescriptor::release_label_font() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.label_font)
  return label_font_.Release();
}
inline void FigureDescriptor_AxisDescriptor::set_allocated_label_font(std::string* label_font) {
  if (label_font != nullptr) {
    
  } else {
    
  }
  label_font_.SetAllocated(label_font, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (label_font_.IsDefault()) {
    label_font_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.label_font)
}

// string ticks_font = 8;
inline void FigureDescriptor_AxisDescriptor::clear_ticks_font() {
  ticks_font_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_AxisDescriptor::ticks_font() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.ticks_font)
  return _internal_ticks_font();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_AxisDescriptor::set_ticks_font(ArgT0&& arg0, ArgT... args) {
 
 ticks_font_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.ticks_font)
}
inline std::string* FigureDescriptor_AxisDescriptor::mutable_ticks_font() {
  std::string* _s = _internal_mutable_ticks_font();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.ticks_font)
  return _s;
}
inline const std::string& FigureDescriptor_AxisDescriptor::_internal_ticks_font() const {
  return ticks_font_.Get();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_ticks_font(const std::string& value) {
  
  ticks_font_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_AxisDescriptor::_internal_mutable_ticks_font() {
  
  return ticks_font_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_AxisDescriptor::release_ticks_font() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.ticks_font)
  return ticks_font_.Release();
}
inline void FigureDescriptor_AxisDescriptor::set_allocated_ticks_font(std::string* ticks_font) {
  if (ticks_font != nullptr) {
    
  } else {
    
  }
  ticks_font_.SetAllocated(ticks_font, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ticks_font_.IsDefault()) {
    ticks_font_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.ticks_font)
}

// optional string format_pattern = 9;
inline bool FigureDescriptor_AxisDescriptor::_internal_has_format_pattern() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FigureDescriptor_AxisDescriptor::has_format_pattern() const {
  return _internal_has_format_pattern();
}
inline void FigureDescriptor_AxisDescriptor::clear_format_pattern() {
  format_pattern_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FigureDescriptor_AxisDescriptor::format_pattern() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.format_pattern)
  return _internal_format_pattern();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_AxisDescriptor::set_format_pattern(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 format_pattern_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.format_pattern)
}
inline std::string* FigureDescriptor_AxisDescriptor::mutable_format_pattern() {
  std::string* _s = _internal_mutable_format_pattern();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.format_pattern)
  return _s;
}
inline const std::string& FigureDescriptor_AxisDescriptor::_internal_format_pattern() const {
  return format_pattern_.Get();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_format_pattern(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  format_pattern_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_AxisDescriptor::_internal_mutable_format_pattern() {
  _has_bits_[0] |= 0x00000001u;
  return format_pattern_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_AxisDescriptor::release_format_pattern() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.format_pattern)
  if (!_internal_has_format_pattern()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = format_pattern_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (format_pattern_.IsDefault()) {
    format_pattern_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FigureDescriptor_AxisDescriptor::set_allocated_format_pattern(std::string* format_pattern) {
  if (format_pattern != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  format_pattern_.SetAllocated(format_pattern, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (format_pattern_.IsDefault()) {
    format_pattern_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.format_pattern)
}

// string color = 10;
inline void FigureDescriptor_AxisDescriptor::clear_color() {
  color_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_AxisDescriptor::color() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_AxisDescriptor::set_color(ArgT0&& arg0, ArgT... args) {
 
 color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.color)
}
inline std::string* FigureDescriptor_AxisDescriptor::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.color)
  return _s;
}
inline const std::string& FigureDescriptor_AxisDescriptor::_internal_color() const {
  return color_.Get();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_color(const std::string& value) {
  
  color_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_AxisDescriptor::_internal_mutable_color() {
  
  return color_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_AxisDescriptor::release_color() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.color)
  return color_.Release();
}
inline void FigureDescriptor_AxisDescriptor::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (color_.IsDefault()) {
    color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.color)
}

// double min_range = 11;
inline void FigureDescriptor_AxisDescriptor::clear_min_range() {
  min_range_ = 0;
}
inline double FigureDescriptor_AxisDescriptor::_internal_min_range() const {
  return min_range_;
}
inline double FigureDescriptor_AxisDescriptor::min_range() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.min_range)
  return _internal_min_range();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_min_range(double value) {
  
  min_range_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_min_range(double value) {
  _internal_set_min_range(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.min_range)
}

// double max_range = 12;
inline void FigureDescriptor_AxisDescriptor::clear_max_range() {
  max_range_ = 0;
}
inline double FigureDescriptor_AxisDescriptor::_internal_max_range() const {
  return max_range_;
}
inline double FigureDescriptor_AxisDescriptor::max_range() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.max_range)
  return _internal_max_range();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_max_range(double value) {
  
  max_range_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_max_range(double value) {
  _internal_set_max_range(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.max_range)
}

// bool minor_ticks_visible = 13;
inline void FigureDescriptor_AxisDescriptor::clear_minor_ticks_visible() {
  minor_ticks_visible_ = false;
}
inline bool FigureDescriptor_AxisDescriptor::_internal_minor_ticks_visible() const {
  return minor_ticks_visible_;
}
inline bool FigureDescriptor_AxisDescriptor::minor_ticks_visible() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.minor_ticks_visible)
  return _internal_minor_ticks_visible();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_minor_ticks_visible(bool value) {
  
  minor_ticks_visible_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_minor_ticks_visible(bool value) {
  _internal_set_minor_ticks_visible(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.minor_ticks_visible)
}

// bool major_ticks_visible = 14;
inline void FigureDescriptor_AxisDescriptor::clear_major_ticks_visible() {
  major_ticks_visible_ = false;
}
inline bool FigureDescriptor_AxisDescriptor::_internal_major_ticks_visible() const {
  return major_ticks_visible_;
}
inline bool FigureDescriptor_AxisDescriptor::major_ticks_visible() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.major_ticks_visible)
  return _internal_major_ticks_visible();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_major_ticks_visible(bool value) {
  
  major_ticks_visible_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_major_ticks_visible(bool value) {
  _internal_set_major_ticks_visible(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.major_ticks_visible)
}

// int32 minor_tick_count = 15;
inline void FigureDescriptor_AxisDescriptor::clear_minor_tick_count() {
  minor_tick_count_ = 0;
}
inline int32_t FigureDescriptor_AxisDescriptor::_internal_minor_tick_count() const {
  return minor_tick_count_;
}
inline int32_t FigureDescriptor_AxisDescriptor::minor_tick_count() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.minor_tick_count)
  return _internal_minor_tick_count();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_minor_tick_count(int32_t value) {
  
  minor_tick_count_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_minor_tick_count(int32_t value) {
  _internal_set_minor_tick_count(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.minor_tick_count)
}

// optional double gap_between_major_ticks = 16;
inline bool FigureDescriptor_AxisDescriptor::_internal_has_gap_between_major_ticks() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FigureDescriptor_AxisDescriptor::has_gap_between_major_ticks() const {
  return _internal_has_gap_between_major_ticks();
}
inline void FigureDescriptor_AxisDescriptor::clear_gap_between_major_ticks() {
  gap_between_major_ticks_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double FigureDescriptor_AxisDescriptor::_internal_gap_between_major_ticks() const {
  return gap_between_major_ticks_;
}
inline double FigureDescriptor_AxisDescriptor::gap_between_major_ticks() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.gap_between_major_ticks)
  return _internal_gap_between_major_ticks();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_gap_between_major_ticks(double value) {
  _has_bits_[0] |= 0x00000002u;
  gap_between_major_ticks_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_gap_between_major_ticks(double value) {
  _internal_set_gap_between_major_ticks(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.gap_between_major_ticks)
}

// repeated double major_tick_locations = 17;
inline int FigureDescriptor_AxisDescriptor::_internal_major_tick_locations_size() const {
  return major_tick_locations_.size();
}
inline int FigureDescriptor_AxisDescriptor::major_tick_locations_size() const {
  return _internal_major_tick_locations_size();
}
inline void FigureDescriptor_AxisDescriptor::clear_major_tick_locations() {
  major_tick_locations_.Clear();
}
inline double FigureDescriptor_AxisDescriptor::_internal_major_tick_locations(int index) const {
  return major_tick_locations_.Get(index);
}
inline double FigureDescriptor_AxisDescriptor::major_tick_locations(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.major_tick_locations)
  return _internal_major_tick_locations(index);
}
inline void FigureDescriptor_AxisDescriptor::set_major_tick_locations(int index, double value) {
  major_tick_locations_.Set(index, value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.major_tick_locations)
}
inline void FigureDescriptor_AxisDescriptor::_internal_add_major_tick_locations(double value) {
  major_tick_locations_.Add(value);
}
inline void FigureDescriptor_AxisDescriptor::add_major_tick_locations(double value) {
  _internal_add_major_tick_locations(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.major_tick_locations)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
FigureDescriptor_AxisDescriptor::_internal_major_tick_locations() const {
  return major_tick_locations_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
FigureDescriptor_AxisDescriptor::major_tick_locations() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.major_tick_locations)
  return _internal_major_tick_locations();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
FigureDescriptor_AxisDescriptor::_internal_mutable_major_tick_locations() {
  return &major_tick_locations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
FigureDescriptor_AxisDescriptor::mutable_major_tick_locations() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.major_tick_locations)
  return _internal_mutable_major_tick_locations();
}

// double tick_label_angle = 18;
inline void FigureDescriptor_AxisDescriptor::clear_tick_label_angle() {
  tick_label_angle_ = 0;
}
inline double FigureDescriptor_AxisDescriptor::_internal_tick_label_angle() const {
  return tick_label_angle_;
}
inline double FigureDescriptor_AxisDescriptor::tick_label_angle() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.tick_label_angle)
  return _internal_tick_label_angle();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_tick_label_angle(double value) {
  
  tick_label_angle_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_tick_label_angle(double value) {
  _internal_set_tick_label_angle(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.tick_label_angle)
}

// bool invert = 19;
inline void FigureDescriptor_AxisDescriptor::clear_invert() {
  invert_ = false;
}
inline bool FigureDescriptor_AxisDescriptor::_internal_invert() const {
  return invert_;
}
inline bool FigureDescriptor_AxisDescriptor::invert() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.invert)
  return _internal_invert();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_invert(bool value) {
  
  invert_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_invert(bool value) {
  _internal_set_invert(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.invert)
}

// bool is_time_axis = 20;
inline void FigureDescriptor_AxisDescriptor::clear_is_time_axis() {
  is_time_axis_ = false;
}
inline bool FigureDescriptor_AxisDescriptor::_internal_is_time_axis() const {
  return is_time_axis_;
}
inline bool FigureDescriptor_AxisDescriptor::is_time_axis() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.is_time_axis)
  return _internal_is_time_axis();
}
inline void FigureDescriptor_AxisDescriptor::_internal_set_is_time_axis(bool value) {
  
  is_time_axis_ = value;
}
inline void FigureDescriptor_AxisDescriptor::set_is_time_axis(bool value) {
  _internal_set_is_time_axis(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.is_time_axis)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor business_calendar_descriptor = 21;
inline bool FigureDescriptor_AxisDescriptor::_internal_has_business_calendar_descriptor() const {
  return this != internal_default_instance() && business_calendar_descriptor_ != nullptr;
}
inline bool FigureDescriptor_AxisDescriptor::has_business_calendar_descriptor() const {
  return _internal_has_business_calendar_descriptor();
}
inline void FigureDescriptor_AxisDescriptor::clear_business_calendar_descriptor() {
  if (GetArenaForAllocation() == nullptr && business_calendar_descriptor_ != nullptr) {
    delete business_calendar_descriptor_;
  }
  business_calendar_descriptor_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor& FigureDescriptor_AxisDescriptor::_internal_business_calendar_descriptor() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* p = business_calendar_descriptor_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_BusinessCalendarDescriptor_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor& FigureDescriptor_AxisDescriptor::business_calendar_descriptor() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.business_calendar_descriptor)
  return _internal_business_calendar_descriptor();
}
inline void FigureDescriptor_AxisDescriptor::unsafe_arena_set_allocated_business_calendar_descriptor(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* business_calendar_descriptor) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(business_calendar_descriptor_);
  }
  business_calendar_descriptor_ = business_calendar_descriptor;
  if (business_calendar_descriptor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.business_calendar_descriptor)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* FigureDescriptor_AxisDescriptor::release_business_calendar_descriptor() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* temp = business_calendar_descriptor_;
  business_calendar_descriptor_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* FigureDescriptor_AxisDescriptor::unsafe_arena_release_business_calendar_descriptor() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.business_calendar_descriptor)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* temp = business_calendar_descriptor_;
  business_calendar_descriptor_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* FigureDescriptor_AxisDescriptor::_internal_mutable_business_calendar_descriptor() {
  
  if (business_calendar_descriptor_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor>(GetArenaForAllocation());
    business_calendar_descriptor_ = p;
  }
  return business_calendar_descriptor_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* FigureDescriptor_AxisDescriptor::mutable_business_calendar_descriptor() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* _msg = _internal_mutable_business_calendar_descriptor();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.business_calendar_descriptor)
  return _msg;
}
inline void FigureDescriptor_AxisDescriptor::set_allocated_business_calendar_descriptor(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor* business_calendar_descriptor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete business_calendar_descriptor_;
  }
  if (business_calendar_descriptor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(business_calendar_descriptor);
    if (message_arena != submessage_arena) {
      business_calendar_descriptor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, business_calendar_descriptor, submessage_arena);
    }
    
  } else {
    
  }
  business_calendar_descriptor_ = business_calendar_descriptor;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.AxisDescriptor.business_calendar_descriptor)
}

// -------------------------------------------------------------------

// FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod

// string open = 1;
inline void FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::clear_open() {
  open_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::open() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod.open)
  return _internal_open();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::set_open(ArgT0&& arg0, ArgT... args) {
 
 open_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod.open)
}
inline std::string* FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::mutable_open() {
  std::string* _s = _internal_mutable_open();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod.open)
  return _s;
}
inline const std::string& FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::_internal_open() const {
  return open_.Get();
}
inline void FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::_internal_set_open(const std::string& value) {
  
  open_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::_internal_mutable_open() {
  
  return open_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::release_open() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod.open)
  return open_.Release();
}
inline void FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::set_allocated_open(std::string* open) {
  if (open != nullptr) {
    
  } else {
    
  }
  open_.SetAllocated(open, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (open_.IsDefault()) {
    open_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod.open)
}

// string close = 2;
inline void FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::clear_close() {
  close_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::close() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod.close)
  return _internal_close();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::set_close(ArgT0&& arg0, ArgT... args) {
 
 close_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod.close)
}
inline std::string* FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::mutable_close() {
  std::string* _s = _internal_mutable_close();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod.close)
  return _s;
}
inline const std::string& FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::_internal_close() const {
  return close_.Get();
}
inline void FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::_internal_set_close(const std::string& value) {
  
  close_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::_internal_mutable_close() {
  
  return close_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::release_close() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod.close)
  return close_.Release();
}
inline void FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod::set_allocated_close(std::string* close) {
  if (close != nullptr) {
    
  } else {
    
  }
  close_.SetAllocated(close, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (close_.IsDefault()) {
    close_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod.close)
}

// -------------------------------------------------------------------

// FigureDescriptor_BusinessCalendarDescriptor_Holiday

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.LocalDate date = 1;
inline bool FigureDescriptor_BusinessCalendarDescriptor_Holiday::_internal_has_date() const {
  return this != internal_default_instance() && date_ != nullptr;
}
inline bool FigureDescriptor_BusinessCalendarDescriptor_Holiday::has_date() const {
  return _internal_has_date();
}
inline void FigureDescriptor_BusinessCalendarDescriptor_Holiday::clear_date() {
  if (GetArenaForAllocation() == nullptr && date_ != nullptr) {
    delete date_;
  }
  date_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate& FigureDescriptor_BusinessCalendarDescriptor_Holiday::_internal_date() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* p = date_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_BusinessCalendarDescriptor_LocalDate_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate& FigureDescriptor_BusinessCalendarDescriptor_Holiday::date() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday.date)
  return _internal_date();
}
inline void FigureDescriptor_BusinessCalendarDescriptor_Holiday::unsafe_arena_set_allocated_date(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* date) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_);
  }
  date_ = date;
  if (date) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday.date)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* FigureDescriptor_BusinessCalendarDescriptor_Holiday::release_date() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* temp = date_;
  date_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* FigureDescriptor_BusinessCalendarDescriptor_Holiday::unsafe_arena_release_date() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday.date)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* temp = date_;
  date_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* FigureDescriptor_BusinessCalendarDescriptor_Holiday::_internal_mutable_date() {
  
  if (date_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate>(GetArenaForAllocation());
    date_ = p;
  }
  return date_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* FigureDescriptor_BusinessCalendarDescriptor_Holiday::mutable_date() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* _msg = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday.date)
  return _msg;
}
inline void FigureDescriptor_BusinessCalendarDescriptor_Holiday::set_allocated_date(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_LocalDate* date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete date_;
  }
  if (date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(date);
    if (message_arena != submessage_arena) {
      date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date, submessage_arena);
    }
    
  } else {
    
  }
  date_ = date;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday.date)
}

// repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod business_periods = 2;
inline int FigureDescriptor_BusinessCalendarDescriptor_Holiday::_internal_business_periods_size() const {
  return business_periods_.size();
}
inline int FigureDescriptor_BusinessCalendarDescriptor_Holiday::business_periods_size() const {
  return _internal_business_periods_size();
}
inline void FigureDescriptor_BusinessCalendarDescriptor_Holiday::clear_business_periods() {
  business_periods_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* FigureDescriptor_BusinessCalendarDescriptor_Holiday::mutable_business_periods(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday.business_periods)
  return business_periods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod >*
FigureDescriptor_BusinessCalendarDescriptor_Holiday::mutable_business_periods() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday.business_periods)
  return &business_periods_;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& FigureDescriptor_BusinessCalendarDescriptor_Holiday::_internal_business_periods(int index) const {
  return business_periods_.Get(index);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& FigureDescriptor_BusinessCalendarDescriptor_Holiday::business_periods(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday.business_periods)
  return _internal_business_periods(index);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* FigureDescriptor_BusinessCalendarDescriptor_Holiday::_internal_add_business_periods() {
  return business_periods_.Add();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* FigureDescriptor_BusinessCalendarDescriptor_Holiday::add_business_periods() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* _add = _internal_add_business_periods();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday.business_periods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod >&
FigureDescriptor_BusinessCalendarDescriptor_Holiday::business_periods() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday.business_periods)
  return business_periods_;
}

// -------------------------------------------------------------------

// FigureDescriptor_BusinessCalendarDescriptor_LocalDate

// int32 year = 1;
inline void FigureDescriptor_BusinessCalendarDescriptor_LocalDate::clear_year() {
  year_ = 0;
}
inline int32_t FigureDescriptor_BusinessCalendarDescriptor_LocalDate::_internal_year() const {
  return year_;
}
inline int32_t FigureDescriptor_BusinessCalendarDescriptor_LocalDate::year() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.LocalDate.year)
  return _internal_year();
}
inline void FigureDescriptor_BusinessCalendarDescriptor_LocalDate::_internal_set_year(int32_t value) {
  
  year_ = value;
}
inline void FigureDescriptor_BusinessCalendarDescriptor_LocalDate::set_year(int32_t value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.LocalDate.year)
}

// int32 month = 2;
inline void FigureDescriptor_BusinessCalendarDescriptor_LocalDate::clear_month() {
  month_ = 0;
}
inline int32_t FigureDescriptor_BusinessCalendarDescriptor_LocalDate::_internal_month() const {
  return month_;
}
inline int32_t FigureDescriptor_BusinessCalendarDescriptor_LocalDate::month() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.LocalDate.month)
  return _internal_month();
}
inline void FigureDescriptor_BusinessCalendarDescriptor_LocalDate::_internal_set_month(int32_t value) {
  
  month_ = value;
}
inline void FigureDescriptor_BusinessCalendarDescriptor_LocalDate::set_month(int32_t value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.LocalDate.month)
}

// int32 day = 3;
inline void FigureDescriptor_BusinessCalendarDescriptor_LocalDate::clear_day() {
  day_ = 0;
}
inline int32_t FigureDescriptor_BusinessCalendarDescriptor_LocalDate::_internal_day() const {
  return day_;
}
inline int32_t FigureDescriptor_BusinessCalendarDescriptor_LocalDate::day() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.LocalDate.day)
  return _internal_day();
}
inline void FigureDescriptor_BusinessCalendarDescriptor_LocalDate::_internal_set_day(int32_t value) {
  
  day_ = value;
}
inline void FigureDescriptor_BusinessCalendarDescriptor_LocalDate::set_day(int32_t value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.LocalDate.day)
}

// -------------------------------------------------------------------

// FigureDescriptor_BusinessCalendarDescriptor

// string name = 1;
inline void FigureDescriptor_BusinessCalendarDescriptor::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_BusinessCalendarDescriptor::name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_BusinessCalendarDescriptor::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.name)
}
inline std::string* FigureDescriptor_BusinessCalendarDescriptor::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.name)
  return _s;
}
inline const std::string& FigureDescriptor_BusinessCalendarDescriptor::_internal_name() const {
  return name_.Get();
}
inline void FigureDescriptor_BusinessCalendarDescriptor::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_BusinessCalendarDescriptor::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_BusinessCalendarDescriptor::release_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.name)
  return name_.Release();
}
inline void FigureDescriptor_BusinessCalendarDescriptor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.name)
}

// string time_zone = 2;
inline void FigureDescriptor_BusinessCalendarDescriptor::clear_time_zone() {
  time_zone_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_BusinessCalendarDescriptor::time_zone() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.time_zone)
  return _internal_time_zone();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_BusinessCalendarDescriptor::set_time_zone(ArgT0&& arg0, ArgT... args) {
 
 time_zone_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.time_zone)
}
inline std::string* FigureDescriptor_BusinessCalendarDescriptor::mutable_time_zone() {
  std::string* _s = _internal_mutable_time_zone();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.time_zone)
  return _s;
}
inline const std::string& FigureDescriptor_BusinessCalendarDescriptor::_internal_time_zone() const {
  return time_zone_.Get();
}
inline void FigureDescriptor_BusinessCalendarDescriptor::_internal_set_time_zone(const std::string& value) {
  
  time_zone_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_BusinessCalendarDescriptor::_internal_mutable_time_zone() {
  
  return time_zone_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_BusinessCalendarDescriptor::release_time_zone() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.time_zone)
  return time_zone_.Release();
}
inline void FigureDescriptor_BusinessCalendarDescriptor::set_allocated_time_zone(std::string* time_zone) {
  if (time_zone != nullptr) {
    
  } else {
    
  }
  time_zone_.SetAllocated(time_zone, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (time_zone_.IsDefault()) {
    time_zone_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.time_zone)
}

// repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.DayOfWeek business_days = 3;
inline int FigureDescriptor_BusinessCalendarDescriptor::_internal_business_days_size() const {
  return business_days_.size();
}
inline int FigureDescriptor_BusinessCalendarDescriptor::business_days_size() const {
  return _internal_business_days_size();
}
inline void FigureDescriptor_BusinessCalendarDescriptor::clear_business_days() {
  business_days_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek FigureDescriptor_BusinessCalendarDescriptor::_internal_business_days(int index) const {
  return static_cast< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek >(business_days_.Get(index));
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek FigureDescriptor_BusinessCalendarDescriptor::business_days(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.business_days)
  return _internal_business_days(index);
}
inline void FigureDescriptor_BusinessCalendarDescriptor::set_business_days(int index, ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek value) {
  business_days_.Set(index, value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.business_days)
}
inline void FigureDescriptor_BusinessCalendarDescriptor::_internal_add_business_days(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek value) {
  business_days_.Add(value);
}
inline void FigureDescriptor_BusinessCalendarDescriptor::add_business_days(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek value) {
  _internal_add_business_days(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.business_days)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
FigureDescriptor_BusinessCalendarDescriptor::business_days() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.business_days)
  return business_days_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
FigureDescriptor_BusinessCalendarDescriptor::_internal_mutable_business_days() {
  return &business_days_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
FigureDescriptor_BusinessCalendarDescriptor::mutable_business_days() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.business_days)
  return _internal_mutable_business_days();
}

// repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.BusinessPeriod business_periods = 4;
inline int FigureDescriptor_BusinessCalendarDescriptor::_internal_business_periods_size() const {
  return business_periods_.size();
}
inline int FigureDescriptor_BusinessCalendarDescriptor::business_periods_size() const {
  return _internal_business_periods_size();
}
inline void FigureDescriptor_BusinessCalendarDescriptor::clear_business_periods() {
  business_periods_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* FigureDescriptor_BusinessCalendarDescriptor::mutable_business_periods(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.business_periods)
  return business_periods_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod >*
FigureDescriptor_BusinessCalendarDescriptor::mutable_business_periods() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.business_periods)
  return &business_periods_;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& FigureDescriptor_BusinessCalendarDescriptor::_internal_business_periods(int index) const {
  return business_periods_.Get(index);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod& FigureDescriptor_BusinessCalendarDescriptor::business_periods(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.business_periods)
  return _internal_business_periods(index);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* FigureDescriptor_BusinessCalendarDescriptor::_internal_add_business_periods() {
  return business_periods_.Add();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* FigureDescriptor_BusinessCalendarDescriptor::add_business_periods() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod* _add = _internal_add_business_periods();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.business_periods)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_BusinessPeriod >&
FigureDescriptor_BusinessCalendarDescriptor::business_periods() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.business_periods)
  return business_periods_;
}

// repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.Holiday holidays = 5;
inline int FigureDescriptor_BusinessCalendarDescriptor::_internal_holidays_size() const {
  return holidays_.size();
}
inline int FigureDescriptor_BusinessCalendarDescriptor::holidays_size() const {
  return _internal_holidays_size();
}
inline void FigureDescriptor_BusinessCalendarDescriptor::clear_holidays() {
  holidays_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday* FigureDescriptor_BusinessCalendarDescriptor::mutable_holidays(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.holidays)
  return holidays_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday >*
FigureDescriptor_BusinessCalendarDescriptor::mutable_holidays() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.holidays)
  return &holidays_;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday& FigureDescriptor_BusinessCalendarDescriptor::_internal_holidays(int index) const {
  return holidays_.Get(index);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday& FigureDescriptor_BusinessCalendarDescriptor::holidays(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.holidays)
  return _internal_holidays(index);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday* FigureDescriptor_BusinessCalendarDescriptor::_internal_add_holidays() {
  return holidays_.Add();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday* FigureDescriptor_BusinessCalendarDescriptor::add_holidays() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday* _add = _internal_add_holidays();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.holidays)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_Holiday >&
FigureDescriptor_BusinessCalendarDescriptor::holidays() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.BusinessCalendarDescriptor.holidays)
  return holidays_;
}

// -------------------------------------------------------------------

// FigureDescriptor_MultiSeriesSourceDescriptor

// string axis_id = 1;
inline void FigureDescriptor_MultiSeriesSourceDescriptor::clear_axis_id() {
  axis_id_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_MultiSeriesSourceDescriptor::axis_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.axis_id)
  return _internal_axis_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_MultiSeriesSourceDescriptor::set_axis_id(ArgT0&& arg0, ArgT... args) {
 
 axis_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.axis_id)
}
inline std::string* FigureDescriptor_MultiSeriesSourceDescriptor::mutable_axis_id() {
  std::string* _s = _internal_mutable_axis_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.axis_id)
  return _s;
}
inline const std::string& FigureDescriptor_MultiSeriesSourceDescriptor::_internal_axis_id() const {
  return axis_id_.Get();
}
inline void FigureDescriptor_MultiSeriesSourceDescriptor::_internal_set_axis_id(const std::string& value) {
  
  axis_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_MultiSeriesSourceDescriptor::_internal_mutable_axis_id() {
  
  return axis_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_MultiSeriesSourceDescriptor::release_axis_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.axis_id)
  return axis_id_.Release();
}
inline void FigureDescriptor_MultiSeriesSourceDescriptor::set_allocated_axis_id(std::string* axis_id) {
  if (axis_id != nullptr) {
    
  } else {
    
  }
  axis_id_.SetAllocated(axis_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (axis_id_.IsDefault()) {
    axis_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.axis_id)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceType type = 2;
inline void FigureDescriptor_MultiSeriesSourceDescriptor::clear_type() {
  type_ = 0;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType FigureDescriptor_MultiSeriesSourceDescriptor::_internal_type() const {
  return static_cast< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType >(type_);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType FigureDescriptor_MultiSeriesSourceDescriptor::type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.type)
  return _internal_type();
}
inline void FigureDescriptor_MultiSeriesSourceDescriptor::_internal_set_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType value) {
  
  type_ = value;
}
inline void FigureDescriptor_MultiSeriesSourceDescriptor::set_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.type)
}

// int32 partitioned_table_id = 3;
inline void FigureDescriptor_MultiSeriesSourceDescriptor::clear_partitioned_table_id() {
  partitioned_table_id_ = 0;
}
inline int32_t FigureDescriptor_MultiSeriesSourceDescriptor::_internal_partitioned_table_id() const {
  return partitioned_table_id_;
}
inline int32_t FigureDescriptor_MultiSeriesSourceDescriptor::partitioned_table_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.partitioned_table_id)
  return _internal_partitioned_table_id();
}
inline void FigureDescriptor_MultiSeriesSourceDescriptor::_internal_set_partitioned_table_id(int32_t value) {
  
  partitioned_table_id_ = value;
}
inline void FigureDescriptor_MultiSeriesSourceDescriptor::set_partitioned_table_id(int32_t value) {
  _internal_set_partitioned_table_id(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.partitioned_table_id)
}

// string column_name = 4;
inline void FigureDescriptor_MultiSeriesSourceDescriptor::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_MultiSeriesSourceDescriptor::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_MultiSeriesSourceDescriptor::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.column_name)
}
inline std::string* FigureDescriptor_MultiSeriesSourceDescriptor::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.column_name)
  return _s;
}
inline const std::string& FigureDescriptor_MultiSeriesSourceDescriptor::_internal_column_name() const {
  return column_name_.Get();
}
inline void FigureDescriptor_MultiSeriesSourceDescriptor::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_MultiSeriesSourceDescriptor::_internal_mutable_column_name() {
  
  return column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_MultiSeriesSourceDescriptor::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.column_name)
  return column_name_.Release();
}
inline void FigureDescriptor_MultiSeriesSourceDescriptor::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (column_name_.IsDefault()) {
    column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.MultiSeriesSourceDescriptor.column_name)
}

// -------------------------------------------------------------------

// FigureDescriptor_SourceDescriptor

// string axis_id = 1;
inline void FigureDescriptor_SourceDescriptor::clear_axis_id() {
  axis_id_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_SourceDescriptor::axis_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.axis_id)
  return _internal_axis_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_SourceDescriptor::set_axis_id(ArgT0&& arg0, ArgT... args) {
 
 axis_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.axis_id)
}
inline std::string* FigureDescriptor_SourceDescriptor::mutable_axis_id() {
  std::string* _s = _internal_mutable_axis_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.axis_id)
  return _s;
}
inline const std::string& FigureDescriptor_SourceDescriptor::_internal_axis_id() const {
  return axis_id_.Get();
}
inline void FigureDescriptor_SourceDescriptor::_internal_set_axis_id(const std::string& value) {
  
  axis_id_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SourceDescriptor::_internal_mutable_axis_id() {
  
  return axis_id_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SourceDescriptor::release_axis_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.axis_id)
  return axis_id_.Release();
}
inline void FigureDescriptor_SourceDescriptor::set_allocated_axis_id(std::string* axis_id) {
  if (axis_id != nullptr) {
    
  } else {
    
  }
  axis_id_.SetAllocated(axis_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (axis_id_.IsDefault()) {
    axis_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.axis_id)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceType type = 2;
inline void FigureDescriptor_SourceDescriptor::clear_type() {
  type_ = 0;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType FigureDescriptor_SourceDescriptor::_internal_type() const {
  return static_cast< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType >(type_);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType FigureDescriptor_SourceDescriptor::type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.type)
  return _internal_type();
}
inline void FigureDescriptor_SourceDescriptor::_internal_set_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType value) {
  
  type_ = value;
}
inline void FigureDescriptor_SourceDescriptor::set_type(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.type)
}

// int32 table_id = 3;
inline void FigureDescriptor_SourceDescriptor::clear_table_id() {
  table_id_ = 0;
}
inline int32_t FigureDescriptor_SourceDescriptor::_internal_table_id() const {
  return table_id_;
}
inline int32_t FigureDescriptor_SourceDescriptor::table_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.table_id)
  return _internal_table_id();
}
inline void FigureDescriptor_SourceDescriptor::_internal_set_table_id(int32_t value) {
  
  table_id_ = value;
}
inline void FigureDescriptor_SourceDescriptor::set_table_id(int32_t value) {
  _internal_set_table_id(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.table_id)
}

// int32 partitioned_table_id = 4;
inline void FigureDescriptor_SourceDescriptor::clear_partitioned_table_id() {
  partitioned_table_id_ = 0;
}
inline int32_t FigureDescriptor_SourceDescriptor::_internal_partitioned_table_id() const {
  return partitioned_table_id_;
}
inline int32_t FigureDescriptor_SourceDescriptor::partitioned_table_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.partitioned_table_id)
  return _internal_partitioned_table_id();
}
inline void FigureDescriptor_SourceDescriptor::_internal_set_partitioned_table_id(int32_t value) {
  
  partitioned_table_id_ = value;
}
inline void FigureDescriptor_SourceDescriptor::set_partitioned_table_id(int32_t value) {
  _internal_set_partitioned_table_id(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.partitioned_table_id)
}

// string column_name = 5;
inline void FigureDescriptor_SourceDescriptor::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_SourceDescriptor::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_SourceDescriptor::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.column_name)
}
inline std::string* FigureDescriptor_SourceDescriptor::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.column_name)
  return _s;
}
inline const std::string& FigureDescriptor_SourceDescriptor::_internal_column_name() const {
  return column_name_.Get();
}
inline void FigureDescriptor_SourceDescriptor::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SourceDescriptor::_internal_mutable_column_name() {
  
  return column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SourceDescriptor::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.column_name)
  return column_name_.Release();
}
inline void FigureDescriptor_SourceDescriptor::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (column_name_.IsDefault()) {
    column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.column_name)
}

// string column_type = 6;
inline void FigureDescriptor_SourceDescriptor::clear_column_type() {
  column_type_.ClearToEmpty();
}
inline const std::string& FigureDescriptor_SourceDescriptor::column_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.column_type)
  return _internal_column_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor_SourceDescriptor::set_column_type(ArgT0&& arg0, ArgT... args) {
 
 column_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.column_type)
}
inline std::string* FigureDescriptor_SourceDescriptor::mutable_column_type() {
  std::string* _s = _internal_mutable_column_type();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.column_type)
  return _s;
}
inline const std::string& FigureDescriptor_SourceDescriptor::_internal_column_type() const {
  return column_type_.Get();
}
inline void FigureDescriptor_SourceDescriptor::_internal_set_column_type(const std::string& value) {
  
  column_type_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SourceDescriptor::_internal_mutable_column_type() {
  
  return column_type_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor_SourceDescriptor::release_column_type() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.column_type)
  return column_type_.Release();
}
inline void FigureDescriptor_SourceDescriptor::set_allocated_column_type(std::string* column_type) {
  if (column_type != nullptr) {
    
  } else {
    
  }
  column_type_.SetAllocated(column_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (column_type_.IsDefault()) {
    column_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.column_type)
}

// .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor one_click = 7;
inline bool FigureDescriptor_SourceDescriptor::_internal_has_one_click() const {
  return this != internal_default_instance() && one_click_ != nullptr;
}
inline bool FigureDescriptor_SourceDescriptor::has_one_click() const {
  return _internal_has_one_click();
}
inline void FigureDescriptor_SourceDescriptor::clear_one_click() {
  if (GetArenaForAllocation() == nullptr && one_click_ != nullptr) {
    delete one_click_;
  }
  one_click_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor& FigureDescriptor_SourceDescriptor::_internal_one_click() const {
  const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* p = one_click_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor&>(
      ::io::deephaven::proto::backplane::script::grpc::_FigureDescriptor_OneClickDescriptor_default_instance_);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor& FigureDescriptor_SourceDescriptor::one_click() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.one_click)
  return _internal_one_click();
}
inline void FigureDescriptor_SourceDescriptor::unsafe_arena_set_allocated_one_click(
    ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* one_click) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(one_click_);
  }
  one_click_ = one_click;
  if (one_click) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.one_click)
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* FigureDescriptor_SourceDescriptor::release_one_click() {
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* temp = one_click_;
  one_click_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* FigureDescriptor_SourceDescriptor::unsafe_arena_release_one_click() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.one_click)
  
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* temp = one_click_;
  one_click_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* FigureDescriptor_SourceDescriptor::_internal_mutable_one_click() {
  
  if (one_click_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor>(GetArenaForAllocation());
    one_click_ = p;
  }
  return one_click_;
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* FigureDescriptor_SourceDescriptor::mutable_one_click() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* _msg = _internal_mutable_one_click();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.one_click)
  return _msg;
}
inline void FigureDescriptor_SourceDescriptor::set_allocated_one_click(::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_OneClickDescriptor* one_click) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete one_click_;
  }
  if (one_click) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(one_click);
    if (message_arena != submessage_arena) {
      one_click = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, one_click, submessage_arena);
    }
    
  } else {
    
  }
  one_click_ = one_click;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.SourceDescriptor.one_click)
}

// -------------------------------------------------------------------

// FigureDescriptor_OneClickDescriptor

// repeated string columns = 1;
inline int FigureDescriptor_OneClickDescriptor::_internal_columns_size() const {
  return columns_.size();
}
inline int FigureDescriptor_OneClickDescriptor::columns_size() const {
  return _internal_columns_size();
}
inline void FigureDescriptor_OneClickDescriptor::clear_columns() {
  columns_.Clear();
}
inline std::string* FigureDescriptor_OneClickDescriptor::add_columns() {
  std::string* _s = _internal_add_columns();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
  return _s;
}
inline const std::string& FigureDescriptor_OneClickDescriptor::_internal_columns(int index) const {
  return columns_.Get(index);
}
inline const std::string& FigureDescriptor_OneClickDescriptor::columns(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
  return _internal_columns(index);
}
inline std::string* FigureDescriptor_OneClickDescriptor::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
  return columns_.Mutable(index);
}
inline void FigureDescriptor_OneClickDescriptor::set_columns(int index, const std::string& value) {
  columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
}
inline void FigureDescriptor_OneClickDescriptor::set_columns(int index, std::string&& value) {
  columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
}
inline void FigureDescriptor_OneClickDescriptor::set_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
}
inline void FigureDescriptor_OneClickDescriptor::set_columns(int index, const char* value, size_t size) {
  columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
}
inline std::string* FigureDescriptor_OneClickDescriptor::_internal_add_columns() {
  return columns_.Add();
}
inline void FigureDescriptor_OneClickDescriptor::add_columns(const std::string& value) {
  columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
}
inline void FigureDescriptor_OneClickDescriptor::add_columns(std::string&& value) {
  columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
}
inline void FigureDescriptor_OneClickDescriptor::add_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
}
inline void FigureDescriptor_OneClickDescriptor::add_columns(const char* value, size_t size) {
  columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FigureDescriptor_OneClickDescriptor::columns() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
  return columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FigureDescriptor_OneClickDescriptor::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.columns)
  return &columns_;
}

// repeated string column_types = 2;
inline int FigureDescriptor_OneClickDescriptor::_internal_column_types_size() const {
  return column_types_.size();
}
inline int FigureDescriptor_OneClickDescriptor::column_types_size() const {
  return _internal_column_types_size();
}
inline void FigureDescriptor_OneClickDescriptor::clear_column_types() {
  column_types_.Clear();
}
inline std::string* FigureDescriptor_OneClickDescriptor::add_column_types() {
  std::string* _s = _internal_add_column_types();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
  return _s;
}
inline const std::string& FigureDescriptor_OneClickDescriptor::_internal_column_types(int index) const {
  return column_types_.Get(index);
}
inline const std::string& FigureDescriptor_OneClickDescriptor::column_types(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
  return _internal_column_types(index);
}
inline std::string* FigureDescriptor_OneClickDescriptor::mutable_column_types(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
  return column_types_.Mutable(index);
}
inline void FigureDescriptor_OneClickDescriptor::set_column_types(int index, const std::string& value) {
  column_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
}
inline void FigureDescriptor_OneClickDescriptor::set_column_types(int index, std::string&& value) {
  column_types_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
}
inline void FigureDescriptor_OneClickDescriptor::set_column_types(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
}
inline void FigureDescriptor_OneClickDescriptor::set_column_types(int index, const char* value, size_t size) {
  column_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
}
inline std::string* FigureDescriptor_OneClickDescriptor::_internal_add_column_types() {
  return column_types_.Add();
}
inline void FigureDescriptor_OneClickDescriptor::add_column_types(const std::string& value) {
  column_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
}
inline void FigureDescriptor_OneClickDescriptor::add_column_types(std::string&& value) {
  column_types_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
}
inline void FigureDescriptor_OneClickDescriptor::add_column_types(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
}
inline void FigureDescriptor_OneClickDescriptor::add_column_types(const char* value, size_t size) {
  column_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FigureDescriptor_OneClickDescriptor::column_types() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
  return column_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FigureDescriptor_OneClickDescriptor::mutable_column_types() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.column_types)
  return &column_types_;
}

// bool require_all_filters_to_display = 3;
inline void FigureDescriptor_OneClickDescriptor::clear_require_all_filters_to_display() {
  require_all_filters_to_display_ = false;
}
inline bool FigureDescriptor_OneClickDescriptor::_internal_require_all_filters_to_display() const {
  return require_all_filters_to_display_;
}
inline bool FigureDescriptor_OneClickDescriptor::require_all_filters_to_display() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.require_all_filters_to_display)
  return _internal_require_all_filters_to_display();
}
inline void FigureDescriptor_OneClickDescriptor::_internal_set_require_all_filters_to_display(bool value) {
  
  require_all_filters_to_display_ = value;
}
inline void FigureDescriptor_OneClickDescriptor::set_require_all_filters_to_display(bool value) {
  _internal_set_require_all_filters_to_display(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.OneClickDescriptor.require_all_filters_to_display)
}

// -------------------------------------------------------------------

// FigureDescriptor

// optional string title = 1;
inline bool FigureDescriptor::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FigureDescriptor::has_title() const {
  return _internal_has_title();
}
inline void FigureDescriptor::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FigureDescriptor::title() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title)
}
inline std::string* FigureDescriptor::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title)
  return _s;
}
inline const std::string& FigureDescriptor::_internal_title() const {
  return title_.Get();
}
inline void FigureDescriptor::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor::release_title() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FigureDescriptor::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title)
}

// string title_font = 2;
inline void FigureDescriptor::clear_title_font() {
  title_font_.ClearToEmpty();
}
inline const std::string& FigureDescriptor::title_font() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title_font)
  return _internal_title_font();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor::set_title_font(ArgT0&& arg0, ArgT... args) {
 
 title_font_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title_font)
}
inline std::string* FigureDescriptor::mutable_title_font() {
  std::string* _s = _internal_mutable_title_font();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title_font)
  return _s;
}
inline const std::string& FigureDescriptor::_internal_title_font() const {
  return title_font_.Get();
}
inline void FigureDescriptor::_internal_set_title_font(const std::string& value) {
  
  title_font_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor::_internal_mutable_title_font() {
  
  return title_font_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor::release_title_font() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title_font)
  return title_font_.Release();
}
inline void FigureDescriptor::set_allocated_title_font(std::string* title_font) {
  if (title_font != nullptr) {
    
  } else {
    
  }
  title_font_.SetAllocated(title_font, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_font_.IsDefault()) {
    title_font_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title_font)
}

// string title_color = 3;
inline void FigureDescriptor::clear_title_color() {
  title_color_.ClearToEmpty();
}
inline const std::string& FigureDescriptor::title_color() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title_color)
  return _internal_title_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FigureDescriptor::set_title_color(ArgT0&& arg0, ArgT... args) {
 
 title_color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title_color)
}
inline std::string* FigureDescriptor::mutable_title_color() {
  std::string* _s = _internal_mutable_title_color();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title_color)
  return _s;
}
inline const std::string& FigureDescriptor::_internal_title_color() const {
  return title_color_.Get();
}
inline void FigureDescriptor::_internal_set_title_color(const std::string& value) {
  
  title_color_.Set(value, GetArenaForAllocation());
}
inline std::string* FigureDescriptor::_internal_mutable_title_color() {
  
  return title_color_.Mutable(GetArenaForAllocation());
}
inline std::string* FigureDescriptor::release_title_color() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title_color)
  return title_color_.Release();
}
inline void FigureDescriptor::set_allocated_title_color(std::string* title_color) {
  if (title_color != nullptr) {
    
  } else {
    
  }
  title_color_.SetAllocated(title_color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_color_.IsDefault()) {
    title_color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.title_color)
}

// int64 update_interval = 7 [jstype = JS_STRING];
inline void FigureDescriptor::clear_update_interval() {
  update_interval_ = int64_t{0};
}
inline int64_t FigureDescriptor::_internal_update_interval() const {
  return update_interval_;
}
inline int64_t FigureDescriptor::update_interval() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.update_interval)
  return _internal_update_interval();
}
inline void FigureDescriptor::_internal_set_update_interval(int64_t value) {
  
  update_interval_ = value;
}
inline void FigureDescriptor::set_update_interval(int64_t value) {
  _internal_set_update_interval(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.update_interval)
}

// int32 cols = 8;
inline void FigureDescriptor::clear_cols() {
  cols_ = 0;
}
inline int32_t FigureDescriptor::_internal_cols() const {
  return cols_;
}
inline int32_t FigureDescriptor::cols() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.cols)
  return _internal_cols();
}
inline void FigureDescriptor::_internal_set_cols(int32_t value) {
  
  cols_ = value;
}
inline void FigureDescriptor::set_cols(int32_t value) {
  _internal_set_cols(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.cols)
}

// int32 rows = 9;
inline void FigureDescriptor::clear_rows() {
  rows_ = 0;
}
inline int32_t FigureDescriptor::_internal_rows() const {
  return rows_;
}
inline int32_t FigureDescriptor::rows() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.rows)
  return _internal_rows();
}
inline void FigureDescriptor::_internal_set_rows(int32_t value) {
  
  rows_ = value;
}
inline void FigureDescriptor::set_rows(int32_t value) {
  _internal_set_rows(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.rows)
}

// repeated .io.deephaven.proto.backplane.script.grpc.FigureDescriptor.ChartDescriptor charts = 10;
inline int FigureDescriptor::_internal_charts_size() const {
  return charts_.size();
}
inline int FigureDescriptor::charts_size() const {
  return _internal_charts_size();
}
inline void FigureDescriptor::clear_charts() {
  charts_.Clear();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor* FigureDescriptor::mutable_charts(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.charts)
  return charts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor >*
FigureDescriptor::mutable_charts() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.charts)
  return &charts_;
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor& FigureDescriptor::_internal_charts(int index) const {
  return charts_.Get(index);
}
inline const ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor& FigureDescriptor::charts(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.charts)
  return _internal_charts(index);
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor* FigureDescriptor::_internal_add_charts() {
  return charts_.Add();
}
inline ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor* FigureDescriptor::add_charts() {
  ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor* _add = _internal_add_charts();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.charts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor >&
FigureDescriptor::charts() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.charts)
  return charts_;
}

// repeated string errors = 13;
inline int FigureDescriptor::_internal_errors_size() const {
  return errors_.size();
}
inline int FigureDescriptor::errors_size() const {
  return _internal_errors_size();
}
inline void FigureDescriptor::clear_errors() {
  errors_.Clear();
}
inline std::string* FigureDescriptor::add_errors() {
  std::string* _s = _internal_add_errors();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
  return _s;
}
inline const std::string& FigureDescriptor::_internal_errors(int index) const {
  return errors_.Get(index);
}
inline const std::string& FigureDescriptor::errors(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
  return _internal_errors(index);
}
inline std::string* FigureDescriptor::mutable_errors(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
  return errors_.Mutable(index);
}
inline void FigureDescriptor::set_errors(int index, const std::string& value) {
  errors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
}
inline void FigureDescriptor::set_errors(int index, std::string&& value) {
  errors_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
}
inline void FigureDescriptor::set_errors(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  errors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
}
inline void FigureDescriptor::set_errors(int index, const char* value, size_t size) {
  errors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
}
inline std::string* FigureDescriptor::_internal_add_errors() {
  return errors_.Add();
}
inline void FigureDescriptor::add_errors(const std::string& value) {
  errors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
}
inline void FigureDescriptor::add_errors(std::string&& value) {
  errors_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
}
inline void FigureDescriptor::add_errors(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  errors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
}
inline void FigureDescriptor::add_errors(const char* value, size_t size) {
  errors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FigureDescriptor::errors() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
  return errors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FigureDescriptor::mutable_errors() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.script.grpc.FigureDescriptor.errors)
  return &errors_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace grpc
}  // namespace script
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor_ChartType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor_ChartType>() {
  return ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_ChartDescriptor_ChartType_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisFormatType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisFormatType>() {
  return ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisFormatType_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisType>() {
  return ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisType_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisPosition>() {
  return ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_AxisDescriptor_AxisPosition_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek>() {
  return ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_BusinessCalendarDescriptor_DayOfWeek_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle>() {
  return ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SeriesPlotStyle_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType>() {
  return ::io::deephaven::proto::backplane::script::grpc::FigureDescriptor_SourceType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2fconsole_2eproto
