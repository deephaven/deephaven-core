// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: deephaven/proto/table.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2ftable_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2ftable_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "deephaven/proto/ticket.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_deephaven_2fproto_2ftable_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_deephaven_2fproto_2ftable_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[48]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_deephaven_2fproto_2ftable_2eproto;
namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace grpc {
class AndCondition;
struct AndConditionDefaultTypeInternal;
extern AndConditionDefaultTypeInternal _AndCondition_default_instance_;
class AsOfJoinTablesRequest;
struct AsOfJoinTablesRequestDefaultTypeInternal;
extern AsOfJoinTablesRequestDefaultTypeInternal _AsOfJoinTablesRequest_default_instance_;
class BatchTableRequest;
struct BatchTableRequestDefaultTypeInternal;
extern BatchTableRequestDefaultTypeInternal _BatchTableRequest_default_instance_;
class BatchTableRequest_Operation;
struct BatchTableRequest_OperationDefaultTypeInternal;
extern BatchTableRequest_OperationDefaultTypeInternal _BatchTableRequest_Operation_default_instance_;
class ComboAggregateRequest;
struct ComboAggregateRequestDefaultTypeInternal;
extern ComboAggregateRequestDefaultTypeInternal _ComboAggregateRequest_default_instance_;
class ComboAggregateRequest_Aggregate;
struct ComboAggregateRequest_AggregateDefaultTypeInternal;
extern ComboAggregateRequest_AggregateDefaultTypeInternal _ComboAggregateRequest_Aggregate_default_instance_;
class CompareCondition;
struct CompareConditionDefaultTypeInternal;
extern CompareConditionDefaultTypeInternal _CompareCondition_default_instance_;
class Condition;
struct ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class ContainsCondition;
struct ContainsConditionDefaultTypeInternal;
extern ContainsConditionDefaultTypeInternal _ContainsCondition_default_instance_;
class CrossJoinTablesRequest;
struct CrossJoinTablesRequestDefaultTypeInternal;
extern CrossJoinTablesRequestDefaultTypeInternal _CrossJoinTablesRequest_default_instance_;
class DropColumnsRequest;
struct DropColumnsRequestDefaultTypeInternal;
extern DropColumnsRequestDefaultTypeInternal _DropColumnsRequest_default_instance_;
class EmptyTableRequest;
struct EmptyTableRequestDefaultTypeInternal;
extern EmptyTableRequestDefaultTypeInternal _EmptyTableRequest_default_instance_;
class ExactJoinTablesRequest;
struct ExactJoinTablesRequestDefaultTypeInternal;
extern ExactJoinTablesRequestDefaultTypeInternal _ExactJoinTablesRequest_default_instance_;
class ExportedTableCreationResponse;
struct ExportedTableCreationResponseDefaultTypeInternal;
extern ExportedTableCreationResponseDefaultTypeInternal _ExportedTableCreationResponse_default_instance_;
class ExportedTableUpdateMessage;
struct ExportedTableUpdateMessageDefaultTypeInternal;
extern ExportedTableUpdateMessageDefaultTypeInternal _ExportedTableUpdateMessage_default_instance_;
class ExportedTableUpdatesRequest;
struct ExportedTableUpdatesRequestDefaultTypeInternal;
extern ExportedTableUpdatesRequestDefaultTypeInternal _ExportedTableUpdatesRequest_default_instance_;
class FetchPandasTableRequest;
struct FetchPandasTableRequestDefaultTypeInternal;
extern FetchPandasTableRequestDefaultTypeInternal _FetchPandasTableRequest_default_instance_;
class FetchTableMapRequest;
struct FetchTableMapRequestDefaultTypeInternal;
extern FetchTableMapRequestDefaultTypeInternal _FetchTableMapRequest_default_instance_;
class FetchTableMapResponse;
struct FetchTableMapResponseDefaultTypeInternal;
extern FetchTableMapResponseDefaultTypeInternal _FetchTableMapResponse_default_instance_;
class FetchTableRequest;
struct FetchTableRequestDefaultTypeInternal;
extern FetchTableRequestDefaultTypeInternal _FetchTableRequest_default_instance_;
class FilterTableRequest;
struct FilterTableRequestDefaultTypeInternal;
extern FilterTableRequestDefaultTypeInternal _FilterTableRequest_default_instance_;
class FlattenRequest;
struct FlattenRequestDefaultTypeInternal;
extern FlattenRequestDefaultTypeInternal _FlattenRequest_default_instance_;
class HeadOrTailByRequest;
struct HeadOrTailByRequestDefaultTypeInternal;
extern HeadOrTailByRequestDefaultTypeInternal _HeadOrTailByRequest_default_instance_;
class HeadOrTailRequest;
struct HeadOrTailRequestDefaultTypeInternal;
extern HeadOrTailRequestDefaultTypeInternal _HeadOrTailRequest_default_instance_;
class InCondition;
struct InConditionDefaultTypeInternal;
extern InConditionDefaultTypeInternal _InCondition_default_instance_;
class InvokeCondition;
struct InvokeConditionDefaultTypeInternal;
extern InvokeConditionDefaultTypeInternal _InvokeCondition_default_instance_;
class IsNullCondition;
struct IsNullConditionDefaultTypeInternal;
extern IsNullConditionDefaultTypeInternal _IsNullCondition_default_instance_;
class LeftJoinTablesRequest;
struct LeftJoinTablesRequestDefaultTypeInternal;
extern LeftJoinTablesRequestDefaultTypeInternal _LeftJoinTablesRequest_default_instance_;
class Literal;
struct LiteralDefaultTypeInternal;
extern LiteralDefaultTypeInternal _Literal_default_instance_;
class MatchesCondition;
struct MatchesConditionDefaultTypeInternal;
extern MatchesConditionDefaultTypeInternal _MatchesCondition_default_instance_;
class MergeTablesRequest;
struct MergeTablesRequestDefaultTypeInternal;
extern MergeTablesRequestDefaultTypeInternal _MergeTablesRequest_default_instance_;
class NaturalJoinTablesRequest;
struct NaturalJoinTablesRequestDefaultTypeInternal;
extern NaturalJoinTablesRequestDefaultTypeInternal _NaturalJoinTablesRequest_default_instance_;
class NotCondition;
struct NotConditionDefaultTypeInternal;
extern NotConditionDefaultTypeInternal _NotCondition_default_instance_;
class OrCondition;
struct OrConditionDefaultTypeInternal;
extern OrConditionDefaultTypeInternal _OrCondition_default_instance_;
class Reference;
struct ReferenceDefaultTypeInternal;
extern ReferenceDefaultTypeInternal _Reference_default_instance_;
class RunChartDownsampleRequest;
struct RunChartDownsampleRequestDefaultTypeInternal;
extern RunChartDownsampleRequestDefaultTypeInternal _RunChartDownsampleRequest_default_instance_;
class RunChartDownsampleRequest_ZoomRange;
struct RunChartDownsampleRequest_ZoomRangeDefaultTypeInternal;
extern RunChartDownsampleRequest_ZoomRangeDefaultTypeInternal _RunChartDownsampleRequest_ZoomRange_default_instance_;
class SearchCondition;
struct SearchConditionDefaultTypeInternal;
extern SearchConditionDefaultTypeInternal _SearchCondition_default_instance_;
class SelectDistinctRequest;
struct SelectDistinctRequestDefaultTypeInternal;
extern SelectDistinctRequestDefaultTypeInternal _SelectDistinctRequest_default_instance_;
class SelectOrUpdateRequest;
struct SelectOrUpdateRequestDefaultTypeInternal;
extern SelectOrUpdateRequestDefaultTypeInternal _SelectOrUpdateRequest_default_instance_;
class SnapshotTableRequest;
struct SnapshotTableRequestDefaultTypeInternal;
extern SnapshotTableRequestDefaultTypeInternal _SnapshotTableRequest_default_instance_;
class SortDescriptor;
struct SortDescriptorDefaultTypeInternal;
extern SortDescriptorDefaultTypeInternal _SortDescriptor_default_instance_;
class SortTableRequest;
struct SortTableRequestDefaultTypeInternal;
extern SortTableRequestDefaultTypeInternal _SortTableRequest_default_instance_;
class TableReference;
struct TableReferenceDefaultTypeInternal;
extern TableReferenceDefaultTypeInternal _TableReference_default_instance_;
class TimeTableRequest;
struct TimeTableRequestDefaultTypeInternal;
extern TimeTableRequestDefaultTypeInternal _TimeTableRequest_default_instance_;
class UngroupRequest;
struct UngroupRequestDefaultTypeInternal;
extern UngroupRequestDefaultTypeInternal _UngroupRequest_default_instance_;
class UnstructuredFilterTableRequest;
struct UnstructuredFilterTableRequestDefaultTypeInternal;
extern UnstructuredFilterTableRequestDefaultTypeInternal _UnstructuredFilterTableRequest_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
}  // namespace grpc
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io
PROTOBUF_NAMESPACE_OPEN
template<> ::io::deephaven::proto::backplane::grpc::AndCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AndCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::BatchTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::BatchTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::CompareCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CompareCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Condition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Condition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ContainsCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ContainsCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::DropColumnsRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::EmptyTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FetchTableMapRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::FetchTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FetchTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::FilterTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FilterTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::FlattenRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FlattenRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::HeadOrTailRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::InCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::InCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::InvokeCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::InvokeCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::IsNullCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::IsNullCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Literal* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Literal>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::MatchesCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MatchesCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MergeTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::NotCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::NotCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::OrCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::OrCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Reference* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Reference>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SearchCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SearchCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SelectDistinctRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SnapshotTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SortDescriptor* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SortDescriptor>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SortTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SortTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::TableReference* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::TimeTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TimeTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UngroupRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UngroupRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Value* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace grpc {

enum AsOfJoinTablesRequest_MatchRule : int {
  AsOfJoinTablesRequest_MatchRule_LESS_THAN_EQUAL = 0,
  AsOfJoinTablesRequest_MatchRule_LESS_THAN = 1,
  AsOfJoinTablesRequest_MatchRule_GREATER_THAN_EQUAL = 2,
  AsOfJoinTablesRequest_MatchRule_GREATER_THAN = 3,
  AsOfJoinTablesRequest_MatchRule_AsOfJoinTablesRequest_MatchRule_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  AsOfJoinTablesRequest_MatchRule_AsOfJoinTablesRequest_MatchRule_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool AsOfJoinTablesRequest_MatchRule_IsValid(int value);
constexpr AsOfJoinTablesRequest_MatchRule AsOfJoinTablesRequest_MatchRule_MatchRule_MIN = AsOfJoinTablesRequest_MatchRule_LESS_THAN_EQUAL;
constexpr AsOfJoinTablesRequest_MatchRule AsOfJoinTablesRequest_MatchRule_MatchRule_MAX = AsOfJoinTablesRequest_MatchRule_GREATER_THAN;
constexpr int AsOfJoinTablesRequest_MatchRule_MatchRule_ARRAYSIZE = AsOfJoinTablesRequest_MatchRule_MatchRule_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsOfJoinTablesRequest_MatchRule_descriptor();
template<typename T>
inline const std::string& AsOfJoinTablesRequest_MatchRule_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AsOfJoinTablesRequest_MatchRule>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AsOfJoinTablesRequest_MatchRule_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AsOfJoinTablesRequest_MatchRule_descriptor(), enum_t_value);
}
inline bool AsOfJoinTablesRequest_MatchRule_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AsOfJoinTablesRequest_MatchRule* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AsOfJoinTablesRequest_MatchRule>(
    AsOfJoinTablesRequest_MatchRule_descriptor(), name, value);
}
enum ComboAggregateRequest_AggType : int {
  ComboAggregateRequest_AggType_SUM = 0,
  ComboAggregateRequest_AggType_ABS_SUM = 1,
  ComboAggregateRequest_AggType_ARRAY = 2,
  ComboAggregateRequest_AggType_AVG = 3,
  ComboAggregateRequest_AggType_COUNT = 4,
  ComboAggregateRequest_AggType_FIRST = 5,
  ComboAggregateRequest_AggType_LAST = 6,
  ComboAggregateRequest_AggType_MIN = 7,
  ComboAggregateRequest_AggType_MAX = 8,
  ComboAggregateRequest_AggType_MEDIAN = 9,
  ComboAggregateRequest_AggType_PERCENTILE = 10,
  ComboAggregateRequest_AggType_STD = 11,
  ComboAggregateRequest_AggType_VAR = 12,
  ComboAggregateRequest_AggType_WEIGHTED_AVG = 13,
  ComboAggregateRequest_AggType_ComboAggregateRequest_AggType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ComboAggregateRequest_AggType_ComboAggregateRequest_AggType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ComboAggregateRequest_AggType_IsValid(int value);
constexpr ComboAggregateRequest_AggType ComboAggregateRequest_AggType_AggType_MIN = ComboAggregateRequest_AggType_SUM;
constexpr ComboAggregateRequest_AggType ComboAggregateRequest_AggType_AggType_MAX = ComboAggregateRequest_AggType_WEIGHTED_AVG;
constexpr int ComboAggregateRequest_AggType_AggType_ARRAYSIZE = ComboAggregateRequest_AggType_AggType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ComboAggregateRequest_AggType_descriptor();
template<typename T>
inline const std::string& ComboAggregateRequest_AggType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ComboAggregateRequest_AggType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ComboAggregateRequest_AggType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ComboAggregateRequest_AggType_descriptor(), enum_t_value);
}
inline bool ComboAggregateRequest_AggType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ComboAggregateRequest_AggType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ComboAggregateRequest_AggType>(
    ComboAggregateRequest_AggType_descriptor(), name, value);
}
enum SortDescriptor_SortDirection : int {
  SortDescriptor_SortDirection_UNKNOWN = 0,
  SortDescriptor_SortDirection_DESCENDING = -1,
  SortDescriptor_SortDirection_ASCENDING = 1,
  SortDescriptor_SortDirection_REVERSE = 2,
  SortDescriptor_SortDirection_SortDescriptor_SortDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  SortDescriptor_SortDirection_SortDescriptor_SortDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool SortDescriptor_SortDirection_IsValid(int value);
constexpr SortDescriptor_SortDirection SortDescriptor_SortDirection_SortDirection_MIN = SortDescriptor_SortDirection_DESCENDING;
constexpr SortDescriptor_SortDirection SortDescriptor_SortDirection_SortDirection_MAX = SortDescriptor_SortDirection_REVERSE;
constexpr int SortDescriptor_SortDirection_SortDirection_ARRAYSIZE = SortDescriptor_SortDirection_SortDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SortDescriptor_SortDirection_descriptor();
template<typename T>
inline const std::string& SortDescriptor_SortDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SortDescriptor_SortDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SortDescriptor_SortDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SortDescriptor_SortDirection_descriptor(), enum_t_value);
}
inline bool SortDescriptor_SortDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SortDescriptor_SortDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SortDescriptor_SortDirection>(
    SortDescriptor_SortDirection_descriptor(), name, value);
}
enum CompareCondition_CompareOperation : int {
  CompareCondition_CompareOperation_LESS_THAN = 0,
  CompareCondition_CompareOperation_LESS_THAN_OR_EQUAL = 1,
  CompareCondition_CompareOperation_GREATER_THAN = 2,
  CompareCondition_CompareOperation_GREATER_THAN_OR_EQUAL = 3,
  CompareCondition_CompareOperation_EQUALS = 4,
  CompareCondition_CompareOperation_NOT_EQUALS = 5,
  CompareCondition_CompareOperation_CompareCondition_CompareOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CompareCondition_CompareOperation_CompareCondition_CompareOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CompareCondition_CompareOperation_IsValid(int value);
constexpr CompareCondition_CompareOperation CompareCondition_CompareOperation_CompareOperation_MIN = CompareCondition_CompareOperation_LESS_THAN;
constexpr CompareCondition_CompareOperation CompareCondition_CompareOperation_CompareOperation_MAX = CompareCondition_CompareOperation_NOT_EQUALS;
constexpr int CompareCondition_CompareOperation_CompareOperation_ARRAYSIZE = CompareCondition_CompareOperation_CompareOperation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompareCondition_CompareOperation_descriptor();
template<typename T>
inline const std::string& CompareCondition_CompareOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompareCondition_CompareOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompareCondition_CompareOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompareCondition_CompareOperation_descriptor(), enum_t_value);
}
inline bool CompareCondition_CompareOperation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompareCondition_CompareOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompareCondition_CompareOperation>(
    CompareCondition_CompareOperation_descriptor(), name, value);
}
enum CaseSensitivity : int {
  MATCH_CASE = 0,
  IGNORE_CASE = 1,
  CaseSensitivity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  CaseSensitivity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool CaseSensitivity_IsValid(int value);
constexpr CaseSensitivity CaseSensitivity_MIN = MATCH_CASE;
constexpr CaseSensitivity CaseSensitivity_MAX = IGNORE_CASE;
constexpr int CaseSensitivity_ARRAYSIZE = CaseSensitivity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CaseSensitivity_descriptor();
template<typename T>
inline const std::string& CaseSensitivity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CaseSensitivity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CaseSensitivity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CaseSensitivity_descriptor(), enum_t_value);
}
inline bool CaseSensitivity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CaseSensitivity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CaseSensitivity>(
    CaseSensitivity_descriptor(), name, value);
}
enum MatchType : int {
  REGULAR = 0,
  INVERTED = 1,
  MatchType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  MatchType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool MatchType_IsValid(int value);
constexpr MatchType MatchType_MIN = REGULAR;
constexpr MatchType MatchType_MAX = INVERTED;
constexpr int MatchType_ARRAYSIZE = MatchType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchType_descriptor();
template<typename T>
inline const std::string& MatchType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MatchType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MatchType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MatchType_descriptor(), enum_t_value);
}
inline bool MatchType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MatchType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MatchType>(
    MatchType_descriptor(), name, value);
}
// ===================================================================

class TableReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.TableReference) */ {
 public:
  inline TableReference() : TableReference(nullptr) {}
  ~TableReference() override;
  explicit constexpr TableReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableReference(const TableReference& from);
  TableReference(TableReference&& from) noexcept
    : TableReference() {
    *this = ::std::move(from);
  }

  inline TableReference& operator=(const TableReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableReference& operator=(TableReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableReference& default_instance() {
    return *internal_default_instance();
  }
  enum RefCase {
    kTicket = 1,
    kBatchOffset = 2,
    REF_NOT_SET = 0,
  };

  static inline const TableReference* internal_default_instance() {
    return reinterpret_cast<const TableReference*>(
               &_TableReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TableReference& a, TableReference& b) {
    a.Swap(&b);
  }
  inline void Swap(TableReference* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableReference* New() const final {
    return new TableReference();
  }

  TableReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableReference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableReference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.TableReference";
  }
  protected:
  explicit TableReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketFieldNumber = 1,
    kBatchOffsetFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket ticket = 1;
  bool has_ticket() const;
  private:
  bool _internal_has_ticket() const;
  public:
  void clear_ticket();
  const ::io::deephaven::proto::backplane::grpc::Ticket& ticket() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_ticket();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_ticket();
  void set_allocated_ticket(::io::deephaven::proto::backplane::grpc::Ticket* ticket);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_ticket() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_ticket();
  public:
  void unsafe_arena_set_allocated_ticket(
      ::io::deephaven::proto::backplane::grpc::Ticket* ticket);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_ticket();

  // sint32 batch_offset = 2;
  bool has_batch_offset() const;
  private:
  bool _internal_has_batch_offset() const;
  public:
  void clear_batch_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 batch_offset() const;
  void set_batch_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batch_offset() const;
  void _internal_set_batch_offset(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  void clear_ref();
  RefCase ref_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.TableReference)
 private:
  class _Internal;
  void set_has_ticket();
  void set_has_batch_offset();

  inline bool has_ref() const;
  inline void clear_has_ref();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union RefUnion {
    constexpr RefUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::Ticket* ticket_;
    ::PROTOBUF_NAMESPACE_ID::int32 batch_offset_;
  } ref_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ExportedTableCreationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse) */ {
 public:
  inline ExportedTableCreationResponse() : ExportedTableCreationResponse(nullptr) {}
  ~ExportedTableCreationResponse() override;
  explicit constexpr ExportedTableCreationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExportedTableCreationResponse(const ExportedTableCreationResponse& from);
  ExportedTableCreationResponse(ExportedTableCreationResponse&& from) noexcept
    : ExportedTableCreationResponse() {
    *this = ::std::move(from);
  }

  inline ExportedTableCreationResponse& operator=(const ExportedTableCreationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportedTableCreationResponse& operator=(ExportedTableCreationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportedTableCreationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportedTableCreationResponse* internal_default_instance() {
    return reinterpret_cast<const ExportedTableCreationResponse*>(
               &_ExportedTableCreationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ExportedTableCreationResponse& a, ExportedTableCreationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportedTableCreationResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportedTableCreationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExportedTableCreationResponse* New() const final {
    return new ExportedTableCreationResponse();
  }

  ExportedTableCreationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExportedTableCreationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExportedTableCreationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExportedTableCreationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExportedTableCreationResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse";
  }
  protected:
  explicit ExportedTableCreationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorInfoFieldNumber = 3,
    kSchemaHeaderFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSizeFieldNumber = 6,
    kSuccessFieldNumber = 2,
    kIsStaticFieldNumber = 5,
  };
  // string error_info = 3;
  void clear_error_info();
  const std::string& error_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_info();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_info();
  void set_allocated_error_info(std::string* error_info);
  private:
  const std::string& _internal_error_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_info(const std::string& value);
  std::string* _internal_mutable_error_info();
  public:

  // bytes schema_header = 4;
  void clear_schema_header();
  const std::string& schema_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_header();
  PROTOBUF_MUST_USE_RESULT std::string* release_schema_header();
  void set_allocated_schema_header(std::string* schema_header);
  private:
  const std::string& _internal_schema_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_header(const std::string& value);
  std::string* _internal_mutable_schema_header();
  public:

  // .io.deephaven.proto.backplane.grpc.TableReference result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_result_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::TableReference* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* result_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_result_id();

  // sint64 size = 6 [jstype = JS_STRING];
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // bool is_static = 5;
  void clear_is_static();
  bool is_static() const;
  void set_is_static(bool value);
  private:
  bool _internal_is_static() const;
  void _internal_set_is_static(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_header_;
  ::io::deephaven::proto::backplane::grpc::TableReference* result_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 size_;
  bool success_;
  bool is_static_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class FetchTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FetchTableRequest) */ {
 public:
  inline FetchTableRequest() : FetchTableRequest(nullptr) {}
  ~FetchTableRequest() override;
  explicit constexpr FetchTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchTableRequest(const FetchTableRequest& from);
  FetchTableRequest(FetchTableRequest&& from) noexcept
    : FetchTableRequest() {
    *this = ::std::move(from);
  }

  inline FetchTableRequest& operator=(const FetchTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchTableRequest& operator=(FetchTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchTableRequest* internal_default_instance() {
    return reinterpret_cast<const FetchTableRequest*>(
               &_FetchTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FetchTableRequest& a, FetchTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchTableRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FetchTableRequest* New() const final {
    return new FetchTableRequest();
  }

  FetchTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FetchTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FetchTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchTableRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FetchTableRequest";
  }
  protected:
  explicit FetchTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 1,
    kResultIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FetchTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class FetchPandasTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FetchPandasTableRequest) */ {
 public:
  inline FetchPandasTableRequest() : FetchPandasTableRequest(nullptr) {}
  ~FetchPandasTableRequest() override;
  explicit constexpr FetchPandasTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchPandasTableRequest(const FetchPandasTableRequest& from);
  FetchPandasTableRequest(FetchPandasTableRequest&& from) noexcept
    : FetchPandasTableRequest() {
    *this = ::std::move(from);
  }

  inline FetchPandasTableRequest& operator=(const FetchPandasTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchPandasTableRequest& operator=(FetchPandasTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchPandasTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchPandasTableRequest* internal_default_instance() {
    return reinterpret_cast<const FetchPandasTableRequest*>(
               &_FetchPandasTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FetchPandasTableRequest& a, FetchPandasTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchPandasTableRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchPandasTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FetchPandasTableRequest* New() const final {
    return new FetchPandasTableRequest();
  }

  FetchPandasTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FetchPandasTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchPandasTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FetchPandasTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchPandasTableRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FetchPandasTableRequest";
  }
  protected:
  explicit FetchPandasTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 1,
    kResultIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FetchPandasTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class FetchTableMapRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FetchTableMapRequest) */ {
 public:
  inline FetchTableMapRequest() : FetchTableMapRequest(nullptr) {}
  ~FetchTableMapRequest() override;
  explicit constexpr FetchTableMapRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchTableMapRequest(const FetchTableMapRequest& from);
  FetchTableMapRequest(FetchTableMapRequest&& from) noexcept
    : FetchTableMapRequest() {
    *this = ::std::move(from);
  }

  inline FetchTableMapRequest& operator=(const FetchTableMapRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchTableMapRequest& operator=(FetchTableMapRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchTableMapRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchTableMapRequest* internal_default_instance() {
    return reinterpret_cast<const FetchTableMapRequest*>(
               &_FetchTableMapRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FetchTableMapRequest& a, FetchTableMapRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchTableMapRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchTableMapRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FetchTableMapRequest* New() const final {
    return new FetchTableMapRequest();
  }

  FetchTableMapRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FetchTableMapRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchTableMapRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FetchTableMapRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchTableMapRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FetchTableMapRequest";
  }
  protected:
  explicit FetchTableMapRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 1,
    kResultIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FetchTableMapRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class FetchTableMapResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FetchTableMapResponse) */ {
 public:
  inline FetchTableMapResponse() : FetchTableMapResponse(nullptr) {}
  explicit constexpr FetchTableMapResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchTableMapResponse(const FetchTableMapResponse& from);
  FetchTableMapResponse(FetchTableMapResponse&& from) noexcept
    : FetchTableMapResponse() {
    *this = ::std::move(from);
  }

  inline FetchTableMapResponse& operator=(const FetchTableMapResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchTableMapResponse& operator=(FetchTableMapResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchTableMapResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchTableMapResponse* internal_default_instance() {
    return reinterpret_cast<const FetchTableMapResponse*>(
               &_FetchTableMapResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FetchTableMapResponse& a, FetchTableMapResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchTableMapResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchTableMapResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FetchTableMapResponse* New() const final {
    return new FetchTableMapResponse();
  }

  FetchTableMapResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FetchTableMapResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FetchTableMapResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FetchTableMapResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FetchTableMapResponse";
  }
  protected:
  explicit FetchTableMapResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FetchTableMapResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ExportedTableUpdatesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ExportedTableUpdatesRequest) */ {
 public:
  inline ExportedTableUpdatesRequest() : ExportedTableUpdatesRequest(nullptr) {}
  explicit constexpr ExportedTableUpdatesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExportedTableUpdatesRequest(const ExportedTableUpdatesRequest& from);
  ExportedTableUpdatesRequest(ExportedTableUpdatesRequest&& from) noexcept
    : ExportedTableUpdatesRequest() {
    *this = ::std::move(from);
  }

  inline ExportedTableUpdatesRequest& operator=(const ExportedTableUpdatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportedTableUpdatesRequest& operator=(ExportedTableUpdatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportedTableUpdatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportedTableUpdatesRequest* internal_default_instance() {
    return reinterpret_cast<const ExportedTableUpdatesRequest*>(
               &_ExportedTableUpdatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ExportedTableUpdatesRequest& a, ExportedTableUpdatesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportedTableUpdatesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportedTableUpdatesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExportedTableUpdatesRequest* New() const final {
    return new ExportedTableUpdatesRequest();
  }

  ExportedTableUpdatesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExportedTableUpdatesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ExportedTableUpdatesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ExportedTableUpdatesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ExportedTableUpdatesRequest";
  }
  protected:
  explicit ExportedTableUpdatesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ExportedTableUpdatesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ExportedTableUpdateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage) */ {
 public:
  inline ExportedTableUpdateMessage() : ExportedTableUpdateMessage(nullptr) {}
  ~ExportedTableUpdateMessage() override;
  explicit constexpr ExportedTableUpdateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExportedTableUpdateMessage(const ExportedTableUpdateMessage& from);
  ExportedTableUpdateMessage(ExportedTableUpdateMessage&& from) noexcept
    : ExportedTableUpdateMessage() {
    *this = ::std::move(from);
  }

  inline ExportedTableUpdateMessage& operator=(const ExportedTableUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportedTableUpdateMessage& operator=(ExportedTableUpdateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportedTableUpdateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportedTableUpdateMessage* internal_default_instance() {
    return reinterpret_cast<const ExportedTableUpdateMessage*>(
               &_ExportedTableUpdateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ExportedTableUpdateMessage& a, ExportedTableUpdateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportedTableUpdateMessage* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportedTableUpdateMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExportedTableUpdateMessage* New() const final {
    return new ExportedTableUpdateMessage();
  }

  ExportedTableUpdateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExportedTableUpdateMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExportedTableUpdateMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExportedTableUpdateMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExportedTableUpdateMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage";
  }
  protected:
  explicit ExportedTableUpdateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateFailureMessageFieldNumber = 3,
    kExportIdFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // string update_failure_message = 3;
  void clear_update_failure_message();
  const std::string& update_failure_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_update_failure_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_update_failure_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_update_failure_message();
  void set_allocated_update_failure_message(std::string* update_failure_message);
  private:
  const std::string& _internal_update_failure_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_failure_message(const std::string& value);
  std::string* _internal_mutable_update_failure_message();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket export_id = 1;
  bool has_export_id() const;
  private:
  bool _internal_has_export_id() const;
  public:
  void clear_export_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& export_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_export_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_export_id();
  void set_allocated_export_id(::io::deephaven::proto::backplane::grpc::Ticket* export_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_export_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_export_id();
  public:
  void unsafe_arena_set_allocated_export_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* export_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_export_id();

  // sint64 size = 2 [jstype = JS_STRING];
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr update_failure_message_;
  ::io::deephaven::proto::backplane::grpc::Ticket* export_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class EmptyTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.EmptyTableRequest) */ {
 public:
  inline EmptyTableRequest() : EmptyTableRequest(nullptr) {}
  ~EmptyTableRequest() override;
  explicit constexpr EmptyTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyTableRequest(const EmptyTableRequest& from);
  EmptyTableRequest(EmptyTableRequest&& from) noexcept
    : EmptyTableRequest() {
    *this = ::std::move(from);
  }

  inline EmptyTableRequest& operator=(const EmptyTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyTableRequest& operator=(EmptyTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyTableRequest* internal_default_instance() {
    return reinterpret_cast<const EmptyTableRequest*>(
               &_EmptyTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EmptyTableRequest& a, EmptyTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyTableRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmptyTableRequest* New() const final {
    return new EmptyTableRequest();
  }

  EmptyTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmptyTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EmptyTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyTableRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.EmptyTableRequest";
  }
  protected:
  explicit EmptyTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // sint64 size = 2 [jstype = JS_STRING];
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::int64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.EmptyTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class TimeTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.TimeTableRequest) */ {
 public:
  inline TimeTableRequest() : TimeTableRequest(nullptr) {}
  ~TimeTableRequest() override;
  explicit constexpr TimeTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeTableRequest(const TimeTableRequest& from);
  TimeTableRequest(TimeTableRequest&& from) noexcept
    : TimeTableRequest() {
    *this = ::std::move(from);
  }

  inline TimeTableRequest& operator=(const TimeTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeTableRequest& operator=(TimeTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeTableRequest* internal_default_instance() {
    return reinterpret_cast<const TimeTableRequest*>(
               &_TimeTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TimeTableRequest& a, TimeTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeTableRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimeTableRequest* New() const final {
    return new TimeTableRequest();
  }

  TimeTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimeTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TimeTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeTableRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.TimeTableRequest";
  }
  protected:
  explicit TimeTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kStartTimeNanosFieldNumber = 2,
    kPeriodNanosFieldNumber = 3,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // sint64 start_time_nanos = 2 [jstype = JS_STRING];
  void clear_start_time_nanos();
  ::PROTOBUF_NAMESPACE_ID::int64 start_time_nanos() const;
  void set_start_time_nanos(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_start_time_nanos() const;
  void _internal_set_start_time_nanos(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // sint64 period_nanos = 3 [jstype = JS_STRING];
  void clear_period_nanos();
  ::PROTOBUF_NAMESPACE_ID::int64 period_nanos() const;
  void set_period_nanos(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_period_nanos() const;
  void _internal_set_period_nanos(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.TimeTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 start_time_nanos_;
  ::PROTOBUF_NAMESPACE_ID::int64 period_nanos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SelectOrUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest) */ {
 public:
  inline SelectOrUpdateRequest() : SelectOrUpdateRequest(nullptr) {}
  ~SelectOrUpdateRequest() override;
  explicit constexpr SelectOrUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectOrUpdateRequest(const SelectOrUpdateRequest& from);
  SelectOrUpdateRequest(SelectOrUpdateRequest&& from) noexcept
    : SelectOrUpdateRequest() {
    *this = ::std::move(from);
  }

  inline SelectOrUpdateRequest& operator=(const SelectOrUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectOrUpdateRequest& operator=(SelectOrUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectOrUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectOrUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const SelectOrUpdateRequest*>(
               &_SelectOrUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SelectOrUpdateRequest& a, SelectOrUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectOrUpdateRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectOrUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SelectOrUpdateRequest* New() const final {
    return new SelectOrUpdateRequest();
  }

  SelectOrUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SelectOrUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectOrUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SelectOrUpdateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectOrUpdateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest";
  }
  protected:
  explicit SelectOrUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnSpecsFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated string column_specs = 3;
  int column_specs_size() const;
  private:
  int _internal_column_specs_size() const;
  public:
  void clear_column_specs();
  const std::string& column_specs(int index) const;
  std::string* mutable_column_specs(int index);
  void set_column_specs(int index, const std::string& value);
  void set_column_specs(int index, std::string&& value);
  void set_column_specs(int index, const char* value);
  void set_column_specs(int index, const char* value, size_t size);
  std::string* add_column_specs();
  void add_column_specs(const std::string& value);
  void add_column_specs(std::string&& value);
  void add_column_specs(const char* value);
  void add_column_specs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_specs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_specs();
  private:
  const std::string& _internal_column_specs(int index) const;
  std::string* _internal_add_column_specs();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_specs_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SelectDistinctRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SelectDistinctRequest) */ {
 public:
  inline SelectDistinctRequest() : SelectDistinctRequest(nullptr) {}
  ~SelectDistinctRequest() override;
  explicit constexpr SelectDistinctRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectDistinctRequest(const SelectDistinctRequest& from);
  SelectDistinctRequest(SelectDistinctRequest&& from) noexcept
    : SelectDistinctRequest() {
    *this = ::std::move(from);
  }

  inline SelectDistinctRequest& operator=(const SelectDistinctRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectDistinctRequest& operator=(SelectDistinctRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectDistinctRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectDistinctRequest* internal_default_instance() {
    return reinterpret_cast<const SelectDistinctRequest*>(
               &_SelectDistinctRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SelectDistinctRequest& a, SelectDistinctRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectDistinctRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectDistinctRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SelectDistinctRequest* New() const final {
    return new SelectDistinctRequest();
  }

  SelectDistinctRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SelectDistinctRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectDistinctRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SelectDistinctRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectDistinctRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SelectDistinctRequest";
  }
  protected:
  explicit SelectDistinctRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNamesFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated string column_names = 3;
  int column_names_size() const;
  private:
  int _internal_column_names_size() const;
  public:
  void clear_column_names();
  const std::string& column_names(int index) const;
  std::string* mutable_column_names(int index);
  void set_column_names(int index, const std::string& value);
  void set_column_names(int index, std::string&& value);
  void set_column_names(int index, const char* value);
  void set_column_names(int index, const char* value, size_t size);
  std::string* add_column_names();
  void add_column_names(const std::string& value);
  void add_column_names(std::string&& value);
  void add_column_names(const char* value);
  void add_column_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_names();
  private:
  const std::string& _internal_column_names(int index) const;
  std::string* _internal_add_column_names();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SelectDistinctRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_names_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class DropColumnsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.DropColumnsRequest) */ {
 public:
  inline DropColumnsRequest() : DropColumnsRequest(nullptr) {}
  ~DropColumnsRequest() override;
  explicit constexpr DropColumnsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropColumnsRequest(const DropColumnsRequest& from);
  DropColumnsRequest(DropColumnsRequest&& from) noexcept
    : DropColumnsRequest() {
    *this = ::std::move(from);
  }

  inline DropColumnsRequest& operator=(const DropColumnsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumnsRequest& operator=(DropColumnsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumnsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumnsRequest* internal_default_instance() {
    return reinterpret_cast<const DropColumnsRequest*>(
               &_DropColumnsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DropColumnsRequest& a, DropColumnsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumnsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumnsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DropColumnsRequest* New() const final {
    return new DropColumnsRequest();
  }

  DropColumnsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DropColumnsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropColumnsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DropColumnsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropColumnsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.DropColumnsRequest";
  }
  protected:
  explicit DropColumnsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNamesFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated string column_names = 3;
  int column_names_size() const;
  private:
  int _internal_column_names_size() const;
  public:
  void clear_column_names();
  const std::string& column_names(int index) const;
  std::string* mutable_column_names(int index);
  void set_column_names(int index, const std::string& value);
  void set_column_names(int index, std::string&& value);
  void set_column_names(int index, const char* value);
  void set_column_names(int index, const char* value, size_t size);
  std::string* add_column_names();
  void add_column_names(const std::string& value);
  void add_column_names(std::string&& value);
  void add_column_names(const char* value);
  void add_column_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_names();
  private:
  const std::string& _internal_column_names(int index) const;
  std::string* _internal_add_column_names();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.DropColumnsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_names_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UnstructuredFilterTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest) */ {
 public:
  inline UnstructuredFilterTableRequest() : UnstructuredFilterTableRequest(nullptr) {}
  ~UnstructuredFilterTableRequest() override;
  explicit constexpr UnstructuredFilterTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnstructuredFilterTableRequest(const UnstructuredFilterTableRequest& from);
  UnstructuredFilterTableRequest(UnstructuredFilterTableRequest&& from) noexcept
    : UnstructuredFilterTableRequest() {
    *this = ::std::move(from);
  }

  inline UnstructuredFilterTableRequest& operator=(const UnstructuredFilterTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnstructuredFilterTableRequest& operator=(UnstructuredFilterTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnstructuredFilterTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnstructuredFilterTableRequest* internal_default_instance() {
    return reinterpret_cast<const UnstructuredFilterTableRequest*>(
               &_UnstructuredFilterTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UnstructuredFilterTableRequest& a, UnstructuredFilterTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnstructuredFilterTableRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnstructuredFilterTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UnstructuredFilterTableRequest* New() const final {
    return new UnstructuredFilterTableRequest();
  }

  UnstructuredFilterTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UnstructuredFilterTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnstructuredFilterTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnstructuredFilterTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnstructuredFilterTableRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest";
  }
  protected:
  explicit UnstructuredFilterTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated string filters = 3;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class HeadOrTailRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.HeadOrTailRequest) */ {
 public:
  inline HeadOrTailRequest() : HeadOrTailRequest(nullptr) {}
  ~HeadOrTailRequest() override;
  explicit constexpr HeadOrTailRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeadOrTailRequest(const HeadOrTailRequest& from);
  HeadOrTailRequest(HeadOrTailRequest&& from) noexcept
    : HeadOrTailRequest() {
    *this = ::std::move(from);
  }

  inline HeadOrTailRequest& operator=(const HeadOrTailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadOrTailRequest& operator=(HeadOrTailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeadOrTailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeadOrTailRequest* internal_default_instance() {
    return reinterpret_cast<const HeadOrTailRequest*>(
               &_HeadOrTailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HeadOrTailRequest& a, HeadOrTailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeadOrTailRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeadOrTailRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeadOrTailRequest* New() const final {
    return new HeadOrTailRequest();
  }

  HeadOrTailRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeadOrTailRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeadOrTailRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeadOrTailRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeadOrTailRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.HeadOrTailRequest";
  }
  protected:
  explicit HeadOrTailRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kNumRowsFieldNumber = 3,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // sint64 num_rows = 3 [jstype = JS_STRING];
  void clear_num_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 num_rows() const;
  void set_num_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_rows() const;
  void _internal_set_num_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.HeadOrTailRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_rows_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class HeadOrTailByRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest) */ {
 public:
  inline HeadOrTailByRequest() : HeadOrTailByRequest(nullptr) {}
  ~HeadOrTailByRequest() override;
  explicit constexpr HeadOrTailByRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeadOrTailByRequest(const HeadOrTailByRequest& from);
  HeadOrTailByRequest(HeadOrTailByRequest&& from) noexcept
    : HeadOrTailByRequest() {
    *this = ::std::move(from);
  }

  inline HeadOrTailByRequest& operator=(const HeadOrTailByRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadOrTailByRequest& operator=(HeadOrTailByRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeadOrTailByRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeadOrTailByRequest* internal_default_instance() {
    return reinterpret_cast<const HeadOrTailByRequest*>(
               &_HeadOrTailByRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HeadOrTailByRequest& a, HeadOrTailByRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeadOrTailByRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeadOrTailByRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HeadOrTailByRequest* New() const final {
    return new HeadOrTailByRequest();
  }

  HeadOrTailByRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HeadOrTailByRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeadOrTailByRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeadOrTailByRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeadOrTailByRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.HeadOrTailByRequest";
  }
  protected:
  explicit HeadOrTailByRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupByColumnSpecsFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kNumRowsFieldNumber = 3,
  };
  // repeated string group_by_column_specs = 4;
  int group_by_column_specs_size() const;
  private:
  int _internal_group_by_column_specs_size() const;
  public:
  void clear_group_by_column_specs();
  const std::string& group_by_column_specs(int index) const;
  std::string* mutable_group_by_column_specs(int index);
  void set_group_by_column_specs(int index, const std::string& value);
  void set_group_by_column_specs(int index, std::string&& value);
  void set_group_by_column_specs(int index, const char* value);
  void set_group_by_column_specs(int index, const char* value, size_t size);
  std::string* add_group_by_column_specs();
  void add_group_by_column_specs(const std::string& value);
  void add_group_by_column_specs(std::string&& value);
  void add_group_by_column_specs(const char* value);
  void add_group_by_column_specs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& group_by_column_specs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_group_by_column_specs();
  private:
  const std::string& _internal_group_by_column_specs(int index) const;
  std::string* _internal_add_group_by_column_specs();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // sint64 num_rows = 3 [jstype = JS_STRING];
  void clear_num_rows();
  ::PROTOBUF_NAMESPACE_ID::int64 num_rows() const;
  void set_num_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_num_rows() const;
  void _internal_set_num_rows(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> group_by_column_specs_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  ::PROTOBUF_NAMESPACE_ID::int64 num_rows_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UngroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UngroupRequest) */ {
 public:
  inline UngroupRequest() : UngroupRequest(nullptr) {}
  ~UngroupRequest() override;
  explicit constexpr UngroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UngroupRequest(const UngroupRequest& from);
  UngroupRequest(UngroupRequest&& from) noexcept
    : UngroupRequest() {
    *this = ::std::move(from);
  }

  inline UngroupRequest& operator=(const UngroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UngroupRequest& operator=(UngroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UngroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UngroupRequest* internal_default_instance() {
    return reinterpret_cast<const UngroupRequest*>(
               &_UngroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UngroupRequest& a, UngroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UngroupRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UngroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UngroupRequest* New() const final {
    return new UngroupRequest();
  }

  UngroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UngroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UngroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UngroupRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UngroupRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UngroupRequest";
  }
  protected:
  explicit UngroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToUngroupFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kNullFillFieldNumber = 3,
  };
  // repeated string columns_to_ungroup = 4;
  int columns_to_ungroup_size() const;
  private:
  int _internal_columns_to_ungroup_size() const;
  public:
  void clear_columns_to_ungroup();
  const std::string& columns_to_ungroup(int index) const;
  std::string* mutable_columns_to_ungroup(int index);
  void set_columns_to_ungroup(int index, const std::string& value);
  void set_columns_to_ungroup(int index, std::string&& value);
  void set_columns_to_ungroup(int index, const char* value);
  void set_columns_to_ungroup(int index, const char* value, size_t size);
  std::string* add_columns_to_ungroup();
  void add_columns_to_ungroup(const std::string& value);
  void add_columns_to_ungroup(std::string&& value);
  void add_columns_to_ungroup(const char* value);
  void add_columns_to_ungroup(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_ungroup() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_ungroup();
  private:
  const std::string& _internal_columns_to_ungroup(int index) const;
  std::string* _internal_add_columns_to_ungroup();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // bool null_fill = 3;
  void clear_null_fill();
  bool null_fill() const;
  void set_null_fill(bool value);
  private:
  bool _internal_null_fill() const;
  void _internal_set_null_fill(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UngroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_ungroup_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  bool null_fill_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class MergeTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MergeTablesRequest) */ {
 public:
  inline MergeTablesRequest() : MergeTablesRequest(nullptr) {}
  ~MergeTablesRequest() override;
  explicit constexpr MergeTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MergeTablesRequest(const MergeTablesRequest& from);
  MergeTablesRequest(MergeTablesRequest&& from) noexcept
    : MergeTablesRequest() {
    *this = ::std::move(from);
  }

  inline MergeTablesRequest& operator=(const MergeTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MergeTablesRequest& operator=(MergeTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MergeTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MergeTablesRequest* internal_default_instance() {
    return reinterpret_cast<const MergeTablesRequest*>(
               &_MergeTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(MergeTablesRequest& a, MergeTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MergeTablesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MergeTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MergeTablesRequest* New() const final {
    return new MergeTablesRequest();
  }

  MergeTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MergeTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MergeTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MergeTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MergeTablesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MergeTablesRequest";
  }
  protected:
  explicit MergeTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdsFieldNumber = 2,
    kKeyColumnFieldNumber = 3,
    kResultIdFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.TableReference source_ids = 2;
  int source_ids_size() const;
  private:
  int _internal_source_ids_size() const;
  public:
  void clear_source_ids();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference >*
      mutable_source_ids();
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_ids(int index) const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_add_source_ids();
  public:
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_ids(int index) const;
  ::io::deephaven::proto::backplane::grpc::TableReference* add_source_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference >&
      source_ids() const;

  // string key_column = 3;
  void clear_key_column();
  const std::string& key_column() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_column(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_column();
  PROTOBUF_MUST_USE_RESULT std::string* release_key_column();
  void set_allocated_key_column(std::string* key_column);
  private:
  const std::string& _internal_key_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_column(const std::string& value);
  std::string* _internal_mutable_key_column();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MergeTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference > source_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_column_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SnapshotTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SnapshotTableRequest) */ {
 public:
  inline SnapshotTableRequest() : SnapshotTableRequest(nullptr) {}
  ~SnapshotTableRequest() override;
  explicit constexpr SnapshotTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotTableRequest(const SnapshotTableRequest& from);
  SnapshotTableRequest(SnapshotTableRequest&& from) noexcept
    : SnapshotTableRequest() {
    *this = ::std::move(from);
  }

  inline SnapshotTableRequest& operator=(const SnapshotTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotTableRequest& operator=(SnapshotTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotTableRequest* internal_default_instance() {
    return reinterpret_cast<const SnapshotTableRequest*>(
               &_SnapshotTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(SnapshotTableRequest& a, SnapshotTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotTableRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SnapshotTableRequest* New() const final {
    return new SnapshotTableRequest();
  }

  SnapshotTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SnapshotTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SnapshotTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotTableRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SnapshotTableRequest";
  }
  protected:
  explicit SnapshotTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStampColumnsFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
    kDoInitialSnapshotFieldNumber = 4,
  };
  // repeated string stamp_columns = 5;
  int stamp_columns_size() const;
  private:
  int _internal_stamp_columns_size() const;
  public:
  void clear_stamp_columns();
  const std::string& stamp_columns(int index) const;
  std::string* mutable_stamp_columns(int index);
  void set_stamp_columns(int index, const std::string& value);
  void set_stamp_columns(int index, std::string&& value);
  void set_stamp_columns(int index, const char* value);
  void set_stamp_columns(int index, const char* value, size_t size);
  std::string* add_stamp_columns();
  void add_stamp_columns(const std::string& value);
  void add_stamp_columns(std::string&& value);
  void add_stamp_columns(const char* value);
  void add_stamp_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stamp_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stamp_columns();
  private:
  const std::string& _internal_stamp_columns(int index) const;
  std::string* _internal_add_stamp_columns();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // bool do_initial_snapshot = 4;
  void clear_do_initial_snapshot();
  bool do_initial_snapshot() const;
  void set_do_initial_snapshot(bool value);
  private:
  bool _internal_do_initial_snapshot() const;
  void _internal_set_do_initial_snapshot(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SnapshotTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stamp_columns_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  bool do_initial_snapshot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class CrossJoinTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest) */ {
 public:
  inline CrossJoinTablesRequest() : CrossJoinTablesRequest(nullptr) {}
  ~CrossJoinTablesRequest() override;
  explicit constexpr CrossJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CrossJoinTablesRequest(const CrossJoinTablesRequest& from);
  CrossJoinTablesRequest(CrossJoinTablesRequest&& from) noexcept
    : CrossJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline CrossJoinTablesRequest& operator=(const CrossJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrossJoinTablesRequest& operator=(CrossJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CrossJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CrossJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const CrossJoinTablesRequest*>(
               &_CrossJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CrossJoinTablesRequest& a, CrossJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CrossJoinTablesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrossJoinTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CrossJoinTablesRequest* New() const final {
    return new CrossJoinTablesRequest();
  }

  CrossJoinTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CrossJoinTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CrossJoinTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CrossJoinTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrossJoinTablesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest";
  }
  protected:
  explicit CrossJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
    kReserveBitsFieldNumber = 6,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;
  public:
  void clear_columns_to_match();
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, size_t size);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_match();
  private:
  const std::string& _internal_columns_to_match(int index) const;
  std::string* _internal_add_columns_to_match();
  public:

  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;
  public:
  void clear_columns_to_add();
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, size_t size);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_add();
  private:
  const std::string& _internal_columns_to_add(int index) const;
  std::string* _internal_add_columns_to_add();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // int32 reserve_bits = 6;
  void clear_reserve_bits();
  ::PROTOBUF_NAMESPACE_ID::int32 reserve_bits() const;
  void set_reserve_bits(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_reserve_bits() const;
  void _internal_set_reserve_bits(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_match_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_add_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 reserve_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class NaturalJoinTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest) */ {
 public:
  inline NaturalJoinTablesRequest() : NaturalJoinTablesRequest(nullptr) {}
  ~NaturalJoinTablesRequest() override;
  explicit constexpr NaturalJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NaturalJoinTablesRequest(const NaturalJoinTablesRequest& from);
  NaturalJoinTablesRequest(NaturalJoinTablesRequest&& from) noexcept
    : NaturalJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline NaturalJoinTablesRequest& operator=(const NaturalJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NaturalJoinTablesRequest& operator=(NaturalJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NaturalJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NaturalJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const NaturalJoinTablesRequest*>(
               &_NaturalJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(NaturalJoinTablesRequest& a, NaturalJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NaturalJoinTablesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NaturalJoinTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NaturalJoinTablesRequest* New() const final {
    return new NaturalJoinTablesRequest();
  }

  NaturalJoinTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NaturalJoinTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NaturalJoinTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NaturalJoinTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NaturalJoinTablesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest";
  }
  protected:
  explicit NaturalJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;
  public:
  void clear_columns_to_match();
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, size_t size);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_match();
  private:
  const std::string& _internal_columns_to_match(int index) const;
  std::string* _internal_add_columns_to_match();
  public:

  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;
  public:
  void clear_columns_to_add();
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, size_t size);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_add();
  private:
  const std::string& _internal_columns_to_add(int index) const;
  std::string* _internal_add_columns_to_add();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_match_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_add_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ExactJoinTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest) */ {
 public:
  inline ExactJoinTablesRequest() : ExactJoinTablesRequest(nullptr) {}
  ~ExactJoinTablesRequest() override;
  explicit constexpr ExactJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExactJoinTablesRequest(const ExactJoinTablesRequest& from);
  ExactJoinTablesRequest(ExactJoinTablesRequest&& from) noexcept
    : ExactJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline ExactJoinTablesRequest& operator=(const ExactJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExactJoinTablesRequest& operator=(ExactJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExactJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExactJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const ExactJoinTablesRequest*>(
               &_ExactJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ExactJoinTablesRequest& a, ExactJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExactJoinTablesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExactJoinTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExactJoinTablesRequest* New() const final {
    return new ExactJoinTablesRequest();
  }

  ExactJoinTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExactJoinTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExactJoinTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExactJoinTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExactJoinTablesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest";
  }
  protected:
  explicit ExactJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;
  public:
  void clear_columns_to_match();
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, size_t size);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_match();
  private:
  const std::string& _internal_columns_to_match(int index) const;
  std::string* _internal_add_columns_to_match();
  public:

  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;
  public:
  void clear_columns_to_add();
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, size_t size);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_add();
  private:
  const std::string& _internal_columns_to_add(int index) const;
  std::string* _internal_add_columns_to_add();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_match_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_add_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class LeftJoinTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest) */ {
 public:
  inline LeftJoinTablesRequest() : LeftJoinTablesRequest(nullptr) {}
  ~LeftJoinTablesRequest() override;
  explicit constexpr LeftJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeftJoinTablesRequest(const LeftJoinTablesRequest& from);
  LeftJoinTablesRequest(LeftJoinTablesRequest&& from) noexcept
    : LeftJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline LeftJoinTablesRequest& operator=(const LeftJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeftJoinTablesRequest& operator=(LeftJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeftJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeftJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const LeftJoinTablesRequest*>(
               &_LeftJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(LeftJoinTablesRequest& a, LeftJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeftJoinTablesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeftJoinTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeftJoinTablesRequest* New() const final {
    return new LeftJoinTablesRequest();
  }

  LeftJoinTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeftJoinTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeftJoinTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LeftJoinTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeftJoinTablesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest";
  }
  protected:
  explicit LeftJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;
  public:
  void clear_columns_to_match();
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, size_t size);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_match();
  private:
  const std::string& _internal_columns_to_match(int index) const;
  std::string* _internal_add_columns_to_match();
  public:

  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;
  public:
  void clear_columns_to_add();
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, size_t size);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_add();
  private:
  const std::string& _internal_columns_to_add(int index) const;
  std::string* _internal_add_columns_to_add();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_match_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_add_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AsOfJoinTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest) */ {
 public:
  inline AsOfJoinTablesRequest() : AsOfJoinTablesRequest(nullptr) {}
  ~AsOfJoinTablesRequest() override;
  explicit constexpr AsOfJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AsOfJoinTablesRequest(const AsOfJoinTablesRequest& from);
  AsOfJoinTablesRequest(AsOfJoinTablesRequest&& from) noexcept
    : AsOfJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline AsOfJoinTablesRequest& operator=(const AsOfJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsOfJoinTablesRequest& operator=(AsOfJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AsOfJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AsOfJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const AsOfJoinTablesRequest*>(
               &_AsOfJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(AsOfJoinTablesRequest& a, AsOfJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AsOfJoinTablesRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AsOfJoinTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AsOfJoinTablesRequest* New() const final {
    return new AsOfJoinTablesRequest();
  }

  AsOfJoinTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AsOfJoinTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AsOfJoinTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AsOfJoinTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AsOfJoinTablesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest";
  }
  protected:
  explicit AsOfJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AsOfJoinTablesRequest_MatchRule MatchRule;
  static constexpr MatchRule LESS_THAN_EQUAL =
    AsOfJoinTablesRequest_MatchRule_LESS_THAN_EQUAL;
  static constexpr MatchRule LESS_THAN =
    AsOfJoinTablesRequest_MatchRule_LESS_THAN;
  static constexpr MatchRule GREATER_THAN_EQUAL =
    AsOfJoinTablesRequest_MatchRule_GREATER_THAN_EQUAL;
  static constexpr MatchRule GREATER_THAN =
    AsOfJoinTablesRequest_MatchRule_GREATER_THAN;
  static inline bool MatchRule_IsValid(int value) {
    return AsOfJoinTablesRequest_MatchRule_IsValid(value);
  }
  static constexpr MatchRule MatchRule_MIN =
    AsOfJoinTablesRequest_MatchRule_MatchRule_MIN;
  static constexpr MatchRule MatchRule_MAX =
    AsOfJoinTablesRequest_MatchRule_MatchRule_MAX;
  static constexpr int MatchRule_ARRAYSIZE =
    AsOfJoinTablesRequest_MatchRule_MatchRule_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MatchRule_descriptor() {
    return AsOfJoinTablesRequest_MatchRule_descriptor();
  }
  template<typename T>
  static inline const std::string& MatchRule_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MatchRule>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MatchRule_Name.");
    return AsOfJoinTablesRequest_MatchRule_Name(enum_t_value);
  }
  static inline bool MatchRule_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MatchRule* value) {
    return AsOfJoinTablesRequest_MatchRule_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
    kAsOfMatchRuleFieldNumber = 7,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;
  public:
  void clear_columns_to_match();
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, size_t size);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_match();
  private:
  const std::string& _internal_columns_to_match(int index) const;
  std::string* _internal_add_columns_to_match();
  public:

  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;
  public:
  void clear_columns_to_add();
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, size_t size);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_add();
  private:
  const std::string& _internal_columns_to_add(int index) const;
  std::string* _internal_add_columns_to_add();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // .io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.MatchRule as_of_match_rule = 7;
  void clear_as_of_match_rule();
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule as_of_match_rule() const;
  void set_as_of_match_rule(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule value);
  private:
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule _internal_as_of_match_rule() const;
  void _internal_set_as_of_match_rule(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_match_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_add_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  int as_of_match_rule_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ComboAggregateRequest_Aggregate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate) */ {
 public:
  inline ComboAggregateRequest_Aggregate() : ComboAggregateRequest_Aggregate(nullptr) {}
  ~ComboAggregateRequest_Aggregate() override;
  explicit constexpr ComboAggregateRequest_Aggregate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComboAggregateRequest_Aggregate(const ComboAggregateRequest_Aggregate& from);
  ComboAggregateRequest_Aggregate(ComboAggregateRequest_Aggregate&& from) noexcept
    : ComboAggregateRequest_Aggregate() {
    *this = ::std::move(from);
  }

  inline ComboAggregateRequest_Aggregate& operator=(const ComboAggregateRequest_Aggregate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComboAggregateRequest_Aggregate& operator=(ComboAggregateRequest_Aggregate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComboAggregateRequest_Aggregate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComboAggregateRequest_Aggregate* internal_default_instance() {
    return reinterpret_cast<const ComboAggregateRequest_Aggregate*>(
               &_ComboAggregateRequest_Aggregate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ComboAggregateRequest_Aggregate& a, ComboAggregateRequest_Aggregate& b) {
    a.Swap(&b);
  }
  inline void Swap(ComboAggregateRequest_Aggregate* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComboAggregateRequest_Aggregate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ComboAggregateRequest_Aggregate* New() const final {
    return new ComboAggregateRequest_Aggregate();
  }

  ComboAggregateRequest_Aggregate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ComboAggregateRequest_Aggregate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComboAggregateRequest_Aggregate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ComboAggregateRequest_Aggregate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComboAggregateRequest_Aggregate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate";
  }
  protected:
  explicit ComboAggregateRequest_Aggregate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchPairsFieldNumber = 2,
    kColumnNameFieldNumber = 3,
    kTypeFieldNumber = 1,
    kAvgMedianFieldNumber = 5,
    kPercentileFieldNumber = 4,
  };
  // repeated string match_pairs = 2;
  int match_pairs_size() const;
  private:
  int _internal_match_pairs_size() const;
  public:
  void clear_match_pairs();
  const std::string& match_pairs(int index) const;
  std::string* mutable_match_pairs(int index);
  void set_match_pairs(int index, const std::string& value);
  void set_match_pairs(int index, std::string&& value);
  void set_match_pairs(int index, const char* value);
  void set_match_pairs(int index, const char* value, size_t size);
  std::string* add_match_pairs();
  void add_match_pairs(const std::string& value);
  void add_match_pairs(std::string&& value);
  void add_match_pairs(const char* value);
  void add_match_pairs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& match_pairs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_match_pairs();
  private:
  const std::string& _internal_match_pairs(int index) const;
  std::string* _internal_add_match_pairs();
  public:

  // string column_name = 3;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // .io.deephaven.proto.backplane.grpc.ComboAggregateRequest.AggType type = 1;
  void clear_type();
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType type() const;
  void set_type(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType value);
  private:
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType _internal_type() const;
  void _internal_set_type(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType value);
  public:

  // bool avg_median = 5;
  void clear_avg_median();
  bool avg_median() const;
  void set_avg_median(bool value);
  private:
  bool _internal_avg_median() const;
  void _internal_set_avg_median(bool value);
  public:

  // double percentile = 4;
  void clear_percentile();
  double percentile() const;
  void set_percentile(double value);
  private:
  double _internal_percentile() const;
  void _internal_set_percentile(double value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> match_pairs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  int type_;
  bool avg_median_;
  double percentile_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ComboAggregateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ComboAggregateRequest) */ {
 public:
  inline ComboAggregateRequest() : ComboAggregateRequest(nullptr) {}
  ~ComboAggregateRequest() override;
  explicit constexpr ComboAggregateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComboAggregateRequest(const ComboAggregateRequest& from);
  ComboAggregateRequest(ComboAggregateRequest&& from) noexcept
    : ComboAggregateRequest() {
    *this = ::std::move(from);
  }

  inline ComboAggregateRequest& operator=(const ComboAggregateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComboAggregateRequest& operator=(ComboAggregateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComboAggregateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComboAggregateRequest* internal_default_instance() {
    return reinterpret_cast<const ComboAggregateRequest*>(
               &_ComboAggregateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ComboAggregateRequest& a, ComboAggregateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ComboAggregateRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComboAggregateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ComboAggregateRequest* New() const final {
    return new ComboAggregateRequest();
  }

  ComboAggregateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ComboAggregateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComboAggregateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ComboAggregateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComboAggregateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ComboAggregateRequest";
  }
  protected:
  explicit ComboAggregateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ComboAggregateRequest_Aggregate Aggregate;

  typedef ComboAggregateRequest_AggType AggType;
  static constexpr AggType SUM =
    ComboAggregateRequest_AggType_SUM;
  static constexpr AggType ABS_SUM =
    ComboAggregateRequest_AggType_ABS_SUM;
  static constexpr AggType ARRAY =
    ComboAggregateRequest_AggType_ARRAY;
  static constexpr AggType AVG =
    ComboAggregateRequest_AggType_AVG;
  static constexpr AggType COUNT =
    ComboAggregateRequest_AggType_COUNT;
  static constexpr AggType FIRST =
    ComboAggregateRequest_AggType_FIRST;
  static constexpr AggType LAST =
    ComboAggregateRequest_AggType_LAST;
  static constexpr AggType MIN =
    ComboAggregateRequest_AggType_MIN;
  static constexpr AggType MAX =
    ComboAggregateRequest_AggType_MAX;
  static constexpr AggType MEDIAN =
    ComboAggregateRequest_AggType_MEDIAN;
  static constexpr AggType PERCENTILE =
    ComboAggregateRequest_AggType_PERCENTILE;
  static constexpr AggType STD =
    ComboAggregateRequest_AggType_STD;
  static constexpr AggType VAR =
    ComboAggregateRequest_AggType_VAR;
  static constexpr AggType WEIGHTED_AVG =
    ComboAggregateRequest_AggType_WEIGHTED_AVG;
  static inline bool AggType_IsValid(int value) {
    return ComboAggregateRequest_AggType_IsValid(value);
  }
  static constexpr AggType AggType_MIN =
    ComboAggregateRequest_AggType_AggType_MIN;
  static constexpr AggType AggType_MAX =
    ComboAggregateRequest_AggType_AggType_MAX;
  static constexpr int AggType_ARRAYSIZE =
    ComboAggregateRequest_AggType_AggType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AggType_descriptor() {
    return ComboAggregateRequest_AggType_descriptor();
  }
  template<typename T>
  static inline const std::string& AggType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AggType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AggType_Name.");
    return ComboAggregateRequest_AggType_Name(enum_t_value);
  }
  static inline bool AggType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AggType* value) {
    return ComboAggregateRequest_AggType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAggregatesFieldNumber = 3,
    kGroupByColumnsFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kForceComboFieldNumber = 5,
  };
  // repeated .io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate aggregates = 3;
  int aggregates_size() const;
  private:
  int _internal_aggregates_size() const;
  public:
  void clear_aggregates();
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* mutable_aggregates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate >*
      mutable_aggregates();
  private:
  const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate& _internal_aggregates(int index) const;
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* _internal_add_aggregates();
  public:
  const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate& aggregates(int index) const;
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* add_aggregates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate >&
      aggregates() const;

  // repeated string group_by_columns = 4;
  int group_by_columns_size() const;
  private:
  int _internal_group_by_columns_size() const;
  public:
  void clear_group_by_columns();
  const std::string& group_by_columns(int index) const;
  std::string* mutable_group_by_columns(int index);
  void set_group_by_columns(int index, const std::string& value);
  void set_group_by_columns(int index, std::string&& value);
  void set_group_by_columns(int index, const char* value);
  void set_group_by_columns(int index, const char* value, size_t size);
  std::string* add_group_by_columns();
  void add_group_by_columns(const std::string& value);
  void add_group_by_columns(std::string&& value);
  void add_group_by_columns(const char* value);
  void add_group_by_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& group_by_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_group_by_columns();
  private:
  const std::string& _internal_group_by_columns(int index) const;
  std::string* _internal_add_group_by_columns();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // bool force_combo = 5;
  void clear_force_combo();
  bool force_combo() const;
  void set_force_combo(bool value);
  private:
  bool _internal_force_combo() const;
  void _internal_set_force_combo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ComboAggregateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate > aggregates_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> group_by_columns_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  bool force_combo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SortDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SortDescriptor) */ {
 public:
  inline SortDescriptor() : SortDescriptor(nullptr) {}
  ~SortDescriptor() override;
  explicit constexpr SortDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SortDescriptor(const SortDescriptor& from);
  SortDescriptor(SortDescriptor&& from) noexcept
    : SortDescriptor() {
    *this = ::std::move(from);
  }

  inline SortDescriptor& operator=(const SortDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortDescriptor& operator=(SortDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const SortDescriptor* internal_default_instance() {
    return reinterpret_cast<const SortDescriptor*>(
               &_SortDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SortDescriptor& a, SortDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(SortDescriptor* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SortDescriptor* New() const final {
    return new SortDescriptor();
  }

  SortDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SortDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SortDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SortDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SortDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SortDescriptor";
  }
  protected:
  explicit SortDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SortDescriptor_SortDirection SortDirection;
  static constexpr SortDirection UNKNOWN =
    SortDescriptor_SortDirection_UNKNOWN;
  static constexpr SortDirection DESCENDING =
    SortDescriptor_SortDirection_DESCENDING;
  static constexpr SortDirection ASCENDING =
    SortDescriptor_SortDirection_ASCENDING;
  static constexpr SortDirection REVERSE =
    SortDescriptor_SortDirection_REVERSE;
  static inline bool SortDirection_IsValid(int value) {
    return SortDescriptor_SortDirection_IsValid(value);
  }
  static constexpr SortDirection SortDirection_MIN =
    SortDescriptor_SortDirection_SortDirection_MIN;
  static constexpr SortDirection SortDirection_MAX =
    SortDescriptor_SortDirection_SortDirection_MAX;
  static constexpr int SortDirection_ARRAYSIZE =
    SortDescriptor_SortDirection_SortDirection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SortDirection_descriptor() {
    return SortDescriptor_SortDirection_descriptor();
  }
  template<typename T>
  static inline const std::string& SortDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SortDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SortDirection_Name.");
    return SortDescriptor_SortDirection_Name(enum_t_value);
  }
  static inline bool SortDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SortDirection* value) {
    return SortDescriptor_SortDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
    kIsAbsoluteFieldNumber = 2,
    kDirectionFieldNumber = 3,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // bool is_absolute = 2;
  void clear_is_absolute();
  bool is_absolute() const;
  void set_is_absolute(bool value);
  private:
  bool _internal_is_absolute() const;
  void _internal_set_is_absolute(bool value);
  public:

  // .io.deephaven.proto.backplane.grpc.SortDescriptor.SortDirection direction = 3;
  void clear_direction();
  ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection direction() const;
  void set_direction(::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection value);
  private:
  ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection _internal_direction() const;
  void _internal_set_direction(::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SortDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  bool is_absolute_;
  int direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SortTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SortTableRequest) */ {
 public:
  inline SortTableRequest() : SortTableRequest(nullptr) {}
  ~SortTableRequest() override;
  explicit constexpr SortTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SortTableRequest(const SortTableRequest& from);
  SortTableRequest(SortTableRequest&& from) noexcept
    : SortTableRequest() {
    *this = ::std::move(from);
  }

  inline SortTableRequest& operator=(const SortTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortTableRequest& operator=(SortTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SortTableRequest* internal_default_instance() {
    return reinterpret_cast<const SortTableRequest*>(
               &_SortTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SortTableRequest& a, SortTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SortTableRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SortTableRequest* New() const final {
    return new SortTableRequest();
  }

  SortTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SortTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SortTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SortTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SortTableRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SortTableRequest";
  }
  protected:
  explicit SortTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSortsFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated .io.deephaven.proto.backplane.grpc.SortDescriptor sorts = 3;
  int sorts_size() const;
  private:
  int _internal_sorts_size() const;
  public:
  void clear_sorts();
  ::io::deephaven::proto::backplane::grpc::SortDescriptor* mutable_sorts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor >*
      mutable_sorts();
  private:
  const ::io::deephaven::proto::backplane::grpc::SortDescriptor& _internal_sorts(int index) const;
  ::io::deephaven::proto::backplane::grpc::SortDescriptor* _internal_add_sorts();
  public:
  const ::io::deephaven::proto::backplane::grpc::SortDescriptor& sorts(int index) const;
  ::io::deephaven::proto::backplane::grpc::SortDescriptor* add_sorts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor >&
      sorts() const;

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SortTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor > sorts_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class FilterTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FilterTableRequest) */ {
 public:
  inline FilterTableRequest() : FilterTableRequest(nullptr) {}
  ~FilterTableRequest() override;
  explicit constexpr FilterTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilterTableRequest(const FilterTableRequest& from);
  FilterTableRequest(FilterTableRequest&& from) noexcept
    : FilterTableRequest() {
    *this = ::std::move(from);
  }

  inline FilterTableRequest& operator=(const FilterTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterTableRequest& operator=(FilterTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilterTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilterTableRequest* internal_default_instance() {
    return reinterpret_cast<const FilterTableRequest*>(
               &_FilterTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(FilterTableRequest& a, FilterTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FilterTableRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilterTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FilterTableRequest* New() const final {
    return new FilterTableRequest();
  }

  FilterTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FilterTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FilterTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FilterTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterTableRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FilterTableRequest";
  }
  protected:
  explicit FilterTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Condition filters = 3;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::io::deephaven::proto::backplane::grpc::Condition* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
      mutable_filters();
  private:
  const ::io::deephaven::proto::backplane::grpc::Condition& _internal_filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* _internal_add_filters();
  public:
  const ::io::deephaven::proto::backplane::grpc::Condition& filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
      filters() const;

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FilterTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition > filters_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Reference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Reference) */ {
 public:
  inline Reference() : Reference(nullptr) {}
  ~Reference() override;
  explicit constexpr Reference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reference(const Reference& from);
  Reference(Reference&& from) noexcept
    : Reference() {
    *this = ::std::move(from);
  }

  inline Reference& operator=(const Reference& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reference& operator=(Reference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reference& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reference* internal_default_instance() {
    return reinterpret_cast<const Reference*>(
               &_Reference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Reference& a, Reference& b) {
    a.Swap(&b);
  }
  inline void Swap(Reference* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Reference* New() const final {
    return new Reference();
  }

  Reference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Reference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Reference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Reference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Reference";
  }
  protected:
  explicit Reference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Reference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Literal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Literal) */ {
 public:
  inline Literal() : Literal(nullptr) {}
  ~Literal() override;
  explicit constexpr Literal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Literal(const Literal& from);
  Literal(Literal&& from) noexcept
    : Literal() {
    *this = ::std::move(from);
  }

  inline Literal& operator=(const Literal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Literal& operator=(Literal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Literal& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kStringValue = 1,
    kDoubleValue = 2,
    kBoolValue = 3,
    kLongValue = 4,
    kNanoTimeValue = 5,
    VALUE_NOT_SET = 0,
  };

  static inline const Literal* internal_default_instance() {
    return reinterpret_cast<const Literal*>(
               &_Literal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Literal& a, Literal& b) {
    a.Swap(&b);
  }
  inline void Swap(Literal* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Literal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Literal* New() const final {
    return new Literal();
  }

  Literal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Literal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Literal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Literal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Literal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Literal";
  }
  protected:
  explicit Literal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringValueFieldNumber = 1,
    kDoubleValueFieldNumber = 2,
    kBoolValueFieldNumber = 3,
    kLongValueFieldNumber = 4,
    kNanoTimeValueFieldNumber = 5,
  };
  // string string_value = 1;
  bool has_string_value() const;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // double double_value = 2;
  bool has_double_value() const;
  private:
  bool _internal_has_double_value() const;
  public:
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);
  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);
  public:

  // bool bool_value = 3;
  bool has_bool_value() const;
  private:
  bool _internal_has_bool_value() const;
  public:
  void clear_bool_value();
  bool bool_value() const;
  void set_bool_value(bool value);
  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);
  public:

  // sint64 long_value = 4 [jstype = JS_STRING];
  bool has_long_value() const;
  private:
  bool _internal_has_long_value() const;
  public:
  void clear_long_value();
  ::PROTOBUF_NAMESPACE_ID::int64 long_value() const;
  void set_long_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_long_value() const;
  void _internal_set_long_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // sint64 nano_time_value = 5 [jstype = JS_STRING];
  bool has_nano_time_value() const;
  private:
  bool _internal_has_nano_time_value() const;
  public:
  void clear_nano_time_value();
  ::PROTOBUF_NAMESPACE_ID::int64 nano_time_value() const;
  void set_nano_time_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_nano_time_value() const;
  void _internal_set_nano_time_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Literal)
 private:
  class _Internal;
  void set_has_string_value();
  void set_has_double_value();
  void set_has_bool_value();
  void set_has_long_value();
  void set_has_nano_time_value();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
    double double_value_;
    bool bool_value_;
    ::PROTOBUF_NAMESPACE_ID::int64 long_value_;
    ::PROTOBUF_NAMESPACE_ID::int64 nano_time_value_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit constexpr Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kReference = 1,
    kLiteral = 2,
    DATA_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Value* New() const final {
    return new Value();
  }

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Value& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferenceFieldNumber = 1,
    kLiteralFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Reference reference = 1;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::io::deephaven::proto::backplane::grpc::Reference& reference() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Reference* release_reference();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_reference();
  void set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference);
  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_reference() const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::io::deephaven::proto::backplane::grpc::Reference* reference);
  ::io::deephaven::proto::backplane::grpc::Reference* unsafe_arena_release_reference();

  // .io.deephaven.proto.backplane.grpc.Literal literal = 2;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;
  public:
  void clear_literal();
  const ::io::deephaven::proto::backplane::grpc::Literal& literal() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Literal* release_literal();
  ::io::deephaven::proto::backplane::grpc::Literal* mutable_literal();
  void set_allocated_literal(::io::deephaven::proto::backplane::grpc::Literal* literal);
  private:
  const ::io::deephaven::proto::backplane::grpc::Literal& _internal_literal() const;
  ::io::deephaven::proto::backplane::grpc::Literal* _internal_mutable_literal();
  public:
  void unsafe_arena_set_allocated_literal(
      ::io::deephaven::proto::backplane::grpc::Literal* literal);
  ::io::deephaven::proto::backplane::grpc::Literal* unsafe_arena_release_literal();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Value)
 private:
  class _Internal;
  void set_has_reference();
  void set_has_literal();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::Reference* reference_;
    ::io::deephaven::proto::backplane::grpc::Literal* literal_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Condition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  ~Condition() override;
  explicit constexpr Condition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Condition(const Condition& from);
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Condition& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kAnd = 1,
    kOr = 2,
    kNot = 3,
    kCompare = 4,
    kIn = 5,
    kInvoke = 6,
    kIsNull = 7,
    kMatches = 8,
    kContains = 9,
    kSearch = 10,
    DATA_NOT_SET = 0,
  };

  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const final {
    return new Condition();
  }

  Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Condition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Condition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Condition";
  }
  protected:
  explicit Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAndFieldNumber = 1,
    kOrFieldNumber = 2,
    kNotFieldNumber = 3,
    kCompareFieldNumber = 4,
    kInFieldNumber = 5,
    kInvokeFieldNumber = 6,
    kIsNullFieldNumber = 7,
    kMatchesFieldNumber = 8,
    kContainsFieldNumber = 9,
    kSearchFieldNumber = 10,
  };
  // .io.deephaven.proto.backplane.grpc.AndCondition and = 1;
  bool has_and_() const;
  private:
  bool _internal_has_and_() const;
  public:
  void clear_and_();
  const ::io::deephaven::proto::backplane::grpc::AndCondition& and_() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::AndCondition* release_and_();
  ::io::deephaven::proto::backplane::grpc::AndCondition* mutable_and_();
  void set_allocated_and_(::io::deephaven::proto::backplane::grpc::AndCondition* and_);
  private:
  const ::io::deephaven::proto::backplane::grpc::AndCondition& _internal_and_() const;
  ::io::deephaven::proto::backplane::grpc::AndCondition* _internal_mutable_and_();
  public:
  void unsafe_arena_set_allocated_and_(
      ::io::deephaven::proto::backplane::grpc::AndCondition* and_);
  ::io::deephaven::proto::backplane::grpc::AndCondition* unsafe_arena_release_and_();

  // .io.deephaven.proto.backplane.grpc.OrCondition or = 2;
  bool has_or_() const;
  private:
  bool _internal_has_or_() const;
  public:
  void clear_or_();
  const ::io::deephaven::proto::backplane::grpc::OrCondition& or_() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::OrCondition* release_or_();
  ::io::deephaven::proto::backplane::grpc::OrCondition* mutable_or_();
  void set_allocated_or_(::io::deephaven::proto::backplane::grpc::OrCondition* or_);
  private:
  const ::io::deephaven::proto::backplane::grpc::OrCondition& _internal_or_() const;
  ::io::deephaven::proto::backplane::grpc::OrCondition* _internal_mutable_or_();
  public:
  void unsafe_arena_set_allocated_or_(
      ::io::deephaven::proto::backplane::grpc::OrCondition* or_);
  ::io::deephaven::proto::backplane::grpc::OrCondition* unsafe_arena_release_or_();

  // .io.deephaven.proto.backplane.grpc.NotCondition not = 3;
  bool has_not_() const;
  private:
  bool _internal_has_not_() const;
  public:
  void clear_not_();
  const ::io::deephaven::proto::backplane::grpc::NotCondition& not_() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::NotCondition* release_not_();
  ::io::deephaven::proto::backplane::grpc::NotCondition* mutable_not_();
  void set_allocated_not_(::io::deephaven::proto::backplane::grpc::NotCondition* not_);
  private:
  const ::io::deephaven::proto::backplane::grpc::NotCondition& _internal_not_() const;
  ::io::deephaven::proto::backplane::grpc::NotCondition* _internal_mutable_not_();
  public:
  void unsafe_arena_set_allocated_not_(
      ::io::deephaven::proto::backplane::grpc::NotCondition* not_);
  ::io::deephaven::proto::backplane::grpc::NotCondition* unsafe_arena_release_not_();

  // .io.deephaven.proto.backplane.grpc.CompareCondition compare = 4;
  bool has_compare() const;
  private:
  bool _internal_has_compare() const;
  public:
  void clear_compare();
  const ::io::deephaven::proto::backplane::grpc::CompareCondition& compare() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::CompareCondition* release_compare();
  ::io::deephaven::proto::backplane::grpc::CompareCondition* mutable_compare();
  void set_allocated_compare(::io::deephaven::proto::backplane::grpc::CompareCondition* compare);
  private:
  const ::io::deephaven::proto::backplane::grpc::CompareCondition& _internal_compare() const;
  ::io::deephaven::proto::backplane::grpc::CompareCondition* _internal_mutable_compare();
  public:
  void unsafe_arena_set_allocated_compare(
      ::io::deephaven::proto::backplane::grpc::CompareCondition* compare);
  ::io::deephaven::proto::backplane::grpc::CompareCondition* unsafe_arena_release_compare();

  // .io.deephaven.proto.backplane.grpc.InCondition in = 5;
  bool has_in() const;
  private:
  bool _internal_has_in() const;
  public:
  void clear_in();
  const ::io::deephaven::proto::backplane::grpc::InCondition& in() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::InCondition* release_in();
  ::io::deephaven::proto::backplane::grpc::InCondition* mutable_in();
  void set_allocated_in(::io::deephaven::proto::backplane::grpc::InCondition* in);
  private:
  const ::io::deephaven::proto::backplane::grpc::InCondition& _internal_in() const;
  ::io::deephaven::proto::backplane::grpc::InCondition* _internal_mutable_in();
  public:
  void unsafe_arena_set_allocated_in(
      ::io::deephaven::proto::backplane::grpc::InCondition* in);
  ::io::deephaven::proto::backplane::grpc::InCondition* unsafe_arena_release_in();

  // .io.deephaven.proto.backplane.grpc.InvokeCondition invoke = 6;
  bool has_invoke() const;
  private:
  bool _internal_has_invoke() const;
  public:
  void clear_invoke();
  const ::io::deephaven::proto::backplane::grpc::InvokeCondition& invoke() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::InvokeCondition* release_invoke();
  ::io::deephaven::proto::backplane::grpc::InvokeCondition* mutable_invoke();
  void set_allocated_invoke(::io::deephaven::proto::backplane::grpc::InvokeCondition* invoke);
  private:
  const ::io::deephaven::proto::backplane::grpc::InvokeCondition& _internal_invoke() const;
  ::io::deephaven::proto::backplane::grpc::InvokeCondition* _internal_mutable_invoke();
  public:
  void unsafe_arena_set_allocated_invoke(
      ::io::deephaven::proto::backplane::grpc::InvokeCondition* invoke);
  ::io::deephaven::proto::backplane::grpc::InvokeCondition* unsafe_arena_release_invoke();

  // .io.deephaven.proto.backplane.grpc.IsNullCondition is_null = 7;
  bool has_is_null() const;
  private:
  bool _internal_has_is_null() const;
  public:
  void clear_is_null();
  const ::io::deephaven::proto::backplane::grpc::IsNullCondition& is_null() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::IsNullCondition* release_is_null();
  ::io::deephaven::proto::backplane::grpc::IsNullCondition* mutable_is_null();
  void set_allocated_is_null(::io::deephaven::proto::backplane::grpc::IsNullCondition* is_null);
  private:
  const ::io::deephaven::proto::backplane::grpc::IsNullCondition& _internal_is_null() const;
  ::io::deephaven::proto::backplane::grpc::IsNullCondition* _internal_mutable_is_null();
  public:
  void unsafe_arena_set_allocated_is_null(
      ::io::deephaven::proto::backplane::grpc::IsNullCondition* is_null);
  ::io::deephaven::proto::backplane::grpc::IsNullCondition* unsafe_arena_release_is_null();

  // .io.deephaven.proto.backplane.grpc.MatchesCondition matches = 8;
  bool has_matches() const;
  private:
  bool _internal_has_matches() const;
  public:
  void clear_matches();
  const ::io::deephaven::proto::backplane::grpc::MatchesCondition& matches() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::MatchesCondition* release_matches();
  ::io::deephaven::proto::backplane::grpc::MatchesCondition* mutable_matches();
  void set_allocated_matches(::io::deephaven::proto::backplane::grpc::MatchesCondition* matches);
  private:
  const ::io::deephaven::proto::backplane::grpc::MatchesCondition& _internal_matches() const;
  ::io::deephaven::proto::backplane::grpc::MatchesCondition* _internal_mutable_matches();
  public:
  void unsafe_arena_set_allocated_matches(
      ::io::deephaven::proto::backplane::grpc::MatchesCondition* matches);
  ::io::deephaven::proto::backplane::grpc::MatchesCondition* unsafe_arena_release_matches();

  // .io.deephaven.proto.backplane.grpc.ContainsCondition contains = 9;
  bool has_contains() const;
  private:
  bool _internal_has_contains() const;
  public:
  void clear_contains();
  const ::io::deephaven::proto::backplane::grpc::ContainsCondition& contains() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::ContainsCondition* release_contains();
  ::io::deephaven::proto::backplane::grpc::ContainsCondition* mutable_contains();
  void set_allocated_contains(::io::deephaven::proto::backplane::grpc::ContainsCondition* contains);
  private:
  const ::io::deephaven::proto::backplane::grpc::ContainsCondition& _internal_contains() const;
  ::io::deephaven::proto::backplane::grpc::ContainsCondition* _internal_mutable_contains();
  public:
  void unsafe_arena_set_allocated_contains(
      ::io::deephaven::proto::backplane::grpc::ContainsCondition* contains);
  ::io::deephaven::proto::backplane::grpc::ContainsCondition* unsafe_arena_release_contains();

  // .io.deephaven.proto.backplane.grpc.SearchCondition search = 10;
  bool has_search() const;
  private:
  bool _internal_has_search() const;
  public:
  void clear_search();
  const ::io::deephaven::proto::backplane::grpc::SearchCondition& search() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::SearchCondition* release_search();
  ::io::deephaven::proto::backplane::grpc::SearchCondition* mutable_search();
  void set_allocated_search(::io::deephaven::proto::backplane::grpc::SearchCondition* search);
  private:
  const ::io::deephaven::proto::backplane::grpc::SearchCondition& _internal_search() const;
  ::io::deephaven::proto::backplane::grpc::SearchCondition* _internal_mutable_search();
  public:
  void unsafe_arena_set_allocated_search(
      ::io::deephaven::proto::backplane::grpc::SearchCondition* search);
  ::io::deephaven::proto::backplane::grpc::SearchCondition* unsafe_arena_release_search();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Condition)
 private:
  class _Internal;
  void set_has_and_();
  void set_has_or_();
  void set_has_not_();
  void set_has_compare();
  void set_has_in();
  void set_has_invoke();
  void set_has_is_null();
  void set_has_matches();
  void set_has_contains();
  void set_has_search();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::AndCondition* and__;
    ::io::deephaven::proto::backplane::grpc::OrCondition* or__;
    ::io::deephaven::proto::backplane::grpc::NotCondition* not__;
    ::io::deephaven::proto::backplane::grpc::CompareCondition* compare_;
    ::io::deephaven::proto::backplane::grpc::InCondition* in_;
    ::io::deephaven::proto::backplane::grpc::InvokeCondition* invoke_;
    ::io::deephaven::proto::backplane::grpc::IsNullCondition* is_null_;
    ::io::deephaven::proto::backplane::grpc::MatchesCondition* matches_;
    ::io::deephaven::proto::backplane::grpc::ContainsCondition* contains_;
    ::io::deephaven::proto::backplane::grpc::SearchCondition* search_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AndCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AndCondition) */ {
 public:
  inline AndCondition() : AndCondition(nullptr) {}
  ~AndCondition() override;
  explicit constexpr AndCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AndCondition(const AndCondition& from);
  AndCondition(AndCondition&& from) noexcept
    : AndCondition() {
    *this = ::std::move(from);
  }

  inline AndCondition& operator=(const AndCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline AndCondition& operator=(AndCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AndCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const AndCondition* internal_default_instance() {
    return reinterpret_cast<const AndCondition*>(
               &_AndCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(AndCondition& a, AndCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(AndCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AndCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AndCondition* New() const final {
    return new AndCondition();
  }

  AndCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AndCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AndCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AndCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AndCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AndCondition";
  }
  protected:
  explicit AndCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Condition filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::io::deephaven::proto::backplane::grpc::Condition* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
      mutable_filters();
  private:
  const ::io::deephaven::proto::backplane::grpc::Condition& _internal_filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* _internal_add_filters();
  public:
  const ::io::deephaven::proto::backplane::grpc::Condition& filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
      filters() const;

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AndCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition > filters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class OrCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.OrCondition) */ {
 public:
  inline OrCondition() : OrCondition(nullptr) {}
  ~OrCondition() override;
  explicit constexpr OrCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrCondition(const OrCondition& from);
  OrCondition(OrCondition&& from) noexcept
    : OrCondition() {
    *this = ::std::move(from);
  }

  inline OrCondition& operator=(const OrCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrCondition& operator=(OrCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrCondition* internal_default_instance() {
    return reinterpret_cast<const OrCondition*>(
               &_OrCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(OrCondition& a, OrCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(OrCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OrCondition* New() const final {
    return new OrCondition();
  }

  OrCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OrCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.OrCondition";
  }
  protected:
  explicit OrCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Condition filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::io::deephaven::proto::backplane::grpc::Condition* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
      mutable_filters();
  private:
  const ::io::deephaven::proto::backplane::grpc::Condition& _internal_filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* _internal_add_filters();
  public:
  const ::io::deephaven::proto::backplane::grpc::Condition& filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
      filters() const;

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.OrCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition > filters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class NotCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.NotCondition) */ {
 public:
  inline NotCondition() : NotCondition(nullptr) {}
  ~NotCondition() override;
  explicit constexpr NotCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotCondition(const NotCondition& from);
  NotCondition(NotCondition&& from) noexcept
    : NotCondition() {
    *this = ::std::move(from);
  }

  inline NotCondition& operator=(const NotCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotCondition& operator=(NotCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotCondition* internal_default_instance() {
    return reinterpret_cast<const NotCondition*>(
               &_NotCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(NotCondition& a, NotCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(NotCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NotCondition* New() const final {
    return new NotCondition();
  }

  NotCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NotCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.NotCondition";
  }
  protected:
  explicit NotCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.Condition filter = 1;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::io::deephaven::proto::backplane::grpc::Condition& filter() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Condition* release_filter();
  ::io::deephaven::proto::backplane::grpc::Condition* mutable_filter();
  void set_allocated_filter(::io::deephaven::proto::backplane::grpc::Condition* filter);
  private:
  const ::io::deephaven::proto::backplane::grpc::Condition& _internal_filter() const;
  ::io::deephaven::proto::backplane::grpc::Condition* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::io::deephaven::proto::backplane::grpc::Condition* filter);
  ::io::deephaven::proto::backplane::grpc::Condition* unsafe_arena_release_filter();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.NotCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Condition* filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class CompareCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CompareCondition) */ {
 public:
  inline CompareCondition() : CompareCondition(nullptr) {}
  ~CompareCondition() override;
  explicit constexpr CompareCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompareCondition(const CompareCondition& from);
  CompareCondition(CompareCondition&& from) noexcept
    : CompareCondition() {
    *this = ::std::move(from);
  }

  inline CompareCondition& operator=(const CompareCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompareCondition& operator=(CompareCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompareCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompareCondition* internal_default_instance() {
    return reinterpret_cast<const CompareCondition*>(
               &_CompareCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CompareCondition& a, CompareCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(CompareCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompareCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompareCondition* New() const final {
    return new CompareCondition();
  }

  CompareCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompareCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompareCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompareCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompareCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CompareCondition";
  }
  protected:
  explicit CompareCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CompareCondition_CompareOperation CompareOperation;
  static constexpr CompareOperation LESS_THAN =
    CompareCondition_CompareOperation_LESS_THAN;
  static constexpr CompareOperation LESS_THAN_OR_EQUAL =
    CompareCondition_CompareOperation_LESS_THAN_OR_EQUAL;
  static constexpr CompareOperation GREATER_THAN =
    CompareCondition_CompareOperation_GREATER_THAN;
  static constexpr CompareOperation GREATER_THAN_OR_EQUAL =
    CompareCondition_CompareOperation_GREATER_THAN_OR_EQUAL;
  static constexpr CompareOperation EQUALS =
    CompareCondition_CompareOperation_EQUALS;
  static constexpr CompareOperation NOT_EQUALS =
    CompareCondition_CompareOperation_NOT_EQUALS;
  static inline bool CompareOperation_IsValid(int value) {
    return CompareCondition_CompareOperation_IsValid(value);
  }
  static constexpr CompareOperation CompareOperation_MIN =
    CompareCondition_CompareOperation_CompareOperation_MIN;
  static constexpr CompareOperation CompareOperation_MAX =
    CompareCondition_CompareOperation_CompareOperation_MAX;
  static constexpr int CompareOperation_ARRAYSIZE =
    CompareCondition_CompareOperation_CompareOperation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CompareOperation_descriptor() {
    return CompareCondition_CompareOperation_descriptor();
  }
  template<typename T>
  static inline const std::string& CompareOperation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CompareOperation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CompareOperation_Name.");
    return CompareCondition_CompareOperation_Name(enum_t_value);
  }
  static inline bool CompareOperation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CompareOperation* value) {
    return CompareCondition_CompareOperation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLhsFieldNumber = 3,
    kRhsFieldNumber = 4,
    kOperationFieldNumber = 1,
    kCaseSensitivityFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Value lhs = 3;
  bool has_lhs() const;
  private:
  bool _internal_has_lhs() const;
  public:
  void clear_lhs();
  const ::io::deephaven::proto::backplane::grpc::Value& lhs() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Value* release_lhs();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_lhs();
  void set_allocated_lhs(::io::deephaven::proto::backplane::grpc::Value* lhs);
  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_lhs() const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_mutable_lhs();
  public:
  void unsafe_arena_set_allocated_lhs(
      ::io::deephaven::proto::backplane::grpc::Value* lhs);
  ::io::deephaven::proto::backplane::grpc::Value* unsafe_arena_release_lhs();

  // .io.deephaven.proto.backplane.grpc.Value rhs = 4;
  bool has_rhs() const;
  private:
  bool _internal_has_rhs() const;
  public:
  void clear_rhs();
  const ::io::deephaven::proto::backplane::grpc::Value& rhs() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Value* release_rhs();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_rhs();
  void set_allocated_rhs(::io::deephaven::proto::backplane::grpc::Value* rhs);
  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_rhs() const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_mutable_rhs();
  public:
  void unsafe_arena_set_allocated_rhs(
      ::io::deephaven::proto::backplane::grpc::Value* rhs);
  ::io::deephaven::proto::backplane::grpc::Value* unsafe_arena_release_rhs();

  // .io.deephaven.proto.backplane.grpc.CompareCondition.CompareOperation operation = 1;
  void clear_operation();
  ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation operation() const;
  void set_operation(::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation value);
  private:
  ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation _internal_operation() const;
  void _internal_set_operation(::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation value);
  public:

  // .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 2;
  void clear_case_sensitivity();
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity case_sensitivity() const;
  void set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  private:
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CompareCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Value* lhs_;
  ::io::deephaven::proto::backplane::grpc::Value* rhs_;
  int operation_;
  int case_sensitivity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class InCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.InCondition) */ {
 public:
  inline InCondition() : InCondition(nullptr) {}
  ~InCondition() override;
  explicit constexpr InCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InCondition(const InCondition& from);
  InCondition(InCondition&& from) noexcept
    : InCondition() {
    *this = ::std::move(from);
  }

  inline InCondition& operator=(const InCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline InCondition& operator=(InCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const InCondition* internal_default_instance() {
    return reinterpret_cast<const InCondition*>(
               &_InCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(InCondition& a, InCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(InCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InCondition* New() const final {
    return new InCondition();
  }

  InCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.InCondition";
  }
  protected:
  explicit InCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidatesFieldNumber = 2,
    kTargetFieldNumber = 1,
    kCaseSensitivityFieldNumber = 3,
    kMatchTypeFieldNumber = 4,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Value candidates = 2;
  int candidates_size() const;
  private:
  int _internal_candidates_size() const;
  public:
  void clear_candidates();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_candidates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >*
      mutable_candidates();
  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_candidates(int index) const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_add_candidates();
  public:
  const ::io::deephaven::proto::backplane::grpc::Value& candidates(int index) const;
  ::io::deephaven::proto::backplane::grpc::Value* add_candidates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >&
      candidates() const;

  // .io.deephaven.proto.backplane.grpc.Value target = 1;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::io::deephaven::proto::backplane::grpc::Value& target() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Value* release_target();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_target();
  void set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* target);
  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_target() const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::io::deephaven::proto::backplane::grpc::Value* target);
  ::io::deephaven::proto::backplane::grpc::Value* unsafe_arena_release_target();

  // .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
  void clear_case_sensitivity();
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity case_sensitivity() const;
  void set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  private:
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  public:

  // .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
  void clear_match_type();
  ::io::deephaven::proto::backplane::grpc::MatchType match_type() const;
  void set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);
  private:
  ::io::deephaven::proto::backplane::grpc::MatchType _internal_match_type() const;
  void _internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.InCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value > candidates_;
  ::io::deephaven::proto::backplane::grpc::Value* target_;
  int case_sensitivity_;
  int match_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class InvokeCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.InvokeCondition) */ {
 public:
  inline InvokeCondition() : InvokeCondition(nullptr) {}
  ~InvokeCondition() override;
  explicit constexpr InvokeCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeCondition(const InvokeCondition& from);
  InvokeCondition(InvokeCondition&& from) noexcept
    : InvokeCondition() {
    *this = ::std::move(from);
  }

  inline InvokeCondition& operator=(const InvokeCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeCondition& operator=(InvokeCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeCondition* internal_default_instance() {
    return reinterpret_cast<const InvokeCondition*>(
               &_InvokeCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(InvokeCondition& a, InvokeCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InvokeCondition* New() const final {
    return new InvokeCondition();
  }

  InvokeCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InvokeCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvokeCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.InvokeCondition";
  }
  protected:
  explicit InvokeCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 3,
    kMethodFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Value arguments = 3;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_arguments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >*
      mutable_arguments();
  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_arguments(int index) const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_add_arguments();
  public:
  const ::io::deephaven::proto::backplane::grpc::Value& arguments(int index) const;
  ::io::deephaven::proto::backplane::grpc::Value* add_arguments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >&
      arguments() const;

  // string method = 1;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_MUST_USE_RESULT std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // .io.deephaven.proto.backplane.grpc.Value target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::io::deephaven::proto::backplane::grpc::Value& target() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Value* release_target();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_target();
  void set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* target);
  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_target() const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::io::deephaven::proto::backplane::grpc::Value* target);
  ::io::deephaven::proto::backplane::grpc::Value* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.InvokeCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value > arguments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::io::deephaven::proto::backplane::grpc::Value* target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class IsNullCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.IsNullCondition) */ {
 public:
  inline IsNullCondition() : IsNullCondition(nullptr) {}
  ~IsNullCondition() override;
  explicit constexpr IsNullCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsNullCondition(const IsNullCondition& from);
  IsNullCondition(IsNullCondition&& from) noexcept
    : IsNullCondition() {
    *this = ::std::move(from);
  }

  inline IsNullCondition& operator=(const IsNullCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsNullCondition& operator=(IsNullCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsNullCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsNullCondition* internal_default_instance() {
    return reinterpret_cast<const IsNullCondition*>(
               &_IsNullCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(IsNullCondition& a, IsNullCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(IsNullCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsNullCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline IsNullCondition* New() const final {
    return new IsNullCondition();
  }

  IsNullCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<IsNullCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsNullCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IsNullCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsNullCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.IsNullCondition";
  }
  protected:
  explicit IsNullCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferenceFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.Reference reference = 1;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::io::deephaven::proto::backplane::grpc::Reference& reference() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Reference* release_reference();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_reference();
  void set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference);
  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_reference() const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::io::deephaven::proto::backplane::grpc::Reference* reference);
  ::io::deephaven::proto::backplane::grpc::Reference* unsafe_arena_release_reference();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.IsNullCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Reference* reference_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class MatchesCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MatchesCondition) */ {
 public:
  inline MatchesCondition() : MatchesCondition(nullptr) {}
  ~MatchesCondition() override;
  explicit constexpr MatchesCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchesCondition(const MatchesCondition& from);
  MatchesCondition(MatchesCondition&& from) noexcept
    : MatchesCondition() {
    *this = ::std::move(from);
  }

  inline MatchesCondition& operator=(const MatchesCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchesCondition& operator=(MatchesCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchesCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchesCondition* internal_default_instance() {
    return reinterpret_cast<const MatchesCondition*>(
               &_MatchesCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(MatchesCondition& a, MatchesCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchesCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchesCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MatchesCondition* New() const final {
    return new MatchesCondition();
  }

  MatchesCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MatchesCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchesCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchesCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchesCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MatchesCondition";
  }
  protected:
  explicit MatchesCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegexFieldNumber = 2,
    kReferenceFieldNumber = 1,
    kCaseSensitivityFieldNumber = 3,
    kMatchTypeFieldNumber = 4,
  };
  // string regex = 2;
  void clear_regex();
  const std::string& regex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_regex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_regex();
  PROTOBUF_MUST_USE_RESULT std::string* release_regex();
  void set_allocated_regex(std::string* regex);
  private:
  const std::string& _internal_regex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_regex(const std::string& value);
  std::string* _internal_mutable_regex();
  public:

  // .io.deephaven.proto.backplane.grpc.Reference reference = 1;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::io::deephaven::proto::backplane::grpc::Reference& reference() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Reference* release_reference();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_reference();
  void set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference);
  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_reference() const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::io::deephaven::proto::backplane::grpc::Reference* reference);
  ::io::deephaven::proto::backplane::grpc::Reference* unsafe_arena_release_reference();

  // .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
  void clear_case_sensitivity();
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity case_sensitivity() const;
  void set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  private:
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  public:

  // .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
  void clear_match_type();
  ::io::deephaven::proto::backplane::grpc::MatchType match_type() const;
  void set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);
  private:
  ::io::deephaven::proto::backplane::grpc::MatchType _internal_match_type() const;
  void _internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MatchesCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr regex_;
  ::io::deephaven::proto::backplane::grpc::Reference* reference_;
  int case_sensitivity_;
  int match_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ContainsCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ContainsCondition) */ {
 public:
  inline ContainsCondition() : ContainsCondition(nullptr) {}
  ~ContainsCondition() override;
  explicit constexpr ContainsCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContainsCondition(const ContainsCondition& from);
  ContainsCondition(ContainsCondition&& from) noexcept
    : ContainsCondition() {
    *this = ::std::move(from);
  }

  inline ContainsCondition& operator=(const ContainsCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContainsCondition& operator=(ContainsCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContainsCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContainsCondition* internal_default_instance() {
    return reinterpret_cast<const ContainsCondition*>(
               &_ContainsCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ContainsCondition& a, ContainsCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(ContainsCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContainsCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ContainsCondition* New() const final {
    return new ContainsCondition();
  }

  ContainsCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ContainsCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContainsCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContainsCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContainsCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ContainsCondition";
  }
  protected:
  explicit ContainsCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSearchStringFieldNumber = 2,
    kReferenceFieldNumber = 1,
    kCaseSensitivityFieldNumber = 3,
    kMatchTypeFieldNumber = 4,
  };
  // string search_string = 2;
  void clear_search_string();
  const std::string& search_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_search_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_search_string();
  PROTOBUF_MUST_USE_RESULT std::string* release_search_string();
  void set_allocated_search_string(std::string* search_string);
  private:
  const std::string& _internal_search_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_string(const std::string& value);
  std::string* _internal_mutable_search_string();
  public:

  // .io.deephaven.proto.backplane.grpc.Reference reference = 1;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::io::deephaven::proto::backplane::grpc::Reference& reference() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Reference* release_reference();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_reference();
  void set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference);
  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_reference() const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::io::deephaven::proto::backplane::grpc::Reference* reference);
  ::io::deephaven::proto::backplane::grpc::Reference* unsafe_arena_release_reference();

  // .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
  void clear_case_sensitivity();
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity case_sensitivity() const;
  void set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  private:
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  public:

  // .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
  void clear_match_type();
  ::io::deephaven::proto::backplane::grpc::MatchType match_type() const;
  void set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);
  private:
  ::io::deephaven::proto::backplane::grpc::MatchType _internal_match_type() const;
  void _internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ContainsCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_string_;
  ::io::deephaven::proto::backplane::grpc::Reference* reference_;
  int case_sensitivity_;
  int match_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SearchCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SearchCondition) */ {
 public:
  inline SearchCondition() : SearchCondition(nullptr) {}
  ~SearchCondition() override;
  explicit constexpr SearchCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchCondition(const SearchCondition& from);
  SearchCondition(SearchCondition&& from) noexcept
    : SearchCondition() {
    *this = ::std::move(from);
  }

  inline SearchCondition& operator=(const SearchCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchCondition& operator=(SearchCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchCondition* internal_default_instance() {
    return reinterpret_cast<const SearchCondition*>(
               &_SearchCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(SearchCondition& a, SearchCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchCondition* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SearchCondition* New() const final {
    return new SearchCondition();
  }

  SearchCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SearchCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SearchCondition";
  }
  protected:
  explicit SearchCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionalReferencesFieldNumber = 2,
    kSearchStringFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Reference optional_references = 2;
  int optional_references_size() const;
  private:
  int _internal_optional_references_size() const;
  public:
  void clear_optional_references();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_optional_references(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference >*
      mutable_optional_references();
  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_optional_references(int index) const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_add_optional_references();
  public:
  const ::io::deephaven::proto::backplane::grpc::Reference& optional_references(int index) const;
  ::io::deephaven::proto::backplane::grpc::Reference* add_optional_references();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference >&
      optional_references() const;

  // string search_string = 1;
  void clear_search_string();
  const std::string& search_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_search_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_search_string();
  PROTOBUF_MUST_USE_RESULT std::string* release_search_string();
  void set_allocated_search_string(std::string* search_string);
  private:
  const std::string& _internal_search_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_string(const std::string& value);
  std::string* _internal_mutable_search_string();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SearchCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference > optional_references_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_string_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class FlattenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FlattenRequest) */ {
 public:
  inline FlattenRequest() : FlattenRequest(nullptr) {}
  ~FlattenRequest() override;
  explicit constexpr FlattenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlattenRequest(const FlattenRequest& from);
  FlattenRequest(FlattenRequest&& from) noexcept
    : FlattenRequest() {
    *this = ::std::move(from);
  }

  inline FlattenRequest& operator=(const FlattenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlattenRequest& operator=(FlattenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlattenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlattenRequest* internal_default_instance() {
    return reinterpret_cast<const FlattenRequest*>(
               &_FlattenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(FlattenRequest& a, FlattenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlattenRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlattenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlattenRequest* New() const final {
    return new FlattenRequest();
  }

  FlattenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlattenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlattenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FlattenRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlattenRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FlattenRequest";
  }
  protected:
  explicit FlattenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FlattenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class RunChartDownsampleRequest_ZoomRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange) */ {
 public:
  inline RunChartDownsampleRequest_ZoomRange() : RunChartDownsampleRequest_ZoomRange(nullptr) {}
  ~RunChartDownsampleRequest_ZoomRange() override;
  explicit constexpr RunChartDownsampleRequest_ZoomRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunChartDownsampleRequest_ZoomRange(const RunChartDownsampleRequest_ZoomRange& from);
  RunChartDownsampleRequest_ZoomRange(RunChartDownsampleRequest_ZoomRange&& from) noexcept
    : RunChartDownsampleRequest_ZoomRange() {
    *this = ::std::move(from);
  }

  inline RunChartDownsampleRequest_ZoomRange& operator=(const RunChartDownsampleRequest_ZoomRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunChartDownsampleRequest_ZoomRange& operator=(RunChartDownsampleRequest_ZoomRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunChartDownsampleRequest_ZoomRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunChartDownsampleRequest_ZoomRange* internal_default_instance() {
    return reinterpret_cast<const RunChartDownsampleRequest_ZoomRange*>(
               &_RunChartDownsampleRequest_ZoomRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(RunChartDownsampleRequest_ZoomRange& a, RunChartDownsampleRequest_ZoomRange& b) {
    a.Swap(&b);
  }
  inline void Swap(RunChartDownsampleRequest_ZoomRange* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunChartDownsampleRequest_ZoomRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RunChartDownsampleRequest_ZoomRange* New() const final {
    return new RunChartDownsampleRequest_ZoomRange();
  }

  RunChartDownsampleRequest_ZoomRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RunChartDownsampleRequest_ZoomRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunChartDownsampleRequest_ZoomRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RunChartDownsampleRequest_ZoomRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunChartDownsampleRequest_ZoomRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange";
  }
  protected:
  explicit RunChartDownsampleRequest_ZoomRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinDateNanosFieldNumber = 1,
    kMaxDateNanosFieldNumber = 2,
  };
  // optional int64 min_date_nanos = 1 [jstype = JS_STRING];
  bool has_min_date_nanos() const;
  private:
  bool _internal_has_min_date_nanos() const;
  public:
  void clear_min_date_nanos();
  ::PROTOBUF_NAMESPACE_ID::int64 min_date_nanos() const;
  void set_min_date_nanos(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_min_date_nanos() const;
  void _internal_set_min_date_nanos(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int64 max_date_nanos = 2 [jstype = JS_STRING];
  bool has_max_date_nanos() const;
  private:
  bool _internal_has_max_date_nanos() const;
  public:
  void clear_max_date_nanos();
  ::PROTOBUF_NAMESPACE_ID::int64 max_date_nanos() const;
  void set_max_date_nanos(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_date_nanos() const;
  void _internal_set_max_date_nanos(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 min_date_nanos_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_date_nanos_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class RunChartDownsampleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest) */ {
 public:
  inline RunChartDownsampleRequest() : RunChartDownsampleRequest(nullptr) {}
  ~RunChartDownsampleRequest() override;
  explicit constexpr RunChartDownsampleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunChartDownsampleRequest(const RunChartDownsampleRequest& from);
  RunChartDownsampleRequest(RunChartDownsampleRequest&& from) noexcept
    : RunChartDownsampleRequest() {
    *this = ::std::move(from);
  }

  inline RunChartDownsampleRequest& operator=(const RunChartDownsampleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunChartDownsampleRequest& operator=(RunChartDownsampleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunChartDownsampleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunChartDownsampleRequest* internal_default_instance() {
    return reinterpret_cast<const RunChartDownsampleRequest*>(
               &_RunChartDownsampleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(RunChartDownsampleRequest& a, RunChartDownsampleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RunChartDownsampleRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunChartDownsampleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RunChartDownsampleRequest* New() const final {
    return new RunChartDownsampleRequest();
  }

  RunChartDownsampleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RunChartDownsampleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunChartDownsampleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RunChartDownsampleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunChartDownsampleRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest";
  }
  protected:
  explicit RunChartDownsampleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RunChartDownsampleRequest_ZoomRange ZoomRange;

  // accessors -------------------------------------------------------

  enum : int {
    kYColumnNamesFieldNumber = 6,
    kXColumnNameFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kZoomRangeFieldNumber = 4,
    kPixelCountFieldNumber = 3,
  };
  // repeated string y_column_names = 6;
  int y_column_names_size() const;
  private:
  int _internal_y_column_names_size() const;
  public:
  void clear_y_column_names();
  const std::string& y_column_names(int index) const;
  std::string* mutable_y_column_names(int index);
  void set_y_column_names(int index, const std::string& value);
  void set_y_column_names(int index, std::string&& value);
  void set_y_column_names(int index, const char* value);
  void set_y_column_names(int index, const char* value, size_t size);
  std::string* add_y_column_names();
  void add_y_column_names(const std::string& value);
  void add_y_column_names(std::string&& value);
  void add_y_column_names(const char* value);
  void add_y_column_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& y_column_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_y_column_names();
  private:
  const std::string& _internal_y_column_names(int index) const;
  std::string* _internal_add_y_column_names();
  public:

  // string x_column_name = 5;
  void clear_x_column_name();
  const std::string& x_column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_x_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_x_column_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_x_column_name();
  void set_allocated_x_column_name(std::string* x_column_name);
  private:
  const std::string& _internal_x_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_x_column_name(const std::string& value);
  std::string* _internal_mutable_x_column_name();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // .io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange zoom_range = 4;
  bool has_zoom_range() const;
  private:
  bool _internal_has_zoom_range() const;
  public:
  void clear_zoom_range();
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange& zoom_range() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* release_zoom_range();
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* mutable_zoom_range();
  void set_allocated_zoom_range(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* zoom_range);
  private:
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange& _internal_zoom_range() const;
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* _internal_mutable_zoom_range();
  public:
  void unsafe_arena_set_allocated_zoom_range(
      ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* zoom_range);
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* unsafe_arena_release_zoom_range();

  // int32 pixel_count = 3;
  void clear_pixel_count();
  ::PROTOBUF_NAMESPACE_ID::int32 pixel_count() const;
  void set_pixel_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_pixel_count() const;
  void _internal_set_pixel_count(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> y_column_names_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x_column_name_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* zoom_range_;
  ::PROTOBUF_NAMESPACE_ID::int32 pixel_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class BatchTableRequest_Operation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation) */ {
 public:
  inline BatchTableRequest_Operation() : BatchTableRequest_Operation(nullptr) {}
  ~BatchTableRequest_Operation() override;
  explicit constexpr BatchTableRequest_Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchTableRequest_Operation(const BatchTableRequest_Operation& from);
  BatchTableRequest_Operation(BatchTableRequest_Operation&& from) noexcept
    : BatchTableRequest_Operation() {
    *this = ::std::move(from);
  }

  inline BatchTableRequest_Operation& operator=(const BatchTableRequest_Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchTableRequest_Operation& operator=(BatchTableRequest_Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchTableRequest_Operation& default_instance() {
    return *internal_default_instance();
  }
  enum OpCase {
    kEmptyTable = 1,
    kTimeTable = 2,
    kDropColumns = 3,
    kUpdate = 4,
    kLazyUpdate = 5,
    kView = 6,
    kUpdateView = 7,
    kSelect = 8,
    kSelectDistinct = 9,
    kFilter = 10,
    kUnstructuredFilter = 11,
    kSort = 12,
    kHead = 13,
    kTail = 14,
    kHeadBy = 15,
    kTailBy = 16,
    kUngroup = 17,
    kMerge = 18,
    kComboAggregate = 19,
    kSnapshot = 20,
    kFlatten = 21,
    kRunChartDownsample = 22,
    kCrossJoin = 23,
    kNaturalJoin = 24,
    kExactJoin = 25,
    kLeftJoin = 26,
    kAsOfJoin = 27,
    kFetchTable = 28,
    kFetchPandasTable = 29,
    OP_NOT_SET = 0,
  };

  static inline const BatchTableRequest_Operation* internal_default_instance() {
    return reinterpret_cast<const BatchTableRequest_Operation*>(
               &_BatchTableRequest_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(BatchTableRequest_Operation& a, BatchTableRequest_Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchTableRequest_Operation* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchTableRequest_Operation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchTableRequest_Operation* New() const final {
    return new BatchTableRequest_Operation();
  }

  BatchTableRequest_Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchTableRequest_Operation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchTableRequest_Operation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchTableRequest_Operation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchTableRequest_Operation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation";
  }
  protected:
  explicit BatchTableRequest_Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmptyTableFieldNumber = 1,
    kTimeTableFieldNumber = 2,
    kDropColumnsFieldNumber = 3,
    kUpdateFieldNumber = 4,
    kLazyUpdateFieldNumber = 5,
    kViewFieldNumber = 6,
    kUpdateViewFieldNumber = 7,
    kSelectFieldNumber = 8,
    kSelectDistinctFieldNumber = 9,
    kFilterFieldNumber = 10,
    kUnstructuredFilterFieldNumber = 11,
    kSortFieldNumber = 12,
    kHeadFieldNumber = 13,
    kTailFieldNumber = 14,
    kHeadByFieldNumber = 15,
    kTailByFieldNumber = 16,
    kUngroupFieldNumber = 17,
    kMergeFieldNumber = 18,
    kComboAggregateFieldNumber = 19,
    kSnapshotFieldNumber = 20,
    kFlattenFieldNumber = 21,
    kRunChartDownsampleFieldNumber = 22,
    kCrossJoinFieldNumber = 23,
    kNaturalJoinFieldNumber = 24,
    kExactJoinFieldNumber = 25,
    kLeftJoinFieldNumber = 26,
    kAsOfJoinFieldNumber = 27,
    kFetchTableFieldNumber = 28,
    kFetchPandasTableFieldNumber = 29,
  };
  // .io.deephaven.proto.backplane.grpc.EmptyTableRequest empty_table = 1;
  bool has_empty_table() const;
  private:
  bool _internal_has_empty_table() const;
  public:
  void clear_empty_table();
  const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& empty_table() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* release_empty_table();
  ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* mutable_empty_table();
  void set_allocated_empty_table(::io::deephaven::proto::backplane::grpc::EmptyTableRequest* empty_table);
  private:
  const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& _internal_empty_table() const;
  ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* _internal_mutable_empty_table();
  public:
  void unsafe_arena_set_allocated_empty_table(
      ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* empty_table);
  ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* unsafe_arena_release_empty_table();

  // .io.deephaven.proto.backplane.grpc.TimeTableRequest time_table = 2;
  bool has_time_table() const;
  private:
  bool _internal_has_time_table() const;
  public:
  void clear_time_table();
  const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& time_table() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::TimeTableRequest* release_time_table();
  ::io::deephaven::proto::backplane::grpc::TimeTableRequest* mutable_time_table();
  void set_allocated_time_table(::io::deephaven::proto::backplane::grpc::TimeTableRequest* time_table);
  private:
  const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& _internal_time_table() const;
  ::io::deephaven::proto::backplane::grpc::TimeTableRequest* _internal_mutable_time_table();
  public:
  void unsafe_arena_set_allocated_time_table(
      ::io::deephaven::proto::backplane::grpc::TimeTableRequest* time_table);
  ::io::deephaven::proto::backplane::grpc::TimeTableRequest* unsafe_arena_release_time_table();

  // .io.deephaven.proto.backplane.grpc.DropColumnsRequest drop_columns = 3;
  bool has_drop_columns() const;
  private:
  bool _internal_has_drop_columns() const;
  public:
  void clear_drop_columns();
  const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& drop_columns() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* release_drop_columns();
  ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* mutable_drop_columns();
  void set_allocated_drop_columns(::io::deephaven::proto::backplane::grpc::DropColumnsRequest* drop_columns);
  private:
  const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& _internal_drop_columns() const;
  ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* _internal_mutable_drop_columns();
  public:
  void unsafe_arena_set_allocated_drop_columns(
      ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* drop_columns);
  ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* unsafe_arena_release_drop_columns();

  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest update = 4;
  bool has_update() const;
  private:
  bool _internal_has_update() const;
  public:
  void clear_update();
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& update() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_update();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_update();
  void set_allocated_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update);
  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_update() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_update();
  public:
  void unsafe_arena_set_allocated_update(
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_update();

  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest lazy_update = 5;
  bool has_lazy_update() const;
  private:
  bool _internal_has_lazy_update() const;
  public:
  void clear_lazy_update();
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& lazy_update() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_lazy_update();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_lazy_update();
  void set_allocated_lazy_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* lazy_update);
  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_lazy_update() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_lazy_update();
  public:
  void unsafe_arena_set_allocated_lazy_update(
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* lazy_update);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_lazy_update();

  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest view = 6;
  bool has_view() const;
  private:
  bool _internal_has_view() const;
  public:
  void clear_view();
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& view() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_view();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_view();
  void set_allocated_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* view);
  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_view() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_view();
  public:
  void unsafe_arena_set_allocated_view(
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* view);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_view();

  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest update_view = 7;
  bool has_update_view() const;
  private:
  bool _internal_has_update_view() const;
  public:
  void clear_update_view();
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& update_view() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_update_view();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_update_view();
  void set_allocated_update_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update_view);
  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_update_view() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_update_view();
  public:
  void unsafe_arena_set_allocated_update_view(
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update_view);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_update_view();

  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest select = 8;
  bool has_select() const;
  private:
  bool _internal_has_select() const;
  public:
  void clear_select();
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& select() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_select();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_select();
  void set_allocated_select(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* select);
  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_select() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_select();
  public:
  void unsafe_arena_set_allocated_select(
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* select);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_select();

  // .io.deephaven.proto.backplane.grpc.SelectDistinctRequest select_distinct = 9;
  bool has_select_distinct() const;
  private:
  bool _internal_has_select_distinct() const;
  public:
  void clear_select_distinct();
  const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& select_distinct() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* release_select_distinct();
  ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* mutable_select_distinct();
  void set_allocated_select_distinct(::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* select_distinct);
  private:
  const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& _internal_select_distinct() const;
  ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* _internal_mutable_select_distinct();
  public:
  void unsafe_arena_set_allocated_select_distinct(
      ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* select_distinct);
  ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* unsafe_arena_release_select_distinct();

  // .io.deephaven.proto.backplane.grpc.FilterTableRequest filter = 10;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& filter() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::FilterTableRequest* release_filter();
  ::io::deephaven::proto::backplane::grpc::FilterTableRequest* mutable_filter();
  void set_allocated_filter(::io::deephaven::proto::backplane::grpc::FilterTableRequest* filter);
  private:
  const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& _internal_filter() const;
  ::io::deephaven::proto::backplane::grpc::FilterTableRequest* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::io::deephaven::proto::backplane::grpc::FilterTableRequest* filter);
  ::io::deephaven::proto::backplane::grpc::FilterTableRequest* unsafe_arena_release_filter();

  // .io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest unstructured_filter = 11;
  bool has_unstructured_filter() const;
  private:
  bool _internal_has_unstructured_filter() const;
  public:
  void clear_unstructured_filter();
  const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& unstructured_filter() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* release_unstructured_filter();
  ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* mutable_unstructured_filter();
  void set_allocated_unstructured_filter(::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* unstructured_filter);
  private:
  const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& _internal_unstructured_filter() const;
  ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* _internal_mutable_unstructured_filter();
  public:
  void unsafe_arena_set_allocated_unstructured_filter(
      ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* unstructured_filter);
  ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* unsafe_arena_release_unstructured_filter();

  // .io.deephaven.proto.backplane.grpc.SortTableRequest sort = 12;
  bool has_sort() const;
  private:
  bool _internal_has_sort() const;
  public:
  void clear_sort();
  const ::io::deephaven::proto::backplane::grpc::SortTableRequest& sort() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::SortTableRequest* release_sort();
  ::io::deephaven::proto::backplane::grpc::SortTableRequest* mutable_sort();
  void set_allocated_sort(::io::deephaven::proto::backplane::grpc::SortTableRequest* sort);
  private:
  const ::io::deephaven::proto::backplane::grpc::SortTableRequest& _internal_sort() const;
  ::io::deephaven::proto::backplane::grpc::SortTableRequest* _internal_mutable_sort();
  public:
  void unsafe_arena_set_allocated_sort(
      ::io::deephaven::proto::backplane::grpc::SortTableRequest* sort);
  ::io::deephaven::proto::backplane::grpc::SortTableRequest* unsafe_arena_release_sort();

  // .io.deephaven.proto.backplane.grpc.HeadOrTailRequest head = 13;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& head() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* release_head();
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* mutable_head();
  void set_allocated_head(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* head);
  private:
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& _internal_head() const;
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* head);
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* unsafe_arena_release_head();

  // .io.deephaven.proto.backplane.grpc.HeadOrTailRequest tail = 14;
  bool has_tail() const;
  private:
  bool _internal_has_tail() const;
  public:
  void clear_tail();
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& tail() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* release_tail();
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* mutable_tail();
  void set_allocated_tail(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* tail);
  private:
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& _internal_tail() const;
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* _internal_mutable_tail();
  public:
  void unsafe_arena_set_allocated_tail(
      ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* tail);
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* unsafe_arena_release_tail();

  // .io.deephaven.proto.backplane.grpc.HeadOrTailByRequest head_by = 15;
  bool has_head_by() const;
  private:
  bool _internal_has_head_by() const;
  public:
  void clear_head_by();
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& head_by() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* release_head_by();
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* mutable_head_by();
  void set_allocated_head_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* head_by);
  private:
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& _internal_head_by() const;
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* _internal_mutable_head_by();
  public:
  void unsafe_arena_set_allocated_head_by(
      ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* head_by);
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* unsafe_arena_release_head_by();

  // .io.deephaven.proto.backplane.grpc.HeadOrTailByRequest tail_by = 16;
  bool has_tail_by() const;
  private:
  bool _internal_has_tail_by() const;
  public:
  void clear_tail_by();
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& tail_by() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* release_tail_by();
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* mutable_tail_by();
  void set_allocated_tail_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* tail_by);
  private:
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& _internal_tail_by() const;
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* _internal_mutable_tail_by();
  public:
  void unsafe_arena_set_allocated_tail_by(
      ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* tail_by);
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* unsafe_arena_release_tail_by();

  // .io.deephaven.proto.backplane.grpc.UngroupRequest ungroup = 17;
  bool has_ungroup() const;
  private:
  bool _internal_has_ungroup() const;
  public:
  void clear_ungroup();
  const ::io::deephaven::proto::backplane::grpc::UngroupRequest& ungroup() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::UngroupRequest* release_ungroup();
  ::io::deephaven::proto::backplane::grpc::UngroupRequest* mutable_ungroup();
  void set_allocated_ungroup(::io::deephaven::proto::backplane::grpc::UngroupRequest* ungroup);
  private:
  const ::io::deephaven::proto::backplane::grpc::UngroupRequest& _internal_ungroup() const;
  ::io::deephaven::proto::backplane::grpc::UngroupRequest* _internal_mutable_ungroup();
  public:
  void unsafe_arena_set_allocated_ungroup(
      ::io::deephaven::proto::backplane::grpc::UngroupRequest* ungroup);
  ::io::deephaven::proto::backplane::grpc::UngroupRequest* unsafe_arena_release_ungroup();

  // .io.deephaven.proto.backplane.grpc.MergeTablesRequest merge = 18;
  bool has_merge() const;
  private:
  bool _internal_has_merge() const;
  public:
  void clear_merge();
  const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& merge() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* release_merge();
  ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* mutable_merge();
  void set_allocated_merge(::io::deephaven::proto::backplane::grpc::MergeTablesRequest* merge);
  private:
  const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& _internal_merge() const;
  ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* _internal_mutable_merge();
  public:
  void unsafe_arena_set_allocated_merge(
      ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* merge);
  ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* unsafe_arena_release_merge();

  // .io.deephaven.proto.backplane.grpc.ComboAggregateRequest combo_aggregate = 19;
  bool has_combo_aggregate() const;
  private:
  bool _internal_has_combo_aggregate() const;
  public:
  void clear_combo_aggregate();
  const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& combo_aggregate() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* release_combo_aggregate();
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* mutable_combo_aggregate();
  void set_allocated_combo_aggregate(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* combo_aggregate);
  private:
  const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& _internal_combo_aggregate() const;
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* _internal_mutable_combo_aggregate();
  public:
  void unsafe_arena_set_allocated_combo_aggregate(
      ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* combo_aggregate);
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* unsafe_arena_release_combo_aggregate();

  // .io.deephaven.proto.backplane.grpc.SnapshotTableRequest snapshot = 20;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;
  public:
  void clear_snapshot();
  const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& snapshot() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* release_snapshot();
  ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* mutable_snapshot();
  void set_allocated_snapshot(::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* snapshot);
  private:
  const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& _internal_snapshot() const;
  ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* _internal_mutable_snapshot();
  public:
  void unsafe_arena_set_allocated_snapshot(
      ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* snapshot);
  ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* unsafe_arena_release_snapshot();

  // .io.deephaven.proto.backplane.grpc.FlattenRequest flatten = 21;
  bool has_flatten() const;
  private:
  bool _internal_has_flatten() const;
  public:
  void clear_flatten();
  const ::io::deephaven::proto::backplane::grpc::FlattenRequest& flatten() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::FlattenRequest* release_flatten();
  ::io::deephaven::proto::backplane::grpc::FlattenRequest* mutable_flatten();
  void set_allocated_flatten(::io::deephaven::proto::backplane::grpc::FlattenRequest* flatten);
  private:
  const ::io::deephaven::proto::backplane::grpc::FlattenRequest& _internal_flatten() const;
  ::io::deephaven::proto::backplane::grpc::FlattenRequest* _internal_mutable_flatten();
  public:
  void unsafe_arena_set_allocated_flatten(
      ::io::deephaven::proto::backplane::grpc::FlattenRequest* flatten);
  ::io::deephaven::proto::backplane::grpc::FlattenRequest* unsafe_arena_release_flatten();

  // .io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest run_chart_downsample = 22;
  bool has_run_chart_downsample() const;
  private:
  bool _internal_has_run_chart_downsample() const;
  public:
  void clear_run_chart_downsample();
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& run_chart_downsample() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* release_run_chart_downsample();
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* mutable_run_chart_downsample();
  void set_allocated_run_chart_downsample(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* run_chart_downsample);
  private:
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& _internal_run_chart_downsample() const;
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* _internal_mutable_run_chart_downsample();
  public:
  void unsafe_arena_set_allocated_run_chart_downsample(
      ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* run_chart_downsample);
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* unsafe_arena_release_run_chart_downsample();

  // .io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest cross_join = 23;
  bool has_cross_join() const;
  private:
  bool _internal_has_cross_join() const;
  public:
  void clear_cross_join();
  const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& cross_join() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* release_cross_join();
  ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* mutable_cross_join();
  void set_allocated_cross_join(::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* cross_join);
  private:
  const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& _internal_cross_join() const;
  ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* _internal_mutable_cross_join();
  public:
  void unsafe_arena_set_allocated_cross_join(
      ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* cross_join);
  ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* unsafe_arena_release_cross_join();

  // .io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest natural_join = 24;
  bool has_natural_join() const;
  private:
  bool _internal_has_natural_join() const;
  public:
  void clear_natural_join();
  const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& natural_join() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* release_natural_join();
  ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* mutable_natural_join();
  void set_allocated_natural_join(::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* natural_join);
  private:
  const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& _internal_natural_join() const;
  ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* _internal_mutable_natural_join();
  public:
  void unsafe_arena_set_allocated_natural_join(
      ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* natural_join);
  ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* unsafe_arena_release_natural_join();

  // .io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest exact_join = 25;
  bool has_exact_join() const;
  private:
  bool _internal_has_exact_join() const;
  public:
  void clear_exact_join();
  const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& exact_join() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* release_exact_join();
  ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* mutable_exact_join();
  void set_allocated_exact_join(::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* exact_join);
  private:
  const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& _internal_exact_join() const;
  ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* _internal_mutable_exact_join();
  public:
  void unsafe_arena_set_allocated_exact_join(
      ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* exact_join);
  ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* unsafe_arena_release_exact_join();

  // .io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest left_join = 26;
  bool has_left_join() const;
  private:
  bool _internal_has_left_join() const;
  public:
  void clear_left_join();
  const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& left_join() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* release_left_join();
  ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* mutable_left_join();
  void set_allocated_left_join(::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* left_join);
  private:
  const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& _internal_left_join() const;
  ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* _internal_mutable_left_join();
  public:
  void unsafe_arena_set_allocated_left_join(
      ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* left_join);
  ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* unsafe_arena_release_left_join();

  // .io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest as_of_join = 27;
  bool has_as_of_join() const;
  private:
  bool _internal_has_as_of_join() const;
  public:
  void clear_as_of_join();
  const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& as_of_join() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* release_as_of_join();
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* mutable_as_of_join();
  void set_allocated_as_of_join(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* as_of_join);
  private:
  const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& _internal_as_of_join() const;
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* _internal_mutable_as_of_join();
  public:
  void unsafe_arena_set_allocated_as_of_join(
      ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* as_of_join);
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* unsafe_arena_release_as_of_join();

  // .io.deephaven.proto.backplane.grpc.FetchTableRequest fetch_table = 28;
  bool has_fetch_table() const;
  private:
  bool _internal_has_fetch_table() const;
  public:
  void clear_fetch_table();
  const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& fetch_table() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::FetchTableRequest* release_fetch_table();
  ::io::deephaven::proto::backplane::grpc::FetchTableRequest* mutable_fetch_table();
  void set_allocated_fetch_table(::io::deephaven::proto::backplane::grpc::FetchTableRequest* fetch_table);
  private:
  const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& _internal_fetch_table() const;
  ::io::deephaven::proto::backplane::grpc::FetchTableRequest* _internal_mutable_fetch_table();
  public:
  void unsafe_arena_set_allocated_fetch_table(
      ::io::deephaven::proto::backplane::grpc::FetchTableRequest* fetch_table);
  ::io::deephaven::proto::backplane::grpc::FetchTableRequest* unsafe_arena_release_fetch_table();

  // .io.deephaven.proto.backplane.grpc.FetchPandasTableRequest fetch_pandas_table = 29;
  bool has_fetch_pandas_table() const;
  private:
  bool _internal_has_fetch_pandas_table() const;
  public:
  void clear_fetch_pandas_table();
  const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& fetch_pandas_table() const;
  PROTOBUF_MUST_USE_RESULT ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* release_fetch_pandas_table();
  ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* mutable_fetch_pandas_table();
  void set_allocated_fetch_pandas_table(::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* fetch_pandas_table);
  private:
  const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& _internal_fetch_pandas_table() const;
  ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* _internal_mutable_fetch_pandas_table();
  public:
  void unsafe_arena_set_allocated_fetch_pandas_table(
      ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* fetch_pandas_table);
  ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* unsafe_arena_release_fetch_pandas_table();

  void clear_op();
  OpCase op_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation)
 private:
  class _Internal;
  void set_has_empty_table();
  void set_has_time_table();
  void set_has_drop_columns();
  void set_has_update();
  void set_has_lazy_update();
  void set_has_view();
  void set_has_update_view();
  void set_has_select();
  void set_has_select_distinct();
  void set_has_filter();
  void set_has_unstructured_filter();
  void set_has_sort();
  void set_has_head();
  void set_has_tail();
  void set_has_head_by();
  void set_has_tail_by();
  void set_has_ungroup();
  void set_has_merge();
  void set_has_combo_aggregate();
  void set_has_snapshot();
  void set_has_flatten();
  void set_has_run_chart_downsample();
  void set_has_cross_join();
  void set_has_natural_join();
  void set_has_exact_join();
  void set_has_left_join();
  void set_has_as_of_join();
  void set_has_fetch_table();
  void set_has_fetch_pandas_table();

  inline bool has_op() const;
  inline void clear_has_op();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union OpUnion {
    constexpr OpUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* empty_table_;
    ::io::deephaven::proto::backplane::grpc::TimeTableRequest* time_table_;
    ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* drop_columns_;
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update_;
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* lazy_update_;
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* view_;
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update_view_;
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* select_;
    ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* select_distinct_;
    ::io::deephaven::proto::backplane::grpc::FilterTableRequest* filter_;
    ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* unstructured_filter_;
    ::io::deephaven::proto::backplane::grpc::SortTableRequest* sort_;
    ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* head_;
    ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* tail_;
    ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* head_by_;
    ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* tail_by_;
    ::io::deephaven::proto::backplane::grpc::UngroupRequest* ungroup_;
    ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* merge_;
    ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* combo_aggregate_;
    ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* snapshot_;
    ::io::deephaven::proto::backplane::grpc::FlattenRequest* flatten_;
    ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* run_chart_downsample_;
    ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* cross_join_;
    ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* natural_join_;
    ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* exact_join_;
    ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* left_join_;
    ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* as_of_join_;
    ::io::deephaven::proto::backplane::grpc::FetchTableRequest* fetch_table_;
    ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* fetch_pandas_table_;
  } op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class BatchTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.BatchTableRequest) */ {
 public:
  inline BatchTableRequest() : BatchTableRequest(nullptr) {}
  ~BatchTableRequest() override;
  explicit constexpr BatchTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchTableRequest(const BatchTableRequest& from);
  BatchTableRequest(BatchTableRequest&& from) noexcept
    : BatchTableRequest() {
    *this = ::std::move(from);
  }

  inline BatchTableRequest& operator=(const BatchTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchTableRequest& operator=(BatchTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchTableRequest* internal_default_instance() {
    return reinterpret_cast<const BatchTableRequest*>(
               &_BatchTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(BatchTableRequest& a, BatchTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchTableRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BatchTableRequest* New() const final {
    return new BatchTableRequest();
  }

  BatchTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BatchTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchTableRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.BatchTableRequest";
  }
  protected:
  explicit BatchTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BatchTableRequest_Operation Operation;

  // accessors -------------------------------------------------------

  enum : int {
    kOpsFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation ops = 1;
  int ops_size() const;
  private:
  int _internal_ops_size() const;
  public:
  void clear_ops();
  ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* mutable_ops(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation >*
      mutable_ops();
  private:
  const ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation& _internal_ops(int index) const;
  ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* _internal_add_ops();
  public:
  const ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation& ops(int index) const;
  ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* add_ops();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation >&
      ops() const;

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.BatchTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation > ops_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TableReference

// .io.deephaven.proto.backplane.grpc.Ticket ticket = 1;
inline bool TableReference::_internal_has_ticket() const {
  return ref_case() == kTicket;
}
inline bool TableReference::has_ticket() const {
  return _internal_has_ticket();
}
inline void TableReference::set_has_ticket() {
  _oneof_case_[0] = kTicket;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TableReference::release_ticket() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.TableReference.ticket)
  if (_internal_has_ticket()) {
    clear_has_ref();
      ::io::deephaven::proto::backplane::grpc::Ticket* temp = ref_.ticket_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ref_.ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& TableReference::_internal_ticket() const {
  return _internal_has_ticket()
      ? *ref_.ticket_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& TableReference::ticket() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TableReference.ticket)
  return _internal_ticket();
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TableReference::unsafe_arena_release_ticket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.TableReference.ticket)
  if (_internal_has_ticket()) {
    clear_has_ref();
    ::io::deephaven::proto::backplane::grpc::Ticket* temp = ref_.ticket_;
    ref_.ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TableReference::unsafe_arena_set_allocated_ticket(::io::deephaven::proto::backplane::grpc::Ticket* ticket) {
  clear_ref();
  if (ticket) {
    set_has_ticket();
    ref_.ticket_ = ticket;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.TableReference.ticket)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TableReference::_internal_mutable_ticket() {
  if (!_internal_has_ticket()) {
    clear_ref();
    set_has_ticket();
    ref_.ticket_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::Ticket >(GetArenaForAllocation());
  }
  return ref_.ticket_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TableReference::mutable_ticket() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_ticket();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.TableReference.ticket)
  return _msg;
}

// sint32 batch_offset = 2;
inline bool TableReference::_internal_has_batch_offset() const {
  return ref_case() == kBatchOffset;
}
inline bool TableReference::has_batch_offset() const {
  return _internal_has_batch_offset();
}
inline void TableReference::set_has_batch_offset() {
  _oneof_case_[0] = kBatchOffset;
}
inline void TableReference::clear_batch_offset() {
  if (_internal_has_batch_offset()) {
    ref_.batch_offset_ = 0;
    clear_has_ref();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TableReference::_internal_batch_offset() const {
  if (_internal_has_batch_offset()) {
    return ref_.batch_offset_;
  }
  return 0;
}
inline void TableReference::_internal_set_batch_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  if (!_internal_has_batch_offset()) {
    clear_ref();
    set_has_batch_offset();
  }
  ref_.batch_offset_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 TableReference::batch_offset() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TableReference.batch_offset)
  return _internal_batch_offset();
}
inline void TableReference::set_batch_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batch_offset(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.TableReference.batch_offset)
}

inline bool TableReference::has_ref() const {
  return ref_case() != REF_NOT_SET;
}
inline void TableReference::clear_has_ref() {
  _oneof_case_[0] = REF_NOT_SET;
}
inline TableReference::RefCase TableReference::ref_case() const {
  return TableReference::RefCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExportedTableCreationResponse

// .io.deephaven.proto.backplane.grpc.TableReference result_id = 1;
inline bool ExportedTableCreationResponse::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool ExportedTableCreationResponse::has_result_id() const {
  return _internal_has_result_id();
}
inline void ExportedTableCreationResponse::clear_result_id() {
  if (GetArenaForAllocation() == nullptr && result_id_ != nullptr) {
    delete result_id_;
  }
  result_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExportedTableCreationResponse::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExportedTableCreationResponse::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
  return _internal_result_id();
}
inline void ExportedTableCreationResponse::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExportedTableCreationResponse::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExportedTableCreationResponse::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExportedTableCreationResponse::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExportedTableCreationResponse::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
  return _msg;
}
inline void ExportedTableCreationResponse::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::TableReference* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_id_;
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(result_id);
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
}

// bool success = 2;
inline void ExportedTableCreationResponse::clear_success() {
  success_ = false;
}
inline bool ExportedTableCreationResponse::_internal_success() const {
  return success_;
}
inline bool ExportedTableCreationResponse::success() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.success)
  return _internal_success();
}
inline void ExportedTableCreationResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ExportedTableCreationResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.success)
}

// string error_info = 3;
inline void ExportedTableCreationResponse::clear_error_info() {
  error_info_.ClearToEmpty();
}
inline const std::string& ExportedTableCreationResponse::error_info() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
  return _internal_error_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportedTableCreationResponse::set_error_info(ArgT0&& arg0, ArgT... args) {
 
 error_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
}
inline std::string* ExportedTableCreationResponse::mutable_error_info() {
  std::string* _s = _internal_mutable_error_info();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
  return _s;
}
inline const std::string& ExportedTableCreationResponse::_internal_error_info() const {
  return error_info_.Get();
}
inline void ExportedTableCreationResponse::_internal_set_error_info(const std::string& value) {
  
  error_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExportedTableCreationResponse::_internal_mutable_error_info() {
  
  return error_info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExportedTableCreationResponse::release_error_info() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
  return error_info_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExportedTableCreationResponse::set_allocated_error_info(std::string* error_info) {
  if (error_info != nullptr) {
    
  } else {
    
  }
  error_info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_info,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
}

// bytes schema_header = 4;
inline void ExportedTableCreationResponse::clear_schema_header() {
  schema_header_.ClearToEmpty();
}
inline const std::string& ExportedTableCreationResponse::schema_header() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
  return _internal_schema_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportedTableCreationResponse::set_schema_header(ArgT0&& arg0, ArgT... args) {
 
 schema_header_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
}
inline std::string* ExportedTableCreationResponse::mutable_schema_header() {
  std::string* _s = _internal_mutable_schema_header();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
  return _s;
}
inline const std::string& ExportedTableCreationResponse::_internal_schema_header() const {
  return schema_header_.Get();
}
inline void ExportedTableCreationResponse::_internal_set_schema_header(const std::string& value) {
  
  schema_header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExportedTableCreationResponse::_internal_mutable_schema_header() {
  
  return schema_header_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExportedTableCreationResponse::release_schema_header() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
  return schema_header_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExportedTableCreationResponse::set_allocated_schema_header(std::string* schema_header) {
  if (schema_header != nullptr) {
    
  } else {
    
  }
  schema_header_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schema_header,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
}

// bool is_static = 5;
inline void ExportedTableCreationResponse::clear_is_static() {
  is_static_ = false;
}
inline bool ExportedTableCreationResponse::_internal_is_static() const {
  return is_static_;
}
inline bool ExportedTableCreationResponse::is_static() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.is_static)
  return _internal_is_static();
}
inline void ExportedTableCreationResponse::_internal_set_is_static(bool value) {
  
  is_static_ = value;
}
inline void ExportedTableCreationResponse::set_is_static(bool value) {
  _internal_set_is_static(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.is_static)
}

// sint64 size = 6 [jstype = JS_STRING];
inline void ExportedTableCreationResponse::clear_size() {
  size_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExportedTableCreationResponse::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExportedTableCreationResponse::size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.size)
  return _internal_size();
}
inline void ExportedTableCreationResponse::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  size_ = value;
}
inline void ExportedTableCreationResponse::set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.size)
}

// -------------------------------------------------------------------

// FetchTableRequest

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
inline bool FetchTableRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool FetchTableRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void FetchTableRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FetchTableRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FetchTableRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
  return _internal_source_id();
}
inline void FetchTableRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
  return _msg;
}
inline void FetchTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
inline bool FetchTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool FetchTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FetchTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FetchTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
  return _internal_result_id();
}
inline void FetchTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
  return _msg;
}
inline void FetchTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
}

// -------------------------------------------------------------------

// FetchPandasTableRequest

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
inline bool FetchPandasTableRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool FetchPandasTableRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void FetchPandasTableRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FetchPandasTableRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FetchPandasTableRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchPandasTableRequest.source_id)
  return _internal_source_id();
}
inline void FetchPandasTableRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FetchPandasTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchPandasTableRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchPandasTableRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchPandasTableRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchPandasTableRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchPandasTableRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchPandasTableRequest.source_id)
  return _msg;
}
inline void FetchPandasTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchPandasTableRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
inline bool FetchPandasTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool FetchPandasTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FetchPandasTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FetchPandasTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchPandasTableRequest.result_id)
  return _internal_result_id();
}
inline void FetchPandasTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FetchPandasTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchPandasTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchPandasTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchPandasTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchPandasTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchPandasTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchPandasTableRequest.result_id)
  return _msg;
}
inline void FetchPandasTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchPandasTableRequest.result_id)
}

// -------------------------------------------------------------------

// FetchTableMapRequest

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
inline bool FetchTableMapRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool FetchTableMapRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void FetchTableMapRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FetchTableMapRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FetchTableMapRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchTableMapRequest.source_id)
  return _internal_source_id();
}
inline void FetchTableMapRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableMapRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableMapRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableMapRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchTableMapRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableMapRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableMapRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchTableMapRequest.source_id)
  return _msg;
}
inline void FetchTableMapRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableMapRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
inline bool FetchTableMapRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool FetchTableMapRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FetchTableMapRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FetchTableMapRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchTableMapRequest.result_id)
  return _internal_result_id();
}
inline void FetchTableMapRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableMapRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableMapRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableMapRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchTableMapRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableMapRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableMapRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchTableMapRequest.result_id)
  return _msg;
}
inline void FetchTableMapRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableMapRequest.result_id)
}

// -------------------------------------------------------------------

// FetchTableMapResponse

// -------------------------------------------------------------------

// ExportedTableUpdatesRequest

// -------------------------------------------------------------------

// ExportedTableUpdateMessage

// .io.deephaven.proto.backplane.grpc.Ticket export_id = 1;
inline bool ExportedTableUpdateMessage::_internal_has_export_id() const {
  return this != internal_default_instance() && export_id_ != nullptr;
}
inline bool ExportedTableUpdateMessage::has_export_id() const {
  return _internal_has_export_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExportedTableUpdateMessage::_internal_export_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = export_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExportedTableUpdateMessage::export_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
  return _internal_export_id();
}
inline void ExportedTableUpdateMessage::unsafe_arena_set_allocated_export_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* export_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(export_id_);
  }
  export_id_ = export_id;
  if (export_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExportedTableUpdateMessage::release_export_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = export_id_;
  export_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExportedTableUpdateMessage::unsafe_arena_release_export_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = export_id_;
  export_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExportedTableUpdateMessage::_internal_mutable_export_id() {
  
  if (export_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    export_id_ = p;
  }
  return export_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExportedTableUpdateMessage::mutable_export_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_export_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
  return _msg;
}
inline void ExportedTableUpdateMessage::set_allocated_export_id(::io::deephaven::proto::backplane::grpc::Ticket* export_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(export_id_);
  }
  if (export_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(export_id));
    if (message_arena != submessage_arena) {
      export_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, export_id, submessage_arena);
    }
    
  } else {
    
  }
  export_id_ = export_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
}

// sint64 size = 2 [jstype = JS_STRING];
inline void ExportedTableUpdateMessage::clear_size() {
  size_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExportedTableUpdateMessage::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ExportedTableUpdateMessage::size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.size)
  return _internal_size();
}
inline void ExportedTableUpdateMessage::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  size_ = value;
}
inline void ExportedTableUpdateMessage::set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.size)
}

// string update_failure_message = 3;
inline void ExportedTableUpdateMessage::clear_update_failure_message() {
  update_failure_message_.ClearToEmpty();
}
inline const std::string& ExportedTableUpdateMessage::update_failure_message() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
  return _internal_update_failure_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportedTableUpdateMessage::set_update_failure_message(ArgT0&& arg0, ArgT... args) {
 
 update_failure_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
}
inline std::string* ExportedTableUpdateMessage::mutable_update_failure_message() {
  std::string* _s = _internal_mutable_update_failure_message();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
  return _s;
}
inline const std::string& ExportedTableUpdateMessage::_internal_update_failure_message() const {
  return update_failure_message_.Get();
}
inline void ExportedTableUpdateMessage::_internal_set_update_failure_message(const std::string& value) {
  
  update_failure_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExportedTableUpdateMessage::_internal_mutable_update_failure_message() {
  
  return update_failure_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExportedTableUpdateMessage::release_update_failure_message() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
  return update_failure_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExportedTableUpdateMessage::set_allocated_update_failure_message(std::string* update_failure_message) {
  if (update_failure_message != nullptr) {
    
  } else {
    
  }
  update_failure_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), update_failure_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
}

// -------------------------------------------------------------------

// EmptyTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool EmptyTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool EmptyTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& EmptyTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& EmptyTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
  return _internal_result_id();
}
inline void EmptyTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* EmptyTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* EmptyTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* EmptyTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* EmptyTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
  return _msg;
}
inline void EmptyTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
}

// sint64 size = 2 [jstype = JS_STRING];
inline void EmptyTableRequest::clear_size() {
  size_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EmptyTableRequest::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 EmptyTableRequest::size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.EmptyTableRequest.size)
  return _internal_size();
}
inline void EmptyTableRequest::_internal_set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  size_ = value;
}
inline void EmptyTableRequest::set_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.EmptyTableRequest.size)
}

// -------------------------------------------------------------------

// TimeTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool TimeTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool TimeTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& TimeTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& TimeTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
  return _internal_result_id();
}
inline void TimeTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TimeTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TimeTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TimeTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TimeTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
  return _msg;
}
inline void TimeTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
}

// sint64 start_time_nanos = 2 [jstype = JS_STRING];
inline void TimeTableRequest::clear_start_time_nanos() {
  start_time_nanos_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimeTableRequest::_internal_start_time_nanos() const {
  return start_time_nanos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimeTableRequest::start_time_nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TimeTableRequest.start_time_nanos)
  return _internal_start_time_nanos();
}
inline void TimeTableRequest::_internal_set_start_time_nanos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  start_time_nanos_ = value;
}
inline void TimeTableRequest::set_start_time_nanos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_start_time_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.TimeTableRequest.start_time_nanos)
}

// sint64 period_nanos = 3 [jstype = JS_STRING];
inline void TimeTableRequest::clear_period_nanos() {
  period_nanos_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimeTableRequest::_internal_period_nanos() const {
  return period_nanos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimeTableRequest::period_nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TimeTableRequest.period_nanos)
  return _internal_period_nanos();
}
inline void TimeTableRequest::_internal_set_period_nanos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  period_nanos_ = value;
}
inline void TimeTableRequest::set_period_nanos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_period_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.TimeTableRequest.period_nanos)
}

// -------------------------------------------------------------------

// SelectOrUpdateRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SelectOrUpdateRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool SelectOrUpdateRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SelectOrUpdateRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SelectOrUpdateRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
  return _internal_result_id();
}
inline void SelectOrUpdateRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectOrUpdateRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectOrUpdateRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectOrUpdateRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectOrUpdateRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
  return _msg;
}
inline void SelectOrUpdateRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool SelectOrUpdateRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool SelectOrUpdateRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void SelectOrUpdateRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SelectOrUpdateRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SelectOrUpdateRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
  return _internal_source_id();
}
inline void SelectOrUpdateRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectOrUpdateRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectOrUpdateRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectOrUpdateRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectOrUpdateRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
  return _msg;
}
inline void SelectOrUpdateRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
}

// repeated string column_specs = 3;
inline int SelectOrUpdateRequest::_internal_column_specs_size() const {
  return column_specs_.size();
}
inline int SelectOrUpdateRequest::column_specs_size() const {
  return _internal_column_specs_size();
}
inline void SelectOrUpdateRequest::clear_column_specs() {
  column_specs_.Clear();
}
inline std::string* SelectOrUpdateRequest::add_column_specs() {
  std::string* _s = _internal_add_column_specs();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return _s;
}
inline const std::string& SelectOrUpdateRequest::_internal_column_specs(int index) const {
  return column_specs_.Get(index);
}
inline const std::string& SelectOrUpdateRequest::column_specs(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return _internal_column_specs(index);
}
inline std::string* SelectOrUpdateRequest::mutable_column_specs(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return column_specs_.Mutable(index);
}
inline void SelectOrUpdateRequest::set_column_specs(int index, const std::string& value) {
  column_specs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::set_column_specs(int index, std::string&& value) {
  column_specs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::set_column_specs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_specs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::set_column_specs(int index, const char* value, size_t size) {
  column_specs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline std::string* SelectOrUpdateRequest::_internal_add_column_specs() {
  return column_specs_.Add();
}
inline void SelectOrUpdateRequest::add_column_specs(const std::string& value) {
  column_specs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::add_column_specs(std::string&& value) {
  column_specs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::add_column_specs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_specs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::add_column_specs(const char* value, size_t size) {
  column_specs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SelectOrUpdateRequest::column_specs() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return column_specs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SelectOrUpdateRequest::mutable_column_specs() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return &column_specs_;
}

// -------------------------------------------------------------------

// SelectDistinctRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SelectDistinctRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool SelectDistinctRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SelectDistinctRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SelectDistinctRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
  return _internal_result_id();
}
inline void SelectDistinctRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectDistinctRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectDistinctRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectDistinctRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectDistinctRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
  return _msg;
}
inline void SelectDistinctRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool SelectDistinctRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool SelectDistinctRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void SelectDistinctRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SelectDistinctRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SelectDistinctRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
  return _internal_source_id();
}
inline void SelectDistinctRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectDistinctRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectDistinctRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectDistinctRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectDistinctRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
  return _msg;
}
inline void SelectDistinctRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
}

// repeated string column_names = 3;
inline int SelectDistinctRequest::_internal_column_names_size() const {
  return column_names_.size();
}
inline int SelectDistinctRequest::column_names_size() const {
  return _internal_column_names_size();
}
inline void SelectDistinctRequest::clear_column_names() {
  column_names_.Clear();
}
inline std::string* SelectDistinctRequest::add_column_names() {
  std::string* _s = _internal_add_column_names();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return _s;
}
inline const std::string& SelectDistinctRequest::_internal_column_names(int index) const {
  return column_names_.Get(index);
}
inline const std::string& SelectDistinctRequest::column_names(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return _internal_column_names(index);
}
inline std::string* SelectDistinctRequest::mutable_column_names(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return column_names_.Mutable(index);
}
inline void SelectDistinctRequest::set_column_names(int index, const std::string& value) {
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::set_column_names(int index, std::string&& value) {
  column_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::set_column_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::set_column_names(int index, const char* value, size_t size) {
  column_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline std::string* SelectDistinctRequest::_internal_add_column_names() {
  return column_names_.Add();
}
inline void SelectDistinctRequest::add_column_names(const std::string& value) {
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::add_column_names(std::string&& value) {
  column_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::add_column_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::add_column_names(const char* value, size_t size) {
  column_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SelectDistinctRequest::column_names() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return column_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SelectDistinctRequest::mutable_column_names() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return &column_names_;
}

// -------------------------------------------------------------------

// DropColumnsRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool DropColumnsRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool DropColumnsRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& DropColumnsRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& DropColumnsRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
  return _internal_result_id();
}
inline void DropColumnsRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* DropColumnsRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* DropColumnsRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* DropColumnsRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* DropColumnsRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
  return _msg;
}
inline void DropColumnsRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool DropColumnsRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool DropColumnsRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void DropColumnsRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& DropColumnsRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& DropColumnsRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
  return _internal_source_id();
}
inline void DropColumnsRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* DropColumnsRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* DropColumnsRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* DropColumnsRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* DropColumnsRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
  return _msg;
}
inline void DropColumnsRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
}

// repeated string column_names = 3;
inline int DropColumnsRequest::_internal_column_names_size() const {
  return column_names_.size();
}
inline int DropColumnsRequest::column_names_size() const {
  return _internal_column_names_size();
}
inline void DropColumnsRequest::clear_column_names() {
  column_names_.Clear();
}
inline std::string* DropColumnsRequest::add_column_names() {
  std::string* _s = _internal_add_column_names();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return _s;
}
inline const std::string& DropColumnsRequest::_internal_column_names(int index) const {
  return column_names_.Get(index);
}
inline const std::string& DropColumnsRequest::column_names(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return _internal_column_names(index);
}
inline std::string* DropColumnsRequest::mutable_column_names(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return column_names_.Mutable(index);
}
inline void DropColumnsRequest::set_column_names(int index, const std::string& value) {
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::set_column_names(int index, std::string&& value) {
  column_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::set_column_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::set_column_names(int index, const char* value, size_t size) {
  column_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline std::string* DropColumnsRequest::_internal_add_column_names() {
  return column_names_.Add();
}
inline void DropColumnsRequest::add_column_names(const std::string& value) {
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::add_column_names(std::string&& value) {
  column_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::add_column_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::add_column_names(const char* value, size_t size) {
  column_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DropColumnsRequest::column_names() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return column_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DropColumnsRequest::mutable_column_names() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return &column_names_;
}

// -------------------------------------------------------------------

// UnstructuredFilterTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool UnstructuredFilterTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool UnstructuredFilterTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UnstructuredFilterTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UnstructuredFilterTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
  return _internal_result_id();
}
inline void UnstructuredFilterTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UnstructuredFilterTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UnstructuredFilterTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UnstructuredFilterTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UnstructuredFilterTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
  return _msg;
}
inline void UnstructuredFilterTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool UnstructuredFilterTableRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool UnstructuredFilterTableRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void UnstructuredFilterTableRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UnstructuredFilterTableRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UnstructuredFilterTableRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
  return _internal_source_id();
}
inline void UnstructuredFilterTableRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UnstructuredFilterTableRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UnstructuredFilterTableRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UnstructuredFilterTableRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UnstructuredFilterTableRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
  return _msg;
}
inline void UnstructuredFilterTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
}

// repeated string filters = 3;
inline int UnstructuredFilterTableRequest::_internal_filters_size() const {
  return filters_.size();
}
inline int UnstructuredFilterTableRequest::filters_size() const {
  return _internal_filters_size();
}
inline void UnstructuredFilterTableRequest::clear_filters() {
  filters_.Clear();
}
inline std::string* UnstructuredFilterTableRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return _s;
}
inline const std::string& UnstructuredFilterTableRequest::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const std::string& UnstructuredFilterTableRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return _internal_filters(index);
}
inline std::string* UnstructuredFilterTableRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return filters_.Mutable(index);
}
inline void UnstructuredFilterTableRequest::set_filters(int index, const std::string& value) {
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::set_filters(int index, std::string&& value) {
  filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::set_filters(int index, const char* value, size_t size) {
  filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline std::string* UnstructuredFilterTableRequest::_internal_add_filters() {
  return filters_.Add();
}
inline void UnstructuredFilterTableRequest::add_filters(const std::string& value) {
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::add_filters(std::string&& value) {
  filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::add_filters(const char* value, size_t size) {
  filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UnstructuredFilterTableRequest::filters() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UnstructuredFilterTableRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return &filters_;
}

// -------------------------------------------------------------------

// HeadOrTailRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool HeadOrTailRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool HeadOrTailRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& HeadOrTailRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& HeadOrTailRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
  return _internal_result_id();
}
inline void HeadOrTailRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
  return _msg;
}
inline void HeadOrTailRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool HeadOrTailRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool HeadOrTailRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void HeadOrTailRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& HeadOrTailRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& HeadOrTailRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
  return _internal_source_id();
}
inline void HeadOrTailRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
  return _msg;
}
inline void HeadOrTailRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
}

// sint64 num_rows = 3 [jstype = JS_STRING];
inline void HeadOrTailRequest::clear_num_rows() {
  num_rows_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 HeadOrTailRequest::_internal_num_rows() const {
  return num_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 HeadOrTailRequest::num_rows() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.num_rows)
  return _internal_num_rows();
}
inline void HeadOrTailRequest::_internal_set_num_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  num_rows_ = value;
}
inline void HeadOrTailRequest::set_num_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_rows(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.num_rows)
}

// -------------------------------------------------------------------

// HeadOrTailByRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool HeadOrTailByRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool HeadOrTailByRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& HeadOrTailByRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& HeadOrTailByRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
  return _internal_result_id();
}
inline void HeadOrTailByRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailByRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailByRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailByRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailByRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
  return _msg;
}
inline void HeadOrTailByRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool HeadOrTailByRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool HeadOrTailByRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void HeadOrTailByRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& HeadOrTailByRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& HeadOrTailByRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
  return _internal_source_id();
}
inline void HeadOrTailByRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailByRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailByRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailByRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailByRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
  return _msg;
}
inline void HeadOrTailByRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
}

// sint64 num_rows = 3 [jstype = JS_STRING];
inline void HeadOrTailByRequest::clear_num_rows() {
  num_rows_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 HeadOrTailByRequest::_internal_num_rows() const {
  return num_rows_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 HeadOrTailByRequest::num_rows() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.num_rows)
  return _internal_num_rows();
}
inline void HeadOrTailByRequest::_internal_set_num_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  num_rows_ = value;
}
inline void HeadOrTailByRequest::set_num_rows(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_num_rows(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.num_rows)
}

// repeated string group_by_column_specs = 4;
inline int HeadOrTailByRequest::_internal_group_by_column_specs_size() const {
  return group_by_column_specs_.size();
}
inline int HeadOrTailByRequest::group_by_column_specs_size() const {
  return _internal_group_by_column_specs_size();
}
inline void HeadOrTailByRequest::clear_group_by_column_specs() {
  group_by_column_specs_.Clear();
}
inline std::string* HeadOrTailByRequest::add_group_by_column_specs() {
  std::string* _s = _internal_add_group_by_column_specs();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return _s;
}
inline const std::string& HeadOrTailByRequest::_internal_group_by_column_specs(int index) const {
  return group_by_column_specs_.Get(index);
}
inline const std::string& HeadOrTailByRequest::group_by_column_specs(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return _internal_group_by_column_specs(index);
}
inline std::string* HeadOrTailByRequest::mutable_group_by_column_specs(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return group_by_column_specs_.Mutable(index);
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, const std::string& value) {
  group_by_column_specs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, std::string&& value) {
  group_by_column_specs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_column_specs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, const char* value, size_t size) {
  group_by_column_specs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline std::string* HeadOrTailByRequest::_internal_add_group_by_column_specs() {
  return group_by_column_specs_.Add();
}
inline void HeadOrTailByRequest::add_group_by_column_specs(const std::string& value) {
  group_by_column_specs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::add_group_by_column_specs(std::string&& value) {
  group_by_column_specs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::add_group_by_column_specs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_column_specs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::add_group_by_column_specs(const char* value, size_t size) {
  group_by_column_specs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HeadOrTailByRequest::group_by_column_specs() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return group_by_column_specs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HeadOrTailByRequest::mutable_group_by_column_specs() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return &group_by_column_specs_;
}

// -------------------------------------------------------------------

// UngroupRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool UngroupRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool UngroupRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UngroupRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UngroupRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
  return _internal_result_id();
}
inline void UngroupRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UngroupRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UngroupRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UngroupRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UngroupRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
  return _msg;
}
inline void UngroupRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool UngroupRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool UngroupRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void UngroupRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UngroupRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UngroupRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
  return _internal_source_id();
}
inline void UngroupRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UngroupRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UngroupRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UngroupRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UngroupRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
  return _msg;
}
inline void UngroupRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
}

// bool null_fill = 3;
inline void UngroupRequest::clear_null_fill() {
  null_fill_ = false;
}
inline bool UngroupRequest::_internal_null_fill() const {
  return null_fill_;
}
inline bool UngroupRequest::null_fill() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UngroupRequest.null_fill)
  return _internal_null_fill();
}
inline void UngroupRequest::_internal_set_null_fill(bool value) {
  
  null_fill_ = value;
}
inline void UngroupRequest::set_null_fill(bool value) {
  _internal_set_null_fill(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UngroupRequest.null_fill)
}

// repeated string columns_to_ungroup = 4;
inline int UngroupRequest::_internal_columns_to_ungroup_size() const {
  return columns_to_ungroup_.size();
}
inline int UngroupRequest::columns_to_ungroup_size() const {
  return _internal_columns_to_ungroup_size();
}
inline void UngroupRequest::clear_columns_to_ungroup() {
  columns_to_ungroup_.Clear();
}
inline std::string* UngroupRequest::add_columns_to_ungroup() {
  std::string* _s = _internal_add_columns_to_ungroup();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return _s;
}
inline const std::string& UngroupRequest::_internal_columns_to_ungroup(int index) const {
  return columns_to_ungroup_.Get(index);
}
inline const std::string& UngroupRequest::columns_to_ungroup(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return _internal_columns_to_ungroup(index);
}
inline std::string* UngroupRequest::mutable_columns_to_ungroup(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return columns_to_ungroup_.Mutable(index);
}
inline void UngroupRequest::set_columns_to_ungroup(int index, const std::string& value) {
  columns_to_ungroup_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::set_columns_to_ungroup(int index, std::string&& value) {
  columns_to_ungroup_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::set_columns_to_ungroup(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_ungroup_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::set_columns_to_ungroup(int index, const char* value, size_t size) {
  columns_to_ungroup_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline std::string* UngroupRequest::_internal_add_columns_to_ungroup() {
  return columns_to_ungroup_.Add();
}
inline void UngroupRequest::add_columns_to_ungroup(const std::string& value) {
  columns_to_ungroup_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::add_columns_to_ungroup(std::string&& value) {
  columns_to_ungroup_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::add_columns_to_ungroup(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_ungroup_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::add_columns_to_ungroup(const char* value, size_t size) {
  columns_to_ungroup_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UngroupRequest::columns_to_ungroup() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return columns_to_ungroup_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UngroupRequest::mutable_columns_to_ungroup() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return &columns_to_ungroup_;
}

// -------------------------------------------------------------------

// MergeTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool MergeTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool MergeTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& MergeTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& MergeTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
  return _internal_result_id();
}
inline void MergeTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MergeTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MergeTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MergeTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MergeTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
  return _msg;
}
inline void MergeTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
}

// repeated .io.deephaven.proto.backplane.grpc.TableReference source_ids = 2;
inline int MergeTablesRequest::_internal_source_ids_size() const {
  return source_ids_.size();
}
inline int MergeTablesRequest::source_ids_size() const {
  return _internal_source_ids_size();
}
inline void MergeTablesRequest::clear_source_ids() {
  source_ids_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MergeTablesRequest::mutable_source_ids(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return source_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference >*
MergeTablesRequest::mutable_source_ids() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return &source_ids_;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& MergeTablesRequest::_internal_source_ids(int index) const {
  return source_ids_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& MergeTablesRequest::source_ids(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return _internal_source_ids(index);
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MergeTablesRequest::_internal_add_source_ids() {
  return source_ids_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MergeTablesRequest::add_source_ids() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _add = _internal_add_source_ids();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference >&
MergeTablesRequest::source_ids() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return source_ids_;
}

// string key_column = 3;
inline void MergeTablesRequest::clear_key_column() {
  key_column_.ClearToEmpty();
}
inline const std::string& MergeTablesRequest::key_column() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
  return _internal_key_column();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MergeTablesRequest::set_key_column(ArgT0&& arg0, ArgT... args) {
 
 key_column_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
}
inline std::string* MergeTablesRequest::mutable_key_column() {
  std::string* _s = _internal_mutable_key_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
  return _s;
}
inline const std::string& MergeTablesRequest::_internal_key_column() const {
  return key_column_.Get();
}
inline void MergeTablesRequest::_internal_set_key_column(const std::string& value) {
  
  key_column_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MergeTablesRequest::_internal_mutable_key_column() {
  
  return key_column_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MergeTablesRequest::release_key_column() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
  return key_column_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MergeTablesRequest::set_allocated_key_column(std::string* key_column) {
  if (key_column != nullptr) {
    
  } else {
    
  }
  key_column_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), key_column,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
}

// -------------------------------------------------------------------

// SnapshotTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SnapshotTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool SnapshotTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SnapshotTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SnapshotTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
  return _internal_result_id();
}
inline void SnapshotTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
  return _msg;
}
inline void SnapshotTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool SnapshotTableRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool SnapshotTableRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void SnapshotTableRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotTableRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotTableRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.left_id)
  return _internal_left_id();
}
inline void SnapshotTableRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.left_id)
  return _msg;
}
inline void SnapshotTableRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool SnapshotTableRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool SnapshotTableRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void SnapshotTableRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotTableRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotTableRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.right_id)
  return _internal_right_id();
}
inline void SnapshotTableRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.right_id)
  return _msg;
}
inline void SnapshotTableRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.right_id)
}

// bool do_initial_snapshot = 4;
inline void SnapshotTableRequest::clear_do_initial_snapshot() {
  do_initial_snapshot_ = false;
}
inline bool SnapshotTableRequest::_internal_do_initial_snapshot() const {
  return do_initial_snapshot_;
}
inline bool SnapshotTableRequest::do_initial_snapshot() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.do_initial_snapshot)
  return _internal_do_initial_snapshot();
}
inline void SnapshotTableRequest::_internal_set_do_initial_snapshot(bool value) {
  
  do_initial_snapshot_ = value;
}
inline void SnapshotTableRequest::set_do_initial_snapshot(bool value) {
  _internal_set_do_initial_snapshot(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.do_initial_snapshot)
}

// repeated string stamp_columns = 5;
inline int SnapshotTableRequest::_internal_stamp_columns_size() const {
  return stamp_columns_.size();
}
inline int SnapshotTableRequest::stamp_columns_size() const {
  return _internal_stamp_columns_size();
}
inline void SnapshotTableRequest::clear_stamp_columns() {
  stamp_columns_.Clear();
}
inline std::string* SnapshotTableRequest::add_stamp_columns() {
  std::string* _s = _internal_add_stamp_columns();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
  return _s;
}
inline const std::string& SnapshotTableRequest::_internal_stamp_columns(int index) const {
  return stamp_columns_.Get(index);
}
inline const std::string& SnapshotTableRequest::stamp_columns(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
  return _internal_stamp_columns(index);
}
inline std::string* SnapshotTableRequest::mutable_stamp_columns(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
  return stamp_columns_.Mutable(index);
}
inline void SnapshotTableRequest::set_stamp_columns(int index, const std::string& value) {
  stamp_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
}
inline void SnapshotTableRequest::set_stamp_columns(int index, std::string&& value) {
  stamp_columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
}
inline void SnapshotTableRequest::set_stamp_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  stamp_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
}
inline void SnapshotTableRequest::set_stamp_columns(int index, const char* value, size_t size) {
  stamp_columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
}
inline std::string* SnapshotTableRequest::_internal_add_stamp_columns() {
  return stamp_columns_.Add();
}
inline void SnapshotTableRequest::add_stamp_columns(const std::string& value) {
  stamp_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
}
inline void SnapshotTableRequest::add_stamp_columns(std::string&& value) {
  stamp_columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
}
inline void SnapshotTableRequest::add_stamp_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  stamp_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
}
inline void SnapshotTableRequest::add_stamp_columns(const char* value, size_t size) {
  stamp_columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SnapshotTableRequest::stamp_columns() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
  return stamp_columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SnapshotTableRequest::mutable_stamp_columns() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.stamp_columns)
  return &stamp_columns_;
}

// -------------------------------------------------------------------

// CrossJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool CrossJoinTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool CrossJoinTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CrossJoinTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CrossJoinTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void CrossJoinTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CrossJoinTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CrossJoinTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CrossJoinTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CrossJoinTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
  return _msg;
}
inline void CrossJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool CrossJoinTablesRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool CrossJoinTablesRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void CrossJoinTablesRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CrossJoinTablesRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CrossJoinTablesRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void CrossJoinTablesRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
  return _msg;
}
inline void CrossJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool CrossJoinTablesRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool CrossJoinTablesRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void CrossJoinTablesRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CrossJoinTablesRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CrossJoinTablesRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void CrossJoinTablesRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
  return _msg;
}
inline void CrossJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int CrossJoinTablesRequest::_internal_columns_to_match_size() const {
  return columns_to_match_.size();
}
inline int CrossJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void CrossJoinTablesRequest::clear_columns_to_match() {
  columns_to_match_.Clear();
}
inline std::string* CrossJoinTablesRequest::add_columns_to_match() {
  std::string* _s = _internal_add_columns_to_match();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& CrossJoinTablesRequest::_internal_columns_to_match(int index) const {
  return columns_to_match_.Get(index);
}
inline const std::string& CrossJoinTablesRequest::columns_to_match(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match(index);
}
inline std::string* CrossJoinTablesRequest::mutable_columns_to_match(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return columns_to_match_.Mutable(index);
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  columns_to_match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, const char* value, size_t size) {
  columns_to_match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline std::string* CrossJoinTablesRequest::_internal_add_columns_to_match() {
  return columns_to_match_.Add();
}
inline void CrossJoinTablesRequest::add_columns_to_match(const std::string& value) {
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::add_columns_to_match(std::string&& value) {
  columns_to_match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::add_columns_to_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::add_columns_to_match(const char* value, size_t size) {
  columns_to_match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CrossJoinTablesRequest::columns_to_match() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return columns_to_match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CrossJoinTablesRequest::mutable_columns_to_match() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return &columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int CrossJoinTablesRequest::_internal_columns_to_add_size() const {
  return columns_to_add_.size();
}
inline int CrossJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void CrossJoinTablesRequest::clear_columns_to_add() {
  columns_to_add_.Clear();
}
inline std::string* CrossJoinTablesRequest::add_columns_to_add() {
  std::string* _s = _internal_add_columns_to_add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& CrossJoinTablesRequest::_internal_columns_to_add(int index) const {
  return columns_to_add_.Get(index);
}
inline const std::string& CrossJoinTablesRequest::columns_to_add(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add(index);
}
inline std::string* CrossJoinTablesRequest::mutable_columns_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return columns_to_add_.Mutable(index);
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  columns_to_add_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, const char* value, size_t size) {
  columns_to_add_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline std::string* CrossJoinTablesRequest::_internal_add_columns_to_add() {
  return columns_to_add_.Add();
}
inline void CrossJoinTablesRequest::add_columns_to_add(const std::string& value) {
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::add_columns_to_add(std::string&& value) {
  columns_to_add_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::add_columns_to_add(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::add_columns_to_add(const char* value, size_t size) {
  columns_to_add_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CrossJoinTablesRequest::columns_to_add() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return columns_to_add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CrossJoinTablesRequest::mutable_columns_to_add() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return &columns_to_add_;
}

// int32 reserve_bits = 6;
inline void CrossJoinTablesRequest::clear_reserve_bits() {
  reserve_bits_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CrossJoinTablesRequest::_internal_reserve_bits() const {
  return reserve_bits_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 CrossJoinTablesRequest::reserve_bits() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.reserve_bits)
  return _internal_reserve_bits();
}
inline void CrossJoinTablesRequest::_internal_set_reserve_bits(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  reserve_bits_ = value;
}
inline void CrossJoinTablesRequest::set_reserve_bits(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_reserve_bits(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.reserve_bits)
}

// -------------------------------------------------------------------

// NaturalJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool NaturalJoinTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool NaturalJoinTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& NaturalJoinTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& NaturalJoinTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void NaturalJoinTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* NaturalJoinTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* NaturalJoinTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* NaturalJoinTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* NaturalJoinTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
  return _msg;
}
inline void NaturalJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool NaturalJoinTablesRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool NaturalJoinTablesRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void NaturalJoinTablesRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& NaturalJoinTablesRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& NaturalJoinTablesRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void NaturalJoinTablesRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
  return _msg;
}
inline void NaturalJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool NaturalJoinTablesRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool NaturalJoinTablesRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void NaturalJoinTablesRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& NaturalJoinTablesRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& NaturalJoinTablesRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void NaturalJoinTablesRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
  return _msg;
}
inline void NaturalJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int NaturalJoinTablesRequest::_internal_columns_to_match_size() const {
  return columns_to_match_.size();
}
inline int NaturalJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void NaturalJoinTablesRequest::clear_columns_to_match() {
  columns_to_match_.Clear();
}
inline std::string* NaturalJoinTablesRequest::add_columns_to_match() {
  std::string* _s = _internal_add_columns_to_match();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& NaturalJoinTablesRequest::_internal_columns_to_match(int index) const {
  return columns_to_match_.Get(index);
}
inline const std::string& NaturalJoinTablesRequest::columns_to_match(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match(index);
}
inline std::string* NaturalJoinTablesRequest::mutable_columns_to_match(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return columns_to_match_.Mutable(index);
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  columns_to_match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, const char* value, size_t size) {
  columns_to_match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline std::string* NaturalJoinTablesRequest::_internal_add_columns_to_match() {
  return columns_to_match_.Add();
}
inline void NaturalJoinTablesRequest::add_columns_to_match(const std::string& value) {
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::add_columns_to_match(std::string&& value) {
  columns_to_match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::add_columns_to_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::add_columns_to_match(const char* value, size_t size) {
  columns_to_match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NaturalJoinTablesRequest::columns_to_match() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return columns_to_match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NaturalJoinTablesRequest::mutable_columns_to_match() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return &columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int NaturalJoinTablesRequest::_internal_columns_to_add_size() const {
  return columns_to_add_.size();
}
inline int NaturalJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void NaturalJoinTablesRequest::clear_columns_to_add() {
  columns_to_add_.Clear();
}
inline std::string* NaturalJoinTablesRequest::add_columns_to_add() {
  std::string* _s = _internal_add_columns_to_add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& NaturalJoinTablesRequest::_internal_columns_to_add(int index) const {
  return columns_to_add_.Get(index);
}
inline const std::string& NaturalJoinTablesRequest::columns_to_add(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add(index);
}
inline std::string* NaturalJoinTablesRequest::mutable_columns_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return columns_to_add_.Mutable(index);
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  columns_to_add_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, const char* value, size_t size) {
  columns_to_add_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline std::string* NaturalJoinTablesRequest::_internal_add_columns_to_add() {
  return columns_to_add_.Add();
}
inline void NaturalJoinTablesRequest::add_columns_to_add(const std::string& value) {
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::add_columns_to_add(std::string&& value) {
  columns_to_add_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::add_columns_to_add(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::add_columns_to_add(const char* value, size_t size) {
  columns_to_add_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NaturalJoinTablesRequest::columns_to_add() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return columns_to_add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NaturalJoinTablesRequest::mutable_columns_to_add() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return &columns_to_add_;
}

// -------------------------------------------------------------------

// ExactJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool ExactJoinTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool ExactJoinTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExactJoinTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExactJoinTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void ExactJoinTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExactJoinTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExactJoinTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExactJoinTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExactJoinTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
  return _msg;
}
inline void ExactJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool ExactJoinTablesRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool ExactJoinTablesRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void ExactJoinTablesRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExactJoinTablesRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExactJoinTablesRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void ExactJoinTablesRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
  return _msg;
}
inline void ExactJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool ExactJoinTablesRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool ExactJoinTablesRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void ExactJoinTablesRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExactJoinTablesRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExactJoinTablesRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void ExactJoinTablesRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
  return _msg;
}
inline void ExactJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int ExactJoinTablesRequest::_internal_columns_to_match_size() const {
  return columns_to_match_.size();
}
inline int ExactJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void ExactJoinTablesRequest::clear_columns_to_match() {
  columns_to_match_.Clear();
}
inline std::string* ExactJoinTablesRequest::add_columns_to_match() {
  std::string* _s = _internal_add_columns_to_match();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& ExactJoinTablesRequest::_internal_columns_to_match(int index) const {
  return columns_to_match_.Get(index);
}
inline const std::string& ExactJoinTablesRequest::columns_to_match(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match(index);
}
inline std::string* ExactJoinTablesRequest::mutable_columns_to_match(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return columns_to_match_.Mutable(index);
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  columns_to_match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, const char* value, size_t size) {
  columns_to_match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline std::string* ExactJoinTablesRequest::_internal_add_columns_to_match() {
  return columns_to_match_.Add();
}
inline void ExactJoinTablesRequest::add_columns_to_match(const std::string& value) {
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::add_columns_to_match(std::string&& value) {
  columns_to_match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::add_columns_to_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::add_columns_to_match(const char* value, size_t size) {
  columns_to_match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExactJoinTablesRequest::columns_to_match() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return columns_to_match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExactJoinTablesRequest::mutable_columns_to_match() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return &columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int ExactJoinTablesRequest::_internal_columns_to_add_size() const {
  return columns_to_add_.size();
}
inline int ExactJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void ExactJoinTablesRequest::clear_columns_to_add() {
  columns_to_add_.Clear();
}
inline std::string* ExactJoinTablesRequest::add_columns_to_add() {
  std::string* _s = _internal_add_columns_to_add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& ExactJoinTablesRequest::_internal_columns_to_add(int index) const {
  return columns_to_add_.Get(index);
}
inline const std::string& ExactJoinTablesRequest::columns_to_add(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add(index);
}
inline std::string* ExactJoinTablesRequest::mutable_columns_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return columns_to_add_.Mutable(index);
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  columns_to_add_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, const char* value, size_t size) {
  columns_to_add_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline std::string* ExactJoinTablesRequest::_internal_add_columns_to_add() {
  return columns_to_add_.Add();
}
inline void ExactJoinTablesRequest::add_columns_to_add(const std::string& value) {
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::add_columns_to_add(std::string&& value) {
  columns_to_add_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::add_columns_to_add(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::add_columns_to_add(const char* value, size_t size) {
  columns_to_add_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExactJoinTablesRequest::columns_to_add() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return columns_to_add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExactJoinTablesRequest::mutable_columns_to_add() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return &columns_to_add_;
}

// -------------------------------------------------------------------

// LeftJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool LeftJoinTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool LeftJoinTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& LeftJoinTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& LeftJoinTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void LeftJoinTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* LeftJoinTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* LeftJoinTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* LeftJoinTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* LeftJoinTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
  return _msg;
}
inline void LeftJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool LeftJoinTablesRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool LeftJoinTablesRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void LeftJoinTablesRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& LeftJoinTablesRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& LeftJoinTablesRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void LeftJoinTablesRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
  return _msg;
}
inline void LeftJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool LeftJoinTablesRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool LeftJoinTablesRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void LeftJoinTablesRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& LeftJoinTablesRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& LeftJoinTablesRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void LeftJoinTablesRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
  return _msg;
}
inline void LeftJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int LeftJoinTablesRequest::_internal_columns_to_match_size() const {
  return columns_to_match_.size();
}
inline int LeftJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void LeftJoinTablesRequest::clear_columns_to_match() {
  columns_to_match_.Clear();
}
inline std::string* LeftJoinTablesRequest::add_columns_to_match() {
  std::string* _s = _internal_add_columns_to_match();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& LeftJoinTablesRequest::_internal_columns_to_match(int index) const {
  return columns_to_match_.Get(index);
}
inline const std::string& LeftJoinTablesRequest::columns_to_match(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match(index);
}
inline std::string* LeftJoinTablesRequest::mutable_columns_to_match(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return columns_to_match_.Mutable(index);
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  columns_to_match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, const char* value, size_t size) {
  columns_to_match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline std::string* LeftJoinTablesRequest::_internal_add_columns_to_match() {
  return columns_to_match_.Add();
}
inline void LeftJoinTablesRequest::add_columns_to_match(const std::string& value) {
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::add_columns_to_match(std::string&& value) {
  columns_to_match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::add_columns_to_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::add_columns_to_match(const char* value, size_t size) {
  columns_to_match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LeftJoinTablesRequest::columns_to_match() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return columns_to_match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LeftJoinTablesRequest::mutable_columns_to_match() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return &columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int LeftJoinTablesRequest::_internal_columns_to_add_size() const {
  return columns_to_add_.size();
}
inline int LeftJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void LeftJoinTablesRequest::clear_columns_to_add() {
  columns_to_add_.Clear();
}
inline std::string* LeftJoinTablesRequest::add_columns_to_add() {
  std::string* _s = _internal_add_columns_to_add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& LeftJoinTablesRequest::_internal_columns_to_add(int index) const {
  return columns_to_add_.Get(index);
}
inline const std::string& LeftJoinTablesRequest::columns_to_add(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add(index);
}
inline std::string* LeftJoinTablesRequest::mutable_columns_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return columns_to_add_.Mutable(index);
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  columns_to_add_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, const char* value, size_t size) {
  columns_to_add_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline std::string* LeftJoinTablesRequest::_internal_add_columns_to_add() {
  return columns_to_add_.Add();
}
inline void LeftJoinTablesRequest::add_columns_to_add(const std::string& value) {
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::add_columns_to_add(std::string&& value) {
  columns_to_add_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::add_columns_to_add(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::add_columns_to_add(const char* value, size_t size) {
  columns_to_add_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LeftJoinTablesRequest::columns_to_add() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return columns_to_add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LeftJoinTablesRequest::mutable_columns_to_add() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return &columns_to_add_;
}

// -------------------------------------------------------------------

// AsOfJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool AsOfJoinTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool AsOfJoinTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AsOfJoinTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AsOfJoinTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void AsOfJoinTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AsOfJoinTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AsOfJoinTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AsOfJoinTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AsOfJoinTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
  return _msg;
}
inline void AsOfJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool AsOfJoinTablesRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool AsOfJoinTablesRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void AsOfJoinTablesRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AsOfJoinTablesRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AsOfJoinTablesRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void AsOfJoinTablesRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
  return _msg;
}
inline void AsOfJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool AsOfJoinTablesRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool AsOfJoinTablesRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void AsOfJoinTablesRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AsOfJoinTablesRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AsOfJoinTablesRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void AsOfJoinTablesRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
  return _msg;
}
inline void AsOfJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int AsOfJoinTablesRequest::_internal_columns_to_match_size() const {
  return columns_to_match_.size();
}
inline int AsOfJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void AsOfJoinTablesRequest::clear_columns_to_match() {
  columns_to_match_.Clear();
}
inline std::string* AsOfJoinTablesRequest::add_columns_to_match() {
  std::string* _s = _internal_add_columns_to_match();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& AsOfJoinTablesRequest::_internal_columns_to_match(int index) const {
  return columns_to_match_.Get(index);
}
inline const std::string& AsOfJoinTablesRequest::columns_to_match(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match(index);
}
inline std::string* AsOfJoinTablesRequest::mutable_columns_to_match(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return columns_to_match_.Mutable(index);
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  columns_to_match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, const char* value, size_t size) {
  columns_to_match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline std::string* AsOfJoinTablesRequest::_internal_add_columns_to_match() {
  return columns_to_match_.Add();
}
inline void AsOfJoinTablesRequest::add_columns_to_match(const std::string& value) {
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::add_columns_to_match(std::string&& value) {
  columns_to_match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::add_columns_to_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::add_columns_to_match(const char* value, size_t size) {
  columns_to_match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AsOfJoinTablesRequest::columns_to_match() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return columns_to_match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AsOfJoinTablesRequest::mutable_columns_to_match() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return &columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int AsOfJoinTablesRequest::_internal_columns_to_add_size() const {
  return columns_to_add_.size();
}
inline int AsOfJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void AsOfJoinTablesRequest::clear_columns_to_add() {
  columns_to_add_.Clear();
}
inline std::string* AsOfJoinTablesRequest::add_columns_to_add() {
  std::string* _s = _internal_add_columns_to_add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& AsOfJoinTablesRequest::_internal_columns_to_add(int index) const {
  return columns_to_add_.Get(index);
}
inline const std::string& AsOfJoinTablesRequest::columns_to_add(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add(index);
}
inline std::string* AsOfJoinTablesRequest::mutable_columns_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return columns_to_add_.Mutable(index);
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  columns_to_add_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, const char* value, size_t size) {
  columns_to_add_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline std::string* AsOfJoinTablesRequest::_internal_add_columns_to_add() {
  return columns_to_add_.Add();
}
inline void AsOfJoinTablesRequest::add_columns_to_add(const std::string& value) {
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::add_columns_to_add(std::string&& value) {
  columns_to_add_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::add_columns_to_add(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::add_columns_to_add(const char* value, size_t size) {
  columns_to_add_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AsOfJoinTablesRequest::columns_to_add() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return columns_to_add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AsOfJoinTablesRequest::mutable_columns_to_add() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return &columns_to_add_;
}

// .io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.MatchRule as_of_match_rule = 7;
inline void AsOfJoinTablesRequest::clear_as_of_match_rule() {
  as_of_match_rule_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule AsOfJoinTablesRequest::_internal_as_of_match_rule() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule >(as_of_match_rule_);
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule AsOfJoinTablesRequest::as_of_match_rule() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.as_of_match_rule)
  return _internal_as_of_match_rule();
}
inline void AsOfJoinTablesRequest::_internal_set_as_of_match_rule(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule value) {
  
  as_of_match_rule_ = value;
}
inline void AsOfJoinTablesRequest::set_as_of_match_rule(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule value) {
  _internal_set_as_of_match_rule(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.as_of_match_rule)
}

// -------------------------------------------------------------------

// ComboAggregateRequest_Aggregate

// .io.deephaven.proto.backplane.grpc.ComboAggregateRequest.AggType type = 1;
inline void ComboAggregateRequest_Aggregate::clear_type() {
  type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType ComboAggregateRequest_Aggregate::_internal_type() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType >(type_);
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType ComboAggregateRequest_Aggregate::type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.type)
  return _internal_type();
}
inline void ComboAggregateRequest_Aggregate::_internal_set_type(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType value) {
  
  type_ = value;
}
inline void ComboAggregateRequest_Aggregate::set_type(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.type)
}

// repeated string match_pairs = 2;
inline int ComboAggregateRequest_Aggregate::_internal_match_pairs_size() const {
  return match_pairs_.size();
}
inline int ComboAggregateRequest_Aggregate::match_pairs_size() const {
  return _internal_match_pairs_size();
}
inline void ComboAggregateRequest_Aggregate::clear_match_pairs() {
  match_pairs_.Clear();
}
inline std::string* ComboAggregateRequest_Aggregate::add_match_pairs() {
  std::string* _s = _internal_add_match_pairs();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return _s;
}
inline const std::string& ComboAggregateRequest_Aggregate::_internal_match_pairs(int index) const {
  return match_pairs_.Get(index);
}
inline const std::string& ComboAggregateRequest_Aggregate::match_pairs(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return _internal_match_pairs(index);
}
inline std::string* ComboAggregateRequest_Aggregate::mutable_match_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return match_pairs_.Mutable(index);
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, const std::string& value) {
  match_pairs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, std::string&& value) {
  match_pairs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  match_pairs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, const char* value, size_t size) {
  match_pairs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline std::string* ComboAggregateRequest_Aggregate::_internal_add_match_pairs() {
  return match_pairs_.Add();
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(const std::string& value) {
  match_pairs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(std::string&& value) {
  match_pairs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  match_pairs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(const char* value, size_t size) {
  match_pairs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ComboAggregateRequest_Aggregate::match_pairs() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return match_pairs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ComboAggregateRequest_Aggregate::mutable_match_pairs() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return &match_pairs_;
}

// string column_name = 3;
inline void ComboAggregateRequest_Aggregate::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& ComboAggregateRequest_Aggregate::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComboAggregateRequest_Aggregate::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
}
inline std::string* ComboAggregateRequest_Aggregate::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
  return _s;
}
inline const std::string& ComboAggregateRequest_Aggregate::_internal_column_name() const {
  return column_name_.Get();
}
inline void ComboAggregateRequest_Aggregate::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ComboAggregateRequest_Aggregate::_internal_mutable_column_name() {
  
  return column_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ComboAggregateRequest_Aggregate::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
  return column_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ComboAggregateRequest_Aggregate::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
}

// double percentile = 4;
inline void ComboAggregateRequest_Aggregate::clear_percentile() {
  percentile_ = 0;
}
inline double ComboAggregateRequest_Aggregate::_internal_percentile() const {
  return percentile_;
}
inline double ComboAggregateRequest_Aggregate::percentile() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.percentile)
  return _internal_percentile();
}
inline void ComboAggregateRequest_Aggregate::_internal_set_percentile(double value) {
  
  percentile_ = value;
}
inline void ComboAggregateRequest_Aggregate::set_percentile(double value) {
  _internal_set_percentile(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.percentile)
}

// bool avg_median = 5;
inline void ComboAggregateRequest_Aggregate::clear_avg_median() {
  avg_median_ = false;
}
inline bool ComboAggregateRequest_Aggregate::_internal_avg_median() const {
  return avg_median_;
}
inline bool ComboAggregateRequest_Aggregate::avg_median() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.avg_median)
  return _internal_avg_median();
}
inline void ComboAggregateRequest_Aggregate::_internal_set_avg_median(bool value) {
  
  avg_median_ = value;
}
inline void ComboAggregateRequest_Aggregate::set_avg_median(bool value) {
  _internal_set_avg_median(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.avg_median)
}

// -------------------------------------------------------------------

// ComboAggregateRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool ComboAggregateRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool ComboAggregateRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ComboAggregateRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ComboAggregateRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
  return _internal_result_id();
}
inline void ComboAggregateRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ComboAggregateRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ComboAggregateRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ComboAggregateRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ComboAggregateRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
  return _msg;
}
inline void ComboAggregateRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool ComboAggregateRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool ComboAggregateRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void ComboAggregateRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ComboAggregateRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ComboAggregateRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
  return _internal_source_id();
}
inline void ComboAggregateRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ComboAggregateRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ComboAggregateRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ComboAggregateRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ComboAggregateRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
  return _msg;
}
inline void ComboAggregateRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
}

// repeated .io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate aggregates = 3;
inline int ComboAggregateRequest::_internal_aggregates_size() const {
  return aggregates_.size();
}
inline int ComboAggregateRequest::aggregates_size() const {
  return _internal_aggregates_size();
}
inline void ComboAggregateRequest::clear_aggregates() {
  aggregates_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* ComboAggregateRequest::mutable_aggregates(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return aggregates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate >*
ComboAggregateRequest::mutable_aggregates() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return &aggregates_;
}
inline const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate& ComboAggregateRequest::_internal_aggregates(int index) const {
  return aggregates_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate& ComboAggregateRequest::aggregates(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return _internal_aggregates(index);
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* ComboAggregateRequest::_internal_add_aggregates() {
  return aggregates_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* ComboAggregateRequest::add_aggregates() {
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* _add = _internal_add_aggregates();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate >&
ComboAggregateRequest::aggregates() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return aggregates_;
}

// repeated string group_by_columns = 4;
inline int ComboAggregateRequest::_internal_group_by_columns_size() const {
  return group_by_columns_.size();
}
inline int ComboAggregateRequest::group_by_columns_size() const {
  return _internal_group_by_columns_size();
}
inline void ComboAggregateRequest::clear_group_by_columns() {
  group_by_columns_.Clear();
}
inline std::string* ComboAggregateRequest::add_group_by_columns() {
  std::string* _s = _internal_add_group_by_columns();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return _s;
}
inline const std::string& ComboAggregateRequest::_internal_group_by_columns(int index) const {
  return group_by_columns_.Get(index);
}
inline const std::string& ComboAggregateRequest::group_by_columns(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return _internal_group_by_columns(index);
}
inline std::string* ComboAggregateRequest::mutable_group_by_columns(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return group_by_columns_.Mutable(index);
}
inline void ComboAggregateRequest::set_group_by_columns(int index, const std::string& value) {
  group_by_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::set_group_by_columns(int index, std::string&& value) {
  group_by_columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::set_group_by_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::set_group_by_columns(int index, const char* value, size_t size) {
  group_by_columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline std::string* ComboAggregateRequest::_internal_add_group_by_columns() {
  return group_by_columns_.Add();
}
inline void ComboAggregateRequest::add_group_by_columns(const std::string& value) {
  group_by_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::add_group_by_columns(std::string&& value) {
  group_by_columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::add_group_by_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::add_group_by_columns(const char* value, size_t size) {
  group_by_columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ComboAggregateRequest::group_by_columns() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return group_by_columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ComboAggregateRequest::mutable_group_by_columns() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return &group_by_columns_;
}

// bool force_combo = 5;
inline void ComboAggregateRequest::clear_force_combo() {
  force_combo_ = false;
}
inline bool ComboAggregateRequest::_internal_force_combo() const {
  return force_combo_;
}
inline bool ComboAggregateRequest::force_combo() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.force_combo)
  return _internal_force_combo();
}
inline void ComboAggregateRequest::_internal_set_force_combo(bool value) {
  
  force_combo_ = value;
}
inline void ComboAggregateRequest::set_force_combo(bool value) {
  _internal_set_force_combo(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.force_combo)
}

// -------------------------------------------------------------------

// SortDescriptor

// string column_name = 1;
inline void SortDescriptor::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& SortDescriptor::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SortDescriptor::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
}
inline std::string* SortDescriptor::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
  return _s;
}
inline const std::string& SortDescriptor::_internal_column_name() const {
  return column_name_.Get();
}
inline void SortDescriptor::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SortDescriptor::_internal_mutable_column_name() {
  
  return column_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SortDescriptor::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
  return column_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SortDescriptor::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
}

// bool is_absolute = 2;
inline void SortDescriptor::clear_is_absolute() {
  is_absolute_ = false;
}
inline bool SortDescriptor::_internal_is_absolute() const {
  return is_absolute_;
}
inline bool SortDescriptor::is_absolute() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortDescriptor.is_absolute)
  return _internal_is_absolute();
}
inline void SortDescriptor::_internal_set_is_absolute(bool value) {
  
  is_absolute_ = value;
}
inline void SortDescriptor::set_is_absolute(bool value) {
  _internal_set_is_absolute(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SortDescriptor.is_absolute)
}

// .io.deephaven.proto.backplane.grpc.SortDescriptor.SortDirection direction = 3;
inline void SortDescriptor::clear_direction() {
  direction_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection SortDescriptor::_internal_direction() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection >(direction_);
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection SortDescriptor::direction() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortDescriptor.direction)
  return _internal_direction();
}
inline void SortDescriptor::_internal_set_direction(::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection value) {
  
  direction_ = value;
}
inline void SortDescriptor::set_direction(::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SortDescriptor.direction)
}

// -------------------------------------------------------------------

// SortTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SortTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool SortTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SortTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SortTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
  return _internal_result_id();
}
inline void SortTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SortTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SortTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SortTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SortTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
  return _msg;
}
inline void SortTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool SortTableRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool SortTableRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void SortTableRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SortTableRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SortTableRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
  return _internal_source_id();
}
inline void SortTableRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SortTableRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SortTableRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SortTableRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SortTableRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
  return _msg;
}
inline void SortTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
}

// repeated .io.deephaven.proto.backplane.grpc.SortDescriptor sorts = 3;
inline int SortTableRequest::_internal_sorts_size() const {
  return sorts_.size();
}
inline int SortTableRequest::sorts_size() const {
  return _internal_sorts_size();
}
inline void SortTableRequest::clear_sorts() {
  sorts_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor* SortTableRequest::mutable_sorts(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return sorts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor >*
SortTableRequest::mutable_sorts() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return &sorts_;
}
inline const ::io::deephaven::proto::backplane::grpc::SortDescriptor& SortTableRequest::_internal_sorts(int index) const {
  return sorts_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::SortDescriptor& SortTableRequest::sorts(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return _internal_sorts(index);
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor* SortTableRequest::_internal_add_sorts() {
  return sorts_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor* SortTableRequest::add_sorts() {
  ::io::deephaven::proto::backplane::grpc::SortDescriptor* _add = _internal_add_sorts();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor >&
SortTableRequest::sorts() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return sorts_;
}

// -------------------------------------------------------------------

// FilterTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool FilterTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool FilterTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FilterTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FilterTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
  return _internal_result_id();
}
inline void FilterTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FilterTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FilterTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FilterTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FilterTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
  return _msg;
}
inline void FilterTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool FilterTableRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool FilterTableRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void FilterTableRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FilterTableRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FilterTableRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
  return _internal_source_id();
}
inline void FilterTableRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FilterTableRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FilterTableRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FilterTableRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FilterTableRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
  return _msg;
}
inline void FilterTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
}

// repeated .io.deephaven.proto.backplane.grpc.Condition filters = 3;
inline int FilterTableRequest::_internal_filters_size() const {
  return filters_.size();
}
inline int FilterTableRequest::filters_size() const {
  return _internal_filters_size();
}
inline void FilterTableRequest::clear_filters() {
  filters_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* FilterTableRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
FilterTableRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return &filters_;
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& FilterTableRequest::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& FilterTableRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return _internal_filters(index);
}
inline ::io::deephaven::proto::backplane::grpc::Condition* FilterTableRequest::_internal_add_filters() {
  return filters_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* FilterTableRequest::add_filters() {
  ::io::deephaven::proto::backplane::grpc::Condition* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
FilterTableRequest::filters() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return filters_;
}

// -------------------------------------------------------------------

// Reference

// string column_name = 1;
inline void Reference::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& Reference::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Reference.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Reference::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Reference.column_name)
}
inline std::string* Reference::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Reference.column_name)
  return _s;
}
inline const std::string& Reference::_internal_column_name() const {
  return column_name_.Get();
}
inline void Reference::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Reference::_internal_mutable_column_name() {
  
  return column_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Reference::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Reference.column_name)
  return column_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Reference::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Reference.column_name)
}

// -------------------------------------------------------------------

// Literal

// string string_value = 1;
inline bool Literal::_internal_has_string_value() const {
  return value_case() == kStringValue;
}
inline bool Literal::has_string_value() const {
  return _internal_has_string_value();
}
inline void Literal::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void Literal::clear_string_value() {
  if (_internal_has_string_value()) {
    value_.string_value_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_value();
  }
}
inline const std::string& Literal::string_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.string_value)
  return _internal_string_value();
}
template <typename ArgT0, typename... ArgT>
inline void Literal::set_string_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.string_value)
}
inline std::string* Literal::mutable_string_value() {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Literal.string_value)
  return _s;
}
inline const std::string& Literal::_internal_string_value() const {
  if (_internal_has_string_value()) {
    return value_.string_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Literal::_internal_set_string_value(const std::string& value) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  value_.string_value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Literal::_internal_mutable_string_value() {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return value_.string_value_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Literal::release_string_value() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Literal.string_value)
  if (_internal_has_string_value()) {
    clear_has_value();
    return value_.string_value_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void Literal::set_allocated_string_value(std::string* string_value) {
  if (has_value()) {
    clear_value();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    value_.string_value_.UnsafeSetDefault(string_value);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(string_value);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Literal.string_value)
}

// double double_value = 2;
inline bool Literal::_internal_has_double_value() const {
  return value_case() == kDoubleValue;
}
inline bool Literal::has_double_value() const {
  return _internal_has_double_value();
}
inline void Literal::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void Literal::clear_double_value() {
  if (_internal_has_double_value()) {
    value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double Literal::_internal_double_value() const {
  if (_internal_has_double_value()) {
    return value_.double_value_;
  }
  return 0;
}
inline void Literal::_internal_set_double_value(double value) {
  if (!_internal_has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  value_.double_value_ = value;
}
inline double Literal::double_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.double_value)
  return _internal_double_value();
}
inline void Literal::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.double_value)
}

// bool bool_value = 3;
inline bool Literal::_internal_has_bool_value() const {
  return value_case() == kBoolValue;
}
inline bool Literal::has_bool_value() const {
  return _internal_has_bool_value();
}
inline void Literal::set_has_bool_value() {
  _oneof_case_[0] = kBoolValue;
}
inline void Literal::clear_bool_value() {
  if (_internal_has_bool_value()) {
    value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool Literal::_internal_bool_value() const {
  if (_internal_has_bool_value()) {
    return value_.bool_value_;
  }
  return false;
}
inline void Literal::_internal_set_bool_value(bool value) {
  if (!_internal_has_bool_value()) {
    clear_value();
    set_has_bool_value();
  }
  value_.bool_value_ = value;
}
inline bool Literal::bool_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.bool_value)
  return _internal_bool_value();
}
inline void Literal::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.bool_value)
}

// sint64 long_value = 4 [jstype = JS_STRING];
inline bool Literal::_internal_has_long_value() const {
  return value_case() == kLongValue;
}
inline bool Literal::has_long_value() const {
  return _internal_has_long_value();
}
inline void Literal::set_has_long_value() {
  _oneof_case_[0] = kLongValue;
}
inline void Literal::clear_long_value() {
  if (_internal_has_long_value()) {
    value_.long_value_ = int64_t{0};
    clear_has_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Literal::_internal_long_value() const {
  if (_internal_has_long_value()) {
    return value_.long_value_;
  }
  return int64_t{0};
}
inline void Literal::_internal_set_long_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!_internal_has_long_value()) {
    clear_value();
    set_has_long_value();
  }
  value_.long_value_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Literal::long_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.long_value)
  return _internal_long_value();
}
inline void Literal::set_long_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_long_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.long_value)
}

// sint64 nano_time_value = 5 [jstype = JS_STRING];
inline bool Literal::_internal_has_nano_time_value() const {
  return value_case() == kNanoTimeValue;
}
inline bool Literal::has_nano_time_value() const {
  return _internal_has_nano_time_value();
}
inline void Literal::set_has_nano_time_value() {
  _oneof_case_[0] = kNanoTimeValue;
}
inline void Literal::clear_nano_time_value() {
  if (_internal_has_nano_time_value()) {
    value_.nano_time_value_ = int64_t{0};
    clear_has_value();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Literal::_internal_nano_time_value() const {
  if (_internal_has_nano_time_value()) {
    return value_.nano_time_value_;
  }
  return int64_t{0};
}
inline void Literal::_internal_set_nano_time_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  if (!_internal_has_nano_time_value()) {
    clear_value();
    set_has_nano_time_value();
  }
  value_.nano_time_value_ = value;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Literal::nano_time_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.nano_time_value)
  return _internal_nano_time_value();
}
inline void Literal::set_nano_time_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_nano_time_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.nano_time_value)
}

inline bool Literal::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Literal::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Literal::ValueCase Literal::value_case() const {
  return Literal::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Value

// .io.deephaven.proto.backplane.grpc.Reference reference = 1;
inline bool Value::_internal_has_reference() const {
  return data_case() == kReference;
}
inline bool Value::has_reference() const {
  return _internal_has_reference();
}
inline void Value::set_has_reference() {
  _oneof_case_[0] = kReference;
}
inline void Value::clear_reference() {
  if (_internal_has_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.reference_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Reference* Value::release_reference() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Value.reference)
  if (_internal_has_reference()) {
    clear_has_data();
      ::io::deephaven::proto::backplane::grpc::Reference* temp = data_.reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& Value::_internal_reference() const {
  return _internal_has_reference()
      ? *data_.reference_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::Reference&>(::io::deephaven::proto::backplane::grpc::_Reference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& Value::reference() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Value.reference)
  return _internal_reference();
}
inline ::io::deephaven::proto::backplane::grpc::Reference* Value::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Value.reference)
  if (_internal_has_reference()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::Reference* temp = data_.reference_;
    data_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference) {
  clear_data();
  if (reference) {
    set_has_reference();
    data_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Value.reference)
}
inline ::io::deephaven::proto::backplane::grpc::Reference* Value::_internal_mutable_reference() {
  if (!_internal_has_reference()) {
    clear_data();
    set_has_reference();
    data_.reference_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::Reference >(GetArenaForAllocation());
  }
  return data_.reference_;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* Value::mutable_reference() {
  ::io::deephaven::proto::backplane::grpc::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Value.reference)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.Literal literal = 2;
inline bool Value::_internal_has_literal() const {
  return data_case() == kLiteral;
}
inline bool Value::has_literal() const {
  return _internal_has_literal();
}
inline void Value::set_has_literal() {
  _oneof_case_[0] = kLiteral;
}
inline void Value::clear_literal() {
  if (_internal_has_literal()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.literal_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Literal* Value::release_literal() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Value.literal)
  if (_internal_has_literal()) {
    clear_has_data();
      ::io::deephaven::proto::backplane::grpc::Literal* temp = data_.literal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.literal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Literal& Value::_internal_literal() const {
  return _internal_has_literal()
      ? *data_.literal_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::Literal&>(::io::deephaven::proto::backplane::grpc::_Literal_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Literal& Value::literal() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Value.literal)
  return _internal_literal();
}
inline ::io::deephaven::proto::backplane::grpc::Literal* Value::unsafe_arena_release_literal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Value.literal)
  if (_internal_has_literal()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::Literal* temp = data_.literal_;
    data_.literal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_literal(::io::deephaven::proto::backplane::grpc::Literal* literal) {
  clear_data();
  if (literal) {
    set_has_literal();
    data_.literal_ = literal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Value.literal)
}
inline ::io::deephaven::proto::backplane::grpc::Literal* Value::_internal_mutable_literal() {
  if (!_internal_has_literal()) {
    clear_data();
    set_has_literal();
    data_.literal_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::Literal >(GetArenaForAllocation());
  }
  return data_.literal_;
}
inline ::io::deephaven::proto::backplane::grpc::Literal* Value::mutable_literal() {
  ::io::deephaven::proto::backplane::grpc::Literal* _msg = _internal_mutable_literal();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Value.literal)
  return _msg;
}

inline bool Value::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Value::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline Value::DataCase Value::data_case() const {
  return Value::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Condition

// .io.deephaven.proto.backplane.grpc.AndCondition and = 1;
inline bool Condition::_internal_has_and_() const {
  return data_case() == kAnd;
}
inline bool Condition::has_and_() const {
  return _internal_has_and_();
}
inline void Condition::set_has_and_() {
  _oneof_case_[0] = kAnd;
}
inline void Condition::clear_and_() {
  if (_internal_has_and_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.and__;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AndCondition* Condition::release_and_() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.and)
  if (_internal_has_and_()) {
    clear_has_data();
      ::io::deephaven::proto::backplane::grpc::AndCondition* temp = data_.and__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.and__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AndCondition& Condition::_internal_and_() const {
  return _internal_has_and_()
      ? *data_.and__
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AndCondition&>(::io::deephaven::proto::backplane::grpc::_AndCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AndCondition& Condition::and_() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.and)
  return _internal_and_();
}
inline ::io::deephaven::proto::backplane::grpc::AndCondition* Condition::unsafe_arena_release_and_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.and)
  if (_internal_has_and_()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::AndCondition* temp = data_.and__;
    data_.and__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_and_(::io::deephaven::proto::backplane::grpc::AndCondition* and_) {
  clear_data();
  if (and_) {
    set_has_and_();
    data_.and__ = and_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.and)
}
inline ::io::deephaven::proto::backplane::grpc::AndCondition* Condition::_internal_mutable_and_() {
  if (!_internal_has_and_()) {
    clear_data();
    set_has_and_();
    data_.and__ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AndCondition >(GetArenaForAllocation());
  }
  return data_.and__;
}
inline ::io::deephaven::proto::backplane::grpc::AndCondition* Condition::mutable_and_() {
  ::io::deephaven::proto::backplane::grpc::AndCondition* _msg = _internal_mutable_and_();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.and)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.OrCondition or = 2;
inline bool Condition::_internal_has_or_() const {
  return data_case() == kOr;
}
inline bool Condition::has_or_() const {
  return _internal_has_or_();
}
inline void Condition::set_has_or_() {
  _oneof_case_[0] = kOr;
}
inline void Condition::clear_or_() {
  if (_internal_has_or_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.or__;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::OrCondition* Condition::release_or_() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.or)
  if (_internal_has_or_()) {
    clear_has_data();
      ::io::deephaven::proto::backplane::grpc::OrCondition* temp = data_.or__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.or__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::OrCondition& Condition::_internal_or_() const {
  return _internal_has_or_()
      ? *data_.or__
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::OrCondition&>(::io::deephaven::proto::backplane::grpc::_OrCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::OrCondition& Condition::or_() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.or)
  return _internal_or_();
}
inline ::io::deephaven::proto::backplane::grpc::OrCondition* Condition::unsafe_arena_release_or_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.or)
  if (_internal_has_or_()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::OrCondition* temp = data_.or__;
    data_.or__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_or_(::io::deephaven::proto::backplane::grpc::OrCondition* or_) {
  clear_data();
  if (or_) {
    set_has_or_();
    data_.or__ = or_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.or)
}
inline ::io::deephaven::proto::backplane::grpc::OrCondition* Condition::_internal_mutable_or_() {
  if (!_internal_has_or_()) {
    clear_data();
    set_has_or_();
    data_.or__ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::OrCondition >(GetArenaForAllocation());
  }
  return data_.or__;
}
inline ::io::deephaven::proto::backplane::grpc::OrCondition* Condition::mutable_or_() {
  ::io::deephaven::proto::backplane::grpc::OrCondition* _msg = _internal_mutable_or_();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.or)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.NotCondition not = 3;
inline bool Condition::_internal_has_not_() const {
  return data_case() == kNot;
}
inline bool Condition::has_not_() const {
  return _internal_has_not_();
}
inline void Condition::set_has_not_() {
  _oneof_case_[0] = kNot;
}
inline void Condition::clear_not_() {
  if (_internal_has_not_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.not__;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::NotCondition* Condition::release_not_() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.not)
  if (_internal_has_not_()) {
    clear_has_data();
      ::io::deephaven::proto::backplane::grpc::NotCondition* temp = data_.not__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.not__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::NotCondition& Condition::_internal_not_() const {
  return _internal_has_not_()
      ? *data_.not__
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::NotCondition&>(::io::deephaven::proto::backplane::grpc::_NotCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::NotCondition& Condition::not_() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.not)
  return _internal_not_();
}
inline ::io::deephaven::proto::backplane::grpc::NotCondition* Condition::unsafe_arena_release_not_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.not)
  if (_internal_has_not_()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::NotCondition* temp = data_.not__;
    data_.not__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_not_(::io::deephaven::proto::backplane::grpc::NotCondition* not_) {
  clear_data();
  if (not_) {
    set_has_not_();
    data_.not__ = not_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.not)
}
inline ::io::deephaven::proto::backplane::grpc::NotCondition* Condition::_internal_mutable_not_() {
  if (!_internal_has_not_()) {
    clear_data();
    set_has_not_();
    data_.not__ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::NotCondition >(GetArenaForAllocation());
  }
  return data_.not__;
}
inline ::io::deephaven::proto::backplane::grpc::NotCondition* Condition::mutable_not_() {
  ::io::deephaven::proto::backplane::grpc::NotCondition* _msg = _internal_mutable_not_();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.not)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.CompareCondition compare = 4;
inline bool Condition::_internal_has_compare() const {
  return data_case() == kCompare;
}
inline bool Condition::has_compare() const {
  return _internal_has_compare();
}
inline void Condition::set_has_compare() {
  _oneof_case_[0] = kCompare;
}
inline void Condition::clear_compare() {
  if (_internal_has_compare()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.compare_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition* Condition::release_compare() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.compare)
  if (_internal_has_compare()) {
    clear_has_data();
      ::io::deephaven::proto::backplane::grpc::CompareCondition* temp = data_.compare_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.compare_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CompareCondition& Condition::_internal_compare() const {
  return _internal_has_compare()
      ? *data_.compare_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::CompareCondition&>(::io::deephaven::proto::backplane::grpc::_CompareCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CompareCondition& Condition::compare() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.compare)
  return _internal_compare();
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition* Condition::unsafe_arena_release_compare() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.compare)
  if (_internal_has_compare()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::CompareCondition* temp = data_.compare_;
    data_.compare_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_compare(::io::deephaven::proto::backplane::grpc::CompareCondition* compare) {
  clear_data();
  if (compare) {
    set_has_compare();
    data_.compare_ = compare;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.compare)
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition* Condition::_internal_mutable_compare() {
  if (!_internal_has_compare()) {
    clear_data();
    set_has_compare();
    data_.compare_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::CompareCondition >(GetArenaForAllocation());
  }
  return data_.compare_;
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition* Condition::mutable_compare() {
  ::io::deephaven::proto::backplane::grpc::CompareCondition* _msg = _internal_mutable_compare();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.compare)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.InCondition in = 5;
inline bool Condition::_internal_has_in() const {
  return data_case() == kIn;
}
inline bool Condition::has_in() const {
  return _internal_has_in();
}
inline void Condition::set_has_in() {
  _oneof_case_[0] = kIn;
}
inline void Condition::clear_in() {
  if (_internal_has_in()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.in_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::InCondition* Condition::release_in() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.in)
  if (_internal_has_in()) {
    clear_has_data();
      ::io::deephaven::proto::backplane::grpc::InCondition* temp = data_.in_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::InCondition& Condition::_internal_in() const {
  return _internal_has_in()
      ? *data_.in_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::InCondition&>(::io::deephaven::proto::backplane::grpc::_InCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::InCondition& Condition::in() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.in)
  return _internal_in();
}
inline ::io::deephaven::proto::backplane::grpc::InCondition* Condition::unsafe_arena_release_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.in)
  if (_internal_has_in()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::InCondition* temp = data_.in_;
    data_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_in(::io::deephaven::proto::backplane::grpc::InCondition* in) {
  clear_data();
  if (in) {
    set_has_in();
    data_.in_ = in;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.in)
}
inline ::io::deephaven::proto::backplane::grpc::InCondition* Condition::_internal_mutable_in() {
  if (!_internal_has_in()) {
    clear_data();
    set_has_in();
    data_.in_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::InCondition >(GetArenaForAllocation());
  }
  return data_.in_;
}
inline ::io::deephaven::proto::backplane::grpc::InCondition* Condition::mutable_in() {
  ::io::deephaven::proto::backplane::grpc::InCondition* _msg = _internal_mutable_in();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.in)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.InvokeCondition invoke = 6;
inline bool Condition::_internal_has_invoke() const {
  return data_case() == kInvoke;
}
inline bool Condition::has_invoke() const {
  return _internal_has_invoke();
}
inline void Condition::set_has_invoke() {
  _oneof_case_[0] = kInvoke;
}
inline void Condition::clear_invoke() {
  if (_internal_has_invoke()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.invoke_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::InvokeCondition* Condition::release_invoke() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.invoke)
  if (_internal_has_invoke()) {
    clear_has_data();
      ::io::deephaven::proto::backplane::grpc::InvokeCondition* temp = data_.invoke_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.invoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::InvokeCondition& Condition::_internal_invoke() const {
  return _internal_has_invoke()
      ? *data_.invoke_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::InvokeCondition&>(::io::deephaven::proto::backplane::grpc::_InvokeCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::InvokeCondition& Condition::invoke() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.invoke)
  return _internal_invoke();
}
inline ::io::deephaven::proto::backplane::grpc::InvokeCondition* Condition::unsafe_arena_release_invoke() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.invoke)
  if (_internal_has_invoke()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::InvokeCondition* temp = data_.invoke_;
    data_.invoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_invoke(::io::deephaven::proto::backplane::grpc::InvokeCondition* invoke) {
  clear_data();
  if (invoke) {
    set_has_invoke();
    data_.invoke_ = invoke;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.invoke)
}
inline ::io::deephaven::proto::backplane::grpc::InvokeCondition* Condition::_internal_mutable_invoke() {
  if (!_internal_has_invoke()) {
    clear_data();
    set_has_invoke();
    data_.invoke_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::InvokeCondition >(GetArenaForAllocation());
  }
  return data_.invoke_;
}
inline ::io::deephaven::proto::backplane::grpc::InvokeCondition* Condition::mutable_invoke() {
  ::io::deephaven::proto::backplane::grpc::InvokeCondition* _msg = _internal_mutable_invoke();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.invoke)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.IsNullCondition is_null = 7;
inline bool Condition::_internal_has_is_null() const {
  return data_case() == kIsNull;
}
inline bool Condition::has_is_null() const {
  return _internal_has_is_null();
}
inline void Condition::set_has_is_null() {
  _oneof_case_[0] = kIsNull;
}
inline void Condition::clear_is_null() {
  if (_internal_has_is_null()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.is_null_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::IsNullCondition* Condition::release_is_null() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.is_null)
  if (_internal_has_is_null()) {
    clear_has_data();
      ::io::deephaven::proto::backplane::grpc::IsNullCondition* temp = data_.is_null_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.is_null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::IsNullCondition& Condition::_internal_is_null() const {
  return _internal_has_is_null()
      ? *data_.is_null_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::IsNullCondition&>(::io::deephaven::proto::backplane::grpc::_IsNullCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::IsNullCondition& Condition::is_null() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.is_null)
  return _internal_is_null();
}
inline ::io::deephaven::proto::backplane::grpc::IsNullCondition* Condition::unsafe_arena_release_is_null() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.is_null)
  if (_internal_has_is_null()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::IsNullCondition* temp = data_.is_null_;
    data_.is_null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_is_null(::io::deephaven::proto::backplane::grpc::IsNullCondition* is_null) {
  clear_data();
  if (is_null) {
    set_has_is_null();
    data_.is_null_ = is_null;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.is_null)
}
inline ::io::deephaven::proto::backplane::grpc::IsNullCondition* Condition::_internal_mutable_is_null() {
  if (!_internal_has_is_null()) {
    clear_data();
    set_has_is_null();
    data_.is_null_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::IsNullCondition >(GetArenaForAllocation());
  }
  return data_.is_null_;
}
inline ::io::deephaven::proto::backplane::grpc::IsNullCondition* Condition::mutable_is_null() {
  ::io::deephaven::proto::backplane::grpc::IsNullCondition* _msg = _internal_mutable_is_null();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.is_null)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.MatchesCondition matches = 8;
inline bool Condition::_internal_has_matches() const {
  return data_case() == kMatches;
}
inline bool Condition::has_matches() const {
  return _internal_has_matches();
}
inline void Condition::set_has_matches() {
  _oneof_case_[0] = kMatches;
}
inline void Condition::clear_matches() {
  if (_internal_has_matches()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.matches_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::MatchesCondition* Condition::release_matches() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.matches)
  if (_internal_has_matches()) {
    clear_has_data();
      ::io::deephaven::proto::backplane::grpc::MatchesCondition* temp = data_.matches_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.matches_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::MatchesCondition& Condition::_internal_matches() const {
  return _internal_has_matches()
      ? *data_.matches_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::MatchesCondition&>(::io::deephaven::proto::backplane::grpc::_MatchesCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MatchesCondition& Condition::matches() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.matches)
  return _internal_matches();
}
inline ::io::deephaven::proto::backplane::grpc::MatchesCondition* Condition::unsafe_arena_release_matches() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.matches)
  if (_internal_has_matches()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::MatchesCondition* temp = data_.matches_;
    data_.matches_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_matches(::io::deephaven::proto::backplane::grpc::MatchesCondition* matches) {
  clear_data();
  if (matches) {
    set_has_matches();
    data_.matches_ = matches;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.matches)
}
inline ::io::deephaven::proto::backplane::grpc::MatchesCondition* Condition::_internal_mutable_matches() {
  if (!_internal_has_matches()) {
    clear_data();
    set_has_matches();
    data_.matches_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::MatchesCondition >(GetArenaForAllocation());
  }
  return data_.matches_;
}
inline ::io::deephaven::proto::backplane::grpc::MatchesCondition* Condition::mutable_matches() {
  ::io::deephaven::proto::backplane::grpc::MatchesCondition* _msg = _internal_mutable_matches();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.matches)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.ContainsCondition contains = 9;
inline bool Condition::_internal_has_contains() const {
  return data_case() == kContains;
}
inline bool Condition::has_contains() const {
  return _internal_has_contains();
}
inline void Condition::set_has_contains() {
  _oneof_case_[0] = kContains;
}
inline void Condition::clear_contains() {
  if (_internal_has_contains()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.contains_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::ContainsCondition* Condition::release_contains() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.contains)
  if (_internal_has_contains()) {
    clear_has_data();
      ::io::deephaven::proto::backplane::grpc::ContainsCondition* temp = data_.contains_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.contains_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::ContainsCondition& Condition::_internal_contains() const {
  return _internal_has_contains()
      ? *data_.contains_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::ContainsCondition&>(::io::deephaven::proto::backplane::grpc::_ContainsCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::ContainsCondition& Condition::contains() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.contains)
  return _internal_contains();
}
inline ::io::deephaven::proto::backplane::grpc::ContainsCondition* Condition::unsafe_arena_release_contains() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.contains)
  if (_internal_has_contains()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::ContainsCondition* temp = data_.contains_;
    data_.contains_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_contains(::io::deephaven::proto::backplane::grpc::ContainsCondition* contains) {
  clear_data();
  if (contains) {
    set_has_contains();
    data_.contains_ = contains;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.contains)
}
inline ::io::deephaven::proto::backplane::grpc::ContainsCondition* Condition::_internal_mutable_contains() {
  if (!_internal_has_contains()) {
    clear_data();
    set_has_contains();
    data_.contains_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::ContainsCondition >(GetArenaForAllocation());
  }
  return data_.contains_;
}
inline ::io::deephaven::proto::backplane::grpc::ContainsCondition* Condition::mutable_contains() {
  ::io::deephaven::proto::backplane::grpc::ContainsCondition* _msg = _internal_mutable_contains();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.contains)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SearchCondition search = 10;
inline bool Condition::_internal_has_search() const {
  return data_case() == kSearch;
}
inline bool Condition::has_search() const {
  return _internal_has_search();
}
inline void Condition::set_has_search() {
  _oneof_case_[0] = kSearch;
}
inline void Condition::clear_search() {
  if (_internal_has_search()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.search_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SearchCondition* Condition::release_search() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.search)
  if (_internal_has_search()) {
    clear_has_data();
      ::io::deephaven::proto::backplane::grpc::SearchCondition* temp = data_.search_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.search_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SearchCondition& Condition::_internal_search() const {
  return _internal_has_search()
      ? *data_.search_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SearchCondition&>(::io::deephaven::proto::backplane::grpc::_SearchCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SearchCondition& Condition::search() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.search)
  return _internal_search();
}
inline ::io::deephaven::proto::backplane::grpc::SearchCondition* Condition::unsafe_arena_release_search() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.search)
  if (_internal_has_search()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::SearchCondition* temp = data_.search_;
    data_.search_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_search(::io::deephaven::proto::backplane::grpc::SearchCondition* search) {
  clear_data();
  if (search) {
    set_has_search();
    data_.search_ = search;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.search)
}
inline ::io::deephaven::proto::backplane::grpc::SearchCondition* Condition::_internal_mutable_search() {
  if (!_internal_has_search()) {
    clear_data();
    set_has_search();
    data_.search_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SearchCondition >(GetArenaForAllocation());
  }
  return data_.search_;
}
inline ::io::deephaven::proto::backplane::grpc::SearchCondition* Condition::mutable_search() {
  ::io::deephaven::proto::backplane::grpc::SearchCondition* _msg = _internal_mutable_search();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.search)
  return _msg;
}

inline bool Condition::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Condition::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline Condition::DataCase Condition::data_case() const {
  return Condition::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AndCondition

// repeated .io.deephaven.proto.backplane.grpc.Condition filters = 1;
inline int AndCondition::_internal_filters_size() const {
  return filters_.size();
}
inline int AndCondition::filters_size() const {
  return _internal_filters_size();
}
inline void AndCondition::clear_filters() {
  filters_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* AndCondition::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
AndCondition::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return &filters_;
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& AndCondition::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& AndCondition::filters(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return _internal_filters(index);
}
inline ::io::deephaven::proto::backplane::grpc::Condition* AndCondition::_internal_add_filters() {
  return filters_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* AndCondition::add_filters() {
  ::io::deephaven::proto::backplane::grpc::Condition* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
AndCondition::filters() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return filters_;
}

// -------------------------------------------------------------------

// OrCondition

// repeated .io.deephaven.proto.backplane.grpc.Condition filters = 1;
inline int OrCondition::_internal_filters_size() const {
  return filters_.size();
}
inline int OrCondition::filters_size() const {
  return _internal_filters_size();
}
inline void OrCondition::clear_filters() {
  filters_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* OrCondition::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
OrCondition::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return &filters_;
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& OrCondition::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& OrCondition::filters(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return _internal_filters(index);
}
inline ::io::deephaven::proto::backplane::grpc::Condition* OrCondition::_internal_add_filters() {
  return filters_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* OrCondition::add_filters() {
  ::io::deephaven::proto::backplane::grpc::Condition* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
OrCondition::filters() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return filters_;
}

// -------------------------------------------------------------------

// NotCondition

// .io.deephaven.proto.backplane.grpc.Condition filter = 1;
inline bool NotCondition::_internal_has_filter() const {
  return this != internal_default_instance() && filter_ != nullptr;
}
inline bool NotCondition::has_filter() const {
  return _internal_has_filter();
}
inline void NotCondition::clear_filter() {
  if (GetArenaForAllocation() == nullptr && filter_ != nullptr) {
    delete filter_;
  }
  filter_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& NotCondition::_internal_filter() const {
  const ::io::deephaven::proto::backplane::grpc::Condition* p = filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Condition&>(
      ::io::deephaven::proto::backplane::grpc::_Condition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& NotCondition::filter() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NotCondition.filter)
  return _internal_filter();
}
inline void NotCondition::unsafe_arena_set_allocated_filter(
    ::io::deephaven::proto::backplane::grpc::Condition* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.NotCondition.filter)
}
inline ::io::deephaven::proto::backplane::grpc::Condition* NotCondition::release_filter() {
  
  ::io::deephaven::proto::backplane::grpc::Condition* temp = filter_;
  filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Condition* NotCondition::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.NotCondition.filter)
  
  ::io::deephaven::proto::backplane::grpc::Condition* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Condition* NotCondition::_internal_mutable_filter() {
  
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Condition>(GetArenaForAllocation());
    filter_ = p;
  }
  return filter_;
}
inline ::io::deephaven::proto::backplane::grpc::Condition* NotCondition::mutable_filter() {
  ::io::deephaven::proto::backplane::grpc::Condition* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NotCondition.filter)
  return _msg;
}
inline void NotCondition::set_allocated_filter(::io::deephaven::proto::backplane::grpc::Condition* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::Condition>::GetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.NotCondition.filter)
}

// -------------------------------------------------------------------

// CompareCondition

// .io.deephaven.proto.backplane.grpc.CompareCondition.CompareOperation operation = 1;
inline void CompareCondition::clear_operation() {
  operation_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation CompareCondition::_internal_operation() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation >(operation_);
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation CompareCondition::operation() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CompareCondition.operation)
  return _internal_operation();
}
inline void CompareCondition::_internal_set_operation(::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation value) {
  
  operation_ = value;
}
inline void CompareCondition::set_operation(::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CompareCondition.operation)
}

// .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 2;
inline void CompareCondition::clear_case_sensitivity() {
  case_sensitivity_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity CompareCondition::_internal_case_sensitivity() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::CaseSensitivity >(case_sensitivity_);
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity CompareCondition::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CompareCondition.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void CompareCondition::_internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  
  case_sensitivity_ = value;
}
inline void CompareCondition::set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CompareCondition.case_sensitivity)
}

// .io.deephaven.proto.backplane.grpc.Value lhs = 3;
inline bool CompareCondition::_internal_has_lhs() const {
  return this != internal_default_instance() && lhs_ != nullptr;
}
inline bool CompareCondition::has_lhs() const {
  return _internal_has_lhs();
}
inline void CompareCondition::clear_lhs() {
  if (GetArenaForAllocation() == nullptr && lhs_ != nullptr) {
    delete lhs_;
  }
  lhs_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& CompareCondition::_internal_lhs() const {
  const ::io::deephaven::proto::backplane::grpc::Value* p = lhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Value&>(
      ::io::deephaven::proto::backplane::grpc::_Value_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& CompareCondition::lhs() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
  return _internal_lhs();
}
inline void CompareCondition::unsafe_arena_set_allocated_lhs(
    ::io::deephaven::proto::backplane::grpc::Value* lhs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lhs_);
  }
  lhs_ = lhs;
  if (lhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::release_lhs() {
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = lhs_;
  lhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::unsafe_arena_release_lhs() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = lhs_;
  lhs_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::_internal_mutable_lhs() {
  
  if (lhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(GetArenaForAllocation());
    lhs_ = p;
  }
  return lhs_;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::mutable_lhs() {
  ::io::deephaven::proto::backplane::grpc::Value* _msg = _internal_mutable_lhs();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
  return _msg;
}
inline void CompareCondition::set_allocated_lhs(::io::deephaven::proto::backplane::grpc::Value* lhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lhs_;
  }
  if (lhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::Value>::GetOwningArena(lhs);
    if (message_arena != submessage_arena) {
      lhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lhs, submessage_arena);
    }
    
  } else {
    
  }
  lhs_ = lhs;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
}

// .io.deephaven.proto.backplane.grpc.Value rhs = 4;
inline bool CompareCondition::_internal_has_rhs() const {
  return this != internal_default_instance() && rhs_ != nullptr;
}
inline bool CompareCondition::has_rhs() const {
  return _internal_has_rhs();
}
inline void CompareCondition::clear_rhs() {
  if (GetArenaForAllocation() == nullptr && rhs_ != nullptr) {
    delete rhs_;
  }
  rhs_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& CompareCondition::_internal_rhs() const {
  const ::io::deephaven::proto::backplane::grpc::Value* p = rhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Value&>(
      ::io::deephaven::proto::backplane::grpc::_Value_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& CompareCondition::rhs() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
  return _internal_rhs();
}
inline void CompareCondition::unsafe_arena_set_allocated_rhs(
    ::io::deephaven::proto::backplane::grpc::Value* rhs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rhs_);
  }
  rhs_ = rhs;
  if (rhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::release_rhs() {
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = rhs_;
  rhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::unsafe_arena_release_rhs() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = rhs_;
  rhs_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::_internal_mutable_rhs() {
  
  if (rhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(GetArenaForAllocation());
    rhs_ = p;
  }
  return rhs_;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::mutable_rhs() {
  ::io::deephaven::proto::backplane::grpc::Value* _msg = _internal_mutable_rhs();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
  return _msg;
}
inline void CompareCondition::set_allocated_rhs(::io::deephaven::proto::backplane::grpc::Value* rhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rhs_;
  }
  if (rhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::Value>::GetOwningArena(rhs);
    if (message_arena != submessage_arena) {
      rhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rhs, submessage_arena);
    }
    
  } else {
    
  }
  rhs_ = rhs;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
}

// -------------------------------------------------------------------

// InCondition

// .io.deephaven.proto.backplane.grpc.Value target = 1;
inline bool InCondition::_internal_has_target() const {
  return this != internal_default_instance() && target_ != nullptr;
}
inline bool InCondition::has_target() const {
  return _internal_has_target();
}
inline void InCondition::clear_target() {
  if (GetArenaForAllocation() == nullptr && target_ != nullptr) {
    delete target_;
  }
  target_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InCondition::_internal_target() const {
  const ::io::deephaven::proto::backplane::grpc::Value* p = target_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Value&>(
      ::io::deephaven::proto::backplane::grpc::_Value_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InCondition::target() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InCondition.target)
  return _internal_target();
}
inline void InCondition::unsafe_arena_set_allocated_target(
    ::io::deephaven::proto::backplane::grpc::Value* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_);
  }
  target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.InCondition.target)
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::release_target() {
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = target_;
  target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.InCondition.target)
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = target_;
  target_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::_internal_mutable_target() {
  
  if (target_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(GetArenaForAllocation());
    target_ = p;
  }
  return target_;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::mutable_target() {
  ::io::deephaven::proto::backplane::grpc::Value* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InCondition.target)
  return _msg;
}
inline void InCondition::set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::Value>::GetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.InCondition.target)
}

// repeated .io.deephaven.proto.backplane.grpc.Value candidates = 2;
inline int InCondition::_internal_candidates_size() const {
  return candidates_.size();
}
inline int InCondition::candidates_size() const {
  return _internal_candidates_size();
}
inline void InCondition::clear_candidates() {
  candidates_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::mutable_candidates(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return candidates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >*
InCondition::mutable_candidates() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return &candidates_;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InCondition::_internal_candidates(int index) const {
  return candidates_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InCondition::candidates(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return _internal_candidates(index);
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::_internal_add_candidates() {
  return candidates_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::add_candidates() {
  ::io::deephaven::proto::backplane::grpc::Value* _add = _internal_add_candidates();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >&
InCondition::candidates() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return candidates_;
}

// .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
inline void InCondition::clear_case_sensitivity() {
  case_sensitivity_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity InCondition::_internal_case_sensitivity() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::CaseSensitivity >(case_sensitivity_);
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity InCondition::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InCondition.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void InCondition::_internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  
  case_sensitivity_ = value;
}
inline void InCondition::set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.InCondition.case_sensitivity)
}

// .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
inline void InCondition::clear_match_type() {
  match_type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::MatchType InCondition::_internal_match_type() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::MatchType >(match_type_);
}
inline ::io::deephaven::proto::backplane::grpc::MatchType InCondition::match_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InCondition.match_type)
  return _internal_match_type();
}
inline void InCondition::_internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  
  match_type_ = value;
}
inline void InCondition::set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  _internal_set_match_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.InCondition.match_type)
}

// -------------------------------------------------------------------

// InvokeCondition

// string method = 1;
inline void InvokeCondition::clear_method() {
  method_.ClearToEmpty();
}
inline const std::string& InvokeCondition::method() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeCondition::set_method(ArgT0&& arg0, ArgT... args) {
 
 method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
}
inline std::string* InvokeCondition::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
  return _s;
}
inline const std::string& InvokeCondition::_internal_method() const {
  return method_.Get();
}
inline void InvokeCondition::_internal_set_method(const std::string& value) {
  
  method_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* InvokeCondition::_internal_mutable_method() {
  
  return method_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* InvokeCondition::release_method() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
  return method_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void InvokeCondition::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
}

// .io.deephaven.proto.backplane.grpc.Value target = 2;
inline bool InvokeCondition::_internal_has_target() const {
  return this != internal_default_instance() && target_ != nullptr;
}
inline bool InvokeCondition::has_target() const {
  return _internal_has_target();
}
inline void InvokeCondition::clear_target() {
  if (GetArenaForAllocation() == nullptr && target_ != nullptr) {
    delete target_;
  }
  target_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InvokeCondition::_internal_target() const {
  const ::io::deephaven::proto::backplane::grpc::Value* p = target_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Value&>(
      ::io::deephaven::proto::backplane::grpc::_Value_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InvokeCondition::target() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
  return _internal_target();
}
inline void InvokeCondition::unsafe_arena_set_allocated_target(
    ::io::deephaven::proto::backplane::grpc::Value* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_);
  }
  target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::release_target() {
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = target_;
  target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = target_;
  target_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::_internal_mutable_target() {
  
  if (target_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(GetArenaForAllocation());
    target_ = p;
  }
  return target_;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::mutable_target() {
  ::io::deephaven::proto::backplane::grpc::Value* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
  return _msg;
}
inline void InvokeCondition::set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::Value>::GetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
}

// repeated .io.deephaven.proto.backplane.grpc.Value arguments = 3;
inline int InvokeCondition::_internal_arguments_size() const {
  return arguments_.size();
}
inline int InvokeCondition::arguments_size() const {
  return _internal_arguments_size();
}
inline void InvokeCondition::clear_arguments() {
  arguments_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return arguments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >*
InvokeCondition::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return &arguments_;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InvokeCondition::_internal_arguments(int index) const {
  return arguments_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InvokeCondition::arguments(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return _internal_arguments(index);
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::_internal_add_arguments() {
  return arguments_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::add_arguments() {
  ::io::deephaven::proto::backplane::grpc::Value* _add = _internal_add_arguments();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >&
InvokeCondition::arguments() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return arguments_;
}

// -------------------------------------------------------------------

// IsNullCondition

// .io.deephaven.proto.backplane.grpc.Reference reference = 1;
inline bool IsNullCondition::_internal_has_reference() const {
  return this != internal_default_instance() && reference_ != nullptr;
}
inline bool IsNullCondition::has_reference() const {
  return _internal_has_reference();
}
inline void IsNullCondition::clear_reference() {
  if (GetArenaForAllocation() == nullptr && reference_ != nullptr) {
    delete reference_;
  }
  reference_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& IsNullCondition::_internal_reference() const {
  const ::io::deephaven::proto::backplane::grpc::Reference* p = reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Reference&>(
      ::io::deephaven::proto::backplane::grpc::_Reference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& IsNullCondition::reference() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
  return _internal_reference();
}
inline void IsNullCondition::unsafe_arena_set_allocated_reference(
    ::io::deephaven::proto::backplane::grpc::Reference* reference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_);
  }
  reference_ = reference;
  if (reference) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
}
inline ::io::deephaven::proto::backplane::grpc::Reference* IsNullCondition::release_reference() {
  
  ::io::deephaven::proto::backplane::grpc::Reference* temp = reference_;
  reference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* IsNullCondition::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
  
  ::io::deephaven::proto::backplane::grpc::Reference* temp = reference_;
  reference_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* IsNullCondition::_internal_mutable_reference() {
  
  if (reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Reference>(GetArenaForAllocation());
    reference_ = p;
  }
  return reference_;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* IsNullCondition::mutable_reference() {
  ::io::deephaven::proto::backplane::grpc::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
  return _msg;
}
inline void IsNullCondition::set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reference_;
  }
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::Reference>::GetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    
  } else {
    
  }
  reference_ = reference;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
}

// -------------------------------------------------------------------

// MatchesCondition

// .io.deephaven.proto.backplane.grpc.Reference reference = 1;
inline bool MatchesCondition::_internal_has_reference() const {
  return this != internal_default_instance() && reference_ != nullptr;
}
inline bool MatchesCondition::has_reference() const {
  return _internal_has_reference();
}
inline void MatchesCondition::clear_reference() {
  if (GetArenaForAllocation() == nullptr && reference_ != nullptr) {
    delete reference_;
  }
  reference_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& MatchesCondition::_internal_reference() const {
  const ::io::deephaven::proto::backplane::grpc::Reference* p = reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Reference&>(
      ::io::deephaven::proto::backplane::grpc::_Reference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& MatchesCondition::reference() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
  return _internal_reference();
}
inline void MatchesCondition::unsafe_arena_set_allocated_reference(
    ::io::deephaven::proto::backplane::grpc::Reference* reference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_);
  }
  reference_ = reference;
  if (reference) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
}
inline ::io::deephaven::proto::backplane::grpc::Reference* MatchesCondition::release_reference() {
  
  ::io::deephaven::proto::backplane::grpc::Reference* temp = reference_;
  reference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* MatchesCondition::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
  
  ::io::deephaven::proto::backplane::grpc::Reference* temp = reference_;
  reference_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* MatchesCondition::_internal_mutable_reference() {
  
  if (reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Reference>(GetArenaForAllocation());
    reference_ = p;
  }
  return reference_;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* MatchesCondition::mutable_reference() {
  ::io::deephaven::proto::backplane::grpc::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
  return _msg;
}
inline void MatchesCondition::set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reference_;
  }
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::Reference>::GetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    
  } else {
    
  }
  reference_ = reference;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
}

// string regex = 2;
inline void MatchesCondition::clear_regex() {
  regex_.ClearToEmpty();
}
inline const std::string& MatchesCondition::regex() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
  return _internal_regex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchesCondition::set_regex(ArgT0&& arg0, ArgT... args) {
 
 regex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
}
inline std::string* MatchesCondition::mutable_regex() {
  std::string* _s = _internal_mutable_regex();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
  return _s;
}
inline const std::string& MatchesCondition::_internal_regex() const {
  return regex_.Get();
}
inline void MatchesCondition::_internal_set_regex(const std::string& value) {
  
  regex_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MatchesCondition::_internal_mutable_regex() {
  
  return regex_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MatchesCondition::release_regex() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
  return regex_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MatchesCondition::set_allocated_regex(std::string* regex) {
  if (regex != nullptr) {
    
  } else {
    
  }
  regex_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), regex,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
}

// .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
inline void MatchesCondition::clear_case_sensitivity() {
  case_sensitivity_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity MatchesCondition::_internal_case_sensitivity() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::CaseSensitivity >(case_sensitivity_);
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity MatchesCondition::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MatchesCondition.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void MatchesCondition::_internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  
  case_sensitivity_ = value;
}
inline void MatchesCondition::set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MatchesCondition.case_sensitivity)
}

// .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
inline void MatchesCondition::clear_match_type() {
  match_type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::MatchType MatchesCondition::_internal_match_type() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::MatchType >(match_type_);
}
inline ::io::deephaven::proto::backplane::grpc::MatchType MatchesCondition::match_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MatchesCondition.match_type)
  return _internal_match_type();
}
inline void MatchesCondition::_internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  
  match_type_ = value;
}
inline void MatchesCondition::set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  _internal_set_match_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MatchesCondition.match_type)
}

// -------------------------------------------------------------------

// ContainsCondition

// .io.deephaven.proto.backplane.grpc.Reference reference = 1;
inline bool ContainsCondition::_internal_has_reference() const {
  return this != internal_default_instance() && reference_ != nullptr;
}
inline bool ContainsCondition::has_reference() const {
  return _internal_has_reference();
}
inline void ContainsCondition::clear_reference() {
  if (GetArenaForAllocation() == nullptr && reference_ != nullptr) {
    delete reference_;
  }
  reference_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& ContainsCondition::_internal_reference() const {
  const ::io::deephaven::proto::backplane::grpc::Reference* p = reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Reference&>(
      ::io::deephaven::proto::backplane::grpc::_Reference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& ContainsCondition::reference() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
  return _internal_reference();
}
inline void ContainsCondition::unsafe_arena_set_allocated_reference(
    ::io::deephaven::proto::backplane::grpc::Reference* reference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_);
  }
  reference_ = reference;
  if (reference) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
}
inline ::io::deephaven::proto::backplane::grpc::Reference* ContainsCondition::release_reference() {
  
  ::io::deephaven::proto::backplane::grpc::Reference* temp = reference_;
  reference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* ContainsCondition::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
  
  ::io::deephaven::proto::backplane::grpc::Reference* temp = reference_;
  reference_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* ContainsCondition::_internal_mutable_reference() {
  
  if (reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Reference>(GetArenaForAllocation());
    reference_ = p;
  }
  return reference_;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* ContainsCondition::mutable_reference() {
  ::io::deephaven::proto::backplane::grpc::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
  return _msg;
}
inline void ContainsCondition::set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reference_;
  }
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::Reference>::GetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    
  } else {
    
  }
  reference_ = reference;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
}

// string search_string = 2;
inline void ContainsCondition::clear_search_string() {
  search_string_.ClearToEmpty();
}
inline const std::string& ContainsCondition::search_string() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
  return _internal_search_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContainsCondition::set_search_string(ArgT0&& arg0, ArgT... args) {
 
 search_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
}
inline std::string* ContainsCondition::mutable_search_string() {
  std::string* _s = _internal_mutable_search_string();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
  return _s;
}
inline const std::string& ContainsCondition::_internal_search_string() const {
  return search_string_.Get();
}
inline void ContainsCondition::_internal_set_search_string(const std::string& value) {
  
  search_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ContainsCondition::_internal_mutable_search_string() {
  
  return search_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ContainsCondition::release_search_string() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
  return search_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ContainsCondition::set_allocated_search_string(std::string* search_string) {
  if (search_string != nullptr) {
    
  } else {
    
  }
  search_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), search_string,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
}

// .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
inline void ContainsCondition::clear_case_sensitivity() {
  case_sensitivity_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity ContainsCondition::_internal_case_sensitivity() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::CaseSensitivity >(case_sensitivity_);
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity ContainsCondition::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ContainsCondition.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void ContainsCondition::_internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  
  case_sensitivity_ = value;
}
inline void ContainsCondition::set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ContainsCondition.case_sensitivity)
}

// .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
inline void ContainsCondition::clear_match_type() {
  match_type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::MatchType ContainsCondition::_internal_match_type() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::MatchType >(match_type_);
}
inline ::io::deephaven::proto::backplane::grpc::MatchType ContainsCondition::match_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ContainsCondition.match_type)
  return _internal_match_type();
}
inline void ContainsCondition::_internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  
  match_type_ = value;
}
inline void ContainsCondition::set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  _internal_set_match_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ContainsCondition.match_type)
}

// -------------------------------------------------------------------

// SearchCondition

// string search_string = 1;
inline void SearchCondition::clear_search_string() {
  search_string_.ClearToEmpty();
}
inline const std::string& SearchCondition::search_string() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
  return _internal_search_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchCondition::set_search_string(ArgT0&& arg0, ArgT... args) {
 
 search_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
}
inline std::string* SearchCondition::mutable_search_string() {
  std::string* _s = _internal_mutable_search_string();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
  return _s;
}
inline const std::string& SearchCondition::_internal_search_string() const {
  return search_string_.Get();
}
inline void SearchCondition::_internal_set_search_string(const std::string& value) {
  
  search_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SearchCondition::_internal_mutable_search_string() {
  
  return search_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SearchCondition::release_search_string() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
  return search_string_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SearchCondition::set_allocated_search_string(std::string* search_string) {
  if (search_string != nullptr) {
    
  } else {
    
  }
  search_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), search_string,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
}

// repeated .io.deephaven.proto.backplane.grpc.Reference optional_references = 2;
inline int SearchCondition::_internal_optional_references_size() const {
  return optional_references_.size();
}
inline int SearchCondition::optional_references_size() const {
  return _internal_optional_references_size();
}
inline void SearchCondition::clear_optional_references() {
  optional_references_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Reference* SearchCondition::mutable_optional_references(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return optional_references_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference >*
SearchCondition::mutable_optional_references() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return &optional_references_;
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& SearchCondition::_internal_optional_references(int index) const {
  return optional_references_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& SearchCondition::optional_references(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return _internal_optional_references(index);
}
inline ::io::deephaven::proto::backplane::grpc::Reference* SearchCondition::_internal_add_optional_references() {
  return optional_references_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Reference* SearchCondition::add_optional_references() {
  ::io::deephaven::proto::backplane::grpc::Reference* _add = _internal_add_optional_references();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference >&
SearchCondition::optional_references() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return optional_references_;
}

// -------------------------------------------------------------------

// FlattenRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool FlattenRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool FlattenRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FlattenRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FlattenRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
  return _internal_result_id();
}
inline void FlattenRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FlattenRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FlattenRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FlattenRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FlattenRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
  return _msg;
}
inline void FlattenRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool FlattenRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool FlattenRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void FlattenRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FlattenRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FlattenRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
  return _internal_source_id();
}
inline void FlattenRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FlattenRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FlattenRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FlattenRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FlattenRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
  return _msg;
}
inline void FlattenRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
}

// -------------------------------------------------------------------

// RunChartDownsampleRequest_ZoomRange

// optional int64 min_date_nanos = 1 [jstype = JS_STRING];
inline bool RunChartDownsampleRequest_ZoomRange::_internal_has_min_date_nanos() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RunChartDownsampleRequest_ZoomRange::has_min_date_nanos() const {
  return _internal_has_min_date_nanos();
}
inline void RunChartDownsampleRequest_ZoomRange::clear_min_date_nanos() {
  min_date_nanos_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RunChartDownsampleRequest_ZoomRange::_internal_min_date_nanos() const {
  return min_date_nanos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RunChartDownsampleRequest_ZoomRange::min_date_nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange.min_date_nanos)
  return _internal_min_date_nanos();
}
inline void RunChartDownsampleRequest_ZoomRange::_internal_set_min_date_nanos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  min_date_nanos_ = value;
}
inline void RunChartDownsampleRequest_ZoomRange::set_min_date_nanos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_min_date_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange.min_date_nanos)
}

// optional int64 max_date_nanos = 2 [jstype = JS_STRING];
inline bool RunChartDownsampleRequest_ZoomRange::_internal_has_max_date_nanos() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RunChartDownsampleRequest_ZoomRange::has_max_date_nanos() const {
  return _internal_has_max_date_nanos();
}
inline void RunChartDownsampleRequest_ZoomRange::clear_max_date_nanos() {
  max_date_nanos_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RunChartDownsampleRequest_ZoomRange::_internal_max_date_nanos() const {
  return max_date_nanos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 RunChartDownsampleRequest_ZoomRange::max_date_nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange.max_date_nanos)
  return _internal_max_date_nanos();
}
inline void RunChartDownsampleRequest_ZoomRange::_internal_set_max_date_nanos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  max_date_nanos_ = value;
}
inline void RunChartDownsampleRequest_ZoomRange::set_max_date_nanos(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_date_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange.max_date_nanos)
}

// -------------------------------------------------------------------

// RunChartDownsampleRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool RunChartDownsampleRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool RunChartDownsampleRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& RunChartDownsampleRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& RunChartDownsampleRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
  return _internal_result_id();
}
inline void RunChartDownsampleRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RunChartDownsampleRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RunChartDownsampleRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RunChartDownsampleRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RunChartDownsampleRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
  return _msg;
}
inline void RunChartDownsampleRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool RunChartDownsampleRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool RunChartDownsampleRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void RunChartDownsampleRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RunChartDownsampleRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RunChartDownsampleRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
  return _internal_source_id();
}
inline void RunChartDownsampleRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RunChartDownsampleRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RunChartDownsampleRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RunChartDownsampleRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RunChartDownsampleRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
  return _msg;
}
inline void RunChartDownsampleRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::TableReference>::GetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
}

// int32 pixel_count = 3;
inline void RunChartDownsampleRequest::clear_pixel_count() {
  pixel_count_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RunChartDownsampleRequest::_internal_pixel_count() const {
  return pixel_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RunChartDownsampleRequest::pixel_count() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.pixel_count)
  return _internal_pixel_count();
}
inline void RunChartDownsampleRequest::_internal_set_pixel_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  pixel_count_ = value;
}
inline void RunChartDownsampleRequest::set_pixel_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_pixel_count(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.pixel_count)
}

// .io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange zoom_range = 4;
inline bool RunChartDownsampleRequest::_internal_has_zoom_range() const {
  return this != internal_default_instance() && zoom_range_ != nullptr;
}
inline bool RunChartDownsampleRequest::has_zoom_range() const {
  return _internal_has_zoom_range();
}
inline void RunChartDownsampleRequest::clear_zoom_range() {
  if (GetArenaForAllocation() == nullptr && zoom_range_ != nullptr) {
    delete zoom_range_;
  }
  zoom_range_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange& RunChartDownsampleRequest::_internal_zoom_range() const {
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* p = zoom_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange&>(
      ::io::deephaven::proto::backplane::grpc::_RunChartDownsampleRequest_ZoomRange_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange& RunChartDownsampleRequest::zoom_range() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
  return _internal_zoom_range();
}
inline void RunChartDownsampleRequest::unsafe_arena_set_allocated_zoom_range(
    ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* zoom_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(zoom_range_);
  }
  zoom_range_ = zoom_range;
  if (zoom_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* RunChartDownsampleRequest::release_zoom_range() {
  
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* temp = zoom_range_;
  zoom_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* RunChartDownsampleRequest::unsafe_arena_release_zoom_range() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
  
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* temp = zoom_range_;
  zoom_range_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* RunChartDownsampleRequest::_internal_mutable_zoom_range() {
  
  if (zoom_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange>(GetArenaForAllocation());
    zoom_range_ = p;
  }
  return zoom_range_;
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* RunChartDownsampleRequest::mutable_zoom_range() {
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* _msg = _internal_mutable_zoom_range();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
  return _msg;
}
inline void RunChartDownsampleRequest::set_allocated_zoom_range(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* zoom_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete zoom_range_;
  }
  if (zoom_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange>::GetOwningArena(zoom_range);
    if (message_arena != submessage_arena) {
      zoom_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zoom_range, submessage_arena);
    }
    
  } else {
    
  }
  zoom_range_ = zoom_range;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
}

// string x_column_name = 5;
inline void RunChartDownsampleRequest::clear_x_column_name() {
  x_column_name_.ClearToEmpty();
}
inline const std::string& RunChartDownsampleRequest::x_column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
  return _internal_x_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunChartDownsampleRequest::set_x_column_name(ArgT0&& arg0, ArgT... args) {
 
 x_column_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
}
inline std::string* RunChartDownsampleRequest::mutable_x_column_name() {
  std::string* _s = _internal_mutable_x_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
  return _s;
}
inline const std::string& RunChartDownsampleRequest::_internal_x_column_name() const {
  return x_column_name_.Get();
}
inline void RunChartDownsampleRequest::_internal_set_x_column_name(const std::string& value) {
  
  x_column_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RunChartDownsampleRequest::_internal_mutable_x_column_name() {
  
  return x_column_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RunChartDownsampleRequest::release_x_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
  return x_column_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RunChartDownsampleRequest::set_allocated_x_column_name(std::string* x_column_name) {
  if (x_column_name != nullptr) {
    
  } else {
    
  }
  x_column_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), x_column_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
}

// repeated string y_column_names = 6;
inline int RunChartDownsampleRequest::_internal_y_column_names_size() const {
  return y_column_names_.size();
}
inline int RunChartDownsampleRequest::y_column_names_size() const {
  return _internal_y_column_names_size();
}
inline void RunChartDownsampleRequest::clear_y_column_names() {
  y_column_names_.Clear();
}
inline std::string* RunChartDownsampleRequest::add_y_column_names() {
  std::string* _s = _internal_add_y_column_names();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return _s;
}
inline const std::string& RunChartDownsampleRequest::_internal_y_column_names(int index) const {
  return y_column_names_.Get(index);
}
inline const std::string& RunChartDownsampleRequest::y_column_names(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return _internal_y_column_names(index);
}
inline std::string* RunChartDownsampleRequest::mutable_y_column_names(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return y_column_names_.Mutable(index);
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, const std::string& value) {
  y_column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, std::string&& value) {
  y_column_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  y_column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, const char* value, size_t size) {
  y_column_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline std::string* RunChartDownsampleRequest::_internal_add_y_column_names() {
  return y_column_names_.Add();
}
inline void RunChartDownsampleRequest::add_y_column_names(const std::string& value) {
  y_column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::add_y_column_names(std::string&& value) {
  y_column_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::add_y_column_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  y_column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::add_y_column_names(const char* value, size_t size) {
  y_column_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RunChartDownsampleRequest::y_column_names() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return y_column_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RunChartDownsampleRequest::mutable_y_column_names() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return &y_column_names_;
}

// -------------------------------------------------------------------

// BatchTableRequest_Operation

// .io.deephaven.proto.backplane.grpc.EmptyTableRequest empty_table = 1;
inline bool BatchTableRequest_Operation::_internal_has_empty_table() const {
  return op_case() == kEmptyTable;
}
inline bool BatchTableRequest_Operation::has_empty_table() const {
  return _internal_has_empty_table();
}
inline void BatchTableRequest_Operation::set_has_empty_table() {
  _oneof_case_[0] = kEmptyTable;
}
inline void BatchTableRequest_Operation::clear_empty_table() {
  if (_internal_has_empty_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.empty_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* BatchTableRequest_Operation::release_empty_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
  if (_internal_has_empty_table()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* temp = op_.empty_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.empty_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& BatchTableRequest_Operation::_internal_empty_table() const {
  return _internal_has_empty_table()
      ? *op_.empty_table_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::EmptyTableRequest&>(::io::deephaven::proto::backplane::grpc::_EmptyTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& BatchTableRequest_Operation::empty_table() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
  return _internal_empty_table();
}
inline ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* BatchTableRequest_Operation::unsafe_arena_release_empty_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
  if (_internal_has_empty_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* temp = op_.empty_table_;
    op_.empty_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_empty_table(::io::deephaven::proto::backplane::grpc::EmptyTableRequest* empty_table) {
  clear_op();
  if (empty_table) {
    set_has_empty_table();
    op_.empty_table_ = empty_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
}
inline ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* BatchTableRequest_Operation::_internal_mutable_empty_table() {
  if (!_internal_has_empty_table()) {
    clear_op();
    set_has_empty_table();
    op_.empty_table_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::EmptyTableRequest >(GetArenaForAllocation());
  }
  return op_.empty_table_;
}
inline ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* BatchTableRequest_Operation::mutable_empty_table() {
  ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* _msg = _internal_mutable_empty_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.TimeTableRequest time_table = 2;
inline bool BatchTableRequest_Operation::_internal_has_time_table() const {
  return op_case() == kTimeTable;
}
inline bool BatchTableRequest_Operation::has_time_table() const {
  return _internal_has_time_table();
}
inline void BatchTableRequest_Operation::set_has_time_table() {
  _oneof_case_[0] = kTimeTable;
}
inline void BatchTableRequest_Operation::clear_time_table() {
  if (_internal_has_time_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.time_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::TimeTableRequest* BatchTableRequest_Operation::release_time_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
  if (_internal_has_time_table()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::TimeTableRequest* temp = op_.time_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.time_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& BatchTableRequest_Operation::_internal_time_table() const {
  return _internal_has_time_table()
      ? *op_.time_table_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::TimeTableRequest&>(::io::deephaven::proto::backplane::grpc::_TimeTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& BatchTableRequest_Operation::time_table() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
  return _internal_time_table();
}
inline ::io::deephaven::proto::backplane::grpc::TimeTableRequest* BatchTableRequest_Operation::unsafe_arena_release_time_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
  if (_internal_has_time_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::TimeTableRequest* temp = op_.time_table_;
    op_.time_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_time_table(::io::deephaven::proto::backplane::grpc::TimeTableRequest* time_table) {
  clear_op();
  if (time_table) {
    set_has_time_table();
    op_.time_table_ = time_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
}
inline ::io::deephaven::proto::backplane::grpc::TimeTableRequest* BatchTableRequest_Operation::_internal_mutable_time_table() {
  if (!_internal_has_time_table()) {
    clear_op();
    set_has_time_table();
    op_.time_table_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::TimeTableRequest >(GetArenaForAllocation());
  }
  return op_.time_table_;
}
inline ::io::deephaven::proto::backplane::grpc::TimeTableRequest* BatchTableRequest_Operation::mutable_time_table() {
  ::io::deephaven::proto::backplane::grpc::TimeTableRequest* _msg = _internal_mutable_time_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.DropColumnsRequest drop_columns = 3;
inline bool BatchTableRequest_Operation::_internal_has_drop_columns() const {
  return op_case() == kDropColumns;
}
inline bool BatchTableRequest_Operation::has_drop_columns() const {
  return _internal_has_drop_columns();
}
inline void BatchTableRequest_Operation::set_has_drop_columns() {
  _oneof_case_[0] = kDropColumns;
}
inline void BatchTableRequest_Operation::clear_drop_columns() {
  if (_internal_has_drop_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.drop_columns_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* BatchTableRequest_Operation::release_drop_columns() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* temp = op_.drop_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& BatchTableRequest_Operation::_internal_drop_columns() const {
  return _internal_has_drop_columns()
      ? *op_.drop_columns_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::DropColumnsRequest&>(::io::deephaven::proto::backplane::grpc::_DropColumnsRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& BatchTableRequest_Operation::drop_columns() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
  return _internal_drop_columns();
}
inline ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* BatchTableRequest_Operation::unsafe_arena_release_drop_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* temp = op_.drop_columns_;
    op_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_drop_columns(::io::deephaven::proto::backplane::grpc::DropColumnsRequest* drop_columns) {
  clear_op();
  if (drop_columns) {
    set_has_drop_columns();
    op_.drop_columns_ = drop_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
}
inline ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* BatchTableRequest_Operation::_internal_mutable_drop_columns() {
  if (!_internal_has_drop_columns()) {
    clear_op();
    set_has_drop_columns();
    op_.drop_columns_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::DropColumnsRequest >(GetArenaForAllocation());
  }
  return op_.drop_columns_;
}
inline ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* BatchTableRequest_Operation::mutable_drop_columns() {
  ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* _msg = _internal_mutable_drop_columns();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest update = 4;
inline bool BatchTableRequest_Operation::_internal_has_update() const {
  return op_case() == kUpdate;
}
inline bool BatchTableRequest_Operation::has_update() const {
  return _internal_has_update();
}
inline void BatchTableRequest_Operation::set_has_update() {
  _oneof_case_[0] = kUpdate;
}
inline void BatchTableRequest_Operation::clear_update() {
  if (_internal_has_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.update_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_update() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
  if (_internal_has_update()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_update() const {
  return _internal_has_update()
      ? *op_.update_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::update() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
  return _internal_update();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
  if (_internal_has_update()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.update_;
    op_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update) {
  clear_op();
  if (update) {
    set_has_update();
    op_.update_ = update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_update() {
  if (!_internal_has_update()) {
    clear_op();
    set_has_update();
    op_.update_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest >(GetArenaForAllocation());
  }
  return op_.update_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_update() {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest lazy_update = 5;
inline bool BatchTableRequest_Operation::_internal_has_lazy_update() const {
  return op_case() == kLazyUpdate;
}
inline bool BatchTableRequest_Operation::has_lazy_update() const {
  return _internal_has_lazy_update();
}
inline void BatchTableRequest_Operation::set_has_lazy_update() {
  _oneof_case_[0] = kLazyUpdate;
}
inline void BatchTableRequest_Operation::clear_lazy_update() {
  if (_internal_has_lazy_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.lazy_update_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_lazy_update() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
  if (_internal_has_lazy_update()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.lazy_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.lazy_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_lazy_update() const {
  return _internal_has_lazy_update()
      ? *op_.lazy_update_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::lazy_update() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
  return _internal_lazy_update();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_lazy_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
  if (_internal_has_lazy_update()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.lazy_update_;
    op_.lazy_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_lazy_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* lazy_update) {
  clear_op();
  if (lazy_update) {
    set_has_lazy_update();
    op_.lazy_update_ = lazy_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_lazy_update() {
  if (!_internal_has_lazy_update()) {
    clear_op();
    set_has_lazy_update();
    op_.lazy_update_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest >(GetArenaForAllocation());
  }
  return op_.lazy_update_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_lazy_update() {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_lazy_update();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest view = 6;
inline bool BatchTableRequest_Operation::_internal_has_view() const {
  return op_case() == kView;
}
inline bool BatchTableRequest_Operation::has_view() const {
  return _internal_has_view();
}
inline void BatchTableRequest_Operation::set_has_view() {
  _oneof_case_[0] = kView;
}
inline void BatchTableRequest_Operation::clear_view() {
  if (_internal_has_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.view_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_view() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
  if (_internal_has_view()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_view() const {
  return _internal_has_view()
      ? *op_.view_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::view() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
  return _internal_view();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
  if (_internal_has_view()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.view_;
    op_.view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* view) {
  clear_op();
  if (view) {
    set_has_view();
    op_.view_ = view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_view() {
  if (!_internal_has_view()) {
    clear_op();
    set_has_view();
    op_.view_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest >(GetArenaForAllocation());
  }
  return op_.view_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_view() {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_view();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest update_view = 7;
inline bool BatchTableRequest_Operation::_internal_has_update_view() const {
  return op_case() == kUpdateView;
}
inline bool BatchTableRequest_Operation::has_update_view() const {
  return _internal_has_update_view();
}
inline void BatchTableRequest_Operation::set_has_update_view() {
  _oneof_case_[0] = kUpdateView;
}
inline void BatchTableRequest_Operation::clear_update_view() {
  if (_internal_has_update_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.update_view_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_update_view() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
  if (_internal_has_update_view()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.update_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.update_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_update_view() const {
  return _internal_has_update_view()
      ? *op_.update_view_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::update_view() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
  return _internal_update_view();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_update_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
  if (_internal_has_update_view()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.update_view_;
    op_.update_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_update_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update_view) {
  clear_op();
  if (update_view) {
    set_has_update_view();
    op_.update_view_ = update_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_update_view() {
  if (!_internal_has_update_view()) {
    clear_op();
    set_has_update_view();
    op_.update_view_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest >(GetArenaForAllocation());
  }
  return op_.update_view_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_update_view() {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_update_view();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest select = 8;
inline bool BatchTableRequest_Operation::_internal_has_select() const {
  return op_case() == kSelect;
}
inline bool BatchTableRequest_Operation::has_select() const {
  return _internal_has_select();
}
inline void BatchTableRequest_Operation::set_has_select() {
  _oneof_case_[0] = kSelect;
}
inline void BatchTableRequest_Operation::clear_select() {
  if (_internal_has_select()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.select_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_select() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
  if (_internal_has_select()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.select_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.select_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_select() const {
  return _internal_has_select()
      ? *op_.select_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::select() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
  return _internal_select();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_select() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
  if (_internal_has_select()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.select_;
    op_.select_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_select(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* select) {
  clear_op();
  if (select) {
    set_has_select();
    op_.select_ = select;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_select() {
  if (!_internal_has_select()) {
    clear_op();
    set_has_select();
    op_.select_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest >(GetArenaForAllocation());
  }
  return op_.select_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_select() {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_select();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectDistinctRequest select_distinct = 9;
inline bool BatchTableRequest_Operation::_internal_has_select_distinct() const {
  return op_case() == kSelectDistinct;
}
inline bool BatchTableRequest_Operation::has_select_distinct() const {
  return _internal_has_select_distinct();
}
inline void BatchTableRequest_Operation::set_has_select_distinct() {
  _oneof_case_[0] = kSelectDistinct;
}
inline void BatchTableRequest_Operation::clear_select_distinct() {
  if (_internal_has_select_distinct()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.select_distinct_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* BatchTableRequest_Operation::release_select_distinct() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
  if (_internal_has_select_distinct()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* temp = op_.select_distinct_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.select_distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& BatchTableRequest_Operation::_internal_select_distinct() const {
  return _internal_has_select_distinct()
      ? *op_.select_distinct_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest&>(::io::deephaven::proto::backplane::grpc::_SelectDistinctRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& BatchTableRequest_Operation::select_distinct() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
  return _internal_select_distinct();
}
inline ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* BatchTableRequest_Operation::unsafe_arena_release_select_distinct() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
  if (_internal_has_select_distinct()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* temp = op_.select_distinct_;
    op_.select_distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_select_distinct(::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* select_distinct) {
  clear_op();
  if (select_distinct) {
    set_has_select_distinct();
    op_.select_distinct_ = select_distinct;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
}
inline ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* BatchTableRequest_Operation::_internal_mutable_select_distinct() {
  if (!_internal_has_select_distinct()) {
    clear_op();
    set_has_select_distinct();
    op_.select_distinct_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest >(GetArenaForAllocation());
  }
  return op_.select_distinct_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* BatchTableRequest_Operation::mutable_select_distinct() {
  ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* _msg = _internal_mutable_select_distinct();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.FilterTableRequest filter = 10;
inline bool BatchTableRequest_Operation::_internal_has_filter() const {
  return op_case() == kFilter;
}
inline bool BatchTableRequest_Operation::has_filter() const {
  return _internal_has_filter();
}
inline void BatchTableRequest_Operation::set_has_filter() {
  _oneof_case_[0] = kFilter;
}
inline void BatchTableRequest_Operation::clear_filter() {
  if (_internal_has_filter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.filter_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::FilterTableRequest* BatchTableRequest_Operation::release_filter() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
  if (_internal_has_filter()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::FilterTableRequest* temp = op_.filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& BatchTableRequest_Operation::_internal_filter() const {
  return _internal_has_filter()
      ? *op_.filter_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::FilterTableRequest&>(::io::deephaven::proto::backplane::grpc::_FilterTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& BatchTableRequest_Operation::filter() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
  return _internal_filter();
}
inline ::io::deephaven::proto::backplane::grpc::FilterTableRequest* BatchTableRequest_Operation::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
  if (_internal_has_filter()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::FilterTableRequest* temp = op_.filter_;
    op_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_filter(::io::deephaven::proto::backplane::grpc::FilterTableRequest* filter) {
  clear_op();
  if (filter) {
    set_has_filter();
    op_.filter_ = filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
}
inline ::io::deephaven::proto::backplane::grpc::FilterTableRequest* BatchTableRequest_Operation::_internal_mutable_filter() {
  if (!_internal_has_filter()) {
    clear_op();
    set_has_filter();
    op_.filter_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::FilterTableRequest >(GetArenaForAllocation());
  }
  return op_.filter_;
}
inline ::io::deephaven::proto::backplane::grpc::FilterTableRequest* BatchTableRequest_Operation::mutable_filter() {
  ::io::deephaven::proto::backplane::grpc::FilterTableRequest* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest unstructured_filter = 11;
inline bool BatchTableRequest_Operation::_internal_has_unstructured_filter() const {
  return op_case() == kUnstructuredFilter;
}
inline bool BatchTableRequest_Operation::has_unstructured_filter() const {
  return _internal_has_unstructured_filter();
}
inline void BatchTableRequest_Operation::set_has_unstructured_filter() {
  _oneof_case_[0] = kUnstructuredFilter;
}
inline void BatchTableRequest_Operation::clear_unstructured_filter() {
  if (_internal_has_unstructured_filter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.unstructured_filter_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* BatchTableRequest_Operation::release_unstructured_filter() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
  if (_internal_has_unstructured_filter()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* temp = op_.unstructured_filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.unstructured_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& BatchTableRequest_Operation::_internal_unstructured_filter() const {
  return _internal_has_unstructured_filter()
      ? *op_.unstructured_filter_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest&>(::io::deephaven::proto::backplane::grpc::_UnstructuredFilterTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& BatchTableRequest_Operation::unstructured_filter() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
  return _internal_unstructured_filter();
}
inline ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* BatchTableRequest_Operation::unsafe_arena_release_unstructured_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
  if (_internal_has_unstructured_filter()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* temp = op_.unstructured_filter_;
    op_.unstructured_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_unstructured_filter(::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* unstructured_filter) {
  clear_op();
  if (unstructured_filter) {
    set_has_unstructured_filter();
    op_.unstructured_filter_ = unstructured_filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
}
inline ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* BatchTableRequest_Operation::_internal_mutable_unstructured_filter() {
  if (!_internal_has_unstructured_filter()) {
    clear_op();
    set_has_unstructured_filter();
    op_.unstructured_filter_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest >(GetArenaForAllocation());
  }
  return op_.unstructured_filter_;
}
inline ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* BatchTableRequest_Operation::mutable_unstructured_filter() {
  ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* _msg = _internal_mutable_unstructured_filter();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SortTableRequest sort = 12;
inline bool BatchTableRequest_Operation::_internal_has_sort() const {
  return op_case() == kSort;
}
inline bool BatchTableRequest_Operation::has_sort() const {
  return _internal_has_sort();
}
inline void BatchTableRequest_Operation::set_has_sort() {
  _oneof_case_[0] = kSort;
}
inline void BatchTableRequest_Operation::clear_sort() {
  if (_internal_has_sort()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.sort_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SortTableRequest* BatchTableRequest_Operation::release_sort() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
  if (_internal_has_sort()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::SortTableRequest* temp = op_.sort_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.sort_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SortTableRequest& BatchTableRequest_Operation::_internal_sort() const {
  return _internal_has_sort()
      ? *op_.sort_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SortTableRequest&>(::io::deephaven::proto::backplane::grpc::_SortTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SortTableRequest& BatchTableRequest_Operation::sort() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
  return _internal_sort();
}
inline ::io::deephaven::proto::backplane::grpc::SortTableRequest* BatchTableRequest_Operation::unsafe_arena_release_sort() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
  if (_internal_has_sort()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SortTableRequest* temp = op_.sort_;
    op_.sort_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_sort(::io::deephaven::proto::backplane::grpc::SortTableRequest* sort) {
  clear_op();
  if (sort) {
    set_has_sort();
    op_.sort_ = sort;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
}
inline ::io::deephaven::proto::backplane::grpc::SortTableRequest* BatchTableRequest_Operation::_internal_mutable_sort() {
  if (!_internal_has_sort()) {
    clear_op();
    set_has_sort();
    op_.sort_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SortTableRequest >(GetArenaForAllocation());
  }
  return op_.sort_;
}
inline ::io::deephaven::proto::backplane::grpc::SortTableRequest* BatchTableRequest_Operation::mutable_sort() {
  ::io::deephaven::proto::backplane::grpc::SortTableRequest* _msg = _internal_mutable_sort();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.HeadOrTailRequest head = 13;
inline bool BatchTableRequest_Operation::_internal_has_head() const {
  return op_case() == kHead;
}
inline bool BatchTableRequest_Operation::has_head() const {
  return _internal_has_head();
}
inline void BatchTableRequest_Operation::set_has_head() {
  _oneof_case_[0] = kHead;
}
inline void BatchTableRequest_Operation::clear_head() {
  if (_internal_has_head()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.head_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::release_head() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
  if (_internal_has_head()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* temp = op_.head_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.head_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& BatchTableRequest_Operation::_internal_head() const {
  return _internal_has_head()
      ? *op_.head_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest&>(::io::deephaven::proto::backplane::grpc::_HeadOrTailRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& BatchTableRequest_Operation::head() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
  return _internal_head();
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
  if (_internal_has_head()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* temp = op_.head_;
    op_.head_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_head(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* head) {
  clear_op();
  if (head) {
    set_has_head();
    op_.head_ = head;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::_internal_mutable_head() {
  if (!_internal_has_head()) {
    clear_op();
    set_has_head();
    op_.head_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest >(GetArenaForAllocation());
  }
  return op_.head_;
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::mutable_head() {
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.HeadOrTailRequest tail = 14;
inline bool BatchTableRequest_Operation::_internal_has_tail() const {
  return op_case() == kTail;
}
inline bool BatchTableRequest_Operation::has_tail() const {
  return _internal_has_tail();
}
inline void BatchTableRequest_Operation::set_has_tail() {
  _oneof_case_[0] = kTail;
}
inline void BatchTableRequest_Operation::clear_tail() {
  if (_internal_has_tail()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.tail_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::release_tail() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
  if (_internal_has_tail()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* temp = op_.tail_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.tail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& BatchTableRequest_Operation::_internal_tail() const {
  return _internal_has_tail()
      ? *op_.tail_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest&>(::io::deephaven::proto::backplane::grpc::_HeadOrTailRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& BatchTableRequest_Operation::tail() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
  return _internal_tail();
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::unsafe_arena_release_tail() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
  if (_internal_has_tail()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* temp = op_.tail_;
    op_.tail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_tail(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* tail) {
  clear_op();
  if (tail) {
    set_has_tail();
    op_.tail_ = tail;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::_internal_mutable_tail() {
  if (!_internal_has_tail()) {
    clear_op();
    set_has_tail();
    op_.tail_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest >(GetArenaForAllocation());
  }
  return op_.tail_;
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::mutable_tail() {
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* _msg = _internal_mutable_tail();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.HeadOrTailByRequest head_by = 15;
inline bool BatchTableRequest_Operation::_internal_has_head_by() const {
  return op_case() == kHeadBy;
}
inline bool BatchTableRequest_Operation::has_head_by() const {
  return _internal_has_head_by();
}
inline void BatchTableRequest_Operation::set_has_head_by() {
  _oneof_case_[0] = kHeadBy;
}
inline void BatchTableRequest_Operation::clear_head_by() {
  if (_internal_has_head_by()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.head_by_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::release_head_by() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
  if (_internal_has_head_by()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* temp = op_.head_by_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.head_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& BatchTableRequest_Operation::_internal_head_by() const {
  return _internal_has_head_by()
      ? *op_.head_by_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest&>(::io::deephaven::proto::backplane::grpc::_HeadOrTailByRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& BatchTableRequest_Operation::head_by() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
  return _internal_head_by();
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::unsafe_arena_release_head_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
  if (_internal_has_head_by()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* temp = op_.head_by_;
    op_.head_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_head_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* head_by) {
  clear_op();
  if (head_by) {
    set_has_head_by();
    op_.head_by_ = head_by;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::_internal_mutable_head_by() {
  if (!_internal_has_head_by()) {
    clear_op();
    set_has_head_by();
    op_.head_by_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest >(GetArenaForAllocation());
  }
  return op_.head_by_;
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::mutable_head_by() {
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* _msg = _internal_mutable_head_by();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.HeadOrTailByRequest tail_by = 16;
inline bool BatchTableRequest_Operation::_internal_has_tail_by() const {
  return op_case() == kTailBy;
}
inline bool BatchTableRequest_Operation::has_tail_by() const {
  return _internal_has_tail_by();
}
inline void BatchTableRequest_Operation::set_has_tail_by() {
  _oneof_case_[0] = kTailBy;
}
inline void BatchTableRequest_Operation::clear_tail_by() {
  if (_internal_has_tail_by()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.tail_by_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::release_tail_by() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
  if (_internal_has_tail_by()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* temp = op_.tail_by_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.tail_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& BatchTableRequest_Operation::_internal_tail_by() const {
  return _internal_has_tail_by()
      ? *op_.tail_by_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest&>(::io::deephaven::proto::backplane::grpc::_HeadOrTailByRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& BatchTableRequest_Operation::tail_by() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
  return _internal_tail_by();
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::unsafe_arena_release_tail_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
  if (_internal_has_tail_by()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* temp = op_.tail_by_;
    op_.tail_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_tail_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* tail_by) {
  clear_op();
  if (tail_by) {
    set_has_tail_by();
    op_.tail_by_ = tail_by;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::_internal_mutable_tail_by() {
  if (!_internal_has_tail_by()) {
    clear_op();
    set_has_tail_by();
    op_.tail_by_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest >(GetArenaForAllocation());
  }
  return op_.tail_by_;
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::mutable_tail_by() {
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* _msg = _internal_mutable_tail_by();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UngroupRequest ungroup = 17;
inline bool BatchTableRequest_Operation::_internal_has_ungroup() const {
  return op_case() == kUngroup;
}
inline bool BatchTableRequest_Operation::has_ungroup() const {
  return _internal_has_ungroup();
}
inline void BatchTableRequest_Operation::set_has_ungroup() {
  _oneof_case_[0] = kUngroup;
}
inline void BatchTableRequest_Operation::clear_ungroup() {
  if (_internal_has_ungroup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.ungroup_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UngroupRequest* BatchTableRequest_Operation::release_ungroup() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
  if (_internal_has_ungroup()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::UngroupRequest* temp = op_.ungroup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.ungroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UngroupRequest& BatchTableRequest_Operation::_internal_ungroup() const {
  return _internal_has_ungroup()
      ? *op_.ungroup_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UngroupRequest&>(::io::deephaven::proto::backplane::grpc::_UngroupRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UngroupRequest& BatchTableRequest_Operation::ungroup() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
  return _internal_ungroup();
}
inline ::io::deephaven::proto::backplane::grpc::UngroupRequest* BatchTableRequest_Operation::unsafe_arena_release_ungroup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
  if (_internal_has_ungroup()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::UngroupRequest* temp = op_.ungroup_;
    op_.ungroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_ungroup(::io::deephaven::proto::backplane::grpc::UngroupRequest* ungroup) {
  clear_op();
  if (ungroup) {
    set_has_ungroup();
    op_.ungroup_ = ungroup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
}
inline ::io::deephaven::proto::backplane::grpc::UngroupRequest* BatchTableRequest_Operation::_internal_mutable_ungroup() {
  if (!_internal_has_ungroup()) {
    clear_op();
    set_has_ungroup();
    op_.ungroup_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UngroupRequest >(GetArenaForAllocation());
  }
  return op_.ungroup_;
}
inline ::io::deephaven::proto::backplane::grpc::UngroupRequest* BatchTableRequest_Operation::mutable_ungroup() {
  ::io::deephaven::proto::backplane::grpc::UngroupRequest* _msg = _internal_mutable_ungroup();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.MergeTablesRequest merge = 18;
inline bool BatchTableRequest_Operation::_internal_has_merge() const {
  return op_case() == kMerge;
}
inline bool BatchTableRequest_Operation::has_merge() const {
  return _internal_has_merge();
}
inline void BatchTableRequest_Operation::set_has_merge() {
  _oneof_case_[0] = kMerge;
}
inline void BatchTableRequest_Operation::clear_merge() {
  if (_internal_has_merge()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.merge_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* BatchTableRequest_Operation::release_merge() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
  if (_internal_has_merge()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* temp = op_.merge_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.merge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& BatchTableRequest_Operation::_internal_merge() const {
  return _internal_has_merge()
      ? *op_.merge_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::MergeTablesRequest&>(::io::deephaven::proto::backplane::grpc::_MergeTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& BatchTableRequest_Operation::merge() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
  return _internal_merge();
}
inline ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_merge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
  if (_internal_has_merge()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* temp = op_.merge_;
    op_.merge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_merge(::io::deephaven::proto::backplane::grpc::MergeTablesRequest* merge) {
  clear_op();
  if (merge) {
    set_has_merge();
    op_.merge_ = merge;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
}
inline ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* BatchTableRequest_Operation::_internal_mutable_merge() {
  if (!_internal_has_merge()) {
    clear_op();
    set_has_merge();
    op_.merge_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::MergeTablesRequest >(GetArenaForAllocation());
  }
  return op_.merge_;
}
inline ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* BatchTableRequest_Operation::mutable_merge() {
  ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* _msg = _internal_mutable_merge();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.ComboAggregateRequest combo_aggregate = 19;
inline bool BatchTableRequest_Operation::_internal_has_combo_aggregate() const {
  return op_case() == kComboAggregate;
}
inline bool BatchTableRequest_Operation::has_combo_aggregate() const {
  return _internal_has_combo_aggregate();
}
inline void BatchTableRequest_Operation::set_has_combo_aggregate() {
  _oneof_case_[0] = kComboAggregate;
}
inline void BatchTableRequest_Operation::clear_combo_aggregate() {
  if (_internal_has_combo_aggregate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.combo_aggregate_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* BatchTableRequest_Operation::release_combo_aggregate() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
  if (_internal_has_combo_aggregate()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* temp = op_.combo_aggregate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.combo_aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& BatchTableRequest_Operation::_internal_combo_aggregate() const {
  return _internal_has_combo_aggregate()
      ? *op_.combo_aggregate_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest&>(::io::deephaven::proto::backplane::grpc::_ComboAggregateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& BatchTableRequest_Operation::combo_aggregate() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
  return _internal_combo_aggregate();
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* BatchTableRequest_Operation::unsafe_arena_release_combo_aggregate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
  if (_internal_has_combo_aggregate()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* temp = op_.combo_aggregate_;
    op_.combo_aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_combo_aggregate(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* combo_aggregate) {
  clear_op();
  if (combo_aggregate) {
    set_has_combo_aggregate();
    op_.combo_aggregate_ = combo_aggregate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* BatchTableRequest_Operation::_internal_mutable_combo_aggregate() {
  if (!_internal_has_combo_aggregate()) {
    clear_op();
    set_has_combo_aggregate();
    op_.combo_aggregate_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest >(GetArenaForAllocation());
  }
  return op_.combo_aggregate_;
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* BatchTableRequest_Operation::mutable_combo_aggregate() {
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* _msg = _internal_mutable_combo_aggregate();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SnapshotTableRequest snapshot = 20;
inline bool BatchTableRequest_Operation::_internal_has_snapshot() const {
  return op_case() == kSnapshot;
}
inline bool BatchTableRequest_Operation::has_snapshot() const {
  return _internal_has_snapshot();
}
inline void BatchTableRequest_Operation::set_has_snapshot() {
  _oneof_case_[0] = kSnapshot;
}
inline void BatchTableRequest_Operation::clear_snapshot() {
  if (_internal_has_snapshot()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.snapshot_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* BatchTableRequest_Operation::release_snapshot() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
  if (_internal_has_snapshot()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* temp = op_.snapshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& BatchTableRequest_Operation::_internal_snapshot() const {
  return _internal_has_snapshot()
      ? *op_.snapshot_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest&>(::io::deephaven::proto::backplane::grpc::_SnapshotTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& BatchTableRequest_Operation::snapshot() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
  return _internal_snapshot();
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* BatchTableRequest_Operation::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
  if (_internal_has_snapshot()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* temp = op_.snapshot_;
    op_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_snapshot(::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* snapshot) {
  clear_op();
  if (snapshot) {
    set_has_snapshot();
    op_.snapshot_ = snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* BatchTableRequest_Operation::_internal_mutable_snapshot() {
  if (!_internal_has_snapshot()) {
    clear_op();
    set_has_snapshot();
    op_.snapshot_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest >(GetArenaForAllocation());
  }
  return op_.snapshot_;
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* BatchTableRequest_Operation::mutable_snapshot() {
  ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.FlattenRequest flatten = 21;
inline bool BatchTableRequest_Operation::_internal_has_flatten() const {
  return op_case() == kFlatten;
}
inline bool BatchTableRequest_Operation::has_flatten() const {
  return _internal_has_flatten();
}
inline void BatchTableRequest_Operation::set_has_flatten() {
  _oneof_case_[0] = kFlatten;
}
inline void BatchTableRequest_Operation::clear_flatten() {
  if (_internal_has_flatten()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.flatten_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::FlattenRequest* BatchTableRequest_Operation::release_flatten() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
  if (_internal_has_flatten()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::FlattenRequest* temp = op_.flatten_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.flatten_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::FlattenRequest& BatchTableRequest_Operation::_internal_flatten() const {
  return _internal_has_flatten()
      ? *op_.flatten_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::FlattenRequest&>(::io::deephaven::proto::backplane::grpc::_FlattenRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::FlattenRequest& BatchTableRequest_Operation::flatten() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
  return _internal_flatten();
}
inline ::io::deephaven::proto::backplane::grpc::FlattenRequest* BatchTableRequest_Operation::unsafe_arena_release_flatten() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
  if (_internal_has_flatten()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::FlattenRequest* temp = op_.flatten_;
    op_.flatten_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_flatten(::io::deephaven::proto::backplane::grpc::FlattenRequest* flatten) {
  clear_op();
  if (flatten) {
    set_has_flatten();
    op_.flatten_ = flatten;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
}
inline ::io::deephaven::proto::backplane::grpc::FlattenRequest* BatchTableRequest_Operation::_internal_mutable_flatten() {
  if (!_internal_has_flatten()) {
    clear_op();
    set_has_flatten();
    op_.flatten_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::FlattenRequest >(GetArenaForAllocation());
  }
  return op_.flatten_;
}
inline ::io::deephaven::proto::backplane::grpc::FlattenRequest* BatchTableRequest_Operation::mutable_flatten() {
  ::io::deephaven::proto::backplane::grpc::FlattenRequest* _msg = _internal_mutable_flatten();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest run_chart_downsample = 22;
inline bool BatchTableRequest_Operation::_internal_has_run_chart_downsample() const {
  return op_case() == kRunChartDownsample;
}
inline bool BatchTableRequest_Operation::has_run_chart_downsample() const {
  return _internal_has_run_chart_downsample();
}
inline void BatchTableRequest_Operation::set_has_run_chart_downsample() {
  _oneof_case_[0] = kRunChartDownsample;
}
inline void BatchTableRequest_Operation::clear_run_chart_downsample() {
  if (_internal_has_run_chart_downsample()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.run_chart_downsample_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* BatchTableRequest_Operation::release_run_chart_downsample() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
  if (_internal_has_run_chart_downsample()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* temp = op_.run_chart_downsample_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.run_chart_downsample_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& BatchTableRequest_Operation::_internal_run_chart_downsample() const {
  return _internal_has_run_chart_downsample()
      ? *op_.run_chart_downsample_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest&>(::io::deephaven::proto::backplane::grpc::_RunChartDownsampleRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& BatchTableRequest_Operation::run_chart_downsample() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
  return _internal_run_chart_downsample();
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* BatchTableRequest_Operation::unsafe_arena_release_run_chart_downsample() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
  if (_internal_has_run_chart_downsample()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* temp = op_.run_chart_downsample_;
    op_.run_chart_downsample_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_run_chart_downsample(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* run_chart_downsample) {
  clear_op();
  if (run_chart_downsample) {
    set_has_run_chart_downsample();
    op_.run_chart_downsample_ = run_chart_downsample;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* BatchTableRequest_Operation::_internal_mutable_run_chart_downsample() {
  if (!_internal_has_run_chart_downsample()) {
    clear_op();
    set_has_run_chart_downsample();
    op_.run_chart_downsample_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest >(GetArenaForAllocation());
  }
  return op_.run_chart_downsample_;
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* BatchTableRequest_Operation::mutable_run_chart_downsample() {
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* _msg = _internal_mutable_run_chart_downsample();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest cross_join = 23;
inline bool BatchTableRequest_Operation::_internal_has_cross_join() const {
  return op_case() == kCrossJoin;
}
inline bool BatchTableRequest_Operation::has_cross_join() const {
  return _internal_has_cross_join();
}
inline void BatchTableRequest_Operation::set_has_cross_join() {
  _oneof_case_[0] = kCrossJoin;
}
inline void BatchTableRequest_Operation::clear_cross_join() {
  if (_internal_has_cross_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.cross_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* BatchTableRequest_Operation::release_cross_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
  if (_internal_has_cross_join()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* temp = op_.cross_join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.cross_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& BatchTableRequest_Operation::_internal_cross_join() const {
  return _internal_has_cross_join()
      ? *op_.cross_join_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_CrossJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& BatchTableRequest_Operation::cross_join() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
  return _internal_cross_join();
}
inline ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_cross_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
  if (_internal_has_cross_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* temp = op_.cross_join_;
    op_.cross_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_cross_join(::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* cross_join) {
  clear_op();
  if (cross_join) {
    set_has_cross_join();
    op_.cross_join_ = cross_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
}
inline ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_cross_join() {
  if (!_internal_has_cross_join()) {
    clear_op();
    set_has_cross_join();
    op_.cross_join_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest >(GetArenaForAllocation());
  }
  return op_.cross_join_;
}
inline ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* BatchTableRequest_Operation::mutable_cross_join() {
  ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* _msg = _internal_mutable_cross_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest natural_join = 24;
inline bool BatchTableRequest_Operation::_internal_has_natural_join() const {
  return op_case() == kNaturalJoin;
}
inline bool BatchTableRequest_Operation::has_natural_join() const {
  return _internal_has_natural_join();
}
inline void BatchTableRequest_Operation::set_has_natural_join() {
  _oneof_case_[0] = kNaturalJoin;
}
inline void BatchTableRequest_Operation::clear_natural_join() {
  if (_internal_has_natural_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.natural_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* BatchTableRequest_Operation::release_natural_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
  if (_internal_has_natural_join()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* temp = op_.natural_join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.natural_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& BatchTableRequest_Operation::_internal_natural_join() const {
  return _internal_has_natural_join()
      ? *op_.natural_join_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_NaturalJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& BatchTableRequest_Operation::natural_join() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
  return _internal_natural_join();
}
inline ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_natural_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
  if (_internal_has_natural_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* temp = op_.natural_join_;
    op_.natural_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_natural_join(::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* natural_join) {
  clear_op();
  if (natural_join) {
    set_has_natural_join();
    op_.natural_join_ = natural_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
}
inline ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_natural_join() {
  if (!_internal_has_natural_join()) {
    clear_op();
    set_has_natural_join();
    op_.natural_join_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest >(GetArenaForAllocation());
  }
  return op_.natural_join_;
}
inline ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* BatchTableRequest_Operation::mutable_natural_join() {
  ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* _msg = _internal_mutable_natural_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest exact_join = 25;
inline bool BatchTableRequest_Operation::_internal_has_exact_join() const {
  return op_case() == kExactJoin;
}
inline bool BatchTableRequest_Operation::has_exact_join() const {
  return _internal_has_exact_join();
}
inline void BatchTableRequest_Operation::set_has_exact_join() {
  _oneof_case_[0] = kExactJoin;
}
inline void BatchTableRequest_Operation::clear_exact_join() {
  if (_internal_has_exact_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.exact_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* BatchTableRequest_Operation::release_exact_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
  if (_internal_has_exact_join()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* temp = op_.exact_join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.exact_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& BatchTableRequest_Operation::_internal_exact_join() const {
  return _internal_has_exact_join()
      ? *op_.exact_join_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_ExactJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& BatchTableRequest_Operation::exact_join() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
  return _internal_exact_join();
}
inline ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_exact_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
  if (_internal_has_exact_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* temp = op_.exact_join_;
    op_.exact_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_exact_join(::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* exact_join) {
  clear_op();
  if (exact_join) {
    set_has_exact_join();
    op_.exact_join_ = exact_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
}
inline ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_exact_join() {
  if (!_internal_has_exact_join()) {
    clear_op();
    set_has_exact_join();
    op_.exact_join_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest >(GetArenaForAllocation());
  }
  return op_.exact_join_;
}
inline ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* BatchTableRequest_Operation::mutable_exact_join() {
  ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* _msg = _internal_mutable_exact_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest left_join = 26;
inline bool BatchTableRequest_Operation::_internal_has_left_join() const {
  return op_case() == kLeftJoin;
}
inline bool BatchTableRequest_Operation::has_left_join() const {
  return _internal_has_left_join();
}
inline void BatchTableRequest_Operation::set_has_left_join() {
  _oneof_case_[0] = kLeftJoin;
}
inline void BatchTableRequest_Operation::clear_left_join() {
  if (_internal_has_left_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.left_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* BatchTableRequest_Operation::release_left_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
  if (_internal_has_left_join()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* temp = op_.left_join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.left_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& BatchTableRequest_Operation::_internal_left_join() const {
  return _internal_has_left_join()
      ? *op_.left_join_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_LeftJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& BatchTableRequest_Operation::left_join() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
  return _internal_left_join();
}
inline ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_left_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
  if (_internal_has_left_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* temp = op_.left_join_;
    op_.left_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_left_join(::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* left_join) {
  clear_op();
  if (left_join) {
    set_has_left_join();
    op_.left_join_ = left_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
}
inline ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_left_join() {
  if (!_internal_has_left_join()) {
    clear_op();
    set_has_left_join();
    op_.left_join_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest >(GetArenaForAllocation());
  }
  return op_.left_join_;
}
inline ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* BatchTableRequest_Operation::mutable_left_join() {
  ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* _msg = _internal_mutable_left_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest as_of_join = 27;
inline bool BatchTableRequest_Operation::_internal_has_as_of_join() const {
  return op_case() == kAsOfJoin;
}
inline bool BatchTableRequest_Operation::has_as_of_join() const {
  return _internal_has_as_of_join();
}
inline void BatchTableRequest_Operation::set_has_as_of_join() {
  _oneof_case_[0] = kAsOfJoin;
}
inline void BatchTableRequest_Operation::clear_as_of_join() {
  if (_internal_has_as_of_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.as_of_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* BatchTableRequest_Operation::release_as_of_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
  if (_internal_has_as_of_join()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* temp = op_.as_of_join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.as_of_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& BatchTableRequest_Operation::_internal_as_of_join() const {
  return _internal_has_as_of_join()
      ? *op_.as_of_join_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_AsOfJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& BatchTableRequest_Operation::as_of_join() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
  return _internal_as_of_join();
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_as_of_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
  if (_internal_has_as_of_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* temp = op_.as_of_join_;
    op_.as_of_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_as_of_join(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* as_of_join) {
  clear_op();
  if (as_of_join) {
    set_has_as_of_join();
    op_.as_of_join_ = as_of_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_as_of_join() {
  if (!_internal_has_as_of_join()) {
    clear_op();
    set_has_as_of_join();
    op_.as_of_join_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest >(GetArenaForAllocation());
  }
  return op_.as_of_join_;
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* BatchTableRequest_Operation::mutable_as_of_join() {
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* _msg = _internal_mutable_as_of_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.FetchTableRequest fetch_table = 28;
inline bool BatchTableRequest_Operation::_internal_has_fetch_table() const {
  return op_case() == kFetchTable;
}
inline bool BatchTableRequest_Operation::has_fetch_table() const {
  return _internal_has_fetch_table();
}
inline void BatchTableRequest_Operation::set_has_fetch_table() {
  _oneof_case_[0] = kFetchTable;
}
inline void BatchTableRequest_Operation::clear_fetch_table() {
  if (_internal_has_fetch_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.fetch_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::FetchTableRequest* BatchTableRequest_Operation::release_fetch_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
  if (_internal_has_fetch_table()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::FetchTableRequest* temp = op_.fetch_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.fetch_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& BatchTableRequest_Operation::_internal_fetch_table() const {
  return _internal_has_fetch_table()
      ? *op_.fetch_table_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::FetchTableRequest&>(::io::deephaven::proto::backplane::grpc::_FetchTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& BatchTableRequest_Operation::fetch_table() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
  return _internal_fetch_table();
}
inline ::io::deephaven::proto::backplane::grpc::FetchTableRequest* BatchTableRequest_Operation::unsafe_arena_release_fetch_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
  if (_internal_has_fetch_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::FetchTableRequest* temp = op_.fetch_table_;
    op_.fetch_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_fetch_table(::io::deephaven::proto::backplane::grpc::FetchTableRequest* fetch_table) {
  clear_op();
  if (fetch_table) {
    set_has_fetch_table();
    op_.fetch_table_ = fetch_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
}
inline ::io::deephaven::proto::backplane::grpc::FetchTableRequest* BatchTableRequest_Operation::_internal_mutable_fetch_table() {
  if (!_internal_has_fetch_table()) {
    clear_op();
    set_has_fetch_table();
    op_.fetch_table_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::FetchTableRequest >(GetArenaForAllocation());
  }
  return op_.fetch_table_;
}
inline ::io::deephaven::proto::backplane::grpc::FetchTableRequest* BatchTableRequest_Operation::mutable_fetch_table() {
  ::io::deephaven::proto::backplane::grpc::FetchTableRequest* _msg = _internal_mutable_fetch_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.FetchPandasTableRequest fetch_pandas_table = 29;
inline bool BatchTableRequest_Operation::_internal_has_fetch_pandas_table() const {
  return op_case() == kFetchPandasTable;
}
inline bool BatchTableRequest_Operation::has_fetch_pandas_table() const {
  return _internal_has_fetch_pandas_table();
}
inline void BatchTableRequest_Operation::set_has_fetch_pandas_table() {
  _oneof_case_[0] = kFetchPandasTable;
}
inline void BatchTableRequest_Operation::clear_fetch_pandas_table() {
  if (_internal_has_fetch_pandas_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.fetch_pandas_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* BatchTableRequest_Operation::release_fetch_pandas_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_pandas_table)
  if (_internal_has_fetch_pandas_table()) {
    clear_has_op();
      ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* temp = op_.fetch_pandas_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.fetch_pandas_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& BatchTableRequest_Operation::_internal_fetch_pandas_table() const {
  return _internal_has_fetch_pandas_table()
      ? *op_.fetch_pandas_table_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest&>(::io::deephaven::proto::backplane::grpc::_FetchPandasTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& BatchTableRequest_Operation::fetch_pandas_table() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_pandas_table)
  return _internal_fetch_pandas_table();
}
inline ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* BatchTableRequest_Operation::unsafe_arena_release_fetch_pandas_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_pandas_table)
  if (_internal_has_fetch_pandas_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* temp = op_.fetch_pandas_table_;
    op_.fetch_pandas_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_fetch_pandas_table(::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* fetch_pandas_table) {
  clear_op();
  if (fetch_pandas_table) {
    set_has_fetch_pandas_table();
    op_.fetch_pandas_table_ = fetch_pandas_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_pandas_table)
}
inline ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* BatchTableRequest_Operation::_internal_mutable_fetch_pandas_table() {
  if (!_internal_has_fetch_pandas_table()) {
    clear_op();
    set_has_fetch_pandas_table();
    op_.fetch_pandas_table_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest >(GetArenaForAllocation());
  }
  return op_.fetch_pandas_table_;
}
inline ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* BatchTableRequest_Operation::mutable_fetch_pandas_table() {
  ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* _msg = _internal_mutable_fetch_pandas_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_pandas_table)
  return _msg;
}

inline bool BatchTableRequest_Operation::has_op() const {
  return op_case() != OP_NOT_SET;
}
inline void BatchTableRequest_Operation::clear_has_op() {
  _oneof_case_[0] = OP_NOT_SET;
}
inline BatchTableRequest_Operation::OpCase BatchTableRequest_Operation::op_case() const {
  return BatchTableRequest_Operation::OpCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BatchTableRequest

// repeated .io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation ops = 1;
inline int BatchTableRequest::_internal_ops_size() const {
  return ops_.size();
}
inline int BatchTableRequest::ops_size() const {
  return _internal_ops_size();
}
inline void BatchTableRequest::clear_ops() {
  ops_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* BatchTableRequest::mutable_ops(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return ops_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation >*
BatchTableRequest::mutable_ops() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return &ops_;
}
inline const ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation& BatchTableRequest::_internal_ops(int index) const {
  return ops_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation& BatchTableRequest::ops(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return _internal_ops(index);
}
inline ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* BatchTableRequest::_internal_add_ops() {
  return ops_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* BatchTableRequest::add_ops() {
  ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* _add = _internal_add_ops();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation >&
BatchTableRequest::ops() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return ops_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace grpc
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule>() {
  return ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType>() {
  return ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection>() {
  return ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation>() {
  return ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::CaseSensitivity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::CaseSensitivity>() {
  return ::io::deephaven::proto::backplane::grpc::CaseSensitivity_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::MatchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::MatchType>() {
  return ::io::deephaven::proto::backplane::grpc::MatchType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2ftable_2eproto
