// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: deephaven/proto/table.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2ftable_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2ftable_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "deephaven/proto/ticket.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_deephaven_2fproto_2ftable_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_deephaven_2fproto_2ftable_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_deephaven_2fproto_2ftable_2eproto;
namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace grpc {
class AggSpec;
struct AggSpecDefaultTypeInternal;
extern AggSpecDefaultTypeInternal _AggSpec_default_instance_;
class AggSpec_AggSpecAbsSum;
struct AggSpec_AggSpecAbsSumDefaultTypeInternal;
extern AggSpec_AggSpecAbsSumDefaultTypeInternal _AggSpec_AggSpecAbsSum_default_instance_;
class AggSpec_AggSpecApproximatePercentile;
struct AggSpec_AggSpecApproximatePercentileDefaultTypeInternal;
extern AggSpec_AggSpecApproximatePercentileDefaultTypeInternal _AggSpec_AggSpecApproximatePercentile_default_instance_;
class AggSpec_AggSpecAvg;
struct AggSpec_AggSpecAvgDefaultTypeInternal;
extern AggSpec_AggSpecAvgDefaultTypeInternal _AggSpec_AggSpecAvg_default_instance_;
class AggSpec_AggSpecCountDistinct;
struct AggSpec_AggSpecCountDistinctDefaultTypeInternal;
extern AggSpec_AggSpecCountDistinctDefaultTypeInternal _AggSpec_AggSpecCountDistinct_default_instance_;
class AggSpec_AggSpecDistinct;
struct AggSpec_AggSpecDistinctDefaultTypeInternal;
extern AggSpec_AggSpecDistinctDefaultTypeInternal _AggSpec_AggSpecDistinct_default_instance_;
class AggSpec_AggSpecFirst;
struct AggSpec_AggSpecFirstDefaultTypeInternal;
extern AggSpec_AggSpecFirstDefaultTypeInternal _AggSpec_AggSpecFirst_default_instance_;
class AggSpec_AggSpecFormula;
struct AggSpec_AggSpecFormulaDefaultTypeInternal;
extern AggSpec_AggSpecFormulaDefaultTypeInternal _AggSpec_AggSpecFormula_default_instance_;
class AggSpec_AggSpecFreeze;
struct AggSpec_AggSpecFreezeDefaultTypeInternal;
extern AggSpec_AggSpecFreezeDefaultTypeInternal _AggSpec_AggSpecFreeze_default_instance_;
class AggSpec_AggSpecGroup;
struct AggSpec_AggSpecGroupDefaultTypeInternal;
extern AggSpec_AggSpecGroupDefaultTypeInternal _AggSpec_AggSpecGroup_default_instance_;
class AggSpec_AggSpecLast;
struct AggSpec_AggSpecLastDefaultTypeInternal;
extern AggSpec_AggSpecLastDefaultTypeInternal _AggSpec_AggSpecLast_default_instance_;
class AggSpec_AggSpecMax;
struct AggSpec_AggSpecMaxDefaultTypeInternal;
extern AggSpec_AggSpecMaxDefaultTypeInternal _AggSpec_AggSpecMax_default_instance_;
class AggSpec_AggSpecMedian;
struct AggSpec_AggSpecMedianDefaultTypeInternal;
extern AggSpec_AggSpecMedianDefaultTypeInternal _AggSpec_AggSpecMedian_default_instance_;
class AggSpec_AggSpecMin;
struct AggSpec_AggSpecMinDefaultTypeInternal;
extern AggSpec_AggSpecMinDefaultTypeInternal _AggSpec_AggSpecMin_default_instance_;
class AggSpec_AggSpecNonUniqueSentinel;
struct AggSpec_AggSpecNonUniqueSentinelDefaultTypeInternal;
extern AggSpec_AggSpecNonUniqueSentinelDefaultTypeInternal _AggSpec_AggSpecNonUniqueSentinel_default_instance_;
class AggSpec_AggSpecPercentile;
struct AggSpec_AggSpecPercentileDefaultTypeInternal;
extern AggSpec_AggSpecPercentileDefaultTypeInternal _AggSpec_AggSpecPercentile_default_instance_;
class AggSpec_AggSpecSorted;
struct AggSpec_AggSpecSortedDefaultTypeInternal;
extern AggSpec_AggSpecSortedDefaultTypeInternal _AggSpec_AggSpecSorted_default_instance_;
class AggSpec_AggSpecSortedColumn;
struct AggSpec_AggSpecSortedColumnDefaultTypeInternal;
extern AggSpec_AggSpecSortedColumnDefaultTypeInternal _AggSpec_AggSpecSortedColumn_default_instance_;
class AggSpec_AggSpecStd;
struct AggSpec_AggSpecStdDefaultTypeInternal;
extern AggSpec_AggSpecStdDefaultTypeInternal _AggSpec_AggSpecStd_default_instance_;
class AggSpec_AggSpecSum;
struct AggSpec_AggSpecSumDefaultTypeInternal;
extern AggSpec_AggSpecSumDefaultTypeInternal _AggSpec_AggSpecSum_default_instance_;
class AggSpec_AggSpecTDigest;
struct AggSpec_AggSpecTDigestDefaultTypeInternal;
extern AggSpec_AggSpecTDigestDefaultTypeInternal _AggSpec_AggSpecTDigest_default_instance_;
class AggSpec_AggSpecUnique;
struct AggSpec_AggSpecUniqueDefaultTypeInternal;
extern AggSpec_AggSpecUniqueDefaultTypeInternal _AggSpec_AggSpecUnique_default_instance_;
class AggSpec_AggSpecVar;
struct AggSpec_AggSpecVarDefaultTypeInternal;
extern AggSpec_AggSpecVarDefaultTypeInternal _AggSpec_AggSpecVar_default_instance_;
class AggSpec_AggSpecWeighted;
struct AggSpec_AggSpecWeightedDefaultTypeInternal;
extern AggSpec_AggSpecWeightedDefaultTypeInternal _AggSpec_AggSpecWeighted_default_instance_;
class AggregateAllRequest;
struct AggregateAllRequestDefaultTypeInternal;
extern AggregateAllRequestDefaultTypeInternal _AggregateAllRequest_default_instance_;
class AggregateRequest;
struct AggregateRequestDefaultTypeInternal;
extern AggregateRequestDefaultTypeInternal _AggregateRequest_default_instance_;
class Aggregation;
struct AggregationDefaultTypeInternal;
extern AggregationDefaultTypeInternal _Aggregation_default_instance_;
class Aggregation_AggregationColumns;
struct Aggregation_AggregationColumnsDefaultTypeInternal;
extern Aggregation_AggregationColumnsDefaultTypeInternal _Aggregation_AggregationColumns_default_instance_;
class Aggregation_AggregationCount;
struct Aggregation_AggregationCountDefaultTypeInternal;
extern Aggregation_AggregationCountDefaultTypeInternal _Aggregation_AggregationCount_default_instance_;
class Aggregation_AggregationPartition;
struct Aggregation_AggregationPartitionDefaultTypeInternal;
extern Aggregation_AggregationPartitionDefaultTypeInternal _Aggregation_AggregationPartition_default_instance_;
class Aggregation_AggregationRowKey;
struct Aggregation_AggregationRowKeyDefaultTypeInternal;
extern Aggregation_AggregationRowKeyDefaultTypeInternal _Aggregation_AggregationRowKey_default_instance_;
class AjRajTablesRequest;
struct AjRajTablesRequestDefaultTypeInternal;
extern AjRajTablesRequestDefaultTypeInternal _AjRajTablesRequest_default_instance_;
class AndCondition;
struct AndConditionDefaultTypeInternal;
extern AndConditionDefaultTypeInternal _AndCondition_default_instance_;
class ApplyPreviewColumnsRequest;
struct ApplyPreviewColumnsRequestDefaultTypeInternal;
extern ApplyPreviewColumnsRequestDefaultTypeInternal _ApplyPreviewColumnsRequest_default_instance_;
class AsOfJoinTablesRequest;
struct AsOfJoinTablesRequestDefaultTypeInternal;
extern AsOfJoinTablesRequestDefaultTypeInternal _AsOfJoinTablesRequest_default_instance_;
class BatchTableRequest;
struct BatchTableRequestDefaultTypeInternal;
extern BatchTableRequestDefaultTypeInternal _BatchTableRequest_default_instance_;
class BatchTableRequest_Operation;
struct BatchTableRequest_OperationDefaultTypeInternal;
extern BatchTableRequest_OperationDefaultTypeInternal _BatchTableRequest_Operation_default_instance_;
class ComboAggregateRequest;
struct ComboAggregateRequestDefaultTypeInternal;
extern ComboAggregateRequestDefaultTypeInternal _ComboAggregateRequest_default_instance_;
class ComboAggregateRequest_Aggregate;
struct ComboAggregateRequest_AggregateDefaultTypeInternal;
extern ComboAggregateRequest_AggregateDefaultTypeInternal _ComboAggregateRequest_Aggregate_default_instance_;
class CompareCondition;
struct CompareConditionDefaultTypeInternal;
extern CompareConditionDefaultTypeInternal _CompareCondition_default_instance_;
class Condition;
struct ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class ContainsCondition;
struct ContainsConditionDefaultTypeInternal;
extern ContainsConditionDefaultTypeInternal _ContainsCondition_default_instance_;
class CreateInputTableRequest;
struct CreateInputTableRequestDefaultTypeInternal;
extern CreateInputTableRequestDefaultTypeInternal _CreateInputTableRequest_default_instance_;
class CreateInputTableRequest_InputTableKind;
struct CreateInputTableRequest_InputTableKindDefaultTypeInternal;
extern CreateInputTableRequest_InputTableKindDefaultTypeInternal _CreateInputTableRequest_InputTableKind_default_instance_;
class CreateInputTableRequest_InputTableKind_InMemoryAppendOnly;
struct CreateInputTableRequest_InputTableKind_InMemoryAppendOnlyDefaultTypeInternal;
extern CreateInputTableRequest_InputTableKind_InMemoryAppendOnlyDefaultTypeInternal _CreateInputTableRequest_InputTableKind_InMemoryAppendOnly_default_instance_;
class CreateInputTableRequest_InputTableKind_InMemoryKeyBacked;
struct CreateInputTableRequest_InputTableKind_InMemoryKeyBackedDefaultTypeInternal;
extern CreateInputTableRequest_InputTableKind_InMemoryKeyBackedDefaultTypeInternal _CreateInputTableRequest_InputTableKind_InMemoryKeyBacked_default_instance_;
class CrossJoinTablesRequest;
struct CrossJoinTablesRequestDefaultTypeInternal;
extern CrossJoinTablesRequestDefaultTypeInternal _CrossJoinTablesRequest_default_instance_;
class DropColumnsRequest;
struct DropColumnsRequestDefaultTypeInternal;
extern DropColumnsRequestDefaultTypeInternal _DropColumnsRequest_default_instance_;
class EmptyTableRequest;
struct EmptyTableRequestDefaultTypeInternal;
extern EmptyTableRequestDefaultTypeInternal _EmptyTableRequest_default_instance_;
class ExactJoinTablesRequest;
struct ExactJoinTablesRequestDefaultTypeInternal;
extern ExactJoinTablesRequestDefaultTypeInternal _ExactJoinTablesRequest_default_instance_;
class ExportedTableCreationResponse;
struct ExportedTableCreationResponseDefaultTypeInternal;
extern ExportedTableCreationResponseDefaultTypeInternal _ExportedTableCreationResponse_default_instance_;
class ExportedTableUpdateMessage;
struct ExportedTableUpdateMessageDefaultTypeInternal;
extern ExportedTableUpdateMessageDefaultTypeInternal _ExportedTableUpdateMessage_default_instance_;
class ExportedTableUpdatesRequest;
struct ExportedTableUpdatesRequestDefaultTypeInternal;
extern ExportedTableUpdatesRequestDefaultTypeInternal _ExportedTableUpdatesRequest_default_instance_;
class FetchTableRequest;
struct FetchTableRequestDefaultTypeInternal;
extern FetchTableRequestDefaultTypeInternal _FetchTableRequest_default_instance_;
class FilterTableRequest;
struct FilterTableRequestDefaultTypeInternal;
extern FilterTableRequestDefaultTypeInternal _FilterTableRequest_default_instance_;
class FlattenRequest;
struct FlattenRequestDefaultTypeInternal;
extern FlattenRequestDefaultTypeInternal _FlattenRequest_default_instance_;
class HeadOrTailByRequest;
struct HeadOrTailByRequestDefaultTypeInternal;
extern HeadOrTailByRequestDefaultTypeInternal _HeadOrTailByRequest_default_instance_;
class HeadOrTailRequest;
struct HeadOrTailRequestDefaultTypeInternal;
extern HeadOrTailRequestDefaultTypeInternal _HeadOrTailRequest_default_instance_;
class InCondition;
struct InConditionDefaultTypeInternal;
extern InConditionDefaultTypeInternal _InCondition_default_instance_;
class InvokeCondition;
struct InvokeConditionDefaultTypeInternal;
extern InvokeConditionDefaultTypeInternal _InvokeCondition_default_instance_;
class IsNullCondition;
struct IsNullConditionDefaultTypeInternal;
extern IsNullConditionDefaultTypeInternal _IsNullCondition_default_instance_;
class LeftJoinTablesRequest;
struct LeftJoinTablesRequestDefaultTypeInternal;
extern LeftJoinTablesRequestDefaultTypeInternal _LeftJoinTablesRequest_default_instance_;
class Literal;
struct LiteralDefaultTypeInternal;
extern LiteralDefaultTypeInternal _Literal_default_instance_;
class MatchesCondition;
struct MatchesConditionDefaultTypeInternal;
extern MatchesConditionDefaultTypeInternal _MatchesCondition_default_instance_;
class MathContext;
struct MathContextDefaultTypeInternal;
extern MathContextDefaultTypeInternal _MathContext_default_instance_;
class MergeTablesRequest;
struct MergeTablesRequestDefaultTypeInternal;
extern MergeTablesRequestDefaultTypeInternal _MergeTablesRequest_default_instance_;
class MetaTableRequest;
struct MetaTableRequestDefaultTypeInternal;
extern MetaTableRequestDefaultTypeInternal _MetaTableRequest_default_instance_;
class NaturalJoinTablesRequest;
struct NaturalJoinTablesRequestDefaultTypeInternal;
extern NaturalJoinTablesRequestDefaultTypeInternal _NaturalJoinTablesRequest_default_instance_;
class NotCondition;
struct NotConditionDefaultTypeInternal;
extern NotConditionDefaultTypeInternal _NotCondition_default_instance_;
class OrCondition;
struct OrConditionDefaultTypeInternal;
extern OrConditionDefaultTypeInternal _OrCondition_default_instance_;
class RangeJoinTablesRequest;
struct RangeJoinTablesRequestDefaultTypeInternal;
extern RangeJoinTablesRequestDefaultTypeInternal _RangeJoinTablesRequest_default_instance_;
class Reference;
struct ReferenceDefaultTypeInternal;
extern ReferenceDefaultTypeInternal _Reference_default_instance_;
class RunChartDownsampleRequest;
struct RunChartDownsampleRequestDefaultTypeInternal;
extern RunChartDownsampleRequestDefaultTypeInternal _RunChartDownsampleRequest_default_instance_;
class RunChartDownsampleRequest_ZoomRange;
struct RunChartDownsampleRequest_ZoomRangeDefaultTypeInternal;
extern RunChartDownsampleRequest_ZoomRangeDefaultTypeInternal _RunChartDownsampleRequest_ZoomRange_default_instance_;
class SearchCondition;
struct SearchConditionDefaultTypeInternal;
extern SearchConditionDefaultTypeInternal _SearchCondition_default_instance_;
class SeekRowRequest;
struct SeekRowRequestDefaultTypeInternal;
extern SeekRowRequestDefaultTypeInternal _SeekRowRequest_default_instance_;
class SeekRowResponse;
struct SeekRowResponseDefaultTypeInternal;
extern SeekRowResponseDefaultTypeInternal _SeekRowResponse_default_instance_;
class SelectDistinctRequest;
struct SelectDistinctRequestDefaultTypeInternal;
extern SelectDistinctRequestDefaultTypeInternal _SelectDistinctRequest_default_instance_;
class SelectOrUpdateRequest;
struct SelectOrUpdateRequestDefaultTypeInternal;
extern SelectOrUpdateRequestDefaultTypeInternal _SelectOrUpdateRequest_default_instance_;
class SnapshotTableRequest;
struct SnapshotTableRequestDefaultTypeInternal;
extern SnapshotTableRequestDefaultTypeInternal _SnapshotTableRequest_default_instance_;
class SnapshotWhenTableRequest;
struct SnapshotWhenTableRequestDefaultTypeInternal;
extern SnapshotWhenTableRequestDefaultTypeInternal _SnapshotWhenTableRequest_default_instance_;
class SortDescriptor;
struct SortDescriptorDefaultTypeInternal;
extern SortDescriptorDefaultTypeInternal _SortDescriptor_default_instance_;
class SortTableRequest;
struct SortTableRequestDefaultTypeInternal;
extern SortTableRequestDefaultTypeInternal _SortTableRequest_default_instance_;
class TableReference;
struct TableReferenceDefaultTypeInternal;
extern TableReferenceDefaultTypeInternal _TableReference_default_instance_;
class TimeTableRequest;
struct TimeTableRequestDefaultTypeInternal;
extern TimeTableRequestDefaultTypeInternal _TimeTableRequest_default_instance_;
class UngroupRequest;
struct UngroupRequestDefaultTypeInternal;
extern UngroupRequestDefaultTypeInternal _UngroupRequest_default_instance_;
class UnstructuredFilterTableRequest;
struct UnstructuredFilterTableRequestDefaultTypeInternal;
extern UnstructuredFilterTableRequestDefaultTypeInternal _UnstructuredFilterTableRequest_default_instance_;
class UpdateByDeltaOptions;
struct UpdateByDeltaOptionsDefaultTypeInternal;
extern UpdateByDeltaOptionsDefaultTypeInternal _UpdateByDeltaOptions_default_instance_;
class UpdateByEmOptions;
struct UpdateByEmOptionsDefaultTypeInternal;
extern UpdateByEmOptionsDefaultTypeInternal _UpdateByEmOptions_default_instance_;
class UpdateByRequest;
struct UpdateByRequestDefaultTypeInternal;
extern UpdateByRequestDefaultTypeInternal _UpdateByRequest_default_instance_;
class UpdateByRequest_UpdateByOperation;
struct UpdateByRequest_UpdateByOperationDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperationDefaultTypeInternal _UpdateByRequest_UpdateByOperation_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn;
struct UpdateByRequest_UpdateByOperation_UpdateByColumnDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumnDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpecDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpecDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMaxDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMaxDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMinDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMinDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProductDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProductDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSumDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSumDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDeltaDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDeltaDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMaxDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMaxDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMinDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMinDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStdDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStdDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmaDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmaDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmsDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmsDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFillDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFillDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvgDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvgDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCountDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCountDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroupDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroupDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMaxDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMaxDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMinDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMinDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProductDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProductDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStdDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStdDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSumDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSumDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvgDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvgDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg_default_instance_;
class UpdateByRequest_UpdateByOptions;
struct UpdateByRequest_UpdateByOptionsDefaultTypeInternal;
extern UpdateByRequest_UpdateByOptionsDefaultTypeInternal _UpdateByRequest_UpdateByOptions_default_instance_;
class UpdateByWindowScale;
struct UpdateByWindowScaleDefaultTypeInternal;
extern UpdateByWindowScaleDefaultTypeInternal _UpdateByWindowScale_default_instance_;
class UpdateByWindowScale_UpdateByWindowTicks;
struct UpdateByWindowScale_UpdateByWindowTicksDefaultTypeInternal;
extern UpdateByWindowScale_UpdateByWindowTicksDefaultTypeInternal _UpdateByWindowScale_UpdateByWindowTicks_default_instance_;
class UpdateByWindowScale_UpdateByWindowTime;
struct UpdateByWindowScale_UpdateByWindowTimeDefaultTypeInternal;
extern UpdateByWindowScale_UpdateByWindowTimeDefaultTypeInternal _UpdateByWindowScale_UpdateByWindowTime_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class WhereInRequest;
struct WhereInRequestDefaultTypeInternal;
extern WhereInRequestDefaultTypeInternal _WhereInRequest_default_instance_;
}  // namespace grpc
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io
PROTOBUF_NAMESPACE_OPEN
template<> ::io::deephaven::proto::backplane::grpc::AggSpec* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggregateAllRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AggregateRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggregateRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Aggregation* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Aggregation>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AjRajTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AndCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AndCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::BatchTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::BatchTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::CompareCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CompareCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Condition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Condition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ContainsCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ContainsCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::DropColumnsRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::EmptyTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::FetchTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FetchTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::FilterTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FilterTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::FlattenRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FlattenRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::HeadOrTailRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::InCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::InCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::InvokeCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::InvokeCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::IsNullCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::IsNullCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Literal* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Literal>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::MatchesCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MatchesCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::MathContext* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MathContext>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MergeTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::MetaTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MetaTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::NotCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::NotCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::OrCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::OrCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Reference* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Reference>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SearchCondition* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SearchCondition>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SeekRowRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SeekRowRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SeekRowResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SeekRowResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SelectDistinctRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SnapshotTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SortDescriptor* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SortDescriptor>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SortTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SortTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::TableReference* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::TimeTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TimeTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UngroupRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UngroupRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::Value* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::WhereInRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::WhereInRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace grpc {

enum MathContext_RoundingMode : int {
  MathContext_RoundingMode_ROUNDING_MODE_NOT_SPECIFIED = 0,
  MathContext_RoundingMode_UP = 1,
  MathContext_RoundingMode_DOWN = 2,
  MathContext_RoundingMode_CEILING = 3,
  MathContext_RoundingMode_FLOOR = 4,
  MathContext_RoundingMode_HALF_UP = 5,
  MathContext_RoundingMode_HALF_DOWN = 6,
  MathContext_RoundingMode_HALF_EVEN = 7,
  MathContext_RoundingMode_UNNECESSARY = 8,
  MathContext_RoundingMode_MathContext_RoundingMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MathContext_RoundingMode_MathContext_RoundingMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MathContext_RoundingMode_IsValid(int value);
constexpr MathContext_RoundingMode MathContext_RoundingMode_RoundingMode_MIN = MathContext_RoundingMode_ROUNDING_MODE_NOT_SPECIFIED;
constexpr MathContext_RoundingMode MathContext_RoundingMode_RoundingMode_MAX = MathContext_RoundingMode_UNNECESSARY;
constexpr int MathContext_RoundingMode_RoundingMode_ARRAYSIZE = MathContext_RoundingMode_RoundingMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MathContext_RoundingMode_descriptor();
template<typename T>
inline const std::string& MathContext_RoundingMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MathContext_RoundingMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MathContext_RoundingMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MathContext_RoundingMode_descriptor(), enum_t_value);
}
inline bool MathContext_RoundingMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MathContext_RoundingMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MathContext_RoundingMode>(
    MathContext_RoundingMode_descriptor(), name, value);
}
enum AsOfJoinTablesRequest_MatchRule : int {
  AsOfJoinTablesRequest_MatchRule_LESS_THAN_EQUAL = 0,
  AsOfJoinTablesRequest_MatchRule_LESS_THAN = 1,
  AsOfJoinTablesRequest_MatchRule_GREATER_THAN_EQUAL = 2,
  AsOfJoinTablesRequest_MatchRule_GREATER_THAN = 3,
  AsOfJoinTablesRequest_MatchRule_AsOfJoinTablesRequest_MatchRule_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AsOfJoinTablesRequest_MatchRule_AsOfJoinTablesRequest_MatchRule_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AsOfJoinTablesRequest_MatchRule_IsValid(int value);
constexpr AsOfJoinTablesRequest_MatchRule AsOfJoinTablesRequest_MatchRule_MatchRule_MIN = AsOfJoinTablesRequest_MatchRule_LESS_THAN_EQUAL;
constexpr AsOfJoinTablesRequest_MatchRule AsOfJoinTablesRequest_MatchRule_MatchRule_MAX = AsOfJoinTablesRequest_MatchRule_GREATER_THAN;
constexpr int AsOfJoinTablesRequest_MatchRule_MatchRule_ARRAYSIZE = AsOfJoinTablesRequest_MatchRule_MatchRule_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AsOfJoinTablesRequest_MatchRule_descriptor();
template<typename T>
inline const std::string& AsOfJoinTablesRequest_MatchRule_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AsOfJoinTablesRequest_MatchRule>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AsOfJoinTablesRequest_MatchRule_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AsOfJoinTablesRequest_MatchRule_descriptor(), enum_t_value);
}
inline bool AsOfJoinTablesRequest_MatchRule_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AsOfJoinTablesRequest_MatchRule* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AsOfJoinTablesRequest_MatchRule>(
    AsOfJoinTablesRequest_MatchRule_descriptor(), name, value);
}
enum RangeJoinTablesRequest_RangeStartRule : int {
  RangeJoinTablesRequest_RangeStartRule_START_UNSPECIFIED = 0,
  RangeJoinTablesRequest_RangeStartRule_LESS_THAN = 1,
  RangeJoinTablesRequest_RangeStartRule_LESS_THAN_OR_EQUAL = 2,
  RangeJoinTablesRequest_RangeStartRule_LESS_THAN_OR_EQUAL_ALLOW_PRECEDING = 3,
  RangeJoinTablesRequest_RangeStartRule_RangeJoinTablesRequest_RangeStartRule_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RangeJoinTablesRequest_RangeStartRule_RangeJoinTablesRequest_RangeStartRule_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RangeJoinTablesRequest_RangeStartRule_IsValid(int value);
constexpr RangeJoinTablesRequest_RangeStartRule RangeJoinTablesRequest_RangeStartRule_RangeStartRule_MIN = RangeJoinTablesRequest_RangeStartRule_START_UNSPECIFIED;
constexpr RangeJoinTablesRequest_RangeStartRule RangeJoinTablesRequest_RangeStartRule_RangeStartRule_MAX = RangeJoinTablesRequest_RangeStartRule_LESS_THAN_OR_EQUAL_ALLOW_PRECEDING;
constexpr int RangeJoinTablesRequest_RangeStartRule_RangeStartRule_ARRAYSIZE = RangeJoinTablesRequest_RangeStartRule_RangeStartRule_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RangeJoinTablesRequest_RangeStartRule_descriptor();
template<typename T>
inline const std::string& RangeJoinTablesRequest_RangeStartRule_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RangeJoinTablesRequest_RangeStartRule>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RangeJoinTablesRequest_RangeStartRule_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RangeJoinTablesRequest_RangeStartRule_descriptor(), enum_t_value);
}
inline bool RangeJoinTablesRequest_RangeStartRule_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RangeJoinTablesRequest_RangeStartRule* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RangeJoinTablesRequest_RangeStartRule>(
    RangeJoinTablesRequest_RangeStartRule_descriptor(), name, value);
}
enum RangeJoinTablesRequest_RangeEndRule : int {
  RangeJoinTablesRequest_RangeEndRule_END_UNSPECIFIED = 0,
  RangeJoinTablesRequest_RangeEndRule_GREATER_THAN = 1,
  RangeJoinTablesRequest_RangeEndRule_GREATER_THAN_OR_EQUAL = 2,
  RangeJoinTablesRequest_RangeEndRule_GREATER_THAN_OR_EQUAL_ALLOW_FOLLOWING = 3,
  RangeJoinTablesRequest_RangeEndRule_RangeJoinTablesRequest_RangeEndRule_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RangeJoinTablesRequest_RangeEndRule_RangeJoinTablesRequest_RangeEndRule_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RangeJoinTablesRequest_RangeEndRule_IsValid(int value);
constexpr RangeJoinTablesRequest_RangeEndRule RangeJoinTablesRequest_RangeEndRule_RangeEndRule_MIN = RangeJoinTablesRequest_RangeEndRule_END_UNSPECIFIED;
constexpr RangeJoinTablesRequest_RangeEndRule RangeJoinTablesRequest_RangeEndRule_RangeEndRule_MAX = RangeJoinTablesRequest_RangeEndRule_GREATER_THAN_OR_EQUAL_ALLOW_FOLLOWING;
constexpr int RangeJoinTablesRequest_RangeEndRule_RangeEndRule_ARRAYSIZE = RangeJoinTablesRequest_RangeEndRule_RangeEndRule_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RangeJoinTablesRequest_RangeEndRule_descriptor();
template<typename T>
inline const std::string& RangeJoinTablesRequest_RangeEndRule_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RangeJoinTablesRequest_RangeEndRule>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RangeJoinTablesRequest_RangeEndRule_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RangeJoinTablesRequest_RangeEndRule_descriptor(), enum_t_value);
}
inline bool RangeJoinTablesRequest_RangeEndRule_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RangeJoinTablesRequest_RangeEndRule* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RangeJoinTablesRequest_RangeEndRule>(
    RangeJoinTablesRequest_RangeEndRule_descriptor(), name, value);
}
enum ComboAggregateRequest_AggType : int {
  ComboAggregateRequest_AggType_SUM = 0,
  ComboAggregateRequest_AggType_ABS_SUM = 1,
  ComboAggregateRequest_AggType_GROUP = 2,
  ComboAggregateRequest_AggType_AVG = 3,
  ComboAggregateRequest_AggType_COUNT = 4,
  ComboAggregateRequest_AggType_FIRST = 5,
  ComboAggregateRequest_AggType_LAST = 6,
  ComboAggregateRequest_AggType_MIN = 7,
  ComboAggregateRequest_AggType_MAX = 8,
  ComboAggregateRequest_AggType_MEDIAN = 9,
  ComboAggregateRequest_AggType_PERCENTILE = 10,
  ComboAggregateRequest_AggType_STD = 11,
  ComboAggregateRequest_AggType_VAR = 12,
  ComboAggregateRequest_AggType_WEIGHTED_AVG = 13,
  ComboAggregateRequest_AggType_ComboAggregateRequest_AggType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ComboAggregateRequest_AggType_ComboAggregateRequest_AggType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ComboAggregateRequest_AggType_IsValid(int value);
constexpr ComboAggregateRequest_AggType ComboAggregateRequest_AggType_AggType_MIN = ComboAggregateRequest_AggType_SUM;
constexpr ComboAggregateRequest_AggType ComboAggregateRequest_AggType_AggType_MAX = ComboAggregateRequest_AggType_WEIGHTED_AVG;
constexpr int ComboAggregateRequest_AggType_AggType_ARRAYSIZE = ComboAggregateRequest_AggType_AggType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ComboAggregateRequest_AggType_descriptor();
template<typename T>
inline const std::string& ComboAggregateRequest_AggType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ComboAggregateRequest_AggType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ComboAggregateRequest_AggType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ComboAggregateRequest_AggType_descriptor(), enum_t_value);
}
inline bool ComboAggregateRequest_AggType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ComboAggregateRequest_AggType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ComboAggregateRequest_AggType>(
    ComboAggregateRequest_AggType_descriptor(), name, value);
}
enum SortDescriptor_SortDirection : int {
  SortDescriptor_SortDirection_UNKNOWN = 0,
  SortDescriptor_SortDirection_DESCENDING = -1,
  SortDescriptor_SortDirection_ASCENDING = 1,
  SortDescriptor_SortDirection_REVERSE = 2,
  SortDescriptor_SortDirection_SortDescriptor_SortDirection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SortDescriptor_SortDirection_SortDescriptor_SortDirection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SortDescriptor_SortDirection_IsValid(int value);
constexpr SortDescriptor_SortDirection SortDescriptor_SortDirection_SortDirection_MIN = SortDescriptor_SortDirection_DESCENDING;
constexpr SortDescriptor_SortDirection SortDescriptor_SortDirection_SortDirection_MAX = SortDescriptor_SortDirection_REVERSE;
constexpr int SortDescriptor_SortDirection_SortDirection_ARRAYSIZE = SortDescriptor_SortDirection_SortDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SortDescriptor_SortDirection_descriptor();
template<typename T>
inline const std::string& SortDescriptor_SortDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SortDescriptor_SortDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SortDescriptor_SortDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SortDescriptor_SortDirection_descriptor(), enum_t_value);
}
inline bool SortDescriptor_SortDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SortDescriptor_SortDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SortDescriptor_SortDirection>(
    SortDescriptor_SortDirection_descriptor(), name, value);
}
enum CompareCondition_CompareOperation : int {
  CompareCondition_CompareOperation_LESS_THAN = 0,
  CompareCondition_CompareOperation_LESS_THAN_OR_EQUAL = 1,
  CompareCondition_CompareOperation_GREATER_THAN = 2,
  CompareCondition_CompareOperation_GREATER_THAN_OR_EQUAL = 3,
  CompareCondition_CompareOperation_EQUALS = 4,
  CompareCondition_CompareOperation_NOT_EQUALS = 5,
  CompareCondition_CompareOperation_CompareCondition_CompareOperation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CompareCondition_CompareOperation_CompareCondition_CompareOperation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CompareCondition_CompareOperation_IsValid(int value);
constexpr CompareCondition_CompareOperation CompareCondition_CompareOperation_CompareOperation_MIN = CompareCondition_CompareOperation_LESS_THAN;
constexpr CompareCondition_CompareOperation CompareCondition_CompareOperation_CompareOperation_MAX = CompareCondition_CompareOperation_NOT_EQUALS;
constexpr int CompareCondition_CompareOperation_CompareOperation_ARRAYSIZE = CompareCondition_CompareOperation_CompareOperation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompareCondition_CompareOperation_descriptor();
template<typename T>
inline const std::string& CompareCondition_CompareOperation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompareCondition_CompareOperation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompareCondition_CompareOperation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompareCondition_CompareOperation_descriptor(), enum_t_value);
}
inline bool CompareCondition_CompareOperation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompareCondition_CompareOperation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompareCondition_CompareOperation>(
    CompareCondition_CompareOperation_descriptor(), name, value);
}
enum BadDataBehavior : int {
  BAD_DATA_BEHAVIOR_NOT_SPECIFIED = 0,
  THROW = 1,
  RESET = 2,
  SKIP = 3,
  POISON = 4,
  BadDataBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BadDataBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BadDataBehavior_IsValid(int value);
constexpr BadDataBehavior BadDataBehavior_MIN = BAD_DATA_BEHAVIOR_NOT_SPECIFIED;
constexpr BadDataBehavior BadDataBehavior_MAX = POISON;
constexpr int BadDataBehavior_ARRAYSIZE = BadDataBehavior_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BadDataBehavior_descriptor();
template<typename T>
inline const std::string& BadDataBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BadDataBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BadDataBehavior_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BadDataBehavior_descriptor(), enum_t_value);
}
inline bool BadDataBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BadDataBehavior* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BadDataBehavior>(
    BadDataBehavior_descriptor(), name, value);
}
enum UpdateByNullBehavior : int {
  NULL_BEHAVIOR_NOT_SPECIFIED = 0,
  NULL_DOMINATES = 1,
  VALUE_DOMINATES = 2,
  ZERO_DOMINATES = 3,
  UpdateByNullBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  UpdateByNullBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool UpdateByNullBehavior_IsValid(int value);
constexpr UpdateByNullBehavior UpdateByNullBehavior_MIN = NULL_BEHAVIOR_NOT_SPECIFIED;
constexpr UpdateByNullBehavior UpdateByNullBehavior_MAX = ZERO_DOMINATES;
constexpr int UpdateByNullBehavior_ARRAYSIZE = UpdateByNullBehavior_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateByNullBehavior_descriptor();
template<typename T>
inline const std::string& UpdateByNullBehavior_Name(T enum_t_value) {
  static_assert(::std::is_same<T, UpdateByNullBehavior>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function UpdateByNullBehavior_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    UpdateByNullBehavior_descriptor(), enum_t_value);
}
inline bool UpdateByNullBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, UpdateByNullBehavior* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<UpdateByNullBehavior>(
    UpdateByNullBehavior_descriptor(), name, value);
}
enum NullValue : int {
  NULL_VALUE = 0,
  NullValue_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NullValue_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NullValue_IsValid(int value);
constexpr NullValue NullValue_MIN = NULL_VALUE;
constexpr NullValue NullValue_MAX = NULL_VALUE;
constexpr int NullValue_ARRAYSIZE = NullValue_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NullValue_descriptor();
template<typename T>
inline const std::string& NullValue_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NullValue>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NullValue_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NullValue_descriptor(), enum_t_value);
}
inline bool NullValue_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NullValue* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NullValue>(
    NullValue_descriptor(), name, value);
}
enum CaseSensitivity : int {
  MATCH_CASE = 0,
  IGNORE_CASE = 1,
  CaseSensitivity_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CaseSensitivity_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CaseSensitivity_IsValid(int value);
constexpr CaseSensitivity CaseSensitivity_MIN = MATCH_CASE;
constexpr CaseSensitivity CaseSensitivity_MAX = IGNORE_CASE;
constexpr int CaseSensitivity_ARRAYSIZE = CaseSensitivity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CaseSensitivity_descriptor();
template<typename T>
inline const std::string& CaseSensitivity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CaseSensitivity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CaseSensitivity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CaseSensitivity_descriptor(), enum_t_value);
}
inline bool CaseSensitivity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CaseSensitivity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CaseSensitivity>(
    CaseSensitivity_descriptor(), name, value);
}
enum MatchType : int {
  REGULAR = 0,
  INVERTED = 1,
  MatchType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MatchType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MatchType_IsValid(int value);
constexpr MatchType MatchType_MIN = REGULAR;
constexpr MatchType MatchType_MAX = INVERTED;
constexpr int MatchType_ARRAYSIZE = MatchType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchType_descriptor();
template<typename T>
inline const std::string& MatchType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MatchType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MatchType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MatchType_descriptor(), enum_t_value);
}
inline bool MatchType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MatchType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MatchType>(
    MatchType_descriptor(), name, value);
}
// ===================================================================

class TableReference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.TableReference) */ {
 public:
  inline TableReference() : TableReference(nullptr) {}
  ~TableReference() override;
  explicit PROTOBUF_CONSTEXPR TableReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableReference(const TableReference& from);
  TableReference(TableReference&& from) noexcept
    : TableReference() {
    *this = ::std::move(from);
  }

  inline TableReference& operator=(const TableReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableReference& operator=(TableReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableReference& default_instance() {
    return *internal_default_instance();
  }
  enum RefCase {
    kTicket = 1,
    kBatchOffset = 2,
    REF_NOT_SET = 0,
  };

  static inline const TableReference* internal_default_instance() {
    return reinterpret_cast<const TableReference*>(
               &_TableReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TableReference& a, TableReference& b) {
    a.Swap(&b);
  }
  inline void Swap(TableReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableReference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableReference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TableReference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableReference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.TableReference";
  }
  protected:
  explicit TableReference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketFieldNumber = 1,
    kBatchOffsetFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket ticket = 1;
  bool has_ticket() const;
  private:
  bool _internal_has_ticket() const;
  public:
  void clear_ticket();
  const ::io::deephaven::proto::backplane::grpc::Ticket& ticket() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_ticket();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_ticket();
  void set_allocated_ticket(::io::deephaven::proto::backplane::grpc::Ticket* ticket);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_ticket() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_ticket();
  public:
  void unsafe_arena_set_allocated_ticket(
      ::io::deephaven::proto::backplane::grpc::Ticket* ticket);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_ticket();

  // sint32 batch_offset = 2;
  bool has_batch_offset() const;
  private:
  bool _internal_has_batch_offset() const;
  public:
  void clear_batch_offset();
  int32_t batch_offset() const;
  void set_batch_offset(int32_t value);
  private:
  int32_t _internal_batch_offset() const;
  void _internal_set_batch_offset(int32_t value);
  public:

  void clear_ref();
  RefCase ref_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.TableReference)
 private:
  class _Internal;
  void set_has_ticket();
  void set_has_batch_offset();

  inline bool has_ref() const;
  inline void clear_has_ref();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union RefUnion {
    constexpr RefUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::Ticket* ticket_;
    int32_t batch_offset_;
  } ref_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ExportedTableCreationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse) */ {
 public:
  inline ExportedTableCreationResponse() : ExportedTableCreationResponse(nullptr) {}
  ~ExportedTableCreationResponse() override;
  explicit PROTOBUF_CONSTEXPR ExportedTableCreationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExportedTableCreationResponse(const ExportedTableCreationResponse& from);
  ExportedTableCreationResponse(ExportedTableCreationResponse&& from) noexcept
    : ExportedTableCreationResponse() {
    *this = ::std::move(from);
  }

  inline ExportedTableCreationResponse& operator=(const ExportedTableCreationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportedTableCreationResponse& operator=(ExportedTableCreationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportedTableCreationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportedTableCreationResponse* internal_default_instance() {
    return reinterpret_cast<const ExportedTableCreationResponse*>(
               &_ExportedTableCreationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ExportedTableCreationResponse& a, ExportedTableCreationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportedTableCreationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportedTableCreationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExportedTableCreationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExportedTableCreationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExportedTableCreationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExportedTableCreationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExportedTableCreationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse";
  }
  protected:
  explicit ExportedTableCreationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorInfoFieldNumber = 3,
    kSchemaHeaderFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSizeFieldNumber = 6,
    kSuccessFieldNumber = 2,
    kIsStaticFieldNumber = 5,
  };
  // string error_info = 3;
  void clear_error_info();
  const std::string& error_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_info();
  PROTOBUF_NODISCARD std::string* release_error_info();
  void set_allocated_error_info(std::string* error_info);
  private:
  const std::string& _internal_error_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_info(const std::string& value);
  std::string* _internal_mutable_error_info();
  public:

  // bytes schema_header = 4;
  void clear_schema_header();
  const std::string& schema_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema_header();
  PROTOBUF_NODISCARD std::string* release_schema_header();
  void set_allocated_schema_header(std::string* schema_header);
  private:
  const std::string& _internal_schema_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_header(const std::string& value);
  std::string* _internal_mutable_schema_header();
  public:

  // .io.deephaven.proto.backplane.grpc.TableReference result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_result_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::TableReference* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* result_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_result_id();

  // sint64 size = 6 [jstype = JS_STRING];
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // bool is_static = 5;
  void clear_is_static();
  bool is_static() const;
  void set_is_static(bool value);
  private:
  bool _internal_is_static() const;
  void _internal_set_is_static(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_info_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_header_;
  ::io::deephaven::proto::backplane::grpc::TableReference* result_id_;
  int64_t size_;
  bool success_;
  bool is_static_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class FetchTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FetchTableRequest) */ {
 public:
  inline FetchTableRequest() : FetchTableRequest(nullptr) {}
  ~FetchTableRequest() override;
  explicit PROTOBUF_CONSTEXPR FetchTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchTableRequest(const FetchTableRequest& from);
  FetchTableRequest(FetchTableRequest&& from) noexcept
    : FetchTableRequest() {
    *this = ::std::move(from);
  }

  inline FetchTableRequest& operator=(const FetchTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchTableRequest& operator=(FetchTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchTableRequest* internal_default_instance() {
    return reinterpret_cast<const FetchTableRequest*>(
               &_FetchTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FetchTableRequest& a, FetchTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FetchTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FetchTableRequest";
  }
  protected:
  explicit FetchTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 1,
    kResultIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FetchTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ApplyPreviewColumnsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest) */ {
 public:
  inline ApplyPreviewColumnsRequest() : ApplyPreviewColumnsRequest(nullptr) {}
  ~ApplyPreviewColumnsRequest() override;
  explicit PROTOBUF_CONSTEXPR ApplyPreviewColumnsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ApplyPreviewColumnsRequest(const ApplyPreviewColumnsRequest& from);
  ApplyPreviewColumnsRequest(ApplyPreviewColumnsRequest&& from) noexcept
    : ApplyPreviewColumnsRequest() {
    *this = ::std::move(from);
  }

  inline ApplyPreviewColumnsRequest& operator=(const ApplyPreviewColumnsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyPreviewColumnsRequest& operator=(ApplyPreviewColumnsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyPreviewColumnsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyPreviewColumnsRequest* internal_default_instance() {
    return reinterpret_cast<const ApplyPreviewColumnsRequest*>(
               &_ApplyPreviewColumnsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ApplyPreviewColumnsRequest& a, ApplyPreviewColumnsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyPreviewColumnsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyPreviewColumnsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyPreviewColumnsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyPreviewColumnsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ApplyPreviewColumnsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ApplyPreviewColumnsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ApplyPreviewColumnsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest";
  }
  protected:
  explicit ApplyPreviewColumnsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 1,
    kResultIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ExportedTableUpdatesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ExportedTableUpdatesRequest) */ {
 public:
  inline ExportedTableUpdatesRequest() : ExportedTableUpdatesRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ExportedTableUpdatesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExportedTableUpdatesRequest(const ExportedTableUpdatesRequest& from);
  ExportedTableUpdatesRequest(ExportedTableUpdatesRequest&& from) noexcept
    : ExportedTableUpdatesRequest() {
    *this = ::std::move(from);
  }

  inline ExportedTableUpdatesRequest& operator=(const ExportedTableUpdatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportedTableUpdatesRequest& operator=(ExportedTableUpdatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportedTableUpdatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportedTableUpdatesRequest* internal_default_instance() {
    return reinterpret_cast<const ExportedTableUpdatesRequest*>(
               &_ExportedTableUpdatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ExportedTableUpdatesRequest& a, ExportedTableUpdatesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportedTableUpdatesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportedTableUpdatesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExportedTableUpdatesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExportedTableUpdatesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ExportedTableUpdatesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ExportedTableUpdatesRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ExportedTableUpdatesRequest";
  }
  protected:
  explicit ExportedTableUpdatesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ExportedTableUpdatesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ExportedTableUpdateMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage) */ {
 public:
  inline ExportedTableUpdateMessage() : ExportedTableUpdateMessage(nullptr) {}
  ~ExportedTableUpdateMessage() override;
  explicit PROTOBUF_CONSTEXPR ExportedTableUpdateMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExportedTableUpdateMessage(const ExportedTableUpdateMessage& from);
  ExportedTableUpdateMessage(ExportedTableUpdateMessage&& from) noexcept
    : ExportedTableUpdateMessage() {
    *this = ::std::move(from);
  }

  inline ExportedTableUpdateMessage& operator=(const ExportedTableUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportedTableUpdateMessage& operator=(ExportedTableUpdateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportedTableUpdateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportedTableUpdateMessage* internal_default_instance() {
    return reinterpret_cast<const ExportedTableUpdateMessage*>(
               &_ExportedTableUpdateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ExportedTableUpdateMessage& a, ExportedTableUpdateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportedTableUpdateMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportedTableUpdateMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExportedTableUpdateMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExportedTableUpdateMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExportedTableUpdateMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExportedTableUpdateMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExportedTableUpdateMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage";
  }
  protected:
  explicit ExportedTableUpdateMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateFailureMessageFieldNumber = 3,
    kExportIdFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // string update_failure_message = 3;
  void clear_update_failure_message();
  const std::string& update_failure_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_update_failure_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_update_failure_message();
  PROTOBUF_NODISCARD std::string* release_update_failure_message();
  void set_allocated_update_failure_message(std::string* update_failure_message);
  private:
  const std::string& _internal_update_failure_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_failure_message(const std::string& value);
  std::string* _internal_mutable_update_failure_message();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket export_id = 1;
  bool has_export_id() const;
  private:
  bool _internal_has_export_id() const;
  public:
  void clear_export_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& export_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_export_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_export_id();
  void set_allocated_export_id(::io::deephaven::proto::backplane::grpc::Ticket* export_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_export_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_export_id();
  public:
  void unsafe_arena_set_allocated_export_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* export_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_export_id();

  // sint64 size = 2 [jstype = JS_STRING];
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr update_failure_message_;
  ::io::deephaven::proto::backplane::grpc::Ticket* export_id_;
  int64_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class EmptyTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.EmptyTableRequest) */ {
 public:
  inline EmptyTableRequest() : EmptyTableRequest(nullptr) {}
  ~EmptyTableRequest() override;
  explicit PROTOBUF_CONSTEXPR EmptyTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EmptyTableRequest(const EmptyTableRequest& from);
  EmptyTableRequest(EmptyTableRequest&& from) noexcept
    : EmptyTableRequest() {
    *this = ::std::move(from);
  }

  inline EmptyTableRequest& operator=(const EmptyTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyTableRequest& operator=(EmptyTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyTableRequest* internal_default_instance() {
    return reinterpret_cast<const EmptyTableRequest*>(
               &_EmptyTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EmptyTableRequest& a, EmptyTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EmptyTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EmptyTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.EmptyTableRequest";
  }
  protected:
  explicit EmptyTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // sint64 size = 2 [jstype = JS_STRING];
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.EmptyTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  int64_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class TimeTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.TimeTableRequest) */ {
 public:
  inline TimeTableRequest() : TimeTableRequest(nullptr) {}
  ~TimeTableRequest() override;
  explicit PROTOBUF_CONSTEXPR TimeTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimeTableRequest(const TimeTableRequest& from);
  TimeTableRequest(TimeTableRequest&& from) noexcept
    : TimeTableRequest() {
    *this = ::std::move(from);
  }

  inline TimeTableRequest& operator=(const TimeTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeTableRequest& operator=(TimeTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimeTableRequest* internal_default_instance() {
    return reinterpret_cast<const TimeTableRequest*>(
               &_TimeTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TimeTableRequest& a, TimeTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TimeTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TimeTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.TimeTableRequest";
  }
  protected:
  explicit TimeTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kStartTimeNanosFieldNumber = 2,
    kPeriodNanosFieldNumber = 3,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // sint64 start_time_nanos = 2 [jstype = JS_STRING];
  void clear_start_time_nanos();
  int64_t start_time_nanos() const;
  void set_start_time_nanos(int64_t value);
  private:
  int64_t _internal_start_time_nanos() const;
  void _internal_set_start_time_nanos(int64_t value);
  public:

  // sint64 period_nanos = 3 [jstype = JS_STRING];
  void clear_period_nanos();
  int64_t period_nanos() const;
  void set_period_nanos(int64_t value);
  private:
  int64_t _internal_period_nanos() const;
  void _internal_set_period_nanos(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.TimeTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  int64_t start_time_nanos_;
  int64_t period_nanos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SelectOrUpdateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest) */ {
 public:
  inline SelectOrUpdateRequest() : SelectOrUpdateRequest(nullptr) {}
  ~SelectOrUpdateRequest() override;
  explicit PROTOBUF_CONSTEXPR SelectOrUpdateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectOrUpdateRequest(const SelectOrUpdateRequest& from);
  SelectOrUpdateRequest(SelectOrUpdateRequest&& from) noexcept
    : SelectOrUpdateRequest() {
    *this = ::std::move(from);
  }

  inline SelectOrUpdateRequest& operator=(const SelectOrUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectOrUpdateRequest& operator=(SelectOrUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectOrUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectOrUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const SelectOrUpdateRequest*>(
               &_SelectOrUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SelectOrUpdateRequest& a, SelectOrUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectOrUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectOrUpdateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectOrUpdateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectOrUpdateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectOrUpdateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SelectOrUpdateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectOrUpdateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest";
  }
  protected:
  explicit SelectOrUpdateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnSpecsFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated string column_specs = 3;
  int column_specs_size() const;
  private:
  int _internal_column_specs_size() const;
  public:
  void clear_column_specs();
  const std::string& column_specs(int index) const;
  std::string* mutable_column_specs(int index);
  void set_column_specs(int index, const std::string& value);
  void set_column_specs(int index, std::string&& value);
  void set_column_specs(int index, const char* value);
  void set_column_specs(int index, const char* value, size_t size);
  std::string* add_column_specs();
  void add_column_specs(const std::string& value);
  void add_column_specs(std::string&& value);
  void add_column_specs(const char* value);
  void add_column_specs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_specs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_specs();
  private:
  const std::string& _internal_column_specs(int index) const;
  std::string* _internal_add_column_specs();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_specs_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class MathContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MathContext) */ {
 public:
  inline MathContext() : MathContext(nullptr) {}
  ~MathContext() override;
  explicit PROTOBUF_CONSTEXPR MathContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MathContext(const MathContext& from);
  MathContext(MathContext&& from) noexcept
    : MathContext() {
    *this = ::std::move(from);
  }

  inline MathContext& operator=(const MathContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline MathContext& operator=(MathContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MathContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const MathContext* internal_default_instance() {
    return reinterpret_cast<const MathContext*>(
               &_MathContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MathContext& a, MathContext& b) {
    a.Swap(&b);
  }
  inline void Swap(MathContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MathContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MathContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MathContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MathContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MathContext& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MathContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MathContext";
  }
  protected:
  explicit MathContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MathContext_RoundingMode RoundingMode;
  static constexpr RoundingMode ROUNDING_MODE_NOT_SPECIFIED =
    MathContext_RoundingMode_ROUNDING_MODE_NOT_SPECIFIED;
  static constexpr RoundingMode UP =
    MathContext_RoundingMode_UP;
  static constexpr RoundingMode DOWN =
    MathContext_RoundingMode_DOWN;
  static constexpr RoundingMode CEILING =
    MathContext_RoundingMode_CEILING;
  static constexpr RoundingMode FLOOR =
    MathContext_RoundingMode_FLOOR;
  static constexpr RoundingMode HALF_UP =
    MathContext_RoundingMode_HALF_UP;
  static constexpr RoundingMode HALF_DOWN =
    MathContext_RoundingMode_HALF_DOWN;
  static constexpr RoundingMode HALF_EVEN =
    MathContext_RoundingMode_HALF_EVEN;
  static constexpr RoundingMode UNNECESSARY =
    MathContext_RoundingMode_UNNECESSARY;
  static inline bool RoundingMode_IsValid(int value) {
    return MathContext_RoundingMode_IsValid(value);
  }
  static constexpr RoundingMode RoundingMode_MIN =
    MathContext_RoundingMode_RoundingMode_MIN;
  static constexpr RoundingMode RoundingMode_MAX =
    MathContext_RoundingMode_RoundingMode_MAX;
  static constexpr int RoundingMode_ARRAYSIZE =
    MathContext_RoundingMode_RoundingMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RoundingMode_descriptor() {
    return MathContext_RoundingMode_descriptor();
  }
  template<typename T>
  static inline const std::string& RoundingMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RoundingMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RoundingMode_Name.");
    return MathContext_RoundingMode_Name(enum_t_value);
  }
  static inline bool RoundingMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RoundingMode* value) {
    return MathContext_RoundingMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPrecisionFieldNumber = 1,
    kRoundingModeFieldNumber = 2,
  };
  // sint32 precision = 1;
  void clear_precision();
  int32_t precision() const;
  void set_precision(int32_t value);
  private:
  int32_t _internal_precision() const;
  void _internal_set_precision(int32_t value);
  public:

  // .io.deephaven.proto.backplane.grpc.MathContext.RoundingMode rounding_mode = 2;
  void clear_rounding_mode();
  ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode rounding_mode() const;
  void set_rounding_mode(::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode value);
  private:
  ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode _internal_rounding_mode() const;
  void _internal_set_rounding_mode(::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MathContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t precision_;
  int rounding_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByWindowScale_UpdateByWindowTicks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks) */ {
 public:
  inline UpdateByWindowScale_UpdateByWindowTicks() : UpdateByWindowScale_UpdateByWindowTicks(nullptr) {}
  ~UpdateByWindowScale_UpdateByWindowTicks() override;
  explicit PROTOBUF_CONSTEXPR UpdateByWindowScale_UpdateByWindowTicks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByWindowScale_UpdateByWindowTicks(const UpdateByWindowScale_UpdateByWindowTicks& from);
  UpdateByWindowScale_UpdateByWindowTicks(UpdateByWindowScale_UpdateByWindowTicks&& from) noexcept
    : UpdateByWindowScale_UpdateByWindowTicks() {
    *this = ::std::move(from);
  }

  inline UpdateByWindowScale_UpdateByWindowTicks& operator=(const UpdateByWindowScale_UpdateByWindowTicks& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByWindowScale_UpdateByWindowTicks& operator=(UpdateByWindowScale_UpdateByWindowTicks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByWindowScale_UpdateByWindowTicks& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByWindowScale_UpdateByWindowTicks* internal_default_instance() {
    return reinterpret_cast<const UpdateByWindowScale_UpdateByWindowTicks*>(
               &_UpdateByWindowScale_UpdateByWindowTicks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UpdateByWindowScale_UpdateByWindowTicks& a, UpdateByWindowScale_UpdateByWindowTicks& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByWindowScale_UpdateByWindowTicks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByWindowScale_UpdateByWindowTicks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByWindowScale_UpdateByWindowTicks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByWindowScale_UpdateByWindowTicks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByWindowScale_UpdateByWindowTicks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByWindowScale_UpdateByWindowTicks& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByWindowScale_UpdateByWindowTicks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks";
  }
  protected:
  explicit UpdateByWindowScale_UpdateByWindowTicks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicksFieldNumber = 1,
  };
  // double ticks = 1;
  void clear_ticks();
  double ticks() const;
  void set_ticks(double value);
  private:
  double _internal_ticks() const;
  void _internal_set_ticks(double value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double ticks_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByWindowScale_UpdateByWindowTime final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime) */ {
 public:
  inline UpdateByWindowScale_UpdateByWindowTime() : UpdateByWindowScale_UpdateByWindowTime(nullptr) {}
  ~UpdateByWindowScale_UpdateByWindowTime() override;
  explicit PROTOBUF_CONSTEXPR UpdateByWindowScale_UpdateByWindowTime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByWindowScale_UpdateByWindowTime(const UpdateByWindowScale_UpdateByWindowTime& from);
  UpdateByWindowScale_UpdateByWindowTime(UpdateByWindowScale_UpdateByWindowTime&& from) noexcept
    : UpdateByWindowScale_UpdateByWindowTime() {
    *this = ::std::move(from);
  }

  inline UpdateByWindowScale_UpdateByWindowTime& operator=(const UpdateByWindowScale_UpdateByWindowTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByWindowScale_UpdateByWindowTime& operator=(UpdateByWindowScale_UpdateByWindowTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByWindowScale_UpdateByWindowTime& default_instance() {
    return *internal_default_instance();
  }
  enum WindowCase {
    kNanos = 2,
    kDurationString = 3,
    WINDOW_NOT_SET = 0,
  };

  static inline const UpdateByWindowScale_UpdateByWindowTime* internal_default_instance() {
    return reinterpret_cast<const UpdateByWindowScale_UpdateByWindowTime*>(
               &_UpdateByWindowScale_UpdateByWindowTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateByWindowScale_UpdateByWindowTime& a, UpdateByWindowScale_UpdateByWindowTime& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByWindowScale_UpdateByWindowTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByWindowScale_UpdateByWindowTime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByWindowScale_UpdateByWindowTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByWindowScale_UpdateByWindowTime>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByWindowScale_UpdateByWindowTime& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByWindowScale_UpdateByWindowTime& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByWindowScale_UpdateByWindowTime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime";
  }
  protected:
  explicit UpdateByWindowScale_UpdateByWindowTime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFieldNumber = 1,
    kNanosFieldNumber = 2,
    kDurationStringFieldNumber = 3,
  };
  // string column = 1;
  void clear_column();
  const std::string& column() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column();
  PROTOBUF_NODISCARD std::string* release_column();
  void set_allocated_column(std::string* column);
  private:
  const std::string& _internal_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column(const std::string& value);
  std::string* _internal_mutable_column();
  public:

  // sint64 nanos = 2 [jstype = JS_STRING];
  bool has_nanos() const;
  private:
  bool _internal_has_nanos() const;
  public:
  void clear_nanos();
  int64_t nanos() const;
  void set_nanos(int64_t value);
  private:
  int64_t _internal_nanos() const;
  void _internal_set_nanos(int64_t value);
  public:

  // string duration_string = 3;
  bool has_duration_string() const;
  private:
  bool _internal_has_duration_string() const;
  public:
  void clear_duration_string();
  const std::string& duration_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_duration_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_duration_string();
  PROTOBUF_NODISCARD std::string* release_duration_string();
  void set_allocated_duration_string(std::string* duration_string);
  private:
  const std::string& _internal_duration_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_duration_string(const std::string& value);
  std::string* _internal_mutable_duration_string();
  public:

  void clear_window();
  WindowCase window_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime)
 private:
  class _Internal;
  void set_has_nanos();
  void set_has_duration_string();

  inline bool has_window() const;
  inline void clear_has_window();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_;
  union WindowUnion {
    constexpr WindowUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int64_t nanos_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr duration_string_;
  } window_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByWindowScale final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByWindowScale) */ {
 public:
  inline UpdateByWindowScale() : UpdateByWindowScale(nullptr) {}
  ~UpdateByWindowScale() override;
  explicit PROTOBUF_CONSTEXPR UpdateByWindowScale(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByWindowScale(const UpdateByWindowScale& from);
  UpdateByWindowScale(UpdateByWindowScale&& from) noexcept
    : UpdateByWindowScale() {
    *this = ::std::move(from);
  }

  inline UpdateByWindowScale& operator=(const UpdateByWindowScale& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByWindowScale& operator=(UpdateByWindowScale&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByWindowScale& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kTicks = 1,
    kTime = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const UpdateByWindowScale* internal_default_instance() {
    return reinterpret_cast<const UpdateByWindowScale*>(
               &_UpdateByWindowScale_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UpdateByWindowScale& a, UpdateByWindowScale& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByWindowScale* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByWindowScale* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByWindowScale* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByWindowScale>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByWindowScale& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByWindowScale& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByWindowScale* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByWindowScale";
  }
  protected:
  explicit UpdateByWindowScale(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateByWindowScale_UpdateByWindowTicks UpdateByWindowTicks;
  typedef UpdateByWindowScale_UpdateByWindowTime UpdateByWindowTime;

  // accessors -------------------------------------------------------

  enum : int {
    kTicksFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks ticks = 1;
  bool has_ticks() const;
  private:
  bool _internal_has_ticks() const;
  public:
  void clear_ticks();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks& ticks() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* release_ticks();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* mutable_ticks();
  void set_allocated_ticks(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* ticks);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks& _internal_ticks() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* _internal_mutable_ticks();
  public:
  void unsafe_arena_set_allocated_ticks(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* ticks);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* unsafe_arena_release_ticks();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime time = 2;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime& time() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* release_time();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* mutable_time();
  void set_allocated_time(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* time);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime& _internal_time() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* _internal_mutable_time();
  public:
  void unsafe_arena_set_allocated_time(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* time);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* unsafe_arena_release_time();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByWindowScale)
 private:
  class _Internal;
  void set_has_ticks();
  void set_has_time();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* ticks_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* time_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByEmOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByEmOptions) */ {
 public:
  inline UpdateByEmOptions() : UpdateByEmOptions(nullptr) {}
  ~UpdateByEmOptions() override;
  explicit PROTOBUF_CONSTEXPR UpdateByEmOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByEmOptions(const UpdateByEmOptions& from);
  UpdateByEmOptions(UpdateByEmOptions&& from) noexcept
    : UpdateByEmOptions() {
    *this = ::std::move(from);
  }

  inline UpdateByEmOptions& operator=(const UpdateByEmOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByEmOptions& operator=(UpdateByEmOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByEmOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByEmOptions* internal_default_instance() {
    return reinterpret_cast<const UpdateByEmOptions*>(
               &_UpdateByEmOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UpdateByEmOptions& a, UpdateByEmOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByEmOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByEmOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByEmOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByEmOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByEmOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByEmOptions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByEmOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByEmOptions";
  }
  protected:
  explicit UpdateByEmOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBigValueContextFieldNumber = 6,
    kOnNullValueFieldNumber = 1,
    kOnNanValueFieldNumber = 2,
    kOnNullTimeFieldNumber = 3,
    kOnNegativeDeltaTimeFieldNumber = 4,
    kOnZeroDeltaTimeFieldNumber = 5,
  };
  // .io.deephaven.proto.backplane.grpc.MathContext big_value_context = 6;
  bool has_big_value_context() const;
  private:
  bool _internal_has_big_value_context() const;
  public:
  void clear_big_value_context();
  const ::io::deephaven::proto::backplane::grpc::MathContext& big_value_context() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::MathContext* release_big_value_context();
  ::io::deephaven::proto::backplane::grpc::MathContext* mutable_big_value_context();
  void set_allocated_big_value_context(::io::deephaven::proto::backplane::grpc::MathContext* big_value_context);
  private:
  const ::io::deephaven::proto::backplane::grpc::MathContext& _internal_big_value_context() const;
  ::io::deephaven::proto::backplane::grpc::MathContext* _internal_mutable_big_value_context();
  public:
  void unsafe_arena_set_allocated_big_value_context(
      ::io::deephaven::proto::backplane::grpc::MathContext* big_value_context);
  ::io::deephaven::proto::backplane::grpc::MathContext* unsafe_arena_release_big_value_context();

  // .io.deephaven.proto.backplane.grpc.BadDataBehavior on_null_value = 1;
  void clear_on_null_value();
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior on_null_value() const;
  void set_on_null_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);
  private:
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior _internal_on_null_value() const;
  void _internal_set_on_null_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);
  public:

  // .io.deephaven.proto.backplane.grpc.BadDataBehavior on_nan_value = 2;
  void clear_on_nan_value();
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior on_nan_value() const;
  void set_on_nan_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);
  private:
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior _internal_on_nan_value() const;
  void _internal_set_on_nan_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);
  public:

  // .io.deephaven.proto.backplane.grpc.BadDataBehavior on_null_time = 3;
  void clear_on_null_time();
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior on_null_time() const;
  void set_on_null_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);
  private:
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior _internal_on_null_time() const;
  void _internal_set_on_null_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);
  public:

  // .io.deephaven.proto.backplane.grpc.BadDataBehavior on_negative_delta_time = 4;
  void clear_on_negative_delta_time();
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior on_negative_delta_time() const;
  void set_on_negative_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);
  private:
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior _internal_on_negative_delta_time() const;
  void _internal_set_on_negative_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);
  public:

  // .io.deephaven.proto.backplane.grpc.BadDataBehavior on_zero_delta_time = 5;
  void clear_on_zero_delta_time();
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior on_zero_delta_time() const;
  void set_on_zero_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);
  private:
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior _internal_on_zero_delta_time() const;
  void _internal_set_on_zero_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByEmOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::MathContext* big_value_context_;
  int on_null_value_;
  int on_nan_value_;
  int on_null_time_;
  int on_negative_delta_time_;
  int on_zero_delta_time_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByDeltaOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions) */ {
 public:
  inline UpdateByDeltaOptions() : UpdateByDeltaOptions(nullptr) {}
  ~UpdateByDeltaOptions() override;
  explicit PROTOBUF_CONSTEXPR UpdateByDeltaOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByDeltaOptions(const UpdateByDeltaOptions& from);
  UpdateByDeltaOptions(UpdateByDeltaOptions&& from) noexcept
    : UpdateByDeltaOptions() {
    *this = ::std::move(from);
  }

  inline UpdateByDeltaOptions& operator=(const UpdateByDeltaOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByDeltaOptions& operator=(UpdateByDeltaOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByDeltaOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByDeltaOptions* internal_default_instance() {
    return reinterpret_cast<const UpdateByDeltaOptions*>(
               &_UpdateByDeltaOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UpdateByDeltaOptions& a, UpdateByDeltaOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByDeltaOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByDeltaOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByDeltaOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByDeltaOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByDeltaOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByDeltaOptions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByDeltaOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions";
  }
  protected:
  explicit UpdateByDeltaOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNullBehaviorFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByNullBehavior null_behavior = 1;
  void clear_null_behavior();
  ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior null_behavior() const;
  void set_null_behavior(::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior value);
  private:
  ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior _internal_null_behavior() const;
  void _internal_set_null_behavior(::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int null_behavior_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions) */ {
 public:
  inline UpdateByRequest_UpdateByOptions() : UpdateByRequest_UpdateByOptions(nullptr) {}
  ~UpdateByRequest_UpdateByOptions() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOptions(const UpdateByRequest_UpdateByOptions& from);
  UpdateByRequest_UpdateByOptions(UpdateByRequest_UpdateByOptions&& from) noexcept
    : UpdateByRequest_UpdateByOptions() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOptions& operator=(const UpdateByRequest_UpdateByOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOptions& operator=(UpdateByRequest_UpdateByOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOptions* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOptions*>(
               &_UpdateByRequest_UpdateByOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UpdateByRequest_UpdateByOptions& a, UpdateByRequest_UpdateByOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOptions& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions";
  }
  protected:
  explicit UpdateByRequest_UpdateByOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMathContextFieldNumber = 7,
    kUseRedirectionFieldNumber = 1,
    kChunkCapacityFieldNumber = 2,
    kMaxStaticSparseMemoryOverheadFieldNumber = 3,
    kMaximumLoadFactorFieldNumber = 5,
    kTargetLoadFactorFieldNumber = 6,
    kInitialHashTableSizeFieldNumber = 4,
  };
  // .io.deephaven.proto.backplane.grpc.MathContext math_context = 7;
  bool has_math_context() const;
  private:
  bool _internal_has_math_context() const;
  public:
  void clear_math_context();
  const ::io::deephaven::proto::backplane::grpc::MathContext& math_context() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::MathContext* release_math_context();
  ::io::deephaven::proto::backplane::grpc::MathContext* mutable_math_context();
  void set_allocated_math_context(::io::deephaven::proto::backplane::grpc::MathContext* math_context);
  private:
  const ::io::deephaven::proto::backplane::grpc::MathContext& _internal_math_context() const;
  ::io::deephaven::proto::backplane::grpc::MathContext* _internal_mutable_math_context();
  public:
  void unsafe_arena_set_allocated_math_context(
      ::io::deephaven::proto::backplane::grpc::MathContext* math_context);
  ::io::deephaven::proto::backplane::grpc::MathContext* unsafe_arena_release_math_context();

  // optional bool use_redirection = 1;
  bool has_use_redirection() const;
  private:
  bool _internal_has_use_redirection() const;
  public:
  void clear_use_redirection();
  bool use_redirection() const;
  void set_use_redirection(bool value);
  private:
  bool _internal_use_redirection() const;
  void _internal_set_use_redirection(bool value);
  public:

  // optional int32 chunk_capacity = 2;
  bool has_chunk_capacity() const;
  private:
  bool _internal_has_chunk_capacity() const;
  public:
  void clear_chunk_capacity();
  int32_t chunk_capacity() const;
  void set_chunk_capacity(int32_t value);
  private:
  int32_t _internal_chunk_capacity() const;
  void _internal_set_chunk_capacity(int32_t value);
  public:

  // optional double max_static_sparse_memory_overhead = 3;
  bool has_max_static_sparse_memory_overhead() const;
  private:
  bool _internal_has_max_static_sparse_memory_overhead() const;
  public:
  void clear_max_static_sparse_memory_overhead();
  double max_static_sparse_memory_overhead() const;
  void set_max_static_sparse_memory_overhead(double value);
  private:
  double _internal_max_static_sparse_memory_overhead() const;
  void _internal_set_max_static_sparse_memory_overhead(double value);
  public:

  // optional double maximum_load_factor = 5;
  bool has_maximum_load_factor() const;
  private:
  bool _internal_has_maximum_load_factor() const;
  public:
  void clear_maximum_load_factor();
  double maximum_load_factor() const;
  void set_maximum_load_factor(double value);
  private:
  double _internal_maximum_load_factor() const;
  void _internal_set_maximum_load_factor(double value);
  public:

  // optional double target_load_factor = 6;
  bool has_target_load_factor() const;
  private:
  bool _internal_has_target_load_factor() const;
  public:
  void clear_target_load_factor();
  double target_load_factor() const;
  void set_target_load_factor(double value);
  private:
  double _internal_target_load_factor() const;
  void _internal_set_target_load_factor(double value);
  public:

  // optional int32 initial_hash_table_size = 4;
  bool has_initial_hash_table_size() const;
  private:
  bool _internal_has_initial_hash_table_size() const;
  public:
  void clear_initial_hash_table_size();
  int32_t initial_hash_table_size() const;
  void set_initial_hash_table_size(int32_t value);
  private:
  int32_t _internal_initial_hash_table_size() const;
  void _internal_set_initial_hash_table_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::io::deephaven::proto::backplane::grpc::MathContext* math_context_;
  bool use_redirection_;
  int32_t chunk_capacity_;
  double max_static_sparse_memory_overhead_;
  double maximum_load_factor_;
  double target_load_factor_;
  int32_t initial_hash_table_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeSum) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeSum";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeSum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMin) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMin";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMax) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMax";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMax)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeProduct) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeProduct";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeProduct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByFill) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByFill";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByFill)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options);
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* unsafe_arena_release_options();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
  bool has_window_scale() const;
  private:
  bool _internal_has_window_scale() const;
  public:
  void clear_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_window_scale();
  void set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_window_scale();
  public:
  void unsafe_arena_set_allocated_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options);
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* unsafe_arena_release_options();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
  bool has_window_scale() const;
  private:
  bool _internal_has_window_scale() const;
  public:
  void clear_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_window_scale();
  void set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_window_scale();
  public:
  void unsafe_arena_set_allocated_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options);
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* unsafe_arena_release_options();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
  bool has_window_scale() const;
  private:
  bool _internal_has_window_scale() const;
  public:
  void clear_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_window_scale();
  void set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_window_scale();
  public:
  void unsafe_arena_set_allocated_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options);
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* unsafe_arena_release_options();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
  bool has_window_scale() const;
  private:
  bool _internal_has_window_scale() const;
  public:
  void clear_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_window_scale();
  void set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_window_scale();
  public:
  void unsafe_arena_set_allocated_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options);
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* unsafe_arena_release_options();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
  bool has_window_scale() const;
  private:
  bool _internal_has_window_scale() const;
  public:
  void clear_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_window_scale();
  void set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_window_scale();
  public:
  void unsafe_arena_set_allocated_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions options = 1;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* options);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* options);
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  private:
  bool _internal_has_reverse_window_scale() const;
  public:
  void clear_reverse_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();
  public:
  void unsafe_arena_set_allocated_reverse_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  private:
  bool _internal_has_forward_window_scale() const;
  public:
  void clear_forward_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();
  public:
  void unsafe_arena_set_allocated_forward_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  private:
  bool _internal_has_reverse_window_scale() const;
  public:
  void clear_reverse_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();
  public:
  void unsafe_arena_set_allocated_reverse_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  private:
  bool _internal_has_forward_window_scale() const;
  public:
  void clear_forward_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();
  public:
  void unsafe_arena_set_allocated_forward_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  private:
  bool _internal_has_reverse_window_scale() const;
  public:
  void clear_reverse_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();
  public:
  void unsafe_arena_set_allocated_reverse_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  private:
  bool _internal_has_forward_window_scale() const;
  public:
  void clear_forward_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();
  public:
  void unsafe_arena_set_allocated_forward_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  private:
  bool _internal_has_reverse_window_scale() const;
  public:
  void clear_reverse_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();
  public:
  void unsafe_arena_set_allocated_reverse_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  private:
  bool _internal_has_forward_window_scale() const;
  public:
  void clear_forward_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();
  public:
  void unsafe_arena_set_allocated_forward_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  private:
  bool _internal_has_reverse_window_scale() const;
  public:
  void clear_reverse_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();
  public:
  void unsafe_arena_set_allocated_reverse_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  private:
  bool _internal_has_forward_window_scale() const;
  public:
  void clear_forward_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();
  public:
  void unsafe_arena_set_allocated_forward_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  private:
  bool _internal_has_reverse_window_scale() const;
  public:
  void clear_reverse_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();
  public:
  void unsafe_arena_set_allocated_reverse_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  private:
  bool _internal_has_forward_window_scale() const;
  public:
  void clear_forward_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();
  public:
  void unsafe_arena_set_allocated_forward_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  private:
  bool _internal_has_reverse_window_scale() const;
  public:
  void clear_reverse_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();
  public:
  void unsafe_arena_set_allocated_reverse_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  private:
  bool _internal_has_forward_window_scale() const;
  public:
  void clear_forward_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();
  public:
  void unsafe_arena_set_allocated_forward_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  private:
  bool _internal_has_reverse_window_scale() const;
  public:
  void clear_reverse_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();
  public:
  void unsafe_arena_set_allocated_reverse_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  private:
  bool _internal_has_forward_window_scale() const;
  public:
  void clear_forward_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();
  public:
  void unsafe_arena_set_allocated_forward_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeightColumnFieldNumber = 3,
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // string weight_column = 3;
  void clear_weight_column();
  const std::string& weight_column() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_weight_column(ArgT0&& arg0, ArgT... args);
  std::string* mutable_weight_column();
  PROTOBUF_NODISCARD std::string* release_weight_column();
  void set_allocated_weight_column(std::string* weight_column);
  private:
  const std::string& _internal_weight_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weight_column(const std::string& value);
  std::string* _internal_mutable_weight_column();
  public:

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  private:
  bool _internal_has_reverse_window_scale() const;
  public:
  void clear_reverse_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();
  public:
  void unsafe_arena_set_allocated_reverse_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  private:
  bool _internal_has_forward_window_scale() const;
  public:
  void clear_forward_window_scale();
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();
  public:
  void unsafe_arena_set_allocated_forward_window_scale(
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weight_column_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kSum = 1,
    kMin = 2,
    kMax = 3,
    kProduct = 4,
    kFill = 5,
    kEma = 6,
    kRollingSum = 7,
    kRollingGroup = 8,
    kRollingAvg = 9,
    kRollingMin = 10,
    kRollingMax = 11,
    kRollingProduct = 12,
    kDelta = 13,
    kEms = 14,
    kEmMin = 15,
    kEmMax = 16,
    kEmStd = 17,
    kRollingCount = 18,
    kRollingStd = 19,
    kRollingWavg = 20,
    TYPE_NOT_SET = 0,
  };

  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum UpdateByCumulativeSum;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin UpdateByCumulativeMin;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax UpdateByCumulativeMax;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct UpdateByCumulativeProduct;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill UpdateByFill;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma UpdateByEma;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms UpdateByEms;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin UpdateByEmMin;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax UpdateByEmMax;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd UpdateByEmStd;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta UpdateByDelta;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum UpdateByRollingSum;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup UpdateByRollingGroup;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg UpdateByRollingAvg;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin UpdateByRollingMin;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax UpdateByRollingMax;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct UpdateByRollingProduct;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount UpdateByRollingCount;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd UpdateByRollingStd;
  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg UpdateByRollingWAvg;

  // accessors -------------------------------------------------------

  enum : int {
    kSumFieldNumber = 1,
    kMinFieldNumber = 2,
    kMaxFieldNumber = 3,
    kProductFieldNumber = 4,
    kFillFieldNumber = 5,
    kEmaFieldNumber = 6,
    kRollingSumFieldNumber = 7,
    kRollingGroupFieldNumber = 8,
    kRollingAvgFieldNumber = 9,
    kRollingMinFieldNumber = 10,
    kRollingMaxFieldNumber = 11,
    kRollingProductFieldNumber = 12,
    kDeltaFieldNumber = 13,
    kEmsFieldNumber = 14,
    kEmMinFieldNumber = 15,
    kEmMaxFieldNumber = 16,
    kEmStdFieldNumber = 17,
    kRollingCountFieldNumber = 18,
    kRollingStdFieldNumber = 19,
    kRollingWavgFieldNumber = 20,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeSum sum = 1;
  bool has_sum() const;
  private:
  bool _internal_has_sum() const;
  public:
  void clear_sum();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& sum() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* release_sum();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* mutable_sum();
  void set_allocated_sum(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* sum);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& _internal_sum() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* _internal_mutable_sum();
  public:
  void unsafe_arena_set_allocated_sum(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* sum);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* unsafe_arena_release_sum();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMin min = 2;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& min() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* release_min();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* mutable_min();
  void set_allocated_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* min);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& _internal_min() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* _internal_mutable_min();
  public:
  void unsafe_arena_set_allocated_min(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* min);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* unsafe_arena_release_min();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMax max = 3;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& max() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* release_max();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* mutable_max();
  void set_allocated_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* max);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& _internal_max() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* _internal_mutable_max();
  public:
  void unsafe_arena_set_allocated_max(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* max);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* unsafe_arena_release_max();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeProduct product = 4;
  bool has_product() const;
  private:
  bool _internal_has_product() const;
  public:
  void clear_product();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& product() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* release_product();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* mutable_product();
  void set_allocated_product(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* product);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& _internal_product() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* _internal_mutable_product();
  public:
  void unsafe_arena_set_allocated_product(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* product);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* unsafe_arena_release_product();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByFill fill = 5;
  bool has_fill() const;
  private:
  bool _internal_has_fill() const;
  public:
  void clear_fill();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& fill() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* release_fill();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* mutable_fill();
  void set_allocated_fill(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* fill);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& _internal_fill() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* _internal_mutable_fill();
  public:
  void unsafe_arena_set_allocated_fill(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* fill);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* unsafe_arena_release_fill();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma ema = 6;
  bool has_ema() const;
  private:
  bool _internal_has_ema() const;
  public:
  void clear_ema();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& ema() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* release_ema();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* mutable_ema();
  void set_allocated_ema(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* ema);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& _internal_ema() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* _internal_mutable_ema();
  public:
  void unsafe_arena_set_allocated_ema(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* ema);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* unsafe_arena_release_ema();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum rolling_sum = 7;
  bool has_rolling_sum() const;
  private:
  bool _internal_has_rolling_sum() const;
  public:
  void clear_rolling_sum();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& rolling_sum() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* release_rolling_sum();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* mutable_rolling_sum();
  void set_allocated_rolling_sum(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* rolling_sum);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& _internal_rolling_sum() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* _internal_mutable_rolling_sum();
  public:
  void unsafe_arena_set_allocated_rolling_sum(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* rolling_sum);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* unsafe_arena_release_rolling_sum();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup rolling_group = 8;
  bool has_rolling_group() const;
  private:
  bool _internal_has_rolling_group() const;
  public:
  void clear_rolling_group();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& rolling_group() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* release_rolling_group();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* mutable_rolling_group();
  void set_allocated_rolling_group(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* rolling_group);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& _internal_rolling_group() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* _internal_mutable_rolling_group();
  public:
  void unsafe_arena_set_allocated_rolling_group(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* rolling_group);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* unsafe_arena_release_rolling_group();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg rolling_avg = 9;
  bool has_rolling_avg() const;
  private:
  bool _internal_has_rolling_avg() const;
  public:
  void clear_rolling_avg();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& rolling_avg() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* release_rolling_avg();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* mutable_rolling_avg();
  void set_allocated_rolling_avg(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* rolling_avg);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& _internal_rolling_avg() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* _internal_mutable_rolling_avg();
  public:
  void unsafe_arena_set_allocated_rolling_avg(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* rolling_avg);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* unsafe_arena_release_rolling_avg();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin rolling_min = 10;
  bool has_rolling_min() const;
  private:
  bool _internal_has_rolling_min() const;
  public:
  void clear_rolling_min();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& rolling_min() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* release_rolling_min();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* mutable_rolling_min();
  void set_allocated_rolling_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* rolling_min);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& _internal_rolling_min() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* _internal_mutable_rolling_min();
  public:
  void unsafe_arena_set_allocated_rolling_min(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* rolling_min);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* unsafe_arena_release_rolling_min();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax rolling_max = 11;
  bool has_rolling_max() const;
  private:
  bool _internal_has_rolling_max() const;
  public:
  void clear_rolling_max();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& rolling_max() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* release_rolling_max();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* mutable_rolling_max();
  void set_allocated_rolling_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* rolling_max);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& _internal_rolling_max() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* _internal_mutable_rolling_max();
  public:
  void unsafe_arena_set_allocated_rolling_max(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* rolling_max);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* unsafe_arena_release_rolling_max();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct rolling_product = 12;
  bool has_rolling_product() const;
  private:
  bool _internal_has_rolling_product() const;
  public:
  void clear_rolling_product();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& rolling_product() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* release_rolling_product();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* mutable_rolling_product();
  void set_allocated_rolling_product(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* rolling_product);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& _internal_rolling_product() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* _internal_mutable_rolling_product();
  public:
  void unsafe_arena_set_allocated_rolling_product(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* rolling_product);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* unsafe_arena_release_rolling_product();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta delta = 13;
  bool has_delta() const;
  private:
  bool _internal_has_delta() const;
  public:
  void clear_delta();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& delta() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* release_delta();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* mutable_delta();
  void set_allocated_delta(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* delta);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& _internal_delta() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* _internal_mutable_delta();
  public:
  void unsafe_arena_set_allocated_delta(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* delta);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* unsafe_arena_release_delta();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms ems = 14;
  bool has_ems() const;
  private:
  bool _internal_has_ems() const;
  public:
  void clear_ems();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& ems() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* release_ems();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* mutable_ems();
  void set_allocated_ems(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* ems);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& _internal_ems() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* _internal_mutable_ems();
  public:
  void unsafe_arena_set_allocated_ems(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* ems);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* unsafe_arena_release_ems();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin em_min = 15;
  bool has_em_min() const;
  private:
  bool _internal_has_em_min() const;
  public:
  void clear_em_min();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& em_min() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* release_em_min();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* mutable_em_min();
  void set_allocated_em_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* em_min);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& _internal_em_min() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* _internal_mutable_em_min();
  public:
  void unsafe_arena_set_allocated_em_min(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* em_min);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* unsafe_arena_release_em_min();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax em_max = 16;
  bool has_em_max() const;
  private:
  bool _internal_has_em_max() const;
  public:
  void clear_em_max();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& em_max() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* release_em_max();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* mutable_em_max();
  void set_allocated_em_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* em_max);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& _internal_em_max() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* _internal_mutable_em_max();
  public:
  void unsafe_arena_set_allocated_em_max(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* em_max);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* unsafe_arena_release_em_max();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd em_std = 17;
  bool has_em_std() const;
  private:
  bool _internal_has_em_std() const;
  public:
  void clear_em_std();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& em_std() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* release_em_std();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* mutable_em_std();
  void set_allocated_em_std(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* em_std);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& _internal_em_std() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* _internal_mutable_em_std();
  public:
  void unsafe_arena_set_allocated_em_std(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* em_std);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* unsafe_arena_release_em_std();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount rolling_count = 18;
  bool has_rolling_count() const;
  private:
  bool _internal_has_rolling_count() const;
  public:
  void clear_rolling_count();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& rolling_count() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* release_rolling_count();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* mutable_rolling_count();
  void set_allocated_rolling_count(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* rolling_count);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& _internal_rolling_count() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* _internal_mutable_rolling_count();
  public:
  void unsafe_arena_set_allocated_rolling_count(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* rolling_count);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* unsafe_arena_release_rolling_count();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd rolling_std = 19;
  bool has_rolling_std() const;
  private:
  bool _internal_has_rolling_std() const;
  public:
  void clear_rolling_std();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& rolling_std() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* release_rolling_std();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* mutable_rolling_std();
  void set_allocated_rolling_std(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* rolling_std);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& _internal_rolling_std() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* _internal_mutable_rolling_std();
  public:
  void unsafe_arena_set_allocated_rolling_std(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* rolling_std);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* unsafe_arena_release_rolling_std();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg rolling_wavg = 20;
  bool has_rolling_wavg() const;
  private:
  bool _internal_has_rolling_wavg() const;
  public:
  void clear_rolling_wavg();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& rolling_wavg() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* release_rolling_wavg();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* mutable_rolling_wavg();
  void set_allocated_rolling_wavg(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* rolling_wavg);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& _internal_rolling_wavg() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* _internal_mutable_rolling_wavg();
  public:
  void unsafe_arena_set_allocated_rolling_wavg(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* rolling_wavg);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* unsafe_arena_release_rolling_wavg();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec)
 private:
  class _Internal;
  void set_has_sum();
  void set_has_min();
  void set_has_max();
  void set_has_product();
  void set_has_fill();
  void set_has_ema();
  void set_has_rolling_sum();
  void set_has_rolling_group();
  void set_has_rolling_avg();
  void set_has_rolling_min();
  void set_has_rolling_max();
  void set_has_rolling_product();
  void set_has_delta();
  void set_has_ems();
  void set_has_em_min();
  void set_has_em_max();
  void set_has_em_std();
  void set_has_rolling_count();
  void set_has_rolling_std();
  void set_has_rolling_wavg();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* sum_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* min_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* max_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* product_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* fill_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* ema_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* rolling_sum_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* rolling_group_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* rolling_avg_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* rolling_min_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* rolling_max_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* rolling_product_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* delta_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* ems_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* em_min_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* em_max_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* em_std_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* rolling_count_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* rolling_std_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* rolling_wavg_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn() : UpdateByRequest_UpdateByOperation_UpdateByColumn(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation_UpdateByColumn(const UpdateByRequest_UpdateByOperation_UpdateByColumn& from);
  UpdateByRequest_UpdateByOperation_UpdateByColumn(UpdateByRequest_UpdateByOperation_UpdateByColumn&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn& a, UpdateByRequest_UpdateByOperation_UpdateByColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec UpdateBySpec;

  // accessors -------------------------------------------------------

  enum : int {
    kMatchPairsFieldNumber = 2,
    kSpecFieldNumber = 1,
  };
  // repeated string match_pairs = 2;
  int match_pairs_size() const;
  private:
  int _internal_match_pairs_size() const;
  public:
  void clear_match_pairs();
  const std::string& match_pairs(int index) const;
  std::string* mutable_match_pairs(int index);
  void set_match_pairs(int index, const std::string& value);
  void set_match_pairs(int index, std::string&& value);
  void set_match_pairs(int index, const char* value);
  void set_match_pairs(int index, const char* value, size_t size);
  std::string* add_match_pairs();
  void add_match_pairs(const std::string& value);
  void add_match_pairs(std::string&& value);
  void add_match_pairs(const char* value);
  void add_match_pairs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& match_pairs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_match_pairs();
  private:
  const std::string& _internal_match_pairs(int index) const;
  std::string* _internal_add_match_pairs();
  public:

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& spec() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* release_spec();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* mutable_spec();
  void set_allocated_spec(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* spec);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& _internal_spec() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* spec);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* unsafe_arena_release_spec();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> match_pairs_;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* spec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation) */ {
 public:
  inline UpdateByRequest_UpdateByOperation() : UpdateByRequest_UpdateByOperation(nullptr) {}
  ~UpdateByRequest_UpdateByOperation() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest_UpdateByOperation(const UpdateByRequest_UpdateByOperation& from);
  UpdateByRequest_UpdateByOperation(UpdateByRequest_UpdateByOperation&& from) noexcept
    : UpdateByRequest_UpdateByOperation() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation& operator=(const UpdateByRequest_UpdateByOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation& operator=(UpdateByRequest_UpdateByOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kColumn = 1,
    TYPE_NOT_SET = 0,
  };

  static inline const UpdateByRequest_UpdateByOperation* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation*>(
               &_UpdateByRequest_UpdateByOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(UpdateByRequest_UpdateByOperation& a, UpdateByRequest_UpdateByOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest_UpdateByOperation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateByRequest_UpdateByOperation_UpdateByColumn UpdateByColumn;

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn column = 1;
  bool has_column() const;
  private:
  bool _internal_has_column() const;
  public:
  void clear_column();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn& column() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* release_column();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* mutable_column();
  void set_allocated_column(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* column);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn& _internal_column() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* _internal_mutable_column();
  public:
  void unsafe_arena_set_allocated_column(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* column);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* unsafe_arena_release_column();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation)
 private:
  class _Internal;
  void set_has_column();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* column_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UpdateByRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest) */ {
 public:
  inline UpdateByRequest() : UpdateByRequest(nullptr) {}
  ~UpdateByRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateByRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateByRequest(const UpdateByRequest& from);
  UpdateByRequest(UpdateByRequest&& from) noexcept
    : UpdateByRequest() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest& operator=(const UpdateByRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest& operator=(UpdateByRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest*>(
               &_UpdateByRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(UpdateByRequest& a, UpdateByRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UpdateByRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateByRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest";
  }
  protected:
  explicit UpdateByRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateByRequest_UpdateByOptions UpdateByOptions;
  typedef UpdateByRequest_UpdateByOperation UpdateByOperation;

  // accessors -------------------------------------------------------

  enum : int {
    kOperationsFieldNumber = 4,
    kGroupByColumnsFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kOptionsFieldNumber = 3,
  };
  // repeated .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation operations = 4;
  int operations_size() const;
  private:
  int _internal_operations_size() const;
  public:
  void clear_operations();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* mutable_operations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation >*
      mutable_operations();
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation& _internal_operations(int index) const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* _internal_add_operations();
  public:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation& operations(int index) const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* add_operations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation >&
      operations() const;

  // repeated string group_by_columns = 5;
  int group_by_columns_size() const;
  private:
  int _internal_group_by_columns_size() const;
  public:
  void clear_group_by_columns();
  const std::string& group_by_columns(int index) const;
  std::string* mutable_group_by_columns(int index);
  void set_group_by_columns(int index, const std::string& value);
  void set_group_by_columns(int index, std::string&& value);
  void set_group_by_columns(int index, const char* value);
  void set_group_by_columns(int index, const char* value, size_t size);
  std::string* add_group_by_columns();
  void add_group_by_columns(const std::string& value);
  void add_group_by_columns(std::string&& value);
  void add_group_by_columns(const char* value);
  void add_group_by_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& group_by_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_group_by_columns();
  private:
  const std::string& _internal_group_by_columns(int index) const;
  std::string* _internal_add_group_by_columns();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* options);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* _internal_mutable_options();
  public:
  void unsafe_arena_set_allocated_options(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* options);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* unsafe_arena_release_options();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation > operations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> group_by_columns_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* options_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SelectDistinctRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SelectDistinctRequest) */ {
 public:
  inline SelectDistinctRequest() : SelectDistinctRequest(nullptr) {}
  ~SelectDistinctRequest() override;
  explicit PROTOBUF_CONSTEXPR SelectDistinctRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SelectDistinctRequest(const SelectDistinctRequest& from);
  SelectDistinctRequest(SelectDistinctRequest&& from) noexcept
    : SelectDistinctRequest() {
    *this = ::std::move(from);
  }

  inline SelectDistinctRequest& operator=(const SelectDistinctRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectDistinctRequest& operator=(SelectDistinctRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectDistinctRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectDistinctRequest* internal_default_instance() {
    return reinterpret_cast<const SelectDistinctRequest*>(
               &_SelectDistinctRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(SelectDistinctRequest& a, SelectDistinctRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectDistinctRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectDistinctRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectDistinctRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectDistinctRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SelectDistinctRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SelectDistinctRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SelectDistinctRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SelectDistinctRequest";
  }
  protected:
  explicit SelectDistinctRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNamesFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated string column_names = 3;
  int column_names_size() const;
  private:
  int _internal_column_names_size() const;
  public:
  void clear_column_names();
  const std::string& column_names(int index) const;
  std::string* mutable_column_names(int index);
  void set_column_names(int index, const std::string& value);
  void set_column_names(int index, std::string&& value);
  void set_column_names(int index, const char* value);
  void set_column_names(int index, const char* value, size_t size);
  std::string* add_column_names();
  void add_column_names(const std::string& value);
  void add_column_names(std::string&& value);
  void add_column_names(const char* value);
  void add_column_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_names();
  private:
  const std::string& _internal_column_names(int index) const;
  std::string* _internal_add_column_names();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SelectDistinctRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_names_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class DropColumnsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.DropColumnsRequest) */ {
 public:
  inline DropColumnsRequest() : DropColumnsRequest(nullptr) {}
  ~DropColumnsRequest() override;
  explicit PROTOBUF_CONSTEXPR DropColumnsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DropColumnsRequest(const DropColumnsRequest& from);
  DropColumnsRequest(DropColumnsRequest&& from) noexcept
    : DropColumnsRequest() {
    *this = ::std::move(from);
  }

  inline DropColumnsRequest& operator=(const DropColumnsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumnsRequest& operator=(DropColumnsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumnsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumnsRequest* internal_default_instance() {
    return reinterpret_cast<const DropColumnsRequest*>(
               &_DropColumnsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(DropColumnsRequest& a, DropColumnsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumnsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumnsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropColumnsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropColumnsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DropColumnsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DropColumnsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DropColumnsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.DropColumnsRequest";
  }
  protected:
  explicit DropColumnsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNamesFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated string column_names = 3;
  int column_names_size() const;
  private:
  int _internal_column_names_size() const;
  public:
  void clear_column_names();
  const std::string& column_names(int index) const;
  std::string* mutable_column_names(int index);
  void set_column_names(int index, const std::string& value);
  void set_column_names(int index, std::string&& value);
  void set_column_names(int index, const char* value);
  void set_column_names(int index, const char* value, size_t size);
  std::string* add_column_names();
  void add_column_names(const std::string& value);
  void add_column_names(std::string&& value);
  void add_column_names(const char* value);
  void add_column_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& column_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_column_names();
  private:
  const std::string& _internal_column_names(int index) const;
  std::string* _internal_add_column_names();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.DropColumnsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> column_names_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UnstructuredFilterTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest) */ {
 public:
  inline UnstructuredFilterTableRequest() : UnstructuredFilterTableRequest(nullptr) {}
  ~UnstructuredFilterTableRequest() override;
  explicit PROTOBUF_CONSTEXPR UnstructuredFilterTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UnstructuredFilterTableRequest(const UnstructuredFilterTableRequest& from);
  UnstructuredFilterTableRequest(UnstructuredFilterTableRequest&& from) noexcept
    : UnstructuredFilterTableRequest() {
    *this = ::std::move(from);
  }

  inline UnstructuredFilterTableRequest& operator=(const UnstructuredFilterTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnstructuredFilterTableRequest& operator=(UnstructuredFilterTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnstructuredFilterTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnstructuredFilterTableRequest* internal_default_instance() {
    return reinterpret_cast<const UnstructuredFilterTableRequest*>(
               &_UnstructuredFilterTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(UnstructuredFilterTableRequest& a, UnstructuredFilterTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnstructuredFilterTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnstructuredFilterTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnstructuredFilterTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnstructuredFilterTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UnstructuredFilterTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UnstructuredFilterTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnstructuredFilterTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest";
  }
  protected:
  explicit UnstructuredFilterTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated string filters = 3;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, size_t size);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filters();
  private:
  const std::string& _internal_filters(int index) const;
  std::string* _internal_add_filters();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filters_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class HeadOrTailRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.HeadOrTailRequest) */ {
 public:
  inline HeadOrTailRequest() : HeadOrTailRequest(nullptr) {}
  ~HeadOrTailRequest() override;
  explicit PROTOBUF_CONSTEXPR HeadOrTailRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeadOrTailRequest(const HeadOrTailRequest& from);
  HeadOrTailRequest(HeadOrTailRequest&& from) noexcept
    : HeadOrTailRequest() {
    *this = ::std::move(from);
  }

  inline HeadOrTailRequest& operator=(const HeadOrTailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadOrTailRequest& operator=(HeadOrTailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeadOrTailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeadOrTailRequest* internal_default_instance() {
    return reinterpret_cast<const HeadOrTailRequest*>(
               &_HeadOrTailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(HeadOrTailRequest& a, HeadOrTailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeadOrTailRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeadOrTailRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeadOrTailRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeadOrTailRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeadOrTailRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeadOrTailRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeadOrTailRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.HeadOrTailRequest";
  }
  protected:
  explicit HeadOrTailRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kNumRowsFieldNumber = 3,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // sint64 num_rows = 3 [jstype = JS_STRING];
  void clear_num_rows();
  int64_t num_rows() const;
  void set_num_rows(int64_t value);
  private:
  int64_t _internal_num_rows() const;
  void _internal_set_num_rows(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.HeadOrTailRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  int64_t num_rows_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class HeadOrTailByRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest) */ {
 public:
  inline HeadOrTailByRequest() : HeadOrTailByRequest(nullptr) {}
  ~HeadOrTailByRequest() override;
  explicit PROTOBUF_CONSTEXPR HeadOrTailByRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeadOrTailByRequest(const HeadOrTailByRequest& from);
  HeadOrTailByRequest(HeadOrTailByRequest&& from) noexcept
    : HeadOrTailByRequest() {
    *this = ::std::move(from);
  }

  inline HeadOrTailByRequest& operator=(const HeadOrTailByRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadOrTailByRequest& operator=(HeadOrTailByRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeadOrTailByRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeadOrTailByRequest* internal_default_instance() {
    return reinterpret_cast<const HeadOrTailByRequest*>(
               &_HeadOrTailByRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(HeadOrTailByRequest& a, HeadOrTailByRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeadOrTailByRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeadOrTailByRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeadOrTailByRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeadOrTailByRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeadOrTailByRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeadOrTailByRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeadOrTailByRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.HeadOrTailByRequest";
  }
  protected:
  explicit HeadOrTailByRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupByColumnSpecsFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kNumRowsFieldNumber = 3,
  };
  // repeated string group_by_column_specs = 4;
  int group_by_column_specs_size() const;
  private:
  int _internal_group_by_column_specs_size() const;
  public:
  void clear_group_by_column_specs();
  const std::string& group_by_column_specs(int index) const;
  std::string* mutable_group_by_column_specs(int index);
  void set_group_by_column_specs(int index, const std::string& value);
  void set_group_by_column_specs(int index, std::string&& value);
  void set_group_by_column_specs(int index, const char* value);
  void set_group_by_column_specs(int index, const char* value, size_t size);
  std::string* add_group_by_column_specs();
  void add_group_by_column_specs(const std::string& value);
  void add_group_by_column_specs(std::string&& value);
  void add_group_by_column_specs(const char* value);
  void add_group_by_column_specs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& group_by_column_specs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_group_by_column_specs();
  private:
  const std::string& _internal_group_by_column_specs(int index) const;
  std::string* _internal_add_group_by_column_specs();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // sint64 num_rows = 3 [jstype = JS_STRING];
  void clear_num_rows();
  int64_t num_rows() const;
  void set_num_rows(int64_t value);
  private:
  int64_t _internal_num_rows() const;
  void _internal_set_num_rows(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> group_by_column_specs_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  int64_t num_rows_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class UngroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UngroupRequest) */ {
 public:
  inline UngroupRequest() : UngroupRequest(nullptr) {}
  ~UngroupRequest() override;
  explicit PROTOBUF_CONSTEXPR UngroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UngroupRequest(const UngroupRequest& from);
  UngroupRequest(UngroupRequest&& from) noexcept
    : UngroupRequest() {
    *this = ::std::move(from);
  }

  inline UngroupRequest& operator=(const UngroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UngroupRequest& operator=(UngroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UngroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UngroupRequest* internal_default_instance() {
    return reinterpret_cast<const UngroupRequest*>(
               &_UngroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(UngroupRequest& a, UngroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UngroupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UngroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UngroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UngroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UngroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const UngroupRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UngroupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UngroupRequest";
  }
  protected:
  explicit UngroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToUngroupFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kNullFillFieldNumber = 3,
  };
  // repeated string columns_to_ungroup = 4;
  int columns_to_ungroup_size() const;
  private:
  int _internal_columns_to_ungroup_size() const;
  public:
  void clear_columns_to_ungroup();
  const std::string& columns_to_ungroup(int index) const;
  std::string* mutable_columns_to_ungroup(int index);
  void set_columns_to_ungroup(int index, const std::string& value);
  void set_columns_to_ungroup(int index, std::string&& value);
  void set_columns_to_ungroup(int index, const char* value);
  void set_columns_to_ungroup(int index, const char* value, size_t size);
  std::string* add_columns_to_ungroup();
  void add_columns_to_ungroup(const std::string& value);
  void add_columns_to_ungroup(std::string&& value);
  void add_columns_to_ungroup(const char* value);
  void add_columns_to_ungroup(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_ungroup() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_ungroup();
  private:
  const std::string& _internal_columns_to_ungroup(int index) const;
  std::string* _internal_add_columns_to_ungroup();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // bool null_fill = 3;
  void clear_null_fill();
  bool null_fill() const;
  void set_null_fill(bool value);
  private:
  bool _internal_null_fill() const;
  void _internal_set_null_fill(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UngroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_ungroup_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  bool null_fill_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class MergeTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MergeTablesRequest) */ {
 public:
  inline MergeTablesRequest() : MergeTablesRequest(nullptr) {}
  ~MergeTablesRequest() override;
  explicit PROTOBUF_CONSTEXPR MergeTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MergeTablesRequest(const MergeTablesRequest& from);
  MergeTablesRequest(MergeTablesRequest&& from) noexcept
    : MergeTablesRequest() {
    *this = ::std::move(from);
  }

  inline MergeTablesRequest& operator=(const MergeTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MergeTablesRequest& operator=(MergeTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MergeTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MergeTablesRequest* internal_default_instance() {
    return reinterpret_cast<const MergeTablesRequest*>(
               &_MergeTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(MergeTablesRequest& a, MergeTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MergeTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MergeTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MergeTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MergeTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MergeTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MergeTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MergeTablesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MergeTablesRequest";
  }
  protected:
  explicit MergeTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdsFieldNumber = 2,
    kKeyColumnFieldNumber = 3,
    kResultIdFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.TableReference source_ids = 2;
  int source_ids_size() const;
  private:
  int _internal_source_ids_size() const;
  public:
  void clear_source_ids();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference >*
      mutable_source_ids();
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_ids(int index) const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_add_source_ids();
  public:
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_ids(int index) const;
  ::io::deephaven::proto::backplane::grpc::TableReference* add_source_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference >&
      source_ids() const;

  // string key_column = 3;
  void clear_key_column();
  const std::string& key_column() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key_column(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key_column();
  PROTOBUF_NODISCARD std::string* release_key_column();
  void set_allocated_key_column(std::string* key_column);
  private:
  const std::string& _internal_key_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_column(const std::string& value);
  std::string* _internal_mutable_key_column();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MergeTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference > source_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_column_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SnapshotTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SnapshotTableRequest) */ {
 public:
  inline SnapshotTableRequest() : SnapshotTableRequest(nullptr) {}
  ~SnapshotTableRequest() override;
  explicit PROTOBUF_CONSTEXPR SnapshotTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotTableRequest(const SnapshotTableRequest& from);
  SnapshotTableRequest(SnapshotTableRequest&& from) noexcept
    : SnapshotTableRequest() {
    *this = ::std::move(from);
  }

  inline SnapshotTableRequest& operator=(const SnapshotTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotTableRequest& operator=(SnapshotTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotTableRequest* internal_default_instance() {
    return reinterpret_cast<const SnapshotTableRequest*>(
               &_SnapshotTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(SnapshotTableRequest& a, SnapshotTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SnapshotTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SnapshotTableRequest";
  }
  protected:
  explicit SnapshotTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SnapshotTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SnapshotWhenTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest) */ {
 public:
  inline SnapshotWhenTableRequest() : SnapshotWhenTableRequest(nullptr) {}
  ~SnapshotWhenTableRequest() override;
  explicit PROTOBUF_CONSTEXPR SnapshotWhenTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotWhenTableRequest(const SnapshotWhenTableRequest& from);
  SnapshotWhenTableRequest(SnapshotWhenTableRequest&& from) noexcept
    : SnapshotWhenTableRequest() {
    *this = ::std::move(from);
  }

  inline SnapshotWhenTableRequest& operator=(const SnapshotWhenTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotWhenTableRequest& operator=(SnapshotWhenTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotWhenTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotWhenTableRequest* internal_default_instance() {
    return reinterpret_cast<const SnapshotWhenTableRequest*>(
               &_SnapshotWhenTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(SnapshotWhenTableRequest& a, SnapshotWhenTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotWhenTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotWhenTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotWhenTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotWhenTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotWhenTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SnapshotWhenTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotWhenTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest";
  }
  protected:
  explicit SnapshotWhenTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStampColumnsFieldNumber = 7,
    kResultIdFieldNumber = 1,
    kBaseIdFieldNumber = 2,
    kTriggerIdFieldNumber = 3,
    kInitialFieldNumber = 4,
    kIncrementalFieldNumber = 5,
    kHistoryFieldNumber = 6,
  };
  // repeated string stamp_columns = 7;
  int stamp_columns_size() const;
  private:
  int _internal_stamp_columns_size() const;
  public:
  void clear_stamp_columns();
  const std::string& stamp_columns(int index) const;
  std::string* mutable_stamp_columns(int index);
  void set_stamp_columns(int index, const std::string& value);
  void set_stamp_columns(int index, std::string&& value);
  void set_stamp_columns(int index, const char* value);
  void set_stamp_columns(int index, const char* value, size_t size);
  std::string* add_stamp_columns();
  void add_stamp_columns(const std::string& value);
  void add_stamp_columns(std::string&& value);
  void add_stamp_columns(const char* value);
  void add_stamp_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& stamp_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_stamp_columns();
  private:
  const std::string& _internal_stamp_columns(int index) const;
  std::string* _internal_add_stamp_columns();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference base_id = 2;
  bool has_base_id() const;
  private:
  bool _internal_has_base_id() const;
  public:
  void clear_base_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& base_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_base_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_base_id();
  void set_allocated_base_id(::io::deephaven::proto::backplane::grpc::TableReference* base_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_base_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_base_id();
  public:
  void unsafe_arena_set_allocated_base_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* base_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_base_id();

  // .io.deephaven.proto.backplane.grpc.TableReference trigger_id = 3;
  bool has_trigger_id() const;
  private:
  bool _internal_has_trigger_id() const;
  public:
  void clear_trigger_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& trigger_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_trigger_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_trigger_id();
  void set_allocated_trigger_id(::io::deephaven::proto::backplane::grpc::TableReference* trigger_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_trigger_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_trigger_id();
  public:
  void unsafe_arena_set_allocated_trigger_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* trigger_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_trigger_id();

  // bool initial = 4;
  void clear_initial();
  bool initial() const;
  void set_initial(bool value);
  private:
  bool _internal_initial() const;
  void _internal_set_initial(bool value);
  public:

  // bool incremental = 5;
  void clear_incremental();
  bool incremental() const;
  void set_incremental(bool value);
  private:
  bool _internal_incremental() const;
  void _internal_set_incremental(bool value);
  public:

  // bool history = 6;
  void clear_history();
  bool history() const;
  void set_history(bool value);
  private:
  bool _internal_history() const;
  void _internal_set_history(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> stamp_columns_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* base_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* trigger_id_;
  bool initial_;
  bool incremental_;
  bool history_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class CrossJoinTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest) */ {
 public:
  inline CrossJoinTablesRequest() : CrossJoinTablesRequest(nullptr) {}
  ~CrossJoinTablesRequest() override;
  explicit PROTOBUF_CONSTEXPR CrossJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CrossJoinTablesRequest(const CrossJoinTablesRequest& from);
  CrossJoinTablesRequest(CrossJoinTablesRequest&& from) noexcept
    : CrossJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline CrossJoinTablesRequest& operator=(const CrossJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrossJoinTablesRequest& operator=(CrossJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CrossJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CrossJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const CrossJoinTablesRequest*>(
               &_CrossJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(CrossJoinTablesRequest& a, CrossJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CrossJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrossJoinTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CrossJoinTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CrossJoinTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CrossJoinTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CrossJoinTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CrossJoinTablesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest";
  }
  protected:
  explicit CrossJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
    kReserveBitsFieldNumber = 6,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;
  public:
  void clear_columns_to_match();
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, size_t size);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_match();
  private:
  const std::string& _internal_columns_to_match(int index) const;
  std::string* _internal_add_columns_to_match();
  public:

  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;
  public:
  void clear_columns_to_add();
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, size_t size);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_add();
  private:
  const std::string& _internal_columns_to_add(int index) const;
  std::string* _internal_add_columns_to_add();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // int32 reserve_bits = 6;
  void clear_reserve_bits();
  int32_t reserve_bits() const;
  void set_reserve_bits(int32_t value);
  private:
  int32_t _internal_reserve_bits() const;
  void _internal_set_reserve_bits(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_match_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_add_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  int32_t reserve_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class NaturalJoinTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest) */ {
 public:
  inline NaturalJoinTablesRequest() : NaturalJoinTablesRequest(nullptr) {}
  ~NaturalJoinTablesRequest() override;
  explicit PROTOBUF_CONSTEXPR NaturalJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NaturalJoinTablesRequest(const NaturalJoinTablesRequest& from);
  NaturalJoinTablesRequest(NaturalJoinTablesRequest&& from) noexcept
    : NaturalJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline NaturalJoinTablesRequest& operator=(const NaturalJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NaturalJoinTablesRequest& operator=(NaturalJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NaturalJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NaturalJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const NaturalJoinTablesRequest*>(
               &_NaturalJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(NaturalJoinTablesRequest& a, NaturalJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NaturalJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NaturalJoinTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NaturalJoinTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NaturalJoinTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NaturalJoinTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NaturalJoinTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NaturalJoinTablesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest";
  }
  protected:
  explicit NaturalJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;
  public:
  void clear_columns_to_match();
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, size_t size);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_match();
  private:
  const std::string& _internal_columns_to_match(int index) const;
  std::string* _internal_add_columns_to_match();
  public:

  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;
  public:
  void clear_columns_to_add();
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, size_t size);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_add();
  private:
  const std::string& _internal_columns_to_add(int index) const;
  std::string* _internal_add_columns_to_add();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_match_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_add_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ExactJoinTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest) */ {
 public:
  inline ExactJoinTablesRequest() : ExactJoinTablesRequest(nullptr) {}
  ~ExactJoinTablesRequest() override;
  explicit PROTOBUF_CONSTEXPR ExactJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExactJoinTablesRequest(const ExactJoinTablesRequest& from);
  ExactJoinTablesRequest(ExactJoinTablesRequest&& from) noexcept
    : ExactJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline ExactJoinTablesRequest& operator=(const ExactJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExactJoinTablesRequest& operator=(ExactJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExactJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExactJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const ExactJoinTablesRequest*>(
               &_ExactJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ExactJoinTablesRequest& a, ExactJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExactJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExactJoinTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExactJoinTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExactJoinTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExactJoinTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExactJoinTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExactJoinTablesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest";
  }
  protected:
  explicit ExactJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;
  public:
  void clear_columns_to_match();
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, size_t size);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_match();
  private:
  const std::string& _internal_columns_to_match(int index) const;
  std::string* _internal_add_columns_to_match();
  public:

  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;
  public:
  void clear_columns_to_add();
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, size_t size);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_add();
  private:
  const std::string& _internal_columns_to_add(int index) const;
  std::string* _internal_add_columns_to_add();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_match_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_add_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class LeftJoinTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest) */ {
 public:
  inline LeftJoinTablesRequest() : LeftJoinTablesRequest(nullptr) {}
  ~LeftJoinTablesRequest() override;
  explicit PROTOBUF_CONSTEXPR LeftJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LeftJoinTablesRequest(const LeftJoinTablesRequest& from);
  LeftJoinTablesRequest(LeftJoinTablesRequest&& from) noexcept
    : LeftJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline LeftJoinTablesRequest& operator=(const LeftJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeftJoinTablesRequest& operator=(LeftJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeftJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeftJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const LeftJoinTablesRequest*>(
               &_LeftJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(LeftJoinTablesRequest& a, LeftJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeftJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeftJoinTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeftJoinTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeftJoinTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LeftJoinTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LeftJoinTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeftJoinTablesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest";
  }
  protected:
  explicit LeftJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;
  public:
  void clear_columns_to_match();
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, size_t size);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_match();
  private:
  const std::string& _internal_columns_to_match(int index) const;
  std::string* _internal_add_columns_to_match();
  public:

  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;
  public:
  void clear_columns_to_add();
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, size_t size);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_add();
  private:
  const std::string& _internal_columns_to_add(int index) const;
  std::string* _internal_add_columns_to_add();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_match_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_add_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AsOfJoinTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest) */ {
 public:
  inline AsOfJoinTablesRequest() : AsOfJoinTablesRequest(nullptr) {}
  ~AsOfJoinTablesRequest() override;
  explicit PROTOBUF_CONSTEXPR AsOfJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AsOfJoinTablesRequest(const AsOfJoinTablesRequest& from);
  AsOfJoinTablesRequest(AsOfJoinTablesRequest&& from) noexcept
    : AsOfJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline AsOfJoinTablesRequest& operator=(const AsOfJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsOfJoinTablesRequest& operator=(AsOfJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AsOfJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AsOfJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const AsOfJoinTablesRequest*>(
               &_AsOfJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(AsOfJoinTablesRequest& a, AsOfJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AsOfJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AsOfJoinTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AsOfJoinTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AsOfJoinTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AsOfJoinTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AsOfJoinTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AsOfJoinTablesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest";
  }
  protected:
  explicit AsOfJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AsOfJoinTablesRequest_MatchRule MatchRule;
  static constexpr MatchRule LESS_THAN_EQUAL =
    AsOfJoinTablesRequest_MatchRule_LESS_THAN_EQUAL;
  static constexpr MatchRule LESS_THAN =
    AsOfJoinTablesRequest_MatchRule_LESS_THAN;
  static constexpr MatchRule GREATER_THAN_EQUAL =
    AsOfJoinTablesRequest_MatchRule_GREATER_THAN_EQUAL;
  static constexpr MatchRule GREATER_THAN =
    AsOfJoinTablesRequest_MatchRule_GREATER_THAN;
  static inline bool MatchRule_IsValid(int value) {
    return AsOfJoinTablesRequest_MatchRule_IsValid(value);
  }
  static constexpr MatchRule MatchRule_MIN =
    AsOfJoinTablesRequest_MatchRule_MatchRule_MIN;
  static constexpr MatchRule MatchRule_MAX =
    AsOfJoinTablesRequest_MatchRule_MatchRule_MAX;
  static constexpr int MatchRule_ARRAYSIZE =
    AsOfJoinTablesRequest_MatchRule_MatchRule_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MatchRule_descriptor() {
    return AsOfJoinTablesRequest_MatchRule_descriptor();
  }
  template<typename T>
  static inline const std::string& MatchRule_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MatchRule>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MatchRule_Name.");
    return AsOfJoinTablesRequest_MatchRule_Name(enum_t_value);
  }
  static inline bool MatchRule_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MatchRule* value) {
    return AsOfJoinTablesRequest_MatchRule_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
    kAsOfMatchRuleFieldNumber = 7,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;
  public:
  void clear_columns_to_match();
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, size_t size);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_match();
  private:
  const std::string& _internal_columns_to_match(int index) const;
  std::string* _internal_add_columns_to_match();
  public:

  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;
  public:
  void clear_columns_to_add();
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, size_t size);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_add();
  private:
  const std::string& _internal_columns_to_add(int index) const;
  std::string* _internal_add_columns_to_add();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // .io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.MatchRule as_of_match_rule = 7;
  void clear_as_of_match_rule();
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule as_of_match_rule() const;
  void set_as_of_match_rule(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule value);
  private:
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule _internal_as_of_match_rule() const;
  void _internal_set_as_of_match_rule(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_match_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_add_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  int as_of_match_rule_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AjRajTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AjRajTablesRequest) */ {
 public:
  inline AjRajTablesRequest() : AjRajTablesRequest(nullptr) {}
  ~AjRajTablesRequest() override;
  explicit PROTOBUF_CONSTEXPR AjRajTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AjRajTablesRequest(const AjRajTablesRequest& from);
  AjRajTablesRequest(AjRajTablesRequest&& from) noexcept
    : AjRajTablesRequest() {
    *this = ::std::move(from);
  }

  inline AjRajTablesRequest& operator=(const AjRajTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AjRajTablesRequest& operator=(AjRajTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AjRajTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AjRajTablesRequest* internal_default_instance() {
    return reinterpret_cast<const AjRajTablesRequest*>(
               &_AjRajTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(AjRajTablesRequest& a, AjRajTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AjRajTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AjRajTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AjRajTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AjRajTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AjRajTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AjRajTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AjRajTablesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AjRajTablesRequest";
  }
  protected:
  explicit AjRajTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExactMatchColumnsFieldNumber = 4,
    kColumnsToAddFieldNumber = 6,
    kAsOfColumnFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
  };
  // repeated string exact_match_columns = 4;
  int exact_match_columns_size() const;
  private:
  int _internal_exact_match_columns_size() const;
  public:
  void clear_exact_match_columns();
  const std::string& exact_match_columns(int index) const;
  std::string* mutable_exact_match_columns(int index);
  void set_exact_match_columns(int index, const std::string& value);
  void set_exact_match_columns(int index, std::string&& value);
  void set_exact_match_columns(int index, const char* value);
  void set_exact_match_columns(int index, const char* value, size_t size);
  std::string* add_exact_match_columns();
  void add_exact_match_columns(const std::string& value);
  void add_exact_match_columns(std::string&& value);
  void add_exact_match_columns(const char* value);
  void add_exact_match_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& exact_match_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_exact_match_columns();
  private:
  const std::string& _internal_exact_match_columns(int index) const;
  std::string* _internal_add_exact_match_columns();
  public:

  // repeated string columns_to_add = 6;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;
  public:
  void clear_columns_to_add();
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, size_t size);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_add() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_add();
  private:
  const std::string& _internal_columns_to_add(int index) const;
  std::string* _internal_add_columns_to_add();
  public:

  // string as_of_column = 5;
  void clear_as_of_column();
  const std::string& as_of_column() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_as_of_column(ArgT0&& arg0, ArgT... args);
  std::string* mutable_as_of_column();
  PROTOBUF_NODISCARD std::string* release_as_of_column();
  void set_allocated_as_of_column(std::string* as_of_column);
  private:
  const std::string& _internal_as_of_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_as_of_column(const std::string& value);
  std::string* _internal_mutable_as_of_column();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AjRajTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> exact_match_columns_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_add_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr as_of_column_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class RangeJoinTablesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest) */ {
 public:
  inline RangeJoinTablesRequest() : RangeJoinTablesRequest(nullptr) {}
  ~RangeJoinTablesRequest() override;
  explicit PROTOBUF_CONSTEXPR RangeJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RangeJoinTablesRequest(const RangeJoinTablesRequest& from);
  RangeJoinTablesRequest(RangeJoinTablesRequest&& from) noexcept
    : RangeJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline RangeJoinTablesRequest& operator=(const RangeJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeJoinTablesRequest& operator=(RangeJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const RangeJoinTablesRequest*>(
               &_RangeJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(RangeJoinTablesRequest& a, RangeJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeJoinTablesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeJoinTablesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeJoinTablesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RangeJoinTablesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RangeJoinTablesRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeJoinTablesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest";
  }
  protected:
  explicit RangeJoinTablesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RangeJoinTablesRequest_RangeStartRule RangeStartRule;
  static constexpr RangeStartRule START_UNSPECIFIED =
    RangeJoinTablesRequest_RangeStartRule_START_UNSPECIFIED;
  static constexpr RangeStartRule LESS_THAN =
    RangeJoinTablesRequest_RangeStartRule_LESS_THAN;
  static constexpr RangeStartRule LESS_THAN_OR_EQUAL =
    RangeJoinTablesRequest_RangeStartRule_LESS_THAN_OR_EQUAL;
  static constexpr RangeStartRule LESS_THAN_OR_EQUAL_ALLOW_PRECEDING =
    RangeJoinTablesRequest_RangeStartRule_LESS_THAN_OR_EQUAL_ALLOW_PRECEDING;
  static inline bool RangeStartRule_IsValid(int value) {
    return RangeJoinTablesRequest_RangeStartRule_IsValid(value);
  }
  static constexpr RangeStartRule RangeStartRule_MIN =
    RangeJoinTablesRequest_RangeStartRule_RangeStartRule_MIN;
  static constexpr RangeStartRule RangeStartRule_MAX =
    RangeJoinTablesRequest_RangeStartRule_RangeStartRule_MAX;
  static constexpr int RangeStartRule_ARRAYSIZE =
    RangeJoinTablesRequest_RangeStartRule_RangeStartRule_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RangeStartRule_descriptor() {
    return RangeJoinTablesRequest_RangeStartRule_descriptor();
  }
  template<typename T>
  static inline const std::string& RangeStartRule_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RangeStartRule>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RangeStartRule_Name.");
    return RangeJoinTablesRequest_RangeStartRule_Name(enum_t_value);
  }
  static inline bool RangeStartRule_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RangeStartRule* value) {
    return RangeJoinTablesRequest_RangeStartRule_Parse(name, value);
  }

  typedef RangeJoinTablesRequest_RangeEndRule RangeEndRule;
  static constexpr RangeEndRule END_UNSPECIFIED =
    RangeJoinTablesRequest_RangeEndRule_END_UNSPECIFIED;
  static constexpr RangeEndRule GREATER_THAN =
    RangeJoinTablesRequest_RangeEndRule_GREATER_THAN;
  static constexpr RangeEndRule GREATER_THAN_OR_EQUAL =
    RangeJoinTablesRequest_RangeEndRule_GREATER_THAN_OR_EQUAL;
  static constexpr RangeEndRule GREATER_THAN_OR_EQUAL_ALLOW_FOLLOWING =
    RangeJoinTablesRequest_RangeEndRule_GREATER_THAN_OR_EQUAL_ALLOW_FOLLOWING;
  static inline bool RangeEndRule_IsValid(int value) {
    return RangeJoinTablesRequest_RangeEndRule_IsValid(value);
  }
  static constexpr RangeEndRule RangeEndRule_MIN =
    RangeJoinTablesRequest_RangeEndRule_RangeEndRule_MIN;
  static constexpr RangeEndRule RangeEndRule_MAX =
    RangeJoinTablesRequest_RangeEndRule_RangeEndRule_MAX;
  static constexpr int RangeEndRule_ARRAYSIZE =
    RangeJoinTablesRequest_RangeEndRule_RangeEndRule_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RangeEndRule_descriptor() {
    return RangeJoinTablesRequest_RangeEndRule_descriptor();
  }
  template<typename T>
  static inline const std::string& RangeEndRule_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RangeEndRule>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RangeEndRule_Name.");
    return RangeJoinTablesRequest_RangeEndRule_Name(enum_t_value);
  }
  static inline bool RangeEndRule_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RangeEndRule* value) {
    return RangeJoinTablesRequest_RangeEndRule_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExactMatchColumnsFieldNumber = 4,
    kAggregationsFieldNumber = 10,
    kLeftStartColumnFieldNumber = 5,
    kRightRangeColumnFieldNumber = 7,
    kLeftEndColumnFieldNumber = 9,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
    kRangeStartRuleFieldNumber = 6,
    kRangeEndRuleFieldNumber = 8,
  };
  // repeated string exact_match_columns = 4;
  int exact_match_columns_size() const;
  private:
  int _internal_exact_match_columns_size() const;
  public:
  void clear_exact_match_columns();
  const std::string& exact_match_columns(int index) const;
  std::string* mutable_exact_match_columns(int index);
  void set_exact_match_columns(int index, const std::string& value);
  void set_exact_match_columns(int index, std::string&& value);
  void set_exact_match_columns(int index, const char* value);
  void set_exact_match_columns(int index, const char* value, size_t size);
  std::string* add_exact_match_columns();
  void add_exact_match_columns(const std::string& value);
  void add_exact_match_columns(std::string&& value);
  void add_exact_match_columns(const char* value);
  void add_exact_match_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& exact_match_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_exact_match_columns();
  private:
  const std::string& _internal_exact_match_columns(int index) const;
  std::string* _internal_add_exact_match_columns();
  public:

  // repeated .io.deephaven.proto.backplane.grpc.Aggregation aggregations = 10;
  int aggregations_size() const;
  private:
  int _internal_aggregations_size() const;
  public:
  void clear_aggregations();
  ::io::deephaven::proto::backplane::grpc::Aggregation* mutable_aggregations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation >*
      mutable_aggregations();
  private:
  const ::io::deephaven::proto::backplane::grpc::Aggregation& _internal_aggregations(int index) const;
  ::io::deephaven::proto::backplane::grpc::Aggregation* _internal_add_aggregations();
  public:
  const ::io::deephaven::proto::backplane::grpc::Aggregation& aggregations(int index) const;
  ::io::deephaven::proto::backplane::grpc::Aggregation* add_aggregations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation >&
      aggregations() const;

  // string left_start_column = 5;
  void clear_left_start_column();
  const std::string& left_start_column() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_left_start_column(ArgT0&& arg0, ArgT... args);
  std::string* mutable_left_start_column();
  PROTOBUF_NODISCARD std::string* release_left_start_column();
  void set_allocated_left_start_column(std::string* left_start_column);
  private:
  const std::string& _internal_left_start_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_left_start_column(const std::string& value);
  std::string* _internal_mutable_left_start_column();
  public:

  // string right_range_column = 7;
  void clear_right_range_column();
  const std::string& right_range_column() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_right_range_column(ArgT0&& arg0, ArgT... args);
  std::string* mutable_right_range_column();
  PROTOBUF_NODISCARD std::string* release_right_range_column();
  void set_allocated_right_range_column(std::string* right_range_column);
  private:
  const std::string& _internal_right_range_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_right_range_column(const std::string& value);
  std::string* _internal_mutable_right_range_column();
  public:

  // string left_end_column = 9;
  void clear_left_end_column();
  const std::string& left_end_column() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_left_end_column(ArgT0&& arg0, ArgT... args);
  std::string* mutable_left_end_column();
  PROTOBUF_NODISCARD std::string* release_left_end_column();
  void set_allocated_left_end_column(std::string* left_end_column);
  private:
  const std::string& _internal_left_end_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_left_end_column(const std::string& value);
  std::string* _internal_mutable_left_end_column();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // .io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.RangeStartRule range_start_rule = 6;
  void clear_range_start_rule();
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule range_start_rule() const;
  void set_range_start_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule value);
  private:
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule _internal_range_start_rule() const;
  void _internal_set_range_start_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule value);
  public:

  // .io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.RangeEndRule range_end_rule = 8;
  void clear_range_end_rule();
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule range_end_rule() const;
  void set_range_end_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule value);
  private:
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule _internal_range_end_rule() const;
  void _internal_set_range_end_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> exact_match_columns_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation > aggregations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr left_start_column_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr right_range_column_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr left_end_column_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  int range_start_rule_;
  int range_end_rule_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ComboAggregateRequest_Aggregate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate) */ {
 public:
  inline ComboAggregateRequest_Aggregate() : ComboAggregateRequest_Aggregate(nullptr) {}
  ~ComboAggregateRequest_Aggregate() override;
  explicit PROTOBUF_CONSTEXPR ComboAggregateRequest_Aggregate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComboAggregateRequest_Aggregate(const ComboAggregateRequest_Aggregate& from);
  ComboAggregateRequest_Aggregate(ComboAggregateRequest_Aggregate&& from) noexcept
    : ComboAggregateRequest_Aggregate() {
    *this = ::std::move(from);
  }

  inline ComboAggregateRequest_Aggregate& operator=(const ComboAggregateRequest_Aggregate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComboAggregateRequest_Aggregate& operator=(ComboAggregateRequest_Aggregate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComboAggregateRequest_Aggregate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComboAggregateRequest_Aggregate* internal_default_instance() {
    return reinterpret_cast<const ComboAggregateRequest_Aggregate*>(
               &_ComboAggregateRequest_Aggregate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(ComboAggregateRequest_Aggregate& a, ComboAggregateRequest_Aggregate& b) {
    a.Swap(&b);
  }
  inline void Swap(ComboAggregateRequest_Aggregate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComboAggregateRequest_Aggregate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComboAggregateRequest_Aggregate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComboAggregateRequest_Aggregate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComboAggregateRequest_Aggregate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ComboAggregateRequest_Aggregate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComboAggregateRequest_Aggregate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate";
  }
  protected:
  explicit ComboAggregateRequest_Aggregate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchPairsFieldNumber = 2,
    kColumnNameFieldNumber = 3,
    kTypeFieldNumber = 1,
    kAvgMedianFieldNumber = 5,
    kPercentileFieldNumber = 4,
  };
  // repeated string match_pairs = 2;
  int match_pairs_size() const;
  private:
  int _internal_match_pairs_size() const;
  public:
  void clear_match_pairs();
  const std::string& match_pairs(int index) const;
  std::string* mutable_match_pairs(int index);
  void set_match_pairs(int index, const std::string& value);
  void set_match_pairs(int index, std::string&& value);
  void set_match_pairs(int index, const char* value);
  void set_match_pairs(int index, const char* value, size_t size);
  std::string* add_match_pairs();
  void add_match_pairs(const std::string& value);
  void add_match_pairs(std::string&& value);
  void add_match_pairs(const char* value);
  void add_match_pairs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& match_pairs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_match_pairs();
  private:
  const std::string& _internal_match_pairs(int index) const;
  std::string* _internal_add_match_pairs();
  public:

  // string column_name = 3;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // .io.deephaven.proto.backplane.grpc.ComboAggregateRequest.AggType type = 1;
  void clear_type();
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType type() const;
  void set_type(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType value);
  private:
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType _internal_type() const;
  void _internal_set_type(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType value);
  public:

  // bool avg_median = 5;
  void clear_avg_median();
  bool avg_median() const;
  void set_avg_median(bool value);
  private:
  bool _internal_avg_median() const;
  void _internal_set_avg_median(bool value);
  public:

  // double percentile = 4;
  void clear_percentile();
  double percentile() const;
  void set_percentile(double value);
  private:
  double _internal_percentile() const;
  void _internal_set_percentile(double value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> match_pairs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  int type_;
  bool avg_median_;
  double percentile_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ComboAggregateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ComboAggregateRequest) */ {
 public:
  inline ComboAggregateRequest() : ComboAggregateRequest(nullptr) {}
  ~ComboAggregateRequest() override;
  explicit PROTOBUF_CONSTEXPR ComboAggregateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComboAggregateRequest(const ComboAggregateRequest& from);
  ComboAggregateRequest(ComboAggregateRequest&& from) noexcept
    : ComboAggregateRequest() {
    *this = ::std::move(from);
  }

  inline ComboAggregateRequest& operator=(const ComboAggregateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComboAggregateRequest& operator=(ComboAggregateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComboAggregateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComboAggregateRequest* internal_default_instance() {
    return reinterpret_cast<const ComboAggregateRequest*>(
               &_ComboAggregateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(ComboAggregateRequest& a, ComboAggregateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ComboAggregateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComboAggregateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComboAggregateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComboAggregateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComboAggregateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ComboAggregateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComboAggregateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ComboAggregateRequest";
  }
  protected:
  explicit ComboAggregateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ComboAggregateRequest_Aggregate Aggregate;

  typedef ComboAggregateRequest_AggType AggType;
  static constexpr AggType SUM =
    ComboAggregateRequest_AggType_SUM;
  static constexpr AggType ABS_SUM =
    ComboAggregateRequest_AggType_ABS_SUM;
  static constexpr AggType GROUP =
    ComboAggregateRequest_AggType_GROUP;
  static constexpr AggType AVG =
    ComboAggregateRequest_AggType_AVG;
  static constexpr AggType COUNT =
    ComboAggregateRequest_AggType_COUNT;
  static constexpr AggType FIRST =
    ComboAggregateRequest_AggType_FIRST;
  static constexpr AggType LAST =
    ComboAggregateRequest_AggType_LAST;
  static constexpr AggType MIN =
    ComboAggregateRequest_AggType_MIN;
  static constexpr AggType MAX =
    ComboAggregateRequest_AggType_MAX;
  static constexpr AggType MEDIAN =
    ComboAggregateRequest_AggType_MEDIAN;
  static constexpr AggType PERCENTILE =
    ComboAggregateRequest_AggType_PERCENTILE;
  static constexpr AggType STD =
    ComboAggregateRequest_AggType_STD;
  static constexpr AggType VAR =
    ComboAggregateRequest_AggType_VAR;
  static constexpr AggType WEIGHTED_AVG =
    ComboAggregateRequest_AggType_WEIGHTED_AVG;
  static inline bool AggType_IsValid(int value) {
    return ComboAggregateRequest_AggType_IsValid(value);
  }
  static constexpr AggType AggType_MIN =
    ComboAggregateRequest_AggType_AggType_MIN;
  static constexpr AggType AggType_MAX =
    ComboAggregateRequest_AggType_AggType_MAX;
  static constexpr int AggType_ARRAYSIZE =
    ComboAggregateRequest_AggType_AggType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AggType_descriptor() {
    return ComboAggregateRequest_AggType_descriptor();
  }
  template<typename T>
  static inline const std::string& AggType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AggType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AggType_Name.");
    return ComboAggregateRequest_AggType_Name(enum_t_value);
  }
  static inline bool AggType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AggType* value) {
    return ComboAggregateRequest_AggType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAggregatesFieldNumber = 3,
    kGroupByColumnsFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kForceComboFieldNumber = 5,
  };
  // repeated .io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate aggregates = 3;
  int aggregates_size() const;
  private:
  int _internal_aggregates_size() const;
  public:
  void clear_aggregates();
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* mutable_aggregates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate >*
      mutable_aggregates();
  private:
  const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate& _internal_aggregates(int index) const;
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* _internal_add_aggregates();
  public:
  const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate& aggregates(int index) const;
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* add_aggregates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate >&
      aggregates() const;

  // repeated string group_by_columns = 4;
  int group_by_columns_size() const;
  private:
  int _internal_group_by_columns_size() const;
  public:
  void clear_group_by_columns();
  const std::string& group_by_columns(int index) const;
  std::string* mutable_group_by_columns(int index);
  void set_group_by_columns(int index, const std::string& value);
  void set_group_by_columns(int index, std::string&& value);
  void set_group_by_columns(int index, const char* value);
  void set_group_by_columns(int index, const char* value, size_t size);
  std::string* add_group_by_columns();
  void add_group_by_columns(const std::string& value);
  void add_group_by_columns(std::string&& value);
  void add_group_by_columns(const char* value);
  void add_group_by_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& group_by_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_group_by_columns();
  private:
  const std::string& _internal_group_by_columns(int index) const;
  std::string* _internal_add_group_by_columns();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // bool force_combo = 5;
  void clear_force_combo();
  bool force_combo() const;
  void set_force_combo(bool value);
  private:
  bool _internal_force_combo() const;
  void _internal_set_force_combo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ComboAggregateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate > aggregates_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> group_by_columns_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  bool force_combo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggregateAllRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggregateAllRequest) */ {
 public:
  inline AggregateAllRequest() : AggregateAllRequest(nullptr) {}
  ~AggregateAllRequest() override;
  explicit PROTOBUF_CONSTEXPR AggregateAllRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregateAllRequest(const AggregateAllRequest& from);
  AggregateAllRequest(AggregateAllRequest&& from) noexcept
    : AggregateAllRequest() {
    *this = ::std::move(from);
  }

  inline AggregateAllRequest& operator=(const AggregateAllRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateAllRequest& operator=(AggregateAllRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateAllRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateAllRequest* internal_default_instance() {
    return reinterpret_cast<const AggregateAllRequest*>(
               &_AggregateAllRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(AggregateAllRequest& a, AggregateAllRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregateAllRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateAllRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateAllRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregateAllRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggregateAllRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggregateAllRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateAllRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggregateAllRequest";
  }
  protected:
  explicit AggregateAllRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupByColumnsFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kSpecFieldNumber = 3,
  };
  // repeated string group_by_columns = 4;
  int group_by_columns_size() const;
  private:
  int _internal_group_by_columns_size() const;
  public:
  void clear_group_by_columns();
  const std::string& group_by_columns(int index) const;
  std::string* mutable_group_by_columns(int index);
  void set_group_by_columns(int index, const std::string& value);
  void set_group_by_columns(int index, std::string&& value);
  void set_group_by_columns(int index, const char* value);
  void set_group_by_columns(int index, const char* value, size_t size);
  std::string* add_group_by_columns();
  void add_group_by_columns(const std::string& value);
  void add_group_by_columns(std::string&& value);
  void add_group_by_columns(const char* value);
  void add_group_by_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& group_by_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_group_by_columns();
  private:
  const std::string& _internal_group_by_columns(int index) const;
  std::string* _internal_add_group_by_columns();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // .io.deephaven.proto.backplane.grpc.AggSpec spec = 3;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::io::deephaven::proto::backplane::grpc::AggSpec& spec() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec* release_spec();
  ::io::deephaven::proto::backplane::grpc::AggSpec* mutable_spec();
  void set_allocated_spec(::io::deephaven::proto::backplane::grpc::AggSpec* spec);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec& _internal_spec() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::io::deephaven::proto::backplane::grpc::AggSpec* spec);
  ::io::deephaven::proto::backplane::grpc::AggSpec* unsafe_arena_release_spec();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggregateAllRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> group_by_columns_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  ::io::deephaven::proto::backplane::grpc::AggSpec* spec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecApproximatePercentile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile) */ {
 public:
  inline AggSpec_AggSpecApproximatePercentile() : AggSpec_AggSpecApproximatePercentile(nullptr) {}
  ~AggSpec_AggSpecApproximatePercentile() override;
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecApproximatePercentile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecApproximatePercentile(const AggSpec_AggSpecApproximatePercentile& from);
  AggSpec_AggSpecApproximatePercentile(AggSpec_AggSpecApproximatePercentile&& from) noexcept
    : AggSpec_AggSpecApproximatePercentile() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecApproximatePercentile& operator=(const AggSpec_AggSpecApproximatePercentile& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecApproximatePercentile& operator=(AggSpec_AggSpecApproximatePercentile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecApproximatePercentile& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecApproximatePercentile* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecApproximatePercentile*>(
               &_AggSpec_AggSpecApproximatePercentile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(AggSpec_AggSpecApproximatePercentile& a, AggSpec_AggSpecApproximatePercentile& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecApproximatePercentile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecApproximatePercentile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecApproximatePercentile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecApproximatePercentile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecApproximatePercentile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecApproximatePercentile& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec_AggSpecApproximatePercentile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile";
  }
  protected:
  explicit AggSpec_AggSpecApproximatePercentile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPercentileFieldNumber = 1,
    kCompressionFieldNumber = 2,
  };
  // double percentile = 1;
  void clear_percentile();
  double percentile() const;
  void set_percentile(double value);
  private:
  double _internal_percentile() const;
  void _internal_set_percentile(double value);
  public:

  // optional double compression = 2;
  bool has_compression() const;
  private:
  bool _internal_has_compression() const;
  public:
  void clear_compression();
  double compression() const;
  void set_compression(double value);
  private:
  double _internal_compression() const;
  void _internal_set_compression(double value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double percentile_;
  double compression_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecCountDistinct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct) */ {
 public:
  inline AggSpec_AggSpecCountDistinct() : AggSpec_AggSpecCountDistinct(nullptr) {}
  ~AggSpec_AggSpecCountDistinct() override;
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecCountDistinct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecCountDistinct(const AggSpec_AggSpecCountDistinct& from);
  AggSpec_AggSpecCountDistinct(AggSpec_AggSpecCountDistinct&& from) noexcept
    : AggSpec_AggSpecCountDistinct() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecCountDistinct& operator=(const AggSpec_AggSpecCountDistinct& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecCountDistinct& operator=(AggSpec_AggSpecCountDistinct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecCountDistinct& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecCountDistinct* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecCountDistinct*>(
               &_AggSpec_AggSpecCountDistinct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(AggSpec_AggSpecCountDistinct& a, AggSpec_AggSpecCountDistinct& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecCountDistinct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecCountDistinct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecCountDistinct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecCountDistinct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecCountDistinct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecCountDistinct& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec_AggSpecCountDistinct* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct";
  }
  protected:
  explicit AggSpec_AggSpecCountDistinct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountNullsFieldNumber = 1,
  };
  // bool count_nulls = 1;
  void clear_count_nulls();
  bool count_nulls() const;
  void set_count_nulls(bool value);
  private:
  bool _internal_count_nulls() const;
  void _internal_set_count_nulls(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool count_nulls_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecDistinct final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct) */ {
 public:
  inline AggSpec_AggSpecDistinct() : AggSpec_AggSpecDistinct(nullptr) {}
  ~AggSpec_AggSpecDistinct() override;
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecDistinct(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecDistinct(const AggSpec_AggSpecDistinct& from);
  AggSpec_AggSpecDistinct(AggSpec_AggSpecDistinct&& from) noexcept
    : AggSpec_AggSpecDistinct() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecDistinct& operator=(const AggSpec_AggSpecDistinct& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecDistinct& operator=(AggSpec_AggSpecDistinct&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecDistinct& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecDistinct* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecDistinct*>(
               &_AggSpec_AggSpecDistinct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(AggSpec_AggSpecDistinct& a, AggSpec_AggSpecDistinct& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecDistinct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecDistinct* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecDistinct* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecDistinct>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecDistinct& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecDistinct& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec_AggSpecDistinct* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct";
  }
  protected:
  explicit AggSpec_AggSpecDistinct(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludeNullsFieldNumber = 1,
  };
  // bool include_nulls = 1;
  void clear_include_nulls();
  bool include_nulls() const;
  void set_include_nulls(bool value);
  private:
  bool _internal_include_nulls() const;
  void _internal_set_include_nulls(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool include_nulls_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecFormula final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula) */ {
 public:
  inline AggSpec_AggSpecFormula() : AggSpec_AggSpecFormula(nullptr) {}
  ~AggSpec_AggSpecFormula() override;
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecFormula(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecFormula(const AggSpec_AggSpecFormula& from);
  AggSpec_AggSpecFormula(AggSpec_AggSpecFormula&& from) noexcept
    : AggSpec_AggSpecFormula() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecFormula& operator=(const AggSpec_AggSpecFormula& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecFormula& operator=(AggSpec_AggSpecFormula&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecFormula& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecFormula* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecFormula*>(
               &_AggSpec_AggSpecFormula_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(AggSpec_AggSpecFormula& a, AggSpec_AggSpecFormula& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecFormula* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecFormula* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecFormula* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecFormula>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecFormula& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecFormula& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec_AggSpecFormula* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula";
  }
  protected:
  explicit AggSpec_AggSpecFormula(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormulaFieldNumber = 1,
    kParamTokenFieldNumber = 2,
  };
  // string formula = 1;
  void clear_formula();
  const std::string& formula() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_formula(ArgT0&& arg0, ArgT... args);
  std::string* mutable_formula();
  PROTOBUF_NODISCARD std::string* release_formula();
  void set_allocated_formula(std::string* formula);
  private:
  const std::string& _internal_formula() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formula(const std::string& value);
  std::string* _internal_mutable_formula();
  public:

  // string param_token = 2;
  void clear_param_token();
  const std::string& param_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_param_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_param_token();
  PROTOBUF_NODISCARD std::string* release_param_token();
  void set_allocated_param_token(std::string* param_token);
  private:
  const std::string& _internal_param_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_param_token(const std::string& value);
  std::string* _internal_mutable_param_token();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr formula_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr param_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecMedian final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian) */ {
 public:
  inline AggSpec_AggSpecMedian() : AggSpec_AggSpecMedian(nullptr) {}
  ~AggSpec_AggSpecMedian() override;
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecMedian(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecMedian(const AggSpec_AggSpecMedian& from);
  AggSpec_AggSpecMedian(AggSpec_AggSpecMedian&& from) noexcept
    : AggSpec_AggSpecMedian() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecMedian& operator=(const AggSpec_AggSpecMedian& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecMedian& operator=(AggSpec_AggSpecMedian&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecMedian& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecMedian* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecMedian*>(
               &_AggSpec_AggSpecMedian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(AggSpec_AggSpecMedian& a, AggSpec_AggSpecMedian& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecMedian* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecMedian* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecMedian* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecMedian>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecMedian& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecMedian& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec_AggSpecMedian* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian";
  }
  protected:
  explicit AggSpec_AggSpecMedian(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAverageEvenlyDividedFieldNumber = 1,
  };
  // bool average_evenly_divided = 1;
  void clear_average_evenly_divided();
  bool average_evenly_divided() const;
  void set_average_evenly_divided(bool value);
  private:
  bool _internal_average_evenly_divided() const;
  void _internal_set_average_evenly_divided(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool average_evenly_divided_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecPercentile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile) */ {
 public:
  inline AggSpec_AggSpecPercentile() : AggSpec_AggSpecPercentile(nullptr) {}
  ~AggSpec_AggSpecPercentile() override;
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecPercentile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecPercentile(const AggSpec_AggSpecPercentile& from);
  AggSpec_AggSpecPercentile(AggSpec_AggSpecPercentile&& from) noexcept
    : AggSpec_AggSpecPercentile() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecPercentile& operator=(const AggSpec_AggSpecPercentile& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecPercentile& operator=(AggSpec_AggSpecPercentile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecPercentile& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecPercentile* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecPercentile*>(
               &_AggSpec_AggSpecPercentile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(AggSpec_AggSpecPercentile& a, AggSpec_AggSpecPercentile& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecPercentile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecPercentile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecPercentile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecPercentile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecPercentile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecPercentile& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec_AggSpecPercentile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile";
  }
  protected:
  explicit AggSpec_AggSpecPercentile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPercentileFieldNumber = 1,
    kAverageEvenlyDividedFieldNumber = 2,
  };
  // double percentile = 1;
  void clear_percentile();
  double percentile() const;
  void set_percentile(double value);
  private:
  double _internal_percentile() const;
  void _internal_set_percentile(double value);
  public:

  // bool average_evenly_divided = 2;
  void clear_average_evenly_divided();
  bool average_evenly_divided() const;
  void set_average_evenly_divided(bool value);
  private:
  bool _internal_average_evenly_divided() const;
  void _internal_set_average_evenly_divided(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  double percentile_;
  bool average_evenly_divided_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecSorted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted) */ {
 public:
  inline AggSpec_AggSpecSorted() : AggSpec_AggSpecSorted(nullptr) {}
  ~AggSpec_AggSpecSorted() override;
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecSorted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecSorted(const AggSpec_AggSpecSorted& from);
  AggSpec_AggSpecSorted(AggSpec_AggSpecSorted&& from) noexcept
    : AggSpec_AggSpecSorted() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecSorted& operator=(const AggSpec_AggSpecSorted& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecSorted& operator=(AggSpec_AggSpecSorted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecSorted& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecSorted* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecSorted*>(
               &_AggSpec_AggSpecSorted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(AggSpec_AggSpecSorted& a, AggSpec_AggSpecSorted& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecSorted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecSorted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecSorted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecSorted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecSorted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecSorted& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec_AggSpecSorted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted";
  }
  protected:
  explicit AggSpec_AggSpecSorted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn columns = 1;
  int columns_size() const;
  private:
  int _internal_columns_size() const;
  public:
  void clear_columns();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* mutable_columns(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn >*
      mutable_columns();
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn& _internal_columns(int index) const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* _internal_add_columns();
  public:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn& columns(int index) const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* add_columns();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn >&
      columns() const;

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn > columns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecSortedColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn) */ {
 public:
  inline AggSpec_AggSpecSortedColumn() : AggSpec_AggSpecSortedColumn(nullptr) {}
  ~AggSpec_AggSpecSortedColumn() override;
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecSortedColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecSortedColumn(const AggSpec_AggSpecSortedColumn& from);
  AggSpec_AggSpecSortedColumn(AggSpec_AggSpecSortedColumn&& from) noexcept
    : AggSpec_AggSpecSortedColumn() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecSortedColumn& operator=(const AggSpec_AggSpecSortedColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecSortedColumn& operator=(AggSpec_AggSpecSortedColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecSortedColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecSortedColumn* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecSortedColumn*>(
               &_AggSpec_AggSpecSortedColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(AggSpec_AggSpecSortedColumn& a, AggSpec_AggSpecSortedColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecSortedColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecSortedColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecSortedColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecSortedColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecSortedColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecSortedColumn& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec_AggSpecSortedColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn";
  }
  protected:
  explicit AggSpec_AggSpecSortedColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecTDigest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest) */ {
 public:
  inline AggSpec_AggSpecTDigest() : AggSpec_AggSpecTDigest(nullptr) {}
  ~AggSpec_AggSpecTDigest() override;
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecTDigest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecTDigest(const AggSpec_AggSpecTDigest& from);
  AggSpec_AggSpecTDigest(AggSpec_AggSpecTDigest&& from) noexcept
    : AggSpec_AggSpecTDigest() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecTDigest& operator=(const AggSpec_AggSpecTDigest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecTDigest& operator=(AggSpec_AggSpecTDigest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecTDigest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecTDigest* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecTDigest*>(
               &_AggSpec_AggSpecTDigest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(AggSpec_AggSpecTDigest& a, AggSpec_AggSpecTDigest& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecTDigest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecTDigest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecTDigest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecTDigest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecTDigest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecTDigest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec_AggSpecTDigest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest";
  }
  protected:
  explicit AggSpec_AggSpecTDigest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompressionFieldNumber = 1,
  };
  // optional double compression = 1;
  bool has_compression() const;
  private:
  bool _internal_has_compression() const;
  public:
  void clear_compression();
  double compression() const;
  void set_compression(double value);
  private:
  double _internal_compression() const;
  void _internal_set_compression(double value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double compression_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecUnique final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique) */ {
 public:
  inline AggSpec_AggSpecUnique() : AggSpec_AggSpecUnique(nullptr) {}
  ~AggSpec_AggSpecUnique() override;
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecUnique(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecUnique(const AggSpec_AggSpecUnique& from);
  AggSpec_AggSpecUnique(AggSpec_AggSpecUnique&& from) noexcept
    : AggSpec_AggSpecUnique() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecUnique& operator=(const AggSpec_AggSpecUnique& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecUnique& operator=(AggSpec_AggSpecUnique&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecUnique& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecUnique* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecUnique*>(
               &_AggSpec_AggSpecUnique_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(AggSpec_AggSpecUnique& a, AggSpec_AggSpecUnique& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecUnique* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecUnique* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecUnique* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecUnique>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecUnique& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecUnique& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec_AggSpecUnique* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique";
  }
  protected:
  explicit AggSpec_AggSpecUnique(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonUniqueSentinelFieldNumber = 2,
    kIncludeNullsFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel non_unique_sentinel = 2;
  bool has_non_unique_sentinel() const;
  private:
  bool _internal_has_non_unique_sentinel() const;
  public:
  void clear_non_unique_sentinel();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel& non_unique_sentinel() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* release_non_unique_sentinel();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* mutable_non_unique_sentinel();
  void set_allocated_non_unique_sentinel(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* non_unique_sentinel);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel& _internal_non_unique_sentinel() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* _internal_mutable_non_unique_sentinel();
  public:
  void unsafe_arena_set_allocated_non_unique_sentinel(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* non_unique_sentinel);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* unsafe_arena_release_non_unique_sentinel();

  // bool include_nulls = 1;
  void clear_include_nulls();
  bool include_nulls() const;
  void set_include_nulls(bool value);
  private:
  bool _internal_include_nulls() const;
  void _internal_set_include_nulls(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* non_unique_sentinel_;
  bool include_nulls_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecNonUniqueSentinel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel) */ {
 public:
  inline AggSpec_AggSpecNonUniqueSentinel() : AggSpec_AggSpecNonUniqueSentinel(nullptr) {}
  ~AggSpec_AggSpecNonUniqueSentinel() override;
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecNonUniqueSentinel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecNonUniqueSentinel(const AggSpec_AggSpecNonUniqueSentinel& from);
  AggSpec_AggSpecNonUniqueSentinel(AggSpec_AggSpecNonUniqueSentinel&& from) noexcept
    : AggSpec_AggSpecNonUniqueSentinel() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecNonUniqueSentinel& operator=(const AggSpec_AggSpecNonUniqueSentinel& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecNonUniqueSentinel& operator=(AggSpec_AggSpecNonUniqueSentinel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecNonUniqueSentinel& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kNullValue = 1,
    kStringValue = 2,
    kIntValue = 3,
    kLongValue = 4,
    kFloatValue = 5,
    kDoubleValue = 6,
    kBoolValue = 7,
    kByteValue = 8,
    kShortValue = 9,
    kCharValue = 10,
    TYPE_NOT_SET = 0,
  };

  static inline const AggSpec_AggSpecNonUniqueSentinel* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecNonUniqueSentinel*>(
               &_AggSpec_AggSpecNonUniqueSentinel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(AggSpec_AggSpecNonUniqueSentinel& a, AggSpec_AggSpecNonUniqueSentinel& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecNonUniqueSentinel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecNonUniqueSentinel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecNonUniqueSentinel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecNonUniqueSentinel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecNonUniqueSentinel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecNonUniqueSentinel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec_AggSpecNonUniqueSentinel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel";
  }
  protected:
  explicit AggSpec_AggSpecNonUniqueSentinel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNullValueFieldNumber = 1,
    kStringValueFieldNumber = 2,
    kIntValueFieldNumber = 3,
    kLongValueFieldNumber = 4,
    kFloatValueFieldNumber = 5,
    kDoubleValueFieldNumber = 6,
    kBoolValueFieldNumber = 7,
    kByteValueFieldNumber = 8,
    kShortValueFieldNumber = 9,
    kCharValueFieldNumber = 10,
  };
  // .io.deephaven.proto.backplane.grpc.NullValue null_value = 1;
  bool has_null_value() const;
  private:
  bool _internal_has_null_value() const;
  public:
  void clear_null_value();
  ::io::deephaven::proto::backplane::grpc::NullValue null_value() const;
  void set_null_value(::io::deephaven::proto::backplane::grpc::NullValue value);
  private:
  ::io::deephaven::proto::backplane::grpc::NullValue _internal_null_value() const;
  void _internal_set_null_value(::io::deephaven::proto::backplane::grpc::NullValue value);
  public:

  // string string_value = 2;
  bool has_string_value() const;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // sint32 int_value = 3;
  bool has_int_value() const;
  private:
  bool _internal_has_int_value() const;
  public:
  void clear_int_value();
  int32_t int_value() const;
  void set_int_value(int32_t value);
  private:
  int32_t _internal_int_value() const;
  void _internal_set_int_value(int32_t value);
  public:

  // sint64 long_value = 4 [jstype = JS_STRING];
  bool has_long_value() const;
  private:
  bool _internal_has_long_value() const;
  public:
  void clear_long_value();
  int64_t long_value() const;
  void set_long_value(int64_t value);
  private:
  int64_t _internal_long_value() const;
  void _internal_set_long_value(int64_t value);
  public:

  // float float_value = 5;
  bool has_float_value() const;
  private:
  bool _internal_has_float_value() const;
  public:
  void clear_float_value();
  float float_value() const;
  void set_float_value(float value);
  private:
  float _internal_float_value() const;
  void _internal_set_float_value(float value);
  public:

  // double double_value = 6;
  bool has_double_value() const;
  private:
  bool _internal_has_double_value() const;
  public:
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);
  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);
  public:

  // bool bool_value = 7;
  bool has_bool_value() const;
  private:
  bool _internal_has_bool_value() const;
  public:
  void clear_bool_value();
  bool bool_value() const;
  void set_bool_value(bool value);
  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);
  public:

  // sint32 byte_value = 8;
  bool has_byte_value() const;
  private:
  bool _internal_has_byte_value() const;
  public:
  void clear_byte_value();
  int32_t byte_value() const;
  void set_byte_value(int32_t value);
  private:
  int32_t _internal_byte_value() const;
  void _internal_set_byte_value(int32_t value);
  public:

  // sint32 short_value = 9;
  bool has_short_value() const;
  private:
  bool _internal_has_short_value() const;
  public:
  void clear_short_value();
  int32_t short_value() const;
  void set_short_value(int32_t value);
  private:
  int32_t _internal_short_value() const;
  void _internal_set_short_value(int32_t value);
  public:

  // sint32 char_value = 10;
  bool has_char_value() const;
  private:
  bool _internal_has_char_value() const;
  public:
  void clear_char_value();
  int32_t char_value() const;
  void set_char_value(int32_t value);
  private:
  int32_t _internal_char_value() const;
  void _internal_set_char_value(int32_t value);
  public:

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel)
 private:
  class _Internal;
  void set_has_null_value();
  void set_has_string_value();
  void set_has_int_value();
  void set_has_long_value();
  void set_has_float_value();
  void set_has_double_value();
  void set_has_bool_value();
  void set_has_byte_value();
  void set_has_short_value();
  void set_has_char_value();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int null_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
    int32_t int_value_;
    int64_t long_value_;
    float float_value_;
    double double_value_;
    bool bool_value_;
    int32_t byte_value_;
    int32_t short_value_;
    int32_t char_value_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecWeighted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted) */ {
 public:
  inline AggSpec_AggSpecWeighted() : AggSpec_AggSpecWeighted(nullptr) {}
  ~AggSpec_AggSpecWeighted() override;
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecWeighted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecWeighted(const AggSpec_AggSpecWeighted& from);
  AggSpec_AggSpecWeighted(AggSpec_AggSpecWeighted&& from) noexcept
    : AggSpec_AggSpecWeighted() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecWeighted& operator=(const AggSpec_AggSpecWeighted& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecWeighted& operator=(AggSpec_AggSpecWeighted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecWeighted& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecWeighted* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecWeighted*>(
               &_AggSpec_AggSpecWeighted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(AggSpec_AggSpecWeighted& a, AggSpec_AggSpecWeighted& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecWeighted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecWeighted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecWeighted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecWeighted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecWeighted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecWeighted& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec_AggSpecWeighted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted";
  }
  protected:
  explicit AggSpec_AggSpecWeighted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeightColumnFieldNumber = 1,
  };
  // string weight_column = 1;
  void clear_weight_column();
  const std::string& weight_column() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_weight_column(ArgT0&& arg0, ArgT... args);
  std::string* mutable_weight_column();
  PROTOBUF_NODISCARD std::string* release_weight_column();
  void set_allocated_weight_column(std::string* weight_column);
  private:
  const std::string& _internal_weight_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weight_column(const std::string& value);
  std::string* _internal_mutable_weight_column();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weight_column_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecAbsSum final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAbsSum) */ {
 public:
  inline AggSpec_AggSpecAbsSum() : AggSpec_AggSpecAbsSum(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecAbsSum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecAbsSum(const AggSpec_AggSpecAbsSum& from);
  AggSpec_AggSpecAbsSum(AggSpec_AggSpecAbsSum&& from) noexcept
    : AggSpec_AggSpecAbsSum() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecAbsSum& operator=(const AggSpec_AggSpecAbsSum& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecAbsSum& operator=(AggSpec_AggSpecAbsSum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecAbsSum& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecAbsSum* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecAbsSum*>(
               &_AggSpec_AggSpecAbsSum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(AggSpec_AggSpecAbsSum& a, AggSpec_AggSpecAbsSum& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecAbsSum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecAbsSum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecAbsSum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecAbsSum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecAbsSum& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecAbsSum& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAbsSum";
  }
  protected:
  explicit AggSpec_AggSpecAbsSum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAbsSum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecAvg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAvg) */ {
 public:
  inline AggSpec_AggSpecAvg() : AggSpec_AggSpecAvg(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecAvg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecAvg(const AggSpec_AggSpecAvg& from);
  AggSpec_AggSpecAvg(AggSpec_AggSpecAvg&& from) noexcept
    : AggSpec_AggSpecAvg() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecAvg& operator=(const AggSpec_AggSpecAvg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecAvg& operator=(AggSpec_AggSpecAvg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecAvg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecAvg* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecAvg*>(
               &_AggSpec_AggSpecAvg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(AggSpec_AggSpecAvg& a, AggSpec_AggSpecAvg& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecAvg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecAvg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecAvg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecAvg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecAvg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecAvg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAvg";
  }
  protected:
  explicit AggSpec_AggSpecAvg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAvg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecFirst final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFirst) */ {
 public:
  inline AggSpec_AggSpecFirst() : AggSpec_AggSpecFirst(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecFirst(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecFirst(const AggSpec_AggSpecFirst& from);
  AggSpec_AggSpecFirst(AggSpec_AggSpecFirst&& from) noexcept
    : AggSpec_AggSpecFirst() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecFirst& operator=(const AggSpec_AggSpecFirst& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecFirst& operator=(AggSpec_AggSpecFirst&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecFirst& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecFirst* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecFirst*>(
               &_AggSpec_AggSpecFirst_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(AggSpec_AggSpecFirst& a, AggSpec_AggSpecFirst& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecFirst* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecFirst* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecFirst* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecFirst>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecFirst& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecFirst& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFirst";
  }
  protected:
  explicit AggSpec_AggSpecFirst(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFirst)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecFreeze final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFreeze) */ {
 public:
  inline AggSpec_AggSpecFreeze() : AggSpec_AggSpecFreeze(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecFreeze(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecFreeze(const AggSpec_AggSpecFreeze& from);
  AggSpec_AggSpecFreeze(AggSpec_AggSpecFreeze&& from) noexcept
    : AggSpec_AggSpecFreeze() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecFreeze& operator=(const AggSpec_AggSpecFreeze& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecFreeze& operator=(AggSpec_AggSpecFreeze&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecFreeze& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecFreeze* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecFreeze*>(
               &_AggSpec_AggSpecFreeze_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(AggSpec_AggSpecFreeze& a, AggSpec_AggSpecFreeze& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecFreeze* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecFreeze* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecFreeze* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecFreeze>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecFreeze& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecFreeze& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFreeze";
  }
  protected:
  explicit AggSpec_AggSpecFreeze(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFreeze)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecGroup final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecGroup) */ {
 public:
  inline AggSpec_AggSpecGroup() : AggSpec_AggSpecGroup(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecGroup(const AggSpec_AggSpecGroup& from);
  AggSpec_AggSpecGroup(AggSpec_AggSpecGroup&& from) noexcept
    : AggSpec_AggSpecGroup() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecGroup& operator=(const AggSpec_AggSpecGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecGroup& operator=(AggSpec_AggSpecGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecGroup* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecGroup*>(
               &_AggSpec_AggSpecGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(AggSpec_AggSpecGroup& a, AggSpec_AggSpecGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecGroup& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecGroup& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecGroup";
  }
  protected:
  explicit AggSpec_AggSpecGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecLast final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecLast) */ {
 public:
  inline AggSpec_AggSpecLast() : AggSpec_AggSpecLast(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecLast(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecLast(const AggSpec_AggSpecLast& from);
  AggSpec_AggSpecLast(AggSpec_AggSpecLast&& from) noexcept
    : AggSpec_AggSpecLast() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecLast& operator=(const AggSpec_AggSpecLast& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecLast& operator=(AggSpec_AggSpecLast&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecLast& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecLast* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecLast*>(
               &_AggSpec_AggSpecLast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(AggSpec_AggSpecLast& a, AggSpec_AggSpecLast& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecLast* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecLast* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecLast* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecLast>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecLast& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecLast& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecLast";
  }
  protected:
  explicit AggSpec_AggSpecLast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecLast)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecMax final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMax) */ {
 public:
  inline AggSpec_AggSpecMax() : AggSpec_AggSpecMax(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecMax(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecMax(const AggSpec_AggSpecMax& from);
  AggSpec_AggSpecMax(AggSpec_AggSpecMax&& from) noexcept
    : AggSpec_AggSpecMax() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecMax& operator=(const AggSpec_AggSpecMax& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecMax& operator=(AggSpec_AggSpecMax&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecMax& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecMax* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecMax*>(
               &_AggSpec_AggSpecMax_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(AggSpec_AggSpecMax& a, AggSpec_AggSpecMax& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecMax* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecMax* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecMax* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecMax>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecMax& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecMax& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMax";
  }
  protected:
  explicit AggSpec_AggSpecMax(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMax)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecMin final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMin) */ {
 public:
  inline AggSpec_AggSpecMin() : AggSpec_AggSpecMin(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecMin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecMin(const AggSpec_AggSpecMin& from);
  AggSpec_AggSpecMin(AggSpec_AggSpecMin&& from) noexcept
    : AggSpec_AggSpecMin() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecMin& operator=(const AggSpec_AggSpecMin& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecMin& operator=(AggSpec_AggSpecMin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecMin& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecMin* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecMin*>(
               &_AggSpec_AggSpecMin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(AggSpec_AggSpecMin& a, AggSpec_AggSpecMin& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecMin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecMin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecMin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecMin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecMin& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecMin& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMin";
  }
  protected:
  explicit AggSpec_AggSpecMin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecStd final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecStd) */ {
 public:
  inline AggSpec_AggSpecStd() : AggSpec_AggSpecStd(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecStd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecStd(const AggSpec_AggSpecStd& from);
  AggSpec_AggSpecStd(AggSpec_AggSpecStd&& from) noexcept
    : AggSpec_AggSpecStd() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecStd& operator=(const AggSpec_AggSpecStd& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecStd& operator=(AggSpec_AggSpecStd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecStd& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecStd* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecStd*>(
               &_AggSpec_AggSpecStd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(AggSpec_AggSpecStd& a, AggSpec_AggSpecStd& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecStd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecStd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecStd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecStd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecStd& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecStd& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecStd";
  }
  protected:
  explicit AggSpec_AggSpecStd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecStd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecSum final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSum) */ {
 public:
  inline AggSpec_AggSpecSum() : AggSpec_AggSpecSum(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecSum(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecSum(const AggSpec_AggSpecSum& from);
  AggSpec_AggSpecSum(AggSpec_AggSpecSum&& from) noexcept
    : AggSpec_AggSpecSum() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecSum& operator=(const AggSpec_AggSpecSum& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecSum& operator=(AggSpec_AggSpecSum&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecSum& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecSum* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecSum*>(
               &_AggSpec_AggSpecSum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(AggSpec_AggSpecSum& a, AggSpec_AggSpecSum& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecSum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecSum* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecSum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecSum>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecSum& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecSum& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSum";
  }
  protected:
  explicit AggSpec_AggSpecSum(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSum)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec_AggSpecVar final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecVar) */ {
 public:
  inline AggSpec_AggSpecVar() : AggSpec_AggSpecVar(nullptr) {}
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecVar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec_AggSpecVar(const AggSpec_AggSpecVar& from);
  AggSpec_AggSpecVar(AggSpec_AggSpecVar&& from) noexcept
    : AggSpec_AggSpecVar() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecVar& operator=(const AggSpec_AggSpecVar& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecVar& operator=(AggSpec_AggSpecVar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecVar& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecVar* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecVar*>(
               &_AggSpec_AggSpecVar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(AggSpec_AggSpecVar& a, AggSpec_AggSpecVar& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecVar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecVar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecVar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecVar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecVar& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecVar& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecVar";
  }
  protected:
  explicit AggSpec_AggSpecVar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecVar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggSpec final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec) */ {
 public:
  inline AggSpec() : AggSpec(nullptr) {}
  ~AggSpec() override;
  explicit PROTOBUF_CONSTEXPR AggSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggSpec(const AggSpec& from);
  AggSpec(AggSpec&& from) noexcept
    : AggSpec() {
    *this = ::std::move(from);
  }

  inline AggSpec& operator=(const AggSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec& operator=(AggSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kAbsSum = 1,
    kApproximatePercentile = 2,
    kAvg = 3,
    kCountDistinct = 4,
    kDistinct = 5,
    kFirst = 6,
    kFormula = 7,
    kFreeze = 8,
    kGroup = 9,
    kLast = 10,
    kMax = 11,
    kMedian = 12,
    kMin = 13,
    kPercentile = 14,
    kSortedFirst = 15,
    kSortedLast = 16,
    kStd = 17,
    kSum = 18,
    kTDigest = 19,
    kUnique = 20,
    kWeightedAvg = 21,
    kWeightedSum = 22,
    kVar = 23,
    TYPE_NOT_SET = 0,
  };

  static inline const AggSpec* internal_default_instance() {
    return reinterpret_cast<const AggSpec*>(
               &_AggSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(AggSpec& a, AggSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggSpec& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggSpec& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec";
  }
  protected:
  explicit AggSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef AggSpec_AggSpecApproximatePercentile AggSpecApproximatePercentile;
  typedef AggSpec_AggSpecCountDistinct AggSpecCountDistinct;
  typedef AggSpec_AggSpecDistinct AggSpecDistinct;
  typedef AggSpec_AggSpecFormula AggSpecFormula;
  typedef AggSpec_AggSpecMedian AggSpecMedian;
  typedef AggSpec_AggSpecPercentile AggSpecPercentile;
  typedef AggSpec_AggSpecSorted AggSpecSorted;
  typedef AggSpec_AggSpecSortedColumn AggSpecSortedColumn;
  typedef AggSpec_AggSpecTDigest AggSpecTDigest;
  typedef AggSpec_AggSpecUnique AggSpecUnique;
  typedef AggSpec_AggSpecNonUniqueSentinel AggSpecNonUniqueSentinel;
  typedef AggSpec_AggSpecWeighted AggSpecWeighted;
  typedef AggSpec_AggSpecAbsSum AggSpecAbsSum;
  typedef AggSpec_AggSpecAvg AggSpecAvg;
  typedef AggSpec_AggSpecFirst AggSpecFirst;
  typedef AggSpec_AggSpecFreeze AggSpecFreeze;
  typedef AggSpec_AggSpecGroup AggSpecGroup;
  typedef AggSpec_AggSpecLast AggSpecLast;
  typedef AggSpec_AggSpecMax AggSpecMax;
  typedef AggSpec_AggSpecMin AggSpecMin;
  typedef AggSpec_AggSpecStd AggSpecStd;
  typedef AggSpec_AggSpecSum AggSpecSum;
  typedef AggSpec_AggSpecVar AggSpecVar;

  // accessors -------------------------------------------------------

  enum : int {
    kAbsSumFieldNumber = 1,
    kApproximatePercentileFieldNumber = 2,
    kAvgFieldNumber = 3,
    kCountDistinctFieldNumber = 4,
    kDistinctFieldNumber = 5,
    kFirstFieldNumber = 6,
    kFormulaFieldNumber = 7,
    kFreezeFieldNumber = 8,
    kGroupFieldNumber = 9,
    kLastFieldNumber = 10,
    kMaxFieldNumber = 11,
    kMedianFieldNumber = 12,
    kMinFieldNumber = 13,
    kPercentileFieldNumber = 14,
    kSortedFirstFieldNumber = 15,
    kSortedLastFieldNumber = 16,
    kStdFieldNumber = 17,
    kSumFieldNumber = 18,
    kTDigestFieldNumber = 19,
    kUniqueFieldNumber = 20,
    kWeightedAvgFieldNumber = 21,
    kWeightedSumFieldNumber = 22,
    kVarFieldNumber = 23,
  };
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAbsSum abs_sum = 1;
  bool has_abs_sum() const;
  private:
  bool _internal_has_abs_sum() const;
  public:
  void clear_abs_sum();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum& abs_sum() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* release_abs_sum();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* mutable_abs_sum();
  void set_allocated_abs_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* abs_sum);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum& _internal_abs_sum() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* _internal_mutable_abs_sum();
  public:
  void unsafe_arena_set_allocated_abs_sum(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* abs_sum);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* unsafe_arena_release_abs_sum();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile approximate_percentile = 2;
  bool has_approximate_percentile() const;
  private:
  bool _internal_has_approximate_percentile() const;
  public:
  void clear_approximate_percentile();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile& approximate_percentile() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* release_approximate_percentile();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* mutable_approximate_percentile();
  void set_allocated_approximate_percentile(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* approximate_percentile);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile& _internal_approximate_percentile() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* _internal_mutable_approximate_percentile();
  public:
  void unsafe_arena_set_allocated_approximate_percentile(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* approximate_percentile);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* unsafe_arena_release_approximate_percentile();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAvg avg = 3;
  bool has_avg() const;
  private:
  bool _internal_has_avg() const;
  public:
  void clear_avg();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg& avg() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* release_avg();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* mutable_avg();
  void set_allocated_avg(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* avg);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg& _internal_avg() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* _internal_mutable_avg();
  public:
  void unsafe_arena_set_allocated_avg(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* avg);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* unsafe_arena_release_avg();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct count_distinct = 4;
  bool has_count_distinct() const;
  private:
  bool _internal_has_count_distinct() const;
  public:
  void clear_count_distinct();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct& count_distinct() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* release_count_distinct();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* mutable_count_distinct();
  void set_allocated_count_distinct(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* count_distinct);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct& _internal_count_distinct() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* _internal_mutable_count_distinct();
  public:
  void unsafe_arena_set_allocated_count_distinct(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* count_distinct);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* unsafe_arena_release_count_distinct();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct distinct = 5;
  bool has_distinct() const;
  private:
  bool _internal_has_distinct() const;
  public:
  void clear_distinct();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct& distinct() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* release_distinct();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* mutable_distinct();
  void set_allocated_distinct(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* distinct);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct& _internal_distinct() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* _internal_mutable_distinct();
  public:
  void unsafe_arena_set_allocated_distinct(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* distinct);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* unsafe_arena_release_distinct();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFirst first = 6;
  bool has_first() const;
  private:
  bool _internal_has_first() const;
  public:
  void clear_first();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst& first() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* release_first();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* mutable_first();
  void set_allocated_first(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* first);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst& _internal_first() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* _internal_mutable_first();
  public:
  void unsafe_arena_set_allocated_first(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* first);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* unsafe_arena_release_first();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula formula = 7;
  bool has_formula() const;
  private:
  bool _internal_has_formula() const;
  public:
  void clear_formula();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula& formula() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* release_formula();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* mutable_formula();
  void set_allocated_formula(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* formula);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula& _internal_formula() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* _internal_mutable_formula();
  public:
  void unsafe_arena_set_allocated_formula(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* formula);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* unsafe_arena_release_formula();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFreeze freeze = 8;
  bool has_freeze() const;
  private:
  bool _internal_has_freeze() const;
  public:
  void clear_freeze();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze& freeze() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* release_freeze();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* mutable_freeze();
  void set_allocated_freeze(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* freeze);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze& _internal_freeze() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* _internal_mutable_freeze();
  public:
  void unsafe_arena_set_allocated_freeze(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* freeze);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* unsafe_arena_release_freeze();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecGroup group = 9;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup& group() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* release_group();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* mutable_group();
  void set_allocated_group(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* group);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup& _internal_group() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* group);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* unsafe_arena_release_group();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecLast last = 10;
  bool has_last() const;
  private:
  bool _internal_has_last() const;
  public:
  void clear_last();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast& last() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* release_last();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* mutable_last();
  void set_allocated_last(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* last);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast& _internal_last() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* _internal_mutable_last();
  public:
  void unsafe_arena_set_allocated_last(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* last);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* unsafe_arena_release_last();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMax max = 11;
  bool has_max() const;
  private:
  bool _internal_has_max() const;
  public:
  void clear_max();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax& max() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* release_max();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* mutable_max();
  void set_allocated_max(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* max);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax& _internal_max() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* _internal_mutable_max();
  public:
  void unsafe_arena_set_allocated_max(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* max);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* unsafe_arena_release_max();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian median = 12;
  bool has_median() const;
  private:
  bool _internal_has_median() const;
  public:
  void clear_median();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian& median() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* release_median();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* mutable_median();
  void set_allocated_median(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* median);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian& _internal_median() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* _internal_mutable_median();
  public:
  void unsafe_arena_set_allocated_median(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* median);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* unsafe_arena_release_median();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMin min = 13;
  bool has_min() const;
  private:
  bool _internal_has_min() const;
  public:
  void clear_min();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin& min() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* release_min();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* mutable_min();
  void set_allocated_min(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* min);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin& _internal_min() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* _internal_mutable_min();
  public:
  void unsafe_arena_set_allocated_min(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* min);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* unsafe_arena_release_min();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile percentile = 14;
  bool has_percentile() const;
  private:
  bool _internal_has_percentile() const;
  public:
  void clear_percentile();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile& percentile() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* release_percentile();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* mutable_percentile();
  void set_allocated_percentile(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* percentile);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile& _internal_percentile() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* _internal_mutable_percentile();
  public:
  void unsafe_arena_set_allocated_percentile(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* percentile);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* unsafe_arena_release_percentile();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted sorted_first = 15;
  bool has_sorted_first() const;
  private:
  bool _internal_has_sorted_first() const;
  public:
  void clear_sorted_first();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& sorted_first() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* release_sorted_first();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* mutable_sorted_first();
  void set_allocated_sorted_first(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* sorted_first);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& _internal_sorted_first() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* _internal_mutable_sorted_first();
  public:
  void unsafe_arena_set_allocated_sorted_first(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* sorted_first);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* unsafe_arena_release_sorted_first();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted sorted_last = 16;
  bool has_sorted_last() const;
  private:
  bool _internal_has_sorted_last() const;
  public:
  void clear_sorted_last();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& sorted_last() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* release_sorted_last();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* mutable_sorted_last();
  void set_allocated_sorted_last(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* sorted_last);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& _internal_sorted_last() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* _internal_mutable_sorted_last();
  public:
  void unsafe_arena_set_allocated_sorted_last(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* sorted_last);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* unsafe_arena_release_sorted_last();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecStd std = 17;
  bool has_std() const;
  private:
  bool _internal_has_std() const;
  public:
  void clear_std();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd& std() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* release_std();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* mutable_std();
  void set_allocated_std(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* std);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd& _internal_std() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* _internal_mutable_std();
  public:
  void unsafe_arena_set_allocated_std(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* std);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* unsafe_arena_release_std();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSum sum = 18;
  bool has_sum() const;
  private:
  bool _internal_has_sum() const;
  public:
  void clear_sum();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum& sum() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* release_sum();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* mutable_sum();
  void set_allocated_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* sum);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum& _internal_sum() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* _internal_mutable_sum();
  public:
  void unsafe_arena_set_allocated_sum(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* sum);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* unsafe_arena_release_sum();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest t_digest = 19;
  bool has_t_digest() const;
  private:
  bool _internal_has_t_digest() const;
  public:
  void clear_t_digest();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest& t_digest() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* release_t_digest();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* mutable_t_digest();
  void set_allocated_t_digest(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* t_digest);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest& _internal_t_digest() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* _internal_mutable_t_digest();
  public:
  void unsafe_arena_set_allocated_t_digest(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* t_digest);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* unsafe_arena_release_t_digest();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique unique = 20;
  bool has_unique() const;
  private:
  bool _internal_has_unique() const;
  public:
  void clear_unique();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique& unique() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* release_unique();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* mutable_unique();
  void set_allocated_unique(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* unique);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique& _internal_unique() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* _internal_mutable_unique();
  public:
  void unsafe_arena_set_allocated_unique(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* unique);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* unsafe_arena_release_unique();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted weighted_avg = 21;
  bool has_weighted_avg() const;
  private:
  bool _internal_has_weighted_avg() const;
  public:
  void clear_weighted_avg();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& weighted_avg() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* release_weighted_avg();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* mutable_weighted_avg();
  void set_allocated_weighted_avg(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* weighted_avg);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& _internal_weighted_avg() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* _internal_mutable_weighted_avg();
  public:
  void unsafe_arena_set_allocated_weighted_avg(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* weighted_avg);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* unsafe_arena_release_weighted_avg();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted weighted_sum = 22;
  bool has_weighted_sum() const;
  private:
  bool _internal_has_weighted_sum() const;
  public:
  void clear_weighted_sum();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& weighted_sum() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* release_weighted_sum();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* mutable_weighted_sum();
  void set_allocated_weighted_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* weighted_sum);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& _internal_weighted_sum() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* _internal_mutable_weighted_sum();
  public:
  void unsafe_arena_set_allocated_weighted_sum(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* weighted_sum);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* unsafe_arena_release_weighted_sum();

  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecVar var = 23;
  bool has_var() const;
  private:
  bool _internal_has_var() const;
  public:
  void clear_var();
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar& var() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* release_var();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* mutable_var();
  void set_allocated_var(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* var);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar& _internal_var() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* _internal_mutable_var();
  public:
  void unsafe_arena_set_allocated_var(
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* var);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* unsafe_arena_release_var();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec)
 private:
  class _Internal;
  void set_has_abs_sum();
  void set_has_approximate_percentile();
  void set_has_avg();
  void set_has_count_distinct();
  void set_has_distinct();
  void set_has_first();
  void set_has_formula();
  void set_has_freeze();
  void set_has_group();
  void set_has_last();
  void set_has_max();
  void set_has_median();
  void set_has_min();
  void set_has_percentile();
  void set_has_sorted_first();
  void set_has_sorted_last();
  void set_has_std();
  void set_has_sum();
  void set_has_t_digest();
  void set_has_unique();
  void set_has_weighted_avg();
  void set_has_weighted_sum();
  void set_has_var();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* abs_sum_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* approximate_percentile_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* avg_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* count_distinct_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* distinct_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* first_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* formula_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* freeze_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* group_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* last_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* max_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* median_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* min_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* percentile_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* sorted_first_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* sorted_last_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* std_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* sum_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* t_digest_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* unique_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* weighted_avg_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* weighted_sum_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* var_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AggregateRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggregateRequest) */ {
 public:
  inline AggregateRequest() : AggregateRequest(nullptr) {}
  ~AggregateRequest() override;
  explicit PROTOBUF_CONSTEXPR AggregateRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AggregateRequest(const AggregateRequest& from);
  AggregateRequest(AggregateRequest&& from) noexcept
    : AggregateRequest() {
    *this = ::std::move(from);
  }

  inline AggregateRequest& operator=(const AggregateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateRequest& operator=(AggregateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateRequest* internal_default_instance() {
    return reinterpret_cast<const AggregateRequest*>(
               &_AggregateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(AggregateRequest& a, AggregateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregateRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AggregateRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AggregateRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AggregateRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggregateRequest";
  }
  protected:
  explicit AggregateRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAggregationsFieldNumber = 5,
    kGroupByColumnsFieldNumber = 6,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kInitialGroupsIdFieldNumber = 3,
    kPreserveEmptyFieldNumber = 4,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Aggregation aggregations = 5;
  int aggregations_size() const;
  private:
  int _internal_aggregations_size() const;
  public:
  void clear_aggregations();
  ::io::deephaven::proto::backplane::grpc::Aggregation* mutable_aggregations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation >*
      mutable_aggregations();
  private:
  const ::io::deephaven::proto::backplane::grpc::Aggregation& _internal_aggregations(int index) const;
  ::io::deephaven::proto::backplane::grpc::Aggregation* _internal_add_aggregations();
  public:
  const ::io::deephaven::proto::backplane::grpc::Aggregation& aggregations(int index) const;
  ::io::deephaven::proto::backplane::grpc::Aggregation* add_aggregations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation >&
      aggregations() const;

  // repeated string group_by_columns = 6;
  int group_by_columns_size() const;
  private:
  int _internal_group_by_columns_size() const;
  public:
  void clear_group_by_columns();
  const std::string& group_by_columns(int index) const;
  std::string* mutable_group_by_columns(int index);
  void set_group_by_columns(int index, const std::string& value);
  void set_group_by_columns(int index, std::string&& value);
  void set_group_by_columns(int index, const char* value);
  void set_group_by_columns(int index, const char* value, size_t size);
  std::string* add_group_by_columns();
  void add_group_by_columns(const std::string& value);
  void add_group_by_columns(std::string&& value);
  void add_group_by_columns(const char* value);
  void add_group_by_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& group_by_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_group_by_columns();
  private:
  const std::string& _internal_group_by_columns(int index) const;
  std::string* _internal_add_group_by_columns();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // .io.deephaven.proto.backplane.grpc.TableReference initial_groups_id = 3;
  bool has_initial_groups_id() const;
  private:
  bool _internal_has_initial_groups_id() const;
  public:
  void clear_initial_groups_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& initial_groups_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_initial_groups_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_initial_groups_id();
  void set_allocated_initial_groups_id(::io::deephaven::proto::backplane::grpc::TableReference* initial_groups_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_initial_groups_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_initial_groups_id();
  public:
  void unsafe_arena_set_allocated_initial_groups_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* initial_groups_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_initial_groups_id();

  // bool preserve_empty = 4;
  void clear_preserve_empty();
  bool preserve_empty() const;
  void set_preserve_empty(bool value);
  private:
  bool _internal_preserve_empty() const;
  void _internal_set_preserve_empty(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggregateRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation > aggregations_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> group_by_columns_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* initial_groups_id_;
  bool preserve_empty_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Aggregation_AggregationColumns final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns) */ {
 public:
  inline Aggregation_AggregationColumns() : Aggregation_AggregationColumns(nullptr) {}
  ~Aggregation_AggregationColumns() override;
  explicit PROTOBUF_CONSTEXPR Aggregation_AggregationColumns(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Aggregation_AggregationColumns(const Aggregation_AggregationColumns& from);
  Aggregation_AggregationColumns(Aggregation_AggregationColumns&& from) noexcept
    : Aggregation_AggregationColumns() {
    *this = ::std::move(from);
  }

  inline Aggregation_AggregationColumns& operator=(const Aggregation_AggregationColumns& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aggregation_AggregationColumns& operator=(Aggregation_AggregationColumns&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aggregation_AggregationColumns& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aggregation_AggregationColumns* internal_default_instance() {
    return reinterpret_cast<const Aggregation_AggregationColumns*>(
               &_Aggregation_AggregationColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(Aggregation_AggregationColumns& a, Aggregation_AggregationColumns& b) {
    a.Swap(&b);
  }
  inline void Swap(Aggregation_AggregationColumns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aggregation_AggregationColumns* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aggregation_AggregationColumns* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aggregation_AggregationColumns>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Aggregation_AggregationColumns& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Aggregation_AggregationColumns& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Aggregation_AggregationColumns* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns";
  }
  protected:
  explicit Aggregation_AggregationColumns(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchPairsFieldNumber = 2,
    kSpecFieldNumber = 1,
  };
  // repeated string match_pairs = 2;
  int match_pairs_size() const;
  private:
  int _internal_match_pairs_size() const;
  public:
  void clear_match_pairs();
  const std::string& match_pairs(int index) const;
  std::string* mutable_match_pairs(int index);
  void set_match_pairs(int index, const std::string& value);
  void set_match_pairs(int index, std::string&& value);
  void set_match_pairs(int index, const char* value);
  void set_match_pairs(int index, const char* value, size_t size);
  std::string* add_match_pairs();
  void add_match_pairs(const std::string& value);
  void add_match_pairs(std::string&& value);
  void add_match_pairs(const char* value);
  void add_match_pairs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& match_pairs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_match_pairs();
  private:
  const std::string& _internal_match_pairs(int index) const;
  std::string* _internal_add_match_pairs();
  public:

  // .io.deephaven.proto.backplane.grpc.AggSpec spec = 1;
  bool has_spec() const;
  private:
  bool _internal_has_spec() const;
  public:
  void clear_spec();
  const ::io::deephaven::proto::backplane::grpc::AggSpec& spec() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec* release_spec();
  ::io::deephaven::proto::backplane::grpc::AggSpec* mutable_spec();
  void set_allocated_spec(::io::deephaven::proto::backplane::grpc::AggSpec* spec);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec& _internal_spec() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec* _internal_mutable_spec();
  public:
  void unsafe_arena_set_allocated_spec(
      ::io::deephaven::proto::backplane::grpc::AggSpec* spec);
  ::io::deephaven::proto::backplane::grpc::AggSpec* unsafe_arena_release_spec();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> match_pairs_;
  ::io::deephaven::proto::backplane::grpc::AggSpec* spec_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Aggregation_AggregationCount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount) */ {
 public:
  inline Aggregation_AggregationCount() : Aggregation_AggregationCount(nullptr) {}
  ~Aggregation_AggregationCount() override;
  explicit PROTOBUF_CONSTEXPR Aggregation_AggregationCount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Aggregation_AggregationCount(const Aggregation_AggregationCount& from);
  Aggregation_AggregationCount(Aggregation_AggregationCount&& from) noexcept
    : Aggregation_AggregationCount() {
    *this = ::std::move(from);
  }

  inline Aggregation_AggregationCount& operator=(const Aggregation_AggregationCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aggregation_AggregationCount& operator=(Aggregation_AggregationCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aggregation_AggregationCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aggregation_AggregationCount* internal_default_instance() {
    return reinterpret_cast<const Aggregation_AggregationCount*>(
               &_Aggregation_AggregationCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(Aggregation_AggregationCount& a, Aggregation_AggregationCount& b) {
    a.Swap(&b);
  }
  inline void Swap(Aggregation_AggregationCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aggregation_AggregationCount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aggregation_AggregationCount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aggregation_AggregationCount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Aggregation_AggregationCount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Aggregation_AggregationCount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Aggregation_AggregationCount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount";
  }
  protected:
  explicit Aggregation_AggregationCount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Aggregation_AggregationRowKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey) */ {
 public:
  inline Aggregation_AggregationRowKey() : Aggregation_AggregationRowKey(nullptr) {}
  ~Aggregation_AggregationRowKey() override;
  explicit PROTOBUF_CONSTEXPR Aggregation_AggregationRowKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Aggregation_AggregationRowKey(const Aggregation_AggregationRowKey& from);
  Aggregation_AggregationRowKey(Aggregation_AggregationRowKey&& from) noexcept
    : Aggregation_AggregationRowKey() {
    *this = ::std::move(from);
  }

  inline Aggregation_AggregationRowKey& operator=(const Aggregation_AggregationRowKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aggregation_AggregationRowKey& operator=(Aggregation_AggregationRowKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aggregation_AggregationRowKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aggregation_AggregationRowKey* internal_default_instance() {
    return reinterpret_cast<const Aggregation_AggregationRowKey*>(
               &_Aggregation_AggregationRowKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(Aggregation_AggregationRowKey& a, Aggregation_AggregationRowKey& b) {
    a.Swap(&b);
  }
  inline void Swap(Aggregation_AggregationRowKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aggregation_AggregationRowKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aggregation_AggregationRowKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aggregation_AggregationRowKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Aggregation_AggregationRowKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Aggregation_AggregationRowKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Aggregation_AggregationRowKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey";
  }
  protected:
  explicit Aggregation_AggregationRowKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Aggregation_AggregationPartition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition) */ {
 public:
  inline Aggregation_AggregationPartition() : Aggregation_AggregationPartition(nullptr) {}
  ~Aggregation_AggregationPartition() override;
  explicit PROTOBUF_CONSTEXPR Aggregation_AggregationPartition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Aggregation_AggregationPartition(const Aggregation_AggregationPartition& from);
  Aggregation_AggregationPartition(Aggregation_AggregationPartition&& from) noexcept
    : Aggregation_AggregationPartition() {
    *this = ::std::move(from);
  }

  inline Aggregation_AggregationPartition& operator=(const Aggregation_AggregationPartition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aggregation_AggregationPartition& operator=(Aggregation_AggregationPartition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aggregation_AggregationPartition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aggregation_AggregationPartition* internal_default_instance() {
    return reinterpret_cast<const Aggregation_AggregationPartition*>(
               &_Aggregation_AggregationPartition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(Aggregation_AggregationPartition& a, Aggregation_AggregationPartition& b) {
    a.Swap(&b);
  }
  inline void Swap(Aggregation_AggregationPartition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aggregation_AggregationPartition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aggregation_AggregationPartition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aggregation_AggregationPartition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Aggregation_AggregationPartition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Aggregation_AggregationPartition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Aggregation_AggregationPartition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition";
  }
  protected:
  explicit Aggregation_AggregationPartition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
    kIncludeGroupByColumnsFieldNumber = 2,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // bool include_group_by_columns = 2;
  void clear_include_group_by_columns();
  bool include_group_by_columns() const;
  void set_include_group_by_columns(bool value);
  private:
  bool _internal_include_group_by_columns() const;
  void _internal_set_include_group_by_columns(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  bool include_group_by_columns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Aggregation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Aggregation) */ {
 public:
  inline Aggregation() : Aggregation(nullptr) {}
  ~Aggregation() override;
  explicit PROTOBUF_CONSTEXPR Aggregation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Aggregation(const Aggregation& from);
  Aggregation(Aggregation&& from) noexcept
    : Aggregation() {
    *this = ::std::move(from);
  }

  inline Aggregation& operator=(const Aggregation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aggregation& operator=(Aggregation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aggregation& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kColumns = 1,
    kCount = 2,
    kFirstRowKey = 3,
    kLastRowKey = 4,
    kPartition = 5,
    TYPE_NOT_SET = 0,
  };

  static inline const Aggregation* internal_default_instance() {
    return reinterpret_cast<const Aggregation*>(
               &_Aggregation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(Aggregation& a, Aggregation& b) {
    a.Swap(&b);
  }
  inline void Swap(Aggregation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aggregation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aggregation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aggregation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Aggregation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Aggregation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Aggregation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Aggregation";
  }
  protected:
  explicit Aggregation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Aggregation_AggregationColumns AggregationColumns;
  typedef Aggregation_AggregationCount AggregationCount;
  typedef Aggregation_AggregationRowKey AggregationRowKey;
  typedef Aggregation_AggregationPartition AggregationPartition;

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 1,
    kCountFieldNumber = 2,
    kFirstRowKeyFieldNumber = 3,
    kLastRowKeyFieldNumber = 4,
    kPartitionFieldNumber = 5,
  };
  // .io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns columns = 1;
  bool has_columns() const;
  private:
  bool _internal_has_columns() const;
  public:
  void clear_columns();
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns& columns() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* release_columns();
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* mutable_columns();
  void set_allocated_columns(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* columns);
  private:
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns& _internal_columns() const;
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* _internal_mutable_columns();
  public:
  void unsafe_arena_set_allocated_columns(
      ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* columns);
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* unsafe_arena_release_columns();

  // .io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount& count() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* release_count();
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* mutable_count();
  void set_allocated_count(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* count);
  private:
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount& _internal_count() const;
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* _internal_mutable_count();
  public:
  void unsafe_arena_set_allocated_count(
      ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* count);
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* unsafe_arena_release_count();

  // .io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey first_row_key = 3;
  bool has_first_row_key() const;
  private:
  bool _internal_has_first_row_key() const;
  public:
  void clear_first_row_key();
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& first_row_key() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* release_first_row_key();
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* mutable_first_row_key();
  void set_allocated_first_row_key(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* first_row_key);
  private:
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& _internal_first_row_key() const;
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* _internal_mutable_first_row_key();
  public:
  void unsafe_arena_set_allocated_first_row_key(
      ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* first_row_key);
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* unsafe_arena_release_first_row_key();

  // .io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey last_row_key = 4;
  bool has_last_row_key() const;
  private:
  bool _internal_has_last_row_key() const;
  public:
  void clear_last_row_key();
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& last_row_key() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* release_last_row_key();
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* mutable_last_row_key();
  void set_allocated_last_row_key(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* last_row_key);
  private:
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& _internal_last_row_key() const;
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* _internal_mutable_last_row_key();
  public:
  void unsafe_arena_set_allocated_last_row_key(
      ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* last_row_key);
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* unsafe_arena_release_last_row_key();

  // .io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition partition = 5;
  bool has_partition() const;
  private:
  bool _internal_has_partition() const;
  public:
  void clear_partition();
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition& partition() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* release_partition();
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* mutable_partition();
  void set_allocated_partition(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* partition);
  private:
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition& _internal_partition() const;
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* _internal_mutable_partition();
  public:
  void unsafe_arena_set_allocated_partition(
      ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* partition);
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* unsafe_arena_release_partition();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Aggregation)
 private:
  class _Internal;
  void set_has_columns();
  void set_has_count();
  void set_has_first_row_key();
  void set_has_last_row_key();
  void set_has_partition();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* columns_;
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* count_;
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* first_row_key_;
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* last_row_key_;
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* partition_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SortDescriptor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SortDescriptor) */ {
 public:
  inline SortDescriptor() : SortDescriptor(nullptr) {}
  ~SortDescriptor() override;
  explicit PROTOBUF_CONSTEXPR SortDescriptor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SortDescriptor(const SortDescriptor& from);
  SortDescriptor(SortDescriptor&& from) noexcept
    : SortDescriptor() {
    *this = ::std::move(from);
  }

  inline SortDescriptor& operator=(const SortDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortDescriptor& operator=(SortDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const SortDescriptor* internal_default_instance() {
    return reinterpret_cast<const SortDescriptor*>(
               &_SortDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(SortDescriptor& a, SortDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(SortDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortDescriptor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SortDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SortDescriptor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SortDescriptor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SortDescriptor& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SortDescriptor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SortDescriptor";
  }
  protected:
  explicit SortDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SortDescriptor_SortDirection SortDirection;
  static constexpr SortDirection UNKNOWN =
    SortDescriptor_SortDirection_UNKNOWN;
  static constexpr SortDirection DESCENDING =
    SortDescriptor_SortDirection_DESCENDING;
  static constexpr SortDirection ASCENDING =
    SortDescriptor_SortDirection_ASCENDING;
  static constexpr SortDirection REVERSE =
    SortDescriptor_SortDirection_REVERSE;
  static inline bool SortDirection_IsValid(int value) {
    return SortDescriptor_SortDirection_IsValid(value);
  }
  static constexpr SortDirection SortDirection_MIN =
    SortDescriptor_SortDirection_SortDirection_MIN;
  static constexpr SortDirection SortDirection_MAX =
    SortDescriptor_SortDirection_SortDirection_MAX;
  static constexpr int SortDirection_ARRAYSIZE =
    SortDescriptor_SortDirection_SortDirection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SortDirection_descriptor() {
    return SortDescriptor_SortDirection_descriptor();
  }
  template<typename T>
  static inline const std::string& SortDirection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SortDirection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SortDirection_Name.");
    return SortDescriptor_SortDirection_Name(enum_t_value);
  }
  static inline bool SortDirection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SortDirection* value) {
    return SortDescriptor_SortDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
    kIsAbsoluteFieldNumber = 2,
    kDirectionFieldNumber = 3,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // bool is_absolute = 2;
  void clear_is_absolute();
  bool is_absolute() const;
  void set_is_absolute(bool value);
  private:
  bool _internal_is_absolute() const;
  void _internal_set_is_absolute(bool value);
  public:

  // .io.deephaven.proto.backplane.grpc.SortDescriptor.SortDirection direction = 3;
  void clear_direction();
  ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection direction() const;
  void set_direction(::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection value);
  private:
  ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection _internal_direction() const;
  void _internal_set_direction(::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SortDescriptor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  bool is_absolute_;
  int direction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SortTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SortTableRequest) */ {
 public:
  inline SortTableRequest() : SortTableRequest(nullptr) {}
  ~SortTableRequest() override;
  explicit PROTOBUF_CONSTEXPR SortTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SortTableRequest(const SortTableRequest& from);
  SortTableRequest(SortTableRequest&& from) noexcept
    : SortTableRequest() {
    *this = ::std::move(from);
  }

  inline SortTableRequest& operator=(const SortTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortTableRequest& operator=(SortTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SortTableRequest* internal_default_instance() {
    return reinterpret_cast<const SortTableRequest*>(
               &_SortTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(SortTableRequest& a, SortTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SortTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SortTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SortTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SortTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SortTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SortTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SortTableRequest";
  }
  protected:
  explicit SortTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSortsFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated .io.deephaven.proto.backplane.grpc.SortDescriptor sorts = 3;
  int sorts_size() const;
  private:
  int _internal_sorts_size() const;
  public:
  void clear_sorts();
  ::io::deephaven::proto::backplane::grpc::SortDescriptor* mutable_sorts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor >*
      mutable_sorts();
  private:
  const ::io::deephaven::proto::backplane::grpc::SortDescriptor& _internal_sorts(int index) const;
  ::io::deephaven::proto::backplane::grpc::SortDescriptor* _internal_add_sorts();
  public:
  const ::io::deephaven::proto::backplane::grpc::SortDescriptor& sorts(int index) const;
  ::io::deephaven::proto::backplane::grpc::SortDescriptor* add_sorts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor >&
      sorts() const;

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SortTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor > sorts_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class FilterTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FilterTableRequest) */ {
 public:
  inline FilterTableRequest() : FilterTableRequest(nullptr) {}
  ~FilterTableRequest() override;
  explicit PROTOBUF_CONSTEXPR FilterTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FilterTableRequest(const FilterTableRequest& from);
  FilterTableRequest(FilterTableRequest&& from) noexcept
    : FilterTableRequest() {
    *this = ::std::move(from);
  }

  inline FilterTableRequest& operator=(const FilterTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterTableRequest& operator=(FilterTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilterTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilterTableRequest* internal_default_instance() {
    return reinterpret_cast<const FilterTableRequest*>(
               &_FilterTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(FilterTableRequest& a, FilterTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FilterTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilterTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilterTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilterTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FilterTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FilterTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FilterTableRequest";
  }
  protected:
  explicit FilterTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Condition filters = 3;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::io::deephaven::proto::backplane::grpc::Condition* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
      mutable_filters();
  private:
  const ::io::deephaven::proto::backplane::grpc::Condition& _internal_filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* _internal_add_filters();
  public:
  const ::io::deephaven::proto::backplane::grpc::Condition& filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
      filters() const;

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FilterTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition > filters_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SeekRowRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SeekRowRequest) */ {
 public:
  inline SeekRowRequest() : SeekRowRequest(nullptr) {}
  ~SeekRowRequest() override;
  explicit PROTOBUF_CONSTEXPR SeekRowRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SeekRowRequest(const SeekRowRequest& from);
  SeekRowRequest(SeekRowRequest&& from) noexcept
    : SeekRowRequest() {
    *this = ::std::move(from);
  }

  inline SeekRowRequest& operator=(const SeekRowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeekRowRequest& operator=(SeekRowRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeekRowRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeekRowRequest* internal_default_instance() {
    return reinterpret_cast<const SeekRowRequest*>(
               &_SeekRowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(SeekRowRequest& a, SeekRowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SeekRowRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeekRowRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SeekRowRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SeekRowRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SeekRowRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SeekRowRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeekRowRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SeekRowRequest";
  }
  protected:
  explicit SeekRowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 3,
    kSourceIdFieldNumber = 1,
    kSeekValueFieldNumber = 4,
    kStartingRowFieldNumber = 2,
    kInsensitiveFieldNumber = 5,
    kContainsFieldNumber = 6,
    kIsBackwardFieldNumber = 7,
  };
  // string column_name = 3;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket source_id = 1;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_source_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::Ticket* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* source_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_source_id();

  // .io.deephaven.proto.backplane.grpc.Literal seek_value = 4;
  bool has_seek_value() const;
  private:
  bool _internal_has_seek_value() const;
  public:
  void clear_seek_value();
  const ::io::deephaven::proto::backplane::grpc::Literal& seek_value() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Literal* release_seek_value();
  ::io::deephaven::proto::backplane::grpc::Literal* mutable_seek_value();
  void set_allocated_seek_value(::io::deephaven::proto::backplane::grpc::Literal* seek_value);
  private:
  const ::io::deephaven::proto::backplane::grpc::Literal& _internal_seek_value() const;
  ::io::deephaven::proto::backplane::grpc::Literal* _internal_mutable_seek_value();
  public:
  void unsafe_arena_set_allocated_seek_value(
      ::io::deephaven::proto::backplane::grpc::Literal* seek_value);
  ::io::deephaven::proto::backplane::grpc::Literal* unsafe_arena_release_seek_value();

  // sint64 starting_row = 2 [jstype = JS_STRING];
  void clear_starting_row();
  int64_t starting_row() const;
  void set_starting_row(int64_t value);
  private:
  int64_t _internal_starting_row() const;
  void _internal_set_starting_row(int64_t value);
  public:

  // bool insensitive = 5;
  void clear_insensitive();
  bool insensitive() const;
  void set_insensitive(bool value);
  private:
  bool _internal_insensitive() const;
  void _internal_set_insensitive(bool value);
  public:

  // bool contains = 6;
  void clear_contains();
  bool contains() const;
  void set_contains(bool value);
  private:
  bool _internal_contains() const;
  void _internal_set_contains(bool value);
  public:

  // bool is_backward = 7;
  void clear_is_backward();
  bool is_backward() const;
  void set_is_backward(bool value);
  private:
  bool _internal_is_backward() const;
  void _internal_set_is_backward(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SeekRowRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  ::io::deephaven::proto::backplane::grpc::Ticket* source_id_;
  ::io::deephaven::proto::backplane::grpc::Literal* seek_value_;
  int64_t starting_row_;
  bool insensitive_;
  bool contains_;
  bool is_backward_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SeekRowResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SeekRowResponse) */ {
 public:
  inline SeekRowResponse() : SeekRowResponse(nullptr) {}
  ~SeekRowResponse() override;
  explicit PROTOBUF_CONSTEXPR SeekRowResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SeekRowResponse(const SeekRowResponse& from);
  SeekRowResponse(SeekRowResponse&& from) noexcept
    : SeekRowResponse() {
    *this = ::std::move(from);
  }

  inline SeekRowResponse& operator=(const SeekRowResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeekRowResponse& operator=(SeekRowResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeekRowResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeekRowResponse* internal_default_instance() {
    return reinterpret_cast<const SeekRowResponse*>(
               &_SeekRowResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(SeekRowResponse& a, SeekRowResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SeekRowResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeekRowResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SeekRowResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SeekRowResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SeekRowResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SeekRowResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeekRowResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SeekRowResponse";
  }
  protected:
  explicit SeekRowResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultRowFieldNumber = 1,
  };
  // sint64 result_row = 1 [jstype = JS_STRING];
  void clear_result_row();
  int64_t result_row() const;
  void set_result_row(int64_t value);
  private:
  int64_t _internal_result_row() const;
  void _internal_set_result_row(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SeekRowResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t result_row_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Reference final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Reference) */ {
 public:
  inline Reference() : Reference(nullptr) {}
  ~Reference() override;
  explicit PROTOBUF_CONSTEXPR Reference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Reference(const Reference& from);
  Reference(Reference&& from) noexcept
    : Reference() {
    *this = ::std::move(from);
  }

  inline Reference& operator=(const Reference& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reference& operator=(Reference&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reference& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reference* internal_default_instance() {
    return reinterpret_cast<const Reference*>(
               &_Reference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(Reference& a, Reference& b) {
    a.Swap(&b);
  }
  inline void Swap(Reference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reference>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Reference& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Reference& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Reference* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Reference";
  }
  protected:
  explicit Reference(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name();
  const std::string& column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* column_name);
  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(const std::string& value);
  std::string* _internal_mutable_column_name();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Reference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Literal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Literal) */ {
 public:
  inline Literal() : Literal(nullptr) {}
  ~Literal() override;
  explicit PROTOBUF_CONSTEXPR Literal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Literal(const Literal& from);
  Literal(Literal&& from) noexcept
    : Literal() {
    *this = ::std::move(from);
  }

  inline Literal& operator=(const Literal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Literal& operator=(Literal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Literal& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kStringValue = 1,
    kDoubleValue = 2,
    kBoolValue = 3,
    kLongValue = 4,
    kNanoTimeValue = 5,
    VALUE_NOT_SET = 0,
  };

  static inline const Literal* internal_default_instance() {
    return reinterpret_cast<const Literal*>(
               &_Literal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(Literal& a, Literal& b) {
    a.Swap(&b);
  }
  inline void Swap(Literal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Literal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Literal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Literal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Literal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Literal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Literal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Literal";
  }
  protected:
  explicit Literal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringValueFieldNumber = 1,
    kDoubleValueFieldNumber = 2,
    kBoolValueFieldNumber = 3,
    kLongValueFieldNumber = 4,
    kNanoTimeValueFieldNumber = 5,
  };
  // string string_value = 1;
  bool has_string_value() const;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // double double_value = 2;
  bool has_double_value() const;
  private:
  bool _internal_has_double_value() const;
  public:
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);
  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);
  public:

  // bool bool_value = 3;
  bool has_bool_value() const;
  private:
  bool _internal_has_bool_value() const;
  public:
  void clear_bool_value();
  bool bool_value() const;
  void set_bool_value(bool value);
  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);
  public:

  // sint64 long_value = 4 [jstype = JS_STRING];
  bool has_long_value() const;
  private:
  bool _internal_has_long_value() const;
  public:
  void clear_long_value();
  int64_t long_value() const;
  void set_long_value(int64_t value);
  private:
  int64_t _internal_long_value() const;
  void _internal_set_long_value(int64_t value);
  public:

  // sint64 nano_time_value = 5 [jstype = JS_STRING];
  bool has_nano_time_value() const;
  private:
  bool _internal_has_nano_time_value() const;
  public:
  void clear_nano_time_value();
  int64_t nano_time_value() const;
  void set_nano_time_value(int64_t value);
  private:
  int64_t _internal_nano_time_value() const;
  void _internal_set_nano_time_value(int64_t value);
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Literal)
 private:
  class _Internal;
  void set_has_string_value();
  void set_has_double_value();
  void set_has_bool_value();
  void set_has_long_value();
  void set_has_nano_time_value();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
    double double_value_;
    bool bool_value_;
    int64_t long_value_;
    int64_t nano_time_value_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit PROTOBUF_CONSTEXPR Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kReference = 1,
    kLiteral = 2,
    DATA_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Value& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferenceFieldNumber = 1,
    kLiteralFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Reference reference = 1;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::io::deephaven::proto::backplane::grpc::Reference& reference() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Reference* release_reference();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_reference();
  void set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference);
  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_reference() const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::io::deephaven::proto::backplane::grpc::Reference* reference);
  ::io::deephaven::proto::backplane::grpc::Reference* unsafe_arena_release_reference();

  // .io.deephaven.proto.backplane.grpc.Literal literal = 2;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;
  public:
  void clear_literal();
  const ::io::deephaven::proto::backplane::grpc::Literal& literal() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Literal* release_literal();
  ::io::deephaven::proto::backplane::grpc::Literal* mutable_literal();
  void set_allocated_literal(::io::deephaven::proto::backplane::grpc::Literal* literal);
  private:
  const ::io::deephaven::proto::backplane::grpc::Literal& _internal_literal() const;
  ::io::deephaven::proto::backplane::grpc::Literal* _internal_mutable_literal();
  public:
  void unsafe_arena_set_allocated_literal(
      ::io::deephaven::proto::backplane::grpc::Literal* literal);
  ::io::deephaven::proto::backplane::grpc::Literal* unsafe_arena_release_literal();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Value)
 private:
  class _Internal;
  void set_has_reference();
  void set_has_literal();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::Reference* reference_;
    ::io::deephaven::proto::backplane::grpc::Literal* literal_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class Condition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  ~Condition() override;
  explicit PROTOBUF_CONSTEXPR Condition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Condition(const Condition& from);
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Condition& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kAnd = 1,
    kOr = 2,
    kNot = 3,
    kCompare = 4,
    kIn = 5,
    kInvoke = 6,
    kIsNull = 7,
    kMatches = 8,
    kContains = 9,
    kSearch = 10,
    DATA_NOT_SET = 0,
  };

  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Condition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Condition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Condition";
  }
  protected:
  explicit Condition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAndFieldNumber = 1,
    kOrFieldNumber = 2,
    kNotFieldNumber = 3,
    kCompareFieldNumber = 4,
    kInFieldNumber = 5,
    kInvokeFieldNumber = 6,
    kIsNullFieldNumber = 7,
    kMatchesFieldNumber = 8,
    kContainsFieldNumber = 9,
    kSearchFieldNumber = 10,
  };
  // .io.deephaven.proto.backplane.grpc.AndCondition and = 1;
  bool has_and_() const;
  private:
  bool _internal_has_and_() const;
  public:
  void clear_and_();
  const ::io::deephaven::proto::backplane::grpc::AndCondition& and_() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AndCondition* release_and_();
  ::io::deephaven::proto::backplane::grpc::AndCondition* mutable_and_();
  void set_allocated_and_(::io::deephaven::proto::backplane::grpc::AndCondition* and_);
  private:
  const ::io::deephaven::proto::backplane::grpc::AndCondition& _internal_and_() const;
  ::io::deephaven::proto::backplane::grpc::AndCondition* _internal_mutable_and_();
  public:
  void unsafe_arena_set_allocated_and_(
      ::io::deephaven::proto::backplane::grpc::AndCondition* and_);
  ::io::deephaven::proto::backplane::grpc::AndCondition* unsafe_arena_release_and_();

  // .io.deephaven.proto.backplane.grpc.OrCondition or = 2;
  bool has_or_() const;
  private:
  bool _internal_has_or_() const;
  public:
  void clear_or_();
  const ::io::deephaven::proto::backplane::grpc::OrCondition& or_() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::OrCondition* release_or_();
  ::io::deephaven::proto::backplane::grpc::OrCondition* mutable_or_();
  void set_allocated_or_(::io::deephaven::proto::backplane::grpc::OrCondition* or_);
  private:
  const ::io::deephaven::proto::backplane::grpc::OrCondition& _internal_or_() const;
  ::io::deephaven::proto::backplane::grpc::OrCondition* _internal_mutable_or_();
  public:
  void unsafe_arena_set_allocated_or_(
      ::io::deephaven::proto::backplane::grpc::OrCondition* or_);
  ::io::deephaven::proto::backplane::grpc::OrCondition* unsafe_arena_release_or_();

  // .io.deephaven.proto.backplane.grpc.NotCondition not = 3;
  bool has_not_() const;
  private:
  bool _internal_has_not_() const;
  public:
  void clear_not_();
  const ::io::deephaven::proto::backplane::grpc::NotCondition& not_() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::NotCondition* release_not_();
  ::io::deephaven::proto::backplane::grpc::NotCondition* mutable_not_();
  void set_allocated_not_(::io::deephaven::proto::backplane::grpc::NotCondition* not_);
  private:
  const ::io::deephaven::proto::backplane::grpc::NotCondition& _internal_not_() const;
  ::io::deephaven::proto::backplane::grpc::NotCondition* _internal_mutable_not_();
  public:
  void unsafe_arena_set_allocated_not_(
      ::io::deephaven::proto::backplane::grpc::NotCondition* not_);
  ::io::deephaven::proto::backplane::grpc::NotCondition* unsafe_arena_release_not_();

  // .io.deephaven.proto.backplane.grpc.CompareCondition compare = 4;
  bool has_compare() const;
  private:
  bool _internal_has_compare() const;
  public:
  void clear_compare();
  const ::io::deephaven::proto::backplane::grpc::CompareCondition& compare() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CompareCondition* release_compare();
  ::io::deephaven::proto::backplane::grpc::CompareCondition* mutable_compare();
  void set_allocated_compare(::io::deephaven::proto::backplane::grpc::CompareCondition* compare);
  private:
  const ::io::deephaven::proto::backplane::grpc::CompareCondition& _internal_compare() const;
  ::io::deephaven::proto::backplane::grpc::CompareCondition* _internal_mutable_compare();
  public:
  void unsafe_arena_set_allocated_compare(
      ::io::deephaven::proto::backplane::grpc::CompareCondition* compare);
  ::io::deephaven::proto::backplane::grpc::CompareCondition* unsafe_arena_release_compare();

  // .io.deephaven.proto.backplane.grpc.InCondition in = 5;
  bool has_in() const;
  private:
  bool _internal_has_in() const;
  public:
  void clear_in();
  const ::io::deephaven::proto::backplane::grpc::InCondition& in() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::InCondition* release_in();
  ::io::deephaven::proto::backplane::grpc::InCondition* mutable_in();
  void set_allocated_in(::io::deephaven::proto::backplane::grpc::InCondition* in);
  private:
  const ::io::deephaven::proto::backplane::grpc::InCondition& _internal_in() const;
  ::io::deephaven::proto::backplane::grpc::InCondition* _internal_mutable_in();
  public:
  void unsafe_arena_set_allocated_in(
      ::io::deephaven::proto::backplane::grpc::InCondition* in);
  ::io::deephaven::proto::backplane::grpc::InCondition* unsafe_arena_release_in();

  // .io.deephaven.proto.backplane.grpc.InvokeCondition invoke = 6;
  bool has_invoke() const;
  private:
  bool _internal_has_invoke() const;
  public:
  void clear_invoke();
  const ::io::deephaven::proto::backplane::grpc::InvokeCondition& invoke() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::InvokeCondition* release_invoke();
  ::io::deephaven::proto::backplane::grpc::InvokeCondition* mutable_invoke();
  void set_allocated_invoke(::io::deephaven::proto::backplane::grpc::InvokeCondition* invoke);
  private:
  const ::io::deephaven::proto::backplane::grpc::InvokeCondition& _internal_invoke() const;
  ::io::deephaven::proto::backplane::grpc::InvokeCondition* _internal_mutable_invoke();
  public:
  void unsafe_arena_set_allocated_invoke(
      ::io::deephaven::proto::backplane::grpc::InvokeCondition* invoke);
  ::io::deephaven::proto::backplane::grpc::InvokeCondition* unsafe_arena_release_invoke();

  // .io.deephaven.proto.backplane.grpc.IsNullCondition is_null = 7;
  bool has_is_null() const;
  private:
  bool _internal_has_is_null() const;
  public:
  void clear_is_null();
  const ::io::deephaven::proto::backplane::grpc::IsNullCondition& is_null() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::IsNullCondition* release_is_null();
  ::io::deephaven::proto::backplane::grpc::IsNullCondition* mutable_is_null();
  void set_allocated_is_null(::io::deephaven::proto::backplane::grpc::IsNullCondition* is_null);
  private:
  const ::io::deephaven::proto::backplane::grpc::IsNullCondition& _internal_is_null() const;
  ::io::deephaven::proto::backplane::grpc::IsNullCondition* _internal_mutable_is_null();
  public:
  void unsafe_arena_set_allocated_is_null(
      ::io::deephaven::proto::backplane::grpc::IsNullCondition* is_null);
  ::io::deephaven::proto::backplane::grpc::IsNullCondition* unsafe_arena_release_is_null();

  // .io.deephaven.proto.backplane.grpc.MatchesCondition matches = 8;
  bool has_matches() const;
  private:
  bool _internal_has_matches() const;
  public:
  void clear_matches();
  const ::io::deephaven::proto::backplane::grpc::MatchesCondition& matches() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::MatchesCondition* release_matches();
  ::io::deephaven::proto::backplane::grpc::MatchesCondition* mutable_matches();
  void set_allocated_matches(::io::deephaven::proto::backplane::grpc::MatchesCondition* matches);
  private:
  const ::io::deephaven::proto::backplane::grpc::MatchesCondition& _internal_matches() const;
  ::io::deephaven::proto::backplane::grpc::MatchesCondition* _internal_mutable_matches();
  public:
  void unsafe_arena_set_allocated_matches(
      ::io::deephaven::proto::backplane::grpc::MatchesCondition* matches);
  ::io::deephaven::proto::backplane::grpc::MatchesCondition* unsafe_arena_release_matches();

  // .io.deephaven.proto.backplane.grpc.ContainsCondition contains = 9;
  bool has_contains() const;
  private:
  bool _internal_has_contains() const;
  public:
  void clear_contains();
  const ::io::deephaven::proto::backplane::grpc::ContainsCondition& contains() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::ContainsCondition* release_contains();
  ::io::deephaven::proto::backplane::grpc::ContainsCondition* mutable_contains();
  void set_allocated_contains(::io::deephaven::proto::backplane::grpc::ContainsCondition* contains);
  private:
  const ::io::deephaven::proto::backplane::grpc::ContainsCondition& _internal_contains() const;
  ::io::deephaven::proto::backplane::grpc::ContainsCondition* _internal_mutable_contains();
  public:
  void unsafe_arena_set_allocated_contains(
      ::io::deephaven::proto::backplane::grpc::ContainsCondition* contains);
  ::io::deephaven::proto::backplane::grpc::ContainsCondition* unsafe_arena_release_contains();

  // .io.deephaven.proto.backplane.grpc.SearchCondition search = 10;
  bool has_search() const;
  private:
  bool _internal_has_search() const;
  public:
  void clear_search();
  const ::io::deephaven::proto::backplane::grpc::SearchCondition& search() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SearchCondition* release_search();
  ::io::deephaven::proto::backplane::grpc::SearchCondition* mutable_search();
  void set_allocated_search(::io::deephaven::proto::backplane::grpc::SearchCondition* search);
  private:
  const ::io::deephaven::proto::backplane::grpc::SearchCondition& _internal_search() const;
  ::io::deephaven::proto::backplane::grpc::SearchCondition* _internal_mutable_search();
  public:
  void unsafe_arena_set_allocated_search(
      ::io::deephaven::proto::backplane::grpc::SearchCondition* search);
  ::io::deephaven::proto::backplane::grpc::SearchCondition* unsafe_arena_release_search();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Condition)
 private:
  class _Internal;
  void set_has_and_();
  void set_has_or_();
  void set_has_not_();
  void set_has_compare();
  void set_has_in();
  void set_has_invoke();
  void set_has_is_null();
  void set_has_matches();
  void set_has_contains();
  void set_has_search();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::AndCondition* and__;
    ::io::deephaven::proto::backplane::grpc::OrCondition* or__;
    ::io::deephaven::proto::backplane::grpc::NotCondition* not__;
    ::io::deephaven::proto::backplane::grpc::CompareCondition* compare_;
    ::io::deephaven::proto::backplane::grpc::InCondition* in_;
    ::io::deephaven::proto::backplane::grpc::InvokeCondition* invoke_;
    ::io::deephaven::proto::backplane::grpc::IsNullCondition* is_null_;
    ::io::deephaven::proto::backplane::grpc::MatchesCondition* matches_;
    ::io::deephaven::proto::backplane::grpc::ContainsCondition* contains_;
    ::io::deephaven::proto::backplane::grpc::SearchCondition* search_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class AndCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AndCondition) */ {
 public:
  inline AndCondition() : AndCondition(nullptr) {}
  ~AndCondition() override;
  explicit PROTOBUF_CONSTEXPR AndCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AndCondition(const AndCondition& from);
  AndCondition(AndCondition&& from) noexcept
    : AndCondition() {
    *this = ::std::move(from);
  }

  inline AndCondition& operator=(const AndCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline AndCondition& operator=(AndCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AndCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const AndCondition* internal_default_instance() {
    return reinterpret_cast<const AndCondition*>(
               &_AndCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(AndCondition& a, AndCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(AndCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AndCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AndCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AndCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AndCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AndCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AndCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AndCondition";
  }
  protected:
  explicit AndCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Condition filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::io::deephaven::proto::backplane::grpc::Condition* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
      mutable_filters();
  private:
  const ::io::deephaven::proto::backplane::grpc::Condition& _internal_filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* _internal_add_filters();
  public:
  const ::io::deephaven::proto::backplane::grpc::Condition& filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
      filters() const;

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AndCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition > filters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class OrCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.OrCondition) */ {
 public:
  inline OrCondition() : OrCondition(nullptr) {}
  ~OrCondition() override;
  explicit PROTOBUF_CONSTEXPR OrCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OrCondition(const OrCondition& from);
  OrCondition(OrCondition&& from) noexcept
    : OrCondition() {
    *this = ::std::move(from);
  }

  inline OrCondition& operator=(const OrCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrCondition& operator=(OrCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrCondition* internal_default_instance() {
    return reinterpret_cast<const OrCondition*>(
               &_OrCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(OrCondition& a, OrCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(OrCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OrCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OrCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.OrCondition";
  }
  protected:
  explicit OrCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Condition filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;
  public:
  void clear_filters();
  ::io::deephaven::proto::backplane::grpc::Condition* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
      mutable_filters();
  private:
  const ::io::deephaven::proto::backplane::grpc::Condition& _internal_filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* _internal_add_filters();
  public:
  const ::io::deephaven::proto::backplane::grpc::Condition& filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
      filters() const;

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.OrCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition > filters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class NotCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.NotCondition) */ {
 public:
  inline NotCondition() : NotCondition(nullptr) {}
  ~NotCondition() override;
  explicit PROTOBUF_CONSTEXPR NotCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NotCondition(const NotCondition& from);
  NotCondition(NotCondition&& from) noexcept
    : NotCondition() {
    *this = ::std::move(from);
  }

  inline NotCondition& operator=(const NotCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotCondition& operator=(NotCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotCondition* internal_default_instance() {
    return reinterpret_cast<const NotCondition*>(
               &_NotCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(NotCondition& a, NotCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(NotCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NotCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const NotCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.NotCondition";
  }
  protected:
  explicit NotCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.Condition filter = 1;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::io::deephaven::proto::backplane::grpc::Condition& filter() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Condition* release_filter();
  ::io::deephaven::proto::backplane::grpc::Condition* mutable_filter();
  void set_allocated_filter(::io::deephaven::proto::backplane::grpc::Condition* filter);
  private:
  const ::io::deephaven::proto::backplane::grpc::Condition& _internal_filter() const;
  ::io::deephaven::proto::backplane::grpc::Condition* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::io::deephaven::proto::backplane::grpc::Condition* filter);
  ::io::deephaven::proto::backplane::grpc::Condition* unsafe_arena_release_filter();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.NotCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Condition* filter_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class CompareCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CompareCondition) */ {
 public:
  inline CompareCondition() : CompareCondition(nullptr) {}
  ~CompareCondition() override;
  explicit PROTOBUF_CONSTEXPR CompareCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompareCondition(const CompareCondition& from);
  CompareCondition(CompareCondition&& from) noexcept
    : CompareCondition() {
    *this = ::std::move(from);
  }

  inline CompareCondition& operator=(const CompareCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompareCondition& operator=(CompareCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompareCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompareCondition* internal_default_instance() {
    return reinterpret_cast<const CompareCondition*>(
               &_CompareCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(CompareCondition& a, CompareCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(CompareCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompareCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompareCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompareCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompareCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CompareCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompareCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CompareCondition";
  }
  protected:
  explicit CompareCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CompareCondition_CompareOperation CompareOperation;
  static constexpr CompareOperation LESS_THAN =
    CompareCondition_CompareOperation_LESS_THAN;
  static constexpr CompareOperation LESS_THAN_OR_EQUAL =
    CompareCondition_CompareOperation_LESS_THAN_OR_EQUAL;
  static constexpr CompareOperation GREATER_THAN =
    CompareCondition_CompareOperation_GREATER_THAN;
  static constexpr CompareOperation GREATER_THAN_OR_EQUAL =
    CompareCondition_CompareOperation_GREATER_THAN_OR_EQUAL;
  static constexpr CompareOperation EQUALS =
    CompareCondition_CompareOperation_EQUALS;
  static constexpr CompareOperation NOT_EQUALS =
    CompareCondition_CompareOperation_NOT_EQUALS;
  static inline bool CompareOperation_IsValid(int value) {
    return CompareCondition_CompareOperation_IsValid(value);
  }
  static constexpr CompareOperation CompareOperation_MIN =
    CompareCondition_CompareOperation_CompareOperation_MIN;
  static constexpr CompareOperation CompareOperation_MAX =
    CompareCondition_CompareOperation_CompareOperation_MAX;
  static constexpr int CompareOperation_ARRAYSIZE =
    CompareCondition_CompareOperation_CompareOperation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  CompareOperation_descriptor() {
    return CompareCondition_CompareOperation_descriptor();
  }
  template<typename T>
  static inline const std::string& CompareOperation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, CompareOperation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function CompareOperation_Name.");
    return CompareCondition_CompareOperation_Name(enum_t_value);
  }
  static inline bool CompareOperation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      CompareOperation* value) {
    return CompareCondition_CompareOperation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLhsFieldNumber = 3,
    kRhsFieldNumber = 4,
    kOperationFieldNumber = 1,
    kCaseSensitivityFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Value lhs = 3;
  bool has_lhs() const;
  private:
  bool _internal_has_lhs() const;
  public:
  void clear_lhs();
  const ::io::deephaven::proto::backplane::grpc::Value& lhs() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Value* release_lhs();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_lhs();
  void set_allocated_lhs(::io::deephaven::proto::backplane::grpc::Value* lhs);
  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_lhs() const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_mutable_lhs();
  public:
  void unsafe_arena_set_allocated_lhs(
      ::io::deephaven::proto::backplane::grpc::Value* lhs);
  ::io::deephaven::proto::backplane::grpc::Value* unsafe_arena_release_lhs();

  // .io.deephaven.proto.backplane.grpc.Value rhs = 4;
  bool has_rhs() const;
  private:
  bool _internal_has_rhs() const;
  public:
  void clear_rhs();
  const ::io::deephaven::proto::backplane::grpc::Value& rhs() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Value* release_rhs();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_rhs();
  void set_allocated_rhs(::io::deephaven::proto::backplane::grpc::Value* rhs);
  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_rhs() const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_mutable_rhs();
  public:
  void unsafe_arena_set_allocated_rhs(
      ::io::deephaven::proto::backplane::grpc::Value* rhs);
  ::io::deephaven::proto::backplane::grpc::Value* unsafe_arena_release_rhs();

  // .io.deephaven.proto.backplane.grpc.CompareCondition.CompareOperation operation = 1;
  void clear_operation();
  ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation operation() const;
  void set_operation(::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation value);
  private:
  ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation _internal_operation() const;
  void _internal_set_operation(::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation value);
  public:

  // .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 2;
  void clear_case_sensitivity();
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity case_sensitivity() const;
  void set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  private:
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CompareCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Value* lhs_;
  ::io::deephaven::proto::backplane::grpc::Value* rhs_;
  int operation_;
  int case_sensitivity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class InCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.InCondition) */ {
 public:
  inline InCondition() : InCondition(nullptr) {}
  ~InCondition() override;
  explicit PROTOBUF_CONSTEXPR InCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InCondition(const InCondition& from);
  InCondition(InCondition&& from) noexcept
    : InCondition() {
    *this = ::std::move(from);
  }

  inline InCondition& operator=(const InCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline InCondition& operator=(InCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const InCondition* internal_default_instance() {
    return reinterpret_cast<const InCondition*>(
               &_InCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(InCondition& a, InCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(InCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.InCondition";
  }
  protected:
  explicit InCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidatesFieldNumber = 2,
    kTargetFieldNumber = 1,
    kCaseSensitivityFieldNumber = 3,
    kMatchTypeFieldNumber = 4,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Value candidates = 2;
  int candidates_size() const;
  private:
  int _internal_candidates_size() const;
  public:
  void clear_candidates();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_candidates(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >*
      mutable_candidates();
  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_candidates(int index) const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_add_candidates();
  public:
  const ::io::deephaven::proto::backplane::grpc::Value& candidates(int index) const;
  ::io::deephaven::proto::backplane::grpc::Value* add_candidates();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >&
      candidates() const;

  // .io.deephaven.proto.backplane.grpc.Value target = 1;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::io::deephaven::proto::backplane::grpc::Value& target() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Value* release_target();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_target();
  void set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* target);
  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_target() const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::io::deephaven::proto::backplane::grpc::Value* target);
  ::io::deephaven::proto::backplane::grpc::Value* unsafe_arena_release_target();

  // .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
  void clear_case_sensitivity();
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity case_sensitivity() const;
  void set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  private:
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  public:

  // .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
  void clear_match_type();
  ::io::deephaven::proto::backplane::grpc::MatchType match_type() const;
  void set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);
  private:
  ::io::deephaven::proto::backplane::grpc::MatchType _internal_match_type() const;
  void _internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.InCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value > candidates_;
  ::io::deephaven::proto::backplane::grpc::Value* target_;
  int case_sensitivity_;
  int match_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class InvokeCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.InvokeCondition) */ {
 public:
  inline InvokeCondition() : InvokeCondition(nullptr) {}
  ~InvokeCondition() override;
  explicit PROTOBUF_CONSTEXPR InvokeCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InvokeCondition(const InvokeCondition& from);
  InvokeCondition(InvokeCondition&& from) noexcept
    : InvokeCondition() {
    *this = ::std::move(from);
  }

  inline InvokeCondition& operator=(const InvokeCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeCondition& operator=(InvokeCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeCondition* internal_default_instance() {
    return reinterpret_cast<const InvokeCondition*>(
               &_InvokeCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(InvokeCondition& a, InvokeCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InvokeCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const InvokeCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InvokeCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.InvokeCondition";
  }
  protected:
  explicit InvokeCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 3,
    kMethodFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Value arguments = 3;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_arguments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >*
      mutable_arguments();
  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_arguments(int index) const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_add_arguments();
  public:
  const ::io::deephaven::proto::backplane::grpc::Value& arguments(int index) const;
  ::io::deephaven::proto::backplane::grpc::Value* add_arguments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >&
      arguments() const;

  // string method = 1;
  void clear_method();
  const std::string& method() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_method(ArgT0&& arg0, ArgT... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* method);
  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(const std::string& value);
  std::string* _internal_mutable_method();
  public:

  // .io.deephaven.proto.backplane.grpc.Value target = 2;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::io::deephaven::proto::backplane::grpc::Value& target() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Value* release_target();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_target();
  void set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* target);
  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_target() const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::io::deephaven::proto::backplane::grpc::Value* target);
  ::io::deephaven::proto::backplane::grpc::Value* unsafe_arena_release_target();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.InvokeCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value > arguments_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_;
  ::io::deephaven::proto::backplane::grpc::Value* target_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class IsNullCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.IsNullCondition) */ {
 public:
  inline IsNullCondition() : IsNullCondition(nullptr) {}
  ~IsNullCondition() override;
  explicit PROTOBUF_CONSTEXPR IsNullCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IsNullCondition(const IsNullCondition& from);
  IsNullCondition(IsNullCondition&& from) noexcept
    : IsNullCondition() {
    *this = ::std::move(from);
  }

  inline IsNullCondition& operator=(const IsNullCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsNullCondition& operator=(IsNullCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsNullCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsNullCondition* internal_default_instance() {
    return reinterpret_cast<const IsNullCondition*>(
               &_IsNullCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(IsNullCondition& a, IsNullCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(IsNullCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsNullCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsNullCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsNullCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IsNullCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const IsNullCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsNullCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.IsNullCondition";
  }
  protected:
  explicit IsNullCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferenceFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.Reference reference = 1;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::io::deephaven::proto::backplane::grpc::Reference& reference() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Reference* release_reference();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_reference();
  void set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference);
  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_reference() const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::io::deephaven::proto::backplane::grpc::Reference* reference);
  ::io::deephaven::proto::backplane::grpc::Reference* unsafe_arena_release_reference();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.IsNullCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Reference* reference_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class MatchesCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MatchesCondition) */ {
 public:
  inline MatchesCondition() : MatchesCondition(nullptr) {}
  ~MatchesCondition() override;
  explicit PROTOBUF_CONSTEXPR MatchesCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchesCondition(const MatchesCondition& from);
  MatchesCondition(MatchesCondition&& from) noexcept
    : MatchesCondition() {
    *this = ::std::move(from);
  }

  inline MatchesCondition& operator=(const MatchesCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchesCondition& operator=(MatchesCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchesCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchesCondition* internal_default_instance() {
    return reinterpret_cast<const MatchesCondition*>(
               &_MatchesCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(MatchesCondition& a, MatchesCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchesCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchesCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchesCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchesCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchesCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchesCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchesCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MatchesCondition";
  }
  protected:
  explicit MatchesCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegexFieldNumber = 2,
    kReferenceFieldNumber = 1,
    kCaseSensitivityFieldNumber = 3,
    kMatchTypeFieldNumber = 4,
  };
  // string regex = 2;
  void clear_regex();
  const std::string& regex() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_regex(ArgT0&& arg0, ArgT... args);
  std::string* mutable_regex();
  PROTOBUF_NODISCARD std::string* release_regex();
  void set_allocated_regex(std::string* regex);
  private:
  const std::string& _internal_regex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_regex(const std::string& value);
  std::string* _internal_mutable_regex();
  public:

  // .io.deephaven.proto.backplane.grpc.Reference reference = 1;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::io::deephaven::proto::backplane::grpc::Reference& reference() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Reference* release_reference();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_reference();
  void set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference);
  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_reference() const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::io::deephaven::proto::backplane::grpc::Reference* reference);
  ::io::deephaven::proto::backplane::grpc::Reference* unsafe_arena_release_reference();

  // .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
  void clear_case_sensitivity();
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity case_sensitivity() const;
  void set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  private:
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  public:

  // .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
  void clear_match_type();
  ::io::deephaven::proto::backplane::grpc::MatchType match_type() const;
  void set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);
  private:
  ::io::deephaven::proto::backplane::grpc::MatchType _internal_match_type() const;
  void _internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MatchesCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr regex_;
  ::io::deephaven::proto::backplane::grpc::Reference* reference_;
  int case_sensitivity_;
  int match_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class ContainsCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ContainsCondition) */ {
 public:
  inline ContainsCondition() : ContainsCondition(nullptr) {}
  ~ContainsCondition() override;
  explicit PROTOBUF_CONSTEXPR ContainsCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContainsCondition(const ContainsCondition& from);
  ContainsCondition(ContainsCondition&& from) noexcept
    : ContainsCondition() {
    *this = ::std::move(from);
  }

  inline ContainsCondition& operator=(const ContainsCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContainsCondition& operator=(ContainsCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContainsCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContainsCondition* internal_default_instance() {
    return reinterpret_cast<const ContainsCondition*>(
               &_ContainsCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(ContainsCondition& a, ContainsCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(ContainsCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContainsCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContainsCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContainsCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ContainsCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ContainsCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContainsCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ContainsCondition";
  }
  protected:
  explicit ContainsCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSearchStringFieldNumber = 2,
    kReferenceFieldNumber = 1,
    kCaseSensitivityFieldNumber = 3,
    kMatchTypeFieldNumber = 4,
  };
  // string search_string = 2;
  void clear_search_string();
  const std::string& search_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_search_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_search_string();
  PROTOBUF_NODISCARD std::string* release_search_string();
  void set_allocated_search_string(std::string* search_string);
  private:
  const std::string& _internal_search_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_string(const std::string& value);
  std::string* _internal_mutable_search_string();
  public:

  // .io.deephaven.proto.backplane.grpc.Reference reference = 1;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;
  public:
  void clear_reference();
  const ::io::deephaven::proto::backplane::grpc::Reference& reference() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Reference* release_reference();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_reference();
  void set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference);
  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_reference() const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_mutable_reference();
  public:
  void unsafe_arena_set_allocated_reference(
      ::io::deephaven::proto::backplane::grpc::Reference* reference);
  ::io::deephaven::proto::backplane::grpc::Reference* unsafe_arena_release_reference();

  // .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
  void clear_case_sensitivity();
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity case_sensitivity() const;
  void set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  private:
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);
  public:

  // .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
  void clear_match_type();
  ::io::deephaven::proto::backplane::grpc::MatchType match_type() const;
  void set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);
  private:
  ::io::deephaven::proto::backplane::grpc::MatchType _internal_match_type() const;
  void _internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ContainsCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_string_;
  ::io::deephaven::proto::backplane::grpc::Reference* reference_;
  int case_sensitivity_;
  int match_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class SearchCondition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SearchCondition) */ {
 public:
  inline SearchCondition() : SearchCondition(nullptr) {}
  ~SearchCondition() override;
  explicit PROTOBUF_CONSTEXPR SearchCondition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SearchCondition(const SearchCondition& from);
  SearchCondition(SearchCondition&& from) noexcept
    : SearchCondition() {
    *this = ::std::move(from);
  }

  inline SearchCondition& operator=(const SearchCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchCondition& operator=(SearchCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchCondition* internal_default_instance() {
    return reinterpret_cast<const SearchCondition*>(
               &_SearchCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(SearchCondition& a, SearchCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchCondition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SearchCondition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SearchCondition& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchCondition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SearchCondition";
  }
  protected:
  explicit SearchCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionalReferencesFieldNumber = 2,
    kSearchStringFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Reference optional_references = 2;
  int optional_references_size() const;
  private:
  int _internal_optional_references_size() const;
  public:
  void clear_optional_references();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_optional_references(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference >*
      mutable_optional_references();
  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_optional_references(int index) const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_add_optional_references();
  public:
  const ::io::deephaven::proto::backplane::grpc::Reference& optional_references(int index) const;
  ::io::deephaven::proto::backplane::grpc::Reference* add_optional_references();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference >&
      optional_references() const;

  // string search_string = 1;
  void clear_search_string();
  const std::string& search_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_search_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_search_string();
  PROTOBUF_NODISCARD std::string* release_search_string();
  void set_allocated_search_string(std::string* search_string);
  private:
  const std::string& _internal_search_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_string(const std::string& value);
  std::string* _internal_mutable_search_string();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SearchCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference > optional_references_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_string_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class FlattenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FlattenRequest) */ {
 public:
  inline FlattenRequest() : FlattenRequest(nullptr) {}
  ~FlattenRequest() override;
  explicit PROTOBUF_CONSTEXPR FlattenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlattenRequest(const FlattenRequest& from);
  FlattenRequest(FlattenRequest&& from) noexcept
    : FlattenRequest() {
    *this = ::std::move(from);
  }

  inline FlattenRequest& operator=(const FlattenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlattenRequest& operator=(FlattenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlattenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlattenRequest* internal_default_instance() {
    return reinterpret_cast<const FlattenRequest*>(
               &_FlattenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(FlattenRequest& a, FlattenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlattenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlattenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlattenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlattenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlattenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FlattenRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlattenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FlattenRequest";
  }
  protected:
  explicit FlattenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FlattenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class MetaTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MetaTableRequest) */ {
 public:
  inline MetaTableRequest() : MetaTableRequest(nullptr) {}
  ~MetaTableRequest() override;
  explicit PROTOBUF_CONSTEXPR MetaTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetaTableRequest(const MetaTableRequest& from);
  MetaTableRequest(MetaTableRequest&& from) noexcept
    : MetaTableRequest() {
    *this = ::std::move(from);
  }

  inline MetaTableRequest& operator=(const MetaTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaTableRequest& operator=(MetaTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetaTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetaTableRequest* internal_default_instance() {
    return reinterpret_cast<const MetaTableRequest*>(
               &_MetaTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(MetaTableRequest& a, MetaTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetaTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetaTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetaTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetaTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetaTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MetaTableRequest";
  }
  protected:
  explicit MetaTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MetaTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class RunChartDownsampleRequest_ZoomRange final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange) */ {
 public:
  inline RunChartDownsampleRequest_ZoomRange() : RunChartDownsampleRequest_ZoomRange(nullptr) {}
  ~RunChartDownsampleRequest_ZoomRange() override;
  explicit PROTOBUF_CONSTEXPR RunChartDownsampleRequest_ZoomRange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunChartDownsampleRequest_ZoomRange(const RunChartDownsampleRequest_ZoomRange& from);
  RunChartDownsampleRequest_ZoomRange(RunChartDownsampleRequest_ZoomRange&& from) noexcept
    : RunChartDownsampleRequest_ZoomRange() {
    *this = ::std::move(from);
  }

  inline RunChartDownsampleRequest_ZoomRange& operator=(const RunChartDownsampleRequest_ZoomRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunChartDownsampleRequest_ZoomRange& operator=(RunChartDownsampleRequest_ZoomRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunChartDownsampleRequest_ZoomRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunChartDownsampleRequest_ZoomRange* internal_default_instance() {
    return reinterpret_cast<const RunChartDownsampleRequest_ZoomRange*>(
               &_RunChartDownsampleRequest_ZoomRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(RunChartDownsampleRequest_ZoomRange& a, RunChartDownsampleRequest_ZoomRange& b) {
    a.Swap(&b);
  }
  inline void Swap(RunChartDownsampleRequest_ZoomRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunChartDownsampleRequest_ZoomRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunChartDownsampleRequest_ZoomRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunChartDownsampleRequest_ZoomRange>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunChartDownsampleRequest_ZoomRange& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RunChartDownsampleRequest_ZoomRange& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunChartDownsampleRequest_ZoomRange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange";
  }
  protected:
  explicit RunChartDownsampleRequest_ZoomRange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinDateNanosFieldNumber = 1,
    kMaxDateNanosFieldNumber = 2,
  };
  // optional int64 min_date_nanos = 1 [jstype = JS_STRING];
  bool has_min_date_nanos() const;
  private:
  bool _internal_has_min_date_nanos() const;
  public:
  void clear_min_date_nanos();
  int64_t min_date_nanos() const;
  void set_min_date_nanos(int64_t value);
  private:
  int64_t _internal_min_date_nanos() const;
  void _internal_set_min_date_nanos(int64_t value);
  public:

  // optional int64 max_date_nanos = 2 [jstype = JS_STRING];
  bool has_max_date_nanos() const;
  private:
  bool _internal_has_max_date_nanos() const;
  public:
  void clear_max_date_nanos();
  int64_t max_date_nanos() const;
  void set_max_date_nanos(int64_t value);
  private:
  int64_t _internal_max_date_nanos() const;
  void _internal_set_max_date_nanos(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t min_date_nanos_;
  int64_t max_date_nanos_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class RunChartDownsampleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest) */ {
 public:
  inline RunChartDownsampleRequest() : RunChartDownsampleRequest(nullptr) {}
  ~RunChartDownsampleRequest() override;
  explicit PROTOBUF_CONSTEXPR RunChartDownsampleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RunChartDownsampleRequest(const RunChartDownsampleRequest& from);
  RunChartDownsampleRequest(RunChartDownsampleRequest&& from) noexcept
    : RunChartDownsampleRequest() {
    *this = ::std::move(from);
  }

  inline RunChartDownsampleRequest& operator=(const RunChartDownsampleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunChartDownsampleRequest& operator=(RunChartDownsampleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunChartDownsampleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunChartDownsampleRequest* internal_default_instance() {
    return reinterpret_cast<const RunChartDownsampleRequest*>(
               &_RunChartDownsampleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(RunChartDownsampleRequest& a, RunChartDownsampleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RunChartDownsampleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunChartDownsampleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunChartDownsampleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunChartDownsampleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RunChartDownsampleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RunChartDownsampleRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunChartDownsampleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest";
  }
  protected:
  explicit RunChartDownsampleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RunChartDownsampleRequest_ZoomRange ZoomRange;

  // accessors -------------------------------------------------------

  enum : int {
    kYColumnNamesFieldNumber = 6,
    kXColumnNameFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kZoomRangeFieldNumber = 4,
    kPixelCountFieldNumber = 3,
  };
  // repeated string y_column_names = 6;
  int y_column_names_size() const;
  private:
  int _internal_y_column_names_size() const;
  public:
  void clear_y_column_names();
  const std::string& y_column_names(int index) const;
  std::string* mutable_y_column_names(int index);
  void set_y_column_names(int index, const std::string& value);
  void set_y_column_names(int index, std::string&& value);
  void set_y_column_names(int index, const char* value);
  void set_y_column_names(int index, const char* value, size_t size);
  std::string* add_y_column_names();
  void add_y_column_names(const std::string& value);
  void add_y_column_names(std::string&& value);
  void add_y_column_names(const char* value);
  void add_y_column_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& y_column_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_y_column_names();
  private:
  const std::string& _internal_y_column_names(int index) const;
  std::string* _internal_add_y_column_names();
  public:

  // string x_column_name = 5;
  void clear_x_column_name();
  const std::string& x_column_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_x_column_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_x_column_name();
  PROTOBUF_NODISCARD std::string* release_x_column_name();
  void set_allocated_x_column_name(std::string* x_column_name);
  private:
  const std::string& _internal_x_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_x_column_name(const std::string& value);
  std::string* _internal_mutable_x_column_name();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  private:
  bool _internal_has_source_id() const;
  public:
  void clear_source_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();
  public:
  void unsafe_arena_set_allocated_source_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  // .io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange zoom_range = 4;
  bool has_zoom_range() const;
  private:
  bool _internal_has_zoom_range() const;
  public:
  void clear_zoom_range();
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange& zoom_range() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* release_zoom_range();
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* mutable_zoom_range();
  void set_allocated_zoom_range(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* zoom_range);
  private:
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange& _internal_zoom_range() const;
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* _internal_mutable_zoom_range();
  public:
  void unsafe_arena_set_allocated_zoom_range(
      ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* zoom_range);
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* unsafe_arena_release_zoom_range();

  // int32 pixel_count = 3;
  void clear_pixel_count();
  int32_t pixel_count() const;
  void set_pixel_count(int32_t value);
  private:
  int32_t _internal_pixel_count() const;
  void _internal_set_pixel_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> y_column_names_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x_column_name_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* zoom_range_;
  int32_t pixel_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class CreateInputTableRequest_InputTableKind_InMemoryAppendOnly final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryAppendOnly) */ {
 public:
  inline CreateInputTableRequest_InputTableKind_InMemoryAppendOnly() : CreateInputTableRequest_InputTableKind_InMemoryAppendOnly(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CreateInputTableRequest_InputTableKind_InMemoryAppendOnly(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInputTableRequest_InputTableKind_InMemoryAppendOnly(const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& from);
  CreateInputTableRequest_InputTableKind_InMemoryAppendOnly(CreateInputTableRequest_InputTableKind_InMemoryAppendOnly&& from) noexcept
    : CreateInputTableRequest_InputTableKind_InMemoryAppendOnly() {
    *this = ::std::move(from);
  }

  inline CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& operator=(const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& operator=(CreateInputTableRequest_InputTableKind_InMemoryAppendOnly&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* internal_default_instance() {
    return reinterpret_cast<const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly*>(
               &_CreateInputTableRequest_InputTableKind_InMemoryAppendOnly_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& a, CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInputTableRequest_InputTableKind_InMemoryAppendOnly>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryAppendOnly";
  }
  protected:
  explicit CreateInputTableRequest_InputTableKind_InMemoryAppendOnly(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryAppendOnly)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class CreateInputTableRequest_InputTableKind_InMemoryKeyBacked final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked) */ {
 public:
  inline CreateInputTableRequest_InputTableKind_InMemoryKeyBacked() : CreateInputTableRequest_InputTableKind_InMemoryKeyBacked(nullptr) {}
  ~CreateInputTableRequest_InputTableKind_InMemoryKeyBacked() override;
  explicit PROTOBUF_CONSTEXPR CreateInputTableRequest_InputTableKind_InMemoryKeyBacked(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInputTableRequest_InputTableKind_InMemoryKeyBacked(const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& from);
  CreateInputTableRequest_InputTableKind_InMemoryKeyBacked(CreateInputTableRequest_InputTableKind_InMemoryKeyBacked&& from) noexcept
    : CreateInputTableRequest_InputTableKind_InMemoryKeyBacked() {
    *this = ::std::move(from);
  }

  inline CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& operator=(const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& operator=(CreateInputTableRequest_InputTableKind_InMemoryKeyBacked&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* internal_default_instance() {
    return reinterpret_cast<const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked*>(
               &_CreateInputTableRequest_InputTableKind_InMemoryKeyBacked_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& a, CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInputTableRequest_InputTableKind_InMemoryKeyBacked>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked";
  }
  protected:
  explicit CreateInputTableRequest_InputTableKind_InMemoryKeyBacked(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyColumnsFieldNumber = 1,
  };
  // repeated string key_columns = 1;
  int key_columns_size() const;
  private:
  int _internal_key_columns_size() const;
  public:
  void clear_key_columns();
  const std::string& key_columns(int index) const;
  std::string* mutable_key_columns(int index);
  void set_key_columns(int index, const std::string& value);
  void set_key_columns(int index, std::string&& value);
  void set_key_columns(int index, const char* value);
  void set_key_columns(int index, const char* value, size_t size);
  std::string* add_key_columns();
  void add_key_columns(const std::string& value);
  void add_key_columns(std::string&& value);
  void add_key_columns(const char* value);
  void add_key_columns(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& key_columns() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_key_columns();
  private:
  const std::string& _internal_key_columns(int index) const;
  std::string* _internal_add_key_columns();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> key_columns_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class CreateInputTableRequest_InputTableKind final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind) */ {
 public:
  inline CreateInputTableRequest_InputTableKind() : CreateInputTableRequest_InputTableKind(nullptr) {}
  ~CreateInputTableRequest_InputTableKind() override;
  explicit PROTOBUF_CONSTEXPR CreateInputTableRequest_InputTableKind(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInputTableRequest_InputTableKind(const CreateInputTableRequest_InputTableKind& from);
  CreateInputTableRequest_InputTableKind(CreateInputTableRequest_InputTableKind&& from) noexcept
    : CreateInputTableRequest_InputTableKind() {
    *this = ::std::move(from);
  }

  inline CreateInputTableRequest_InputTableKind& operator=(const CreateInputTableRequest_InputTableKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInputTableRequest_InputTableKind& operator=(CreateInputTableRequest_InputTableKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInputTableRequest_InputTableKind& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kInMemoryAppendOnly = 1,
    kInMemoryKeyBacked = 2,
    KIND_NOT_SET = 0,
  };

  static inline const CreateInputTableRequest_InputTableKind* internal_default_instance() {
    return reinterpret_cast<const CreateInputTableRequest_InputTableKind*>(
               &_CreateInputTableRequest_InputTableKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(CreateInputTableRequest_InputTableKind& a, CreateInputTableRequest_InputTableKind& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInputTableRequest_InputTableKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInputTableRequest_InputTableKind* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInputTableRequest_InputTableKind* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInputTableRequest_InputTableKind>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInputTableRequest_InputTableKind& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateInputTableRequest_InputTableKind& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInputTableRequest_InputTableKind* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind";
  }
  protected:
  explicit CreateInputTableRequest_InputTableKind(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CreateInputTableRequest_InputTableKind_InMemoryAppendOnly InMemoryAppendOnly;
  typedef CreateInputTableRequest_InputTableKind_InMemoryKeyBacked InMemoryKeyBacked;

  // accessors -------------------------------------------------------

  enum : int {
    kInMemoryAppendOnlyFieldNumber = 1,
    kInMemoryKeyBackedFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryAppendOnly in_memory_append_only = 1;
  bool has_in_memory_append_only() const;
  private:
  bool _internal_has_in_memory_append_only() const;
  public:
  void clear_in_memory_append_only();
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& in_memory_append_only() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* release_in_memory_append_only();
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* mutable_in_memory_append_only();
  void set_allocated_in_memory_append_only(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* in_memory_append_only);
  private:
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& _internal_in_memory_append_only() const;
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* _internal_mutable_in_memory_append_only();
  public:
  void unsafe_arena_set_allocated_in_memory_append_only(
      ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* in_memory_append_only);
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* unsafe_arena_release_in_memory_append_only();

  // .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked in_memory_key_backed = 2;
  bool has_in_memory_key_backed() const;
  private:
  bool _internal_has_in_memory_key_backed() const;
  public:
  void clear_in_memory_key_backed();
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& in_memory_key_backed() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* release_in_memory_key_backed();
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* mutable_in_memory_key_backed();
  void set_allocated_in_memory_key_backed(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* in_memory_key_backed);
  private:
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& _internal_in_memory_key_backed() const;
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* _internal_mutable_in_memory_key_backed();
  public:
  void unsafe_arena_set_allocated_in_memory_key_backed(
      ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* in_memory_key_backed);
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* unsafe_arena_release_in_memory_key_backed();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind)
 private:
  class _Internal;
  void set_has_in_memory_append_only();
  void set_has_in_memory_key_backed();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union KindUnion {
    constexpr KindUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* in_memory_append_only_;
    ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* in_memory_key_backed_;
  } kind_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class CreateInputTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateInputTableRequest) */ {
 public:
  inline CreateInputTableRequest() : CreateInputTableRequest(nullptr) {}
  ~CreateInputTableRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateInputTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateInputTableRequest(const CreateInputTableRequest& from);
  CreateInputTableRequest(CreateInputTableRequest&& from) noexcept
    : CreateInputTableRequest() {
    *this = ::std::move(from);
  }

  inline CreateInputTableRequest& operator=(const CreateInputTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInputTableRequest& operator=(CreateInputTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInputTableRequest& default_instance() {
    return *internal_default_instance();
  }
  enum DefinitionCase {
    kSourceTableId = 2,
    kSchema = 3,
    DEFINITION_NOT_SET = 0,
  };

  static inline const CreateInputTableRequest* internal_default_instance() {
    return reinterpret_cast<const CreateInputTableRequest*>(
               &_CreateInputTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(CreateInputTableRequest& a, CreateInputTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInputTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInputTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInputTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInputTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateInputTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateInputTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateInputTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateInputTableRequest";
  }
  protected:
  explicit CreateInputTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CreateInputTableRequest_InputTableKind InputTableKind;

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kKindFieldNumber = 4,
    kSourceTableIdFieldNumber = 2,
    kSchemaFieldNumber = 3,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind kind = 4;
  bool has_kind() const;
  private:
  bool _internal_has_kind() const;
  public:
  void clear_kind();
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind& kind() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* release_kind();
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* mutable_kind();
  void set_allocated_kind(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* kind);
  private:
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind& _internal_kind() const;
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* _internal_mutable_kind();
  public:
  void unsafe_arena_set_allocated_kind(
      ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* kind);
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* unsafe_arena_release_kind();

  // .io.deephaven.proto.backplane.grpc.TableReference source_table_id = 2;
  bool has_source_table_id() const;
  private:
  bool _internal_has_source_table_id() const;
  public:
  void clear_source_table_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_table_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_table_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_table_id();
  void set_allocated_source_table_id(::io::deephaven::proto::backplane::grpc::TableReference* source_table_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_table_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_table_id();
  public:
  void unsafe_arena_set_allocated_source_table_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* source_table_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_table_id();

  // bytes schema = 3;
  bool has_schema() const;
  private:
  bool _internal_has_schema() const;
  public:
  void clear_schema();
  const std::string& schema() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schema(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schema();
  PROTOBUF_NODISCARD std::string* release_schema();
  void set_allocated_schema(std::string* schema);
  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(const std::string& value);
  std::string* _internal_mutable_schema();
  public:

  void clear_definition();
  DefinitionCase definition_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateInputTableRequest)
 private:
  class _Internal;
  void set_has_source_table_id();
  void set_has_schema();

  inline bool has_definition() const;
  inline void clear_has_definition();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* kind_;
  union DefinitionUnion {
    constexpr DefinitionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_table_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schema_;
  } definition_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class WhereInRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.WhereInRequest) */ {
 public:
  inline WhereInRequest() : WhereInRequest(nullptr) {}
  ~WhereInRequest() override;
  explicit PROTOBUF_CONSTEXPR WhereInRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WhereInRequest(const WhereInRequest& from);
  WhereInRequest(WhereInRequest&& from) noexcept
    : WhereInRequest() {
    *this = ::std::move(from);
  }

  inline WhereInRequest& operator=(const WhereInRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WhereInRequest& operator=(WhereInRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WhereInRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WhereInRequest* internal_default_instance() {
    return reinterpret_cast<const WhereInRequest*>(
               &_WhereInRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(WhereInRequest& a, WhereInRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WhereInRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WhereInRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WhereInRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WhereInRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WhereInRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WhereInRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WhereInRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.WhereInRequest";
  }
  protected:
  explicit WhereInRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
    kInvertedFieldNumber = 4,
  };
  // repeated string columns_to_match = 5;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;
  public:
  void clear_columns_to_match();
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, size_t size);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& columns_to_match() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_columns_to_match();
  private:
  const std::string& _internal_columns_to_match(int index) const;
  std::string* _internal_add_columns_to_match();
  public:

  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  private:
  bool _internal_has_result_id() const;
  public:
  void clear_result_id();
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();
  public:
  void unsafe_arena_set_allocated_result_id(
      ::io::deephaven::proto::backplane::grpc::Ticket* result_id);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  private:
  bool _internal_has_left_id() const;
  public:
  void clear_left_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();
  public:
  void unsafe_arena_set_allocated_left_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* left_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  private:
  bool _internal_has_right_id() const;
  public:
  void clear_right_id();
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();
  public:
  void unsafe_arena_set_allocated_right_id(
      ::io::deephaven::proto::backplane::grpc::TableReference* right_id);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  // bool inverted = 4;
  void clear_inverted();
  bool inverted() const;
  void set_inverted(bool value);
  private:
  bool _internal_inverted() const;
  void _internal_set_inverted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.WhereInRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> columns_to_match_;
  ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
  ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
  bool inverted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class BatchTableRequest_Operation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation) */ {
 public:
  inline BatchTableRequest_Operation() : BatchTableRequest_Operation(nullptr) {}
  ~BatchTableRequest_Operation() override;
  explicit PROTOBUF_CONSTEXPR BatchTableRequest_Operation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchTableRequest_Operation(const BatchTableRequest_Operation& from);
  BatchTableRequest_Operation(BatchTableRequest_Operation&& from) noexcept
    : BatchTableRequest_Operation() {
    *this = ::std::move(from);
  }

  inline BatchTableRequest_Operation& operator=(const BatchTableRequest_Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchTableRequest_Operation& operator=(BatchTableRequest_Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchTableRequest_Operation& default_instance() {
    return *internal_default_instance();
  }
  enum OpCase {
    kEmptyTable = 1,
    kTimeTable = 2,
    kDropColumns = 3,
    kUpdate = 4,
    kLazyUpdate = 5,
    kView = 6,
    kUpdateView = 7,
    kSelect = 8,
    kSelectDistinct = 9,
    kFilter = 10,
    kUnstructuredFilter = 11,
    kSort = 12,
    kHead = 13,
    kTail = 14,
    kHeadBy = 15,
    kTailBy = 16,
    kUngroup = 17,
    kMerge = 18,
    kComboAggregate = 19,
    kFlatten = 21,
    kRunChartDownsample = 22,
    kCrossJoin = 23,
    kNaturalJoin = 24,
    kExactJoin = 25,
    kLeftJoin = 26,
    kAsOfJoin = 27,
    kFetchTable = 28,
    kApplyPreviewColumns = 30,
    kCreateInputTable = 31,
    kUpdateBy = 32,
    kWhereIn = 33,
    kAggregateAll = 34,
    kAggregate = 35,
    kSnapshot = 36,
    kSnapshotWhen = 37,
    kMetaTable = 38,
    kRangeJoin = 39,
    kAj = 40,
    kRaj = 41,
    OP_NOT_SET = 0,
  };

  static inline const BatchTableRequest_Operation* internal_default_instance() {
    return reinterpret_cast<const BatchTableRequest_Operation*>(
               &_BatchTableRequest_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(BatchTableRequest_Operation& a, BatchTableRequest_Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchTableRequest_Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchTableRequest_Operation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchTableRequest_Operation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchTableRequest_Operation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchTableRequest_Operation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchTableRequest_Operation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchTableRequest_Operation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation";
  }
  protected:
  explicit BatchTableRequest_Operation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmptyTableFieldNumber = 1,
    kTimeTableFieldNumber = 2,
    kDropColumnsFieldNumber = 3,
    kUpdateFieldNumber = 4,
    kLazyUpdateFieldNumber = 5,
    kViewFieldNumber = 6,
    kUpdateViewFieldNumber = 7,
    kSelectFieldNumber = 8,
    kSelectDistinctFieldNumber = 9,
    kFilterFieldNumber = 10,
    kUnstructuredFilterFieldNumber = 11,
    kSortFieldNumber = 12,
    kHeadFieldNumber = 13,
    kTailFieldNumber = 14,
    kHeadByFieldNumber = 15,
    kTailByFieldNumber = 16,
    kUngroupFieldNumber = 17,
    kMergeFieldNumber = 18,
    kComboAggregateFieldNumber = 19,
    kFlattenFieldNumber = 21,
    kRunChartDownsampleFieldNumber = 22,
    kCrossJoinFieldNumber = 23,
    kNaturalJoinFieldNumber = 24,
    kExactJoinFieldNumber = 25,
    kLeftJoinFieldNumber = 26,
    kAsOfJoinFieldNumber = 27,
    kFetchTableFieldNumber = 28,
    kApplyPreviewColumnsFieldNumber = 30,
    kCreateInputTableFieldNumber = 31,
    kUpdateByFieldNumber = 32,
    kWhereInFieldNumber = 33,
    kAggregateAllFieldNumber = 34,
    kAggregateFieldNumber = 35,
    kSnapshotFieldNumber = 36,
    kSnapshotWhenFieldNumber = 37,
    kMetaTableFieldNumber = 38,
    kRangeJoinFieldNumber = 39,
    kAjFieldNumber = 40,
    kRajFieldNumber = 41,
  };
  // .io.deephaven.proto.backplane.grpc.EmptyTableRequest empty_table = 1;
  bool has_empty_table() const;
  private:
  bool _internal_has_empty_table() const;
  public:
  void clear_empty_table();
  const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& empty_table() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* release_empty_table();
  ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* mutable_empty_table();
  void set_allocated_empty_table(::io::deephaven::proto::backplane::grpc::EmptyTableRequest* empty_table);
  private:
  const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& _internal_empty_table() const;
  ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* _internal_mutable_empty_table();
  public:
  void unsafe_arena_set_allocated_empty_table(
      ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* empty_table);
  ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* unsafe_arena_release_empty_table();

  // .io.deephaven.proto.backplane.grpc.TimeTableRequest time_table = 2;
  bool has_time_table() const;
  private:
  bool _internal_has_time_table() const;
  public:
  void clear_time_table();
  const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& time_table() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TimeTableRequest* release_time_table();
  ::io::deephaven::proto::backplane::grpc::TimeTableRequest* mutable_time_table();
  void set_allocated_time_table(::io::deephaven::proto::backplane::grpc::TimeTableRequest* time_table);
  private:
  const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& _internal_time_table() const;
  ::io::deephaven::proto::backplane::grpc::TimeTableRequest* _internal_mutable_time_table();
  public:
  void unsafe_arena_set_allocated_time_table(
      ::io::deephaven::proto::backplane::grpc::TimeTableRequest* time_table);
  ::io::deephaven::proto::backplane::grpc::TimeTableRequest* unsafe_arena_release_time_table();

  // .io.deephaven.proto.backplane.grpc.DropColumnsRequest drop_columns = 3;
  bool has_drop_columns() const;
  private:
  bool _internal_has_drop_columns() const;
  public:
  void clear_drop_columns();
  const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& drop_columns() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* release_drop_columns();
  ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* mutable_drop_columns();
  void set_allocated_drop_columns(::io::deephaven::proto::backplane::grpc::DropColumnsRequest* drop_columns);
  private:
  const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& _internal_drop_columns() const;
  ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* _internal_mutable_drop_columns();
  public:
  void unsafe_arena_set_allocated_drop_columns(
      ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* drop_columns);
  ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* unsafe_arena_release_drop_columns();

  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest update = 4;
  bool has_update() const;
  private:
  bool _internal_has_update() const;
  public:
  void clear_update();
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& update() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_update();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_update();
  void set_allocated_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update);
  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_update() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_update();
  public:
  void unsafe_arena_set_allocated_update(
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_update();

  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest lazy_update = 5;
  bool has_lazy_update() const;
  private:
  bool _internal_has_lazy_update() const;
  public:
  void clear_lazy_update();
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& lazy_update() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_lazy_update();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_lazy_update();
  void set_allocated_lazy_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* lazy_update);
  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_lazy_update() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_lazy_update();
  public:
  void unsafe_arena_set_allocated_lazy_update(
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* lazy_update);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_lazy_update();

  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest view = 6;
  bool has_view() const;
  private:
  bool _internal_has_view() const;
  public:
  void clear_view();
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& view() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_view();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_view();
  void set_allocated_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* view);
  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_view() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_view();
  public:
  void unsafe_arena_set_allocated_view(
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* view);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_view();

  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest update_view = 7;
  bool has_update_view() const;
  private:
  bool _internal_has_update_view() const;
  public:
  void clear_update_view();
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& update_view() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_update_view();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_update_view();
  void set_allocated_update_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update_view);
  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_update_view() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_update_view();
  public:
  void unsafe_arena_set_allocated_update_view(
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update_view);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_update_view();

  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest select = 8;
  bool has_select() const;
  private:
  bool _internal_has_select() const;
  public:
  void clear_select();
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& select() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_select();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_select();
  void set_allocated_select(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* select);
  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_select() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_select();
  public:
  void unsafe_arena_set_allocated_select(
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* select);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_select();

  // .io.deephaven.proto.backplane.grpc.SelectDistinctRequest select_distinct = 9;
  bool has_select_distinct() const;
  private:
  bool _internal_has_select_distinct() const;
  public:
  void clear_select_distinct();
  const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& select_distinct() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* release_select_distinct();
  ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* mutable_select_distinct();
  void set_allocated_select_distinct(::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* select_distinct);
  private:
  const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& _internal_select_distinct() const;
  ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* _internal_mutable_select_distinct();
  public:
  void unsafe_arena_set_allocated_select_distinct(
      ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* select_distinct);
  ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* unsafe_arena_release_select_distinct();

  // .io.deephaven.proto.backplane.grpc.FilterTableRequest filter = 10;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& filter() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::FilterTableRequest* release_filter();
  ::io::deephaven::proto::backplane::grpc::FilterTableRequest* mutable_filter();
  void set_allocated_filter(::io::deephaven::proto::backplane::grpc::FilterTableRequest* filter);
  private:
  const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& _internal_filter() const;
  ::io::deephaven::proto::backplane::grpc::FilterTableRequest* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::io::deephaven::proto::backplane::grpc::FilterTableRequest* filter);
  ::io::deephaven::proto::backplane::grpc::FilterTableRequest* unsafe_arena_release_filter();

  // .io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest unstructured_filter = 11;
  bool has_unstructured_filter() const;
  private:
  bool _internal_has_unstructured_filter() const;
  public:
  void clear_unstructured_filter();
  const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& unstructured_filter() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* release_unstructured_filter();
  ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* mutable_unstructured_filter();
  void set_allocated_unstructured_filter(::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* unstructured_filter);
  private:
  const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& _internal_unstructured_filter() const;
  ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* _internal_mutable_unstructured_filter();
  public:
  void unsafe_arena_set_allocated_unstructured_filter(
      ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* unstructured_filter);
  ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* unsafe_arena_release_unstructured_filter();

  // .io.deephaven.proto.backplane.grpc.SortTableRequest sort = 12;
  bool has_sort() const;
  private:
  bool _internal_has_sort() const;
  public:
  void clear_sort();
  const ::io::deephaven::proto::backplane::grpc::SortTableRequest& sort() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SortTableRequest* release_sort();
  ::io::deephaven::proto::backplane::grpc::SortTableRequest* mutable_sort();
  void set_allocated_sort(::io::deephaven::proto::backplane::grpc::SortTableRequest* sort);
  private:
  const ::io::deephaven::proto::backplane::grpc::SortTableRequest& _internal_sort() const;
  ::io::deephaven::proto::backplane::grpc::SortTableRequest* _internal_mutable_sort();
  public:
  void unsafe_arena_set_allocated_sort(
      ::io::deephaven::proto::backplane::grpc::SortTableRequest* sort);
  ::io::deephaven::proto::backplane::grpc::SortTableRequest* unsafe_arena_release_sort();

  // .io.deephaven.proto.backplane.grpc.HeadOrTailRequest head = 13;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& head() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* release_head();
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* mutable_head();
  void set_allocated_head(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* head);
  private:
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& _internal_head() const;
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* head);
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* unsafe_arena_release_head();

  // .io.deephaven.proto.backplane.grpc.HeadOrTailRequest tail = 14;
  bool has_tail() const;
  private:
  bool _internal_has_tail() const;
  public:
  void clear_tail();
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& tail() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* release_tail();
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* mutable_tail();
  void set_allocated_tail(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* tail);
  private:
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& _internal_tail() const;
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* _internal_mutable_tail();
  public:
  void unsafe_arena_set_allocated_tail(
      ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* tail);
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* unsafe_arena_release_tail();

  // .io.deephaven.proto.backplane.grpc.HeadOrTailByRequest head_by = 15;
  bool has_head_by() const;
  private:
  bool _internal_has_head_by() const;
  public:
  void clear_head_by();
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& head_by() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* release_head_by();
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* mutable_head_by();
  void set_allocated_head_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* head_by);
  private:
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& _internal_head_by() const;
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* _internal_mutable_head_by();
  public:
  void unsafe_arena_set_allocated_head_by(
      ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* head_by);
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* unsafe_arena_release_head_by();

  // .io.deephaven.proto.backplane.grpc.HeadOrTailByRequest tail_by = 16;
  bool has_tail_by() const;
  private:
  bool _internal_has_tail_by() const;
  public:
  void clear_tail_by();
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& tail_by() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* release_tail_by();
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* mutable_tail_by();
  void set_allocated_tail_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* tail_by);
  private:
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& _internal_tail_by() const;
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* _internal_mutable_tail_by();
  public:
  void unsafe_arena_set_allocated_tail_by(
      ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* tail_by);
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* unsafe_arena_release_tail_by();

  // .io.deephaven.proto.backplane.grpc.UngroupRequest ungroup = 17;
  bool has_ungroup() const;
  private:
  bool _internal_has_ungroup() const;
  public:
  void clear_ungroup();
  const ::io::deephaven::proto::backplane::grpc::UngroupRequest& ungroup() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UngroupRequest* release_ungroup();
  ::io::deephaven::proto::backplane::grpc::UngroupRequest* mutable_ungroup();
  void set_allocated_ungroup(::io::deephaven::proto::backplane::grpc::UngroupRequest* ungroup);
  private:
  const ::io::deephaven::proto::backplane::grpc::UngroupRequest& _internal_ungroup() const;
  ::io::deephaven::proto::backplane::grpc::UngroupRequest* _internal_mutable_ungroup();
  public:
  void unsafe_arena_set_allocated_ungroup(
      ::io::deephaven::proto::backplane::grpc::UngroupRequest* ungroup);
  ::io::deephaven::proto::backplane::grpc::UngroupRequest* unsafe_arena_release_ungroup();

  // .io.deephaven.proto.backplane.grpc.MergeTablesRequest merge = 18;
  bool has_merge() const;
  private:
  bool _internal_has_merge() const;
  public:
  void clear_merge();
  const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& merge() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* release_merge();
  ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* mutable_merge();
  void set_allocated_merge(::io::deephaven::proto::backplane::grpc::MergeTablesRequest* merge);
  private:
  const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& _internal_merge() const;
  ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* _internal_mutable_merge();
  public:
  void unsafe_arena_set_allocated_merge(
      ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* merge);
  ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* unsafe_arena_release_merge();

  // .io.deephaven.proto.backplane.grpc.ComboAggregateRequest combo_aggregate = 19;
  bool has_combo_aggregate() const;
  private:
  bool _internal_has_combo_aggregate() const;
  public:
  void clear_combo_aggregate();
  const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& combo_aggregate() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* release_combo_aggregate();
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* mutable_combo_aggregate();
  void set_allocated_combo_aggregate(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* combo_aggregate);
  private:
  const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& _internal_combo_aggregate() const;
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* _internal_mutable_combo_aggregate();
  public:
  void unsafe_arena_set_allocated_combo_aggregate(
      ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* combo_aggregate);
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* unsafe_arena_release_combo_aggregate();

  // .io.deephaven.proto.backplane.grpc.FlattenRequest flatten = 21;
  bool has_flatten() const;
  private:
  bool _internal_has_flatten() const;
  public:
  void clear_flatten();
  const ::io::deephaven::proto::backplane::grpc::FlattenRequest& flatten() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::FlattenRequest* release_flatten();
  ::io::deephaven::proto::backplane::grpc::FlattenRequest* mutable_flatten();
  void set_allocated_flatten(::io::deephaven::proto::backplane::grpc::FlattenRequest* flatten);
  private:
  const ::io::deephaven::proto::backplane::grpc::FlattenRequest& _internal_flatten() const;
  ::io::deephaven::proto::backplane::grpc::FlattenRequest* _internal_mutable_flatten();
  public:
  void unsafe_arena_set_allocated_flatten(
      ::io::deephaven::proto::backplane::grpc::FlattenRequest* flatten);
  ::io::deephaven::proto::backplane::grpc::FlattenRequest* unsafe_arena_release_flatten();

  // .io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest run_chart_downsample = 22;
  bool has_run_chart_downsample() const;
  private:
  bool _internal_has_run_chart_downsample() const;
  public:
  void clear_run_chart_downsample();
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& run_chart_downsample() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* release_run_chart_downsample();
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* mutable_run_chart_downsample();
  void set_allocated_run_chart_downsample(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* run_chart_downsample);
  private:
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& _internal_run_chart_downsample() const;
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* _internal_mutable_run_chart_downsample();
  public:
  void unsafe_arena_set_allocated_run_chart_downsample(
      ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* run_chart_downsample);
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* unsafe_arena_release_run_chart_downsample();

  // .io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest cross_join = 23;
  bool has_cross_join() const;
  private:
  bool _internal_has_cross_join() const;
  public:
  void clear_cross_join();
  const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& cross_join() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* release_cross_join();
  ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* mutable_cross_join();
  void set_allocated_cross_join(::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* cross_join);
  private:
  const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& _internal_cross_join() const;
  ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* _internal_mutable_cross_join();
  public:
  void unsafe_arena_set_allocated_cross_join(
      ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* cross_join);
  ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* unsafe_arena_release_cross_join();

  // .io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest natural_join = 24;
  bool has_natural_join() const;
  private:
  bool _internal_has_natural_join() const;
  public:
  void clear_natural_join();
  const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& natural_join() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* release_natural_join();
  ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* mutable_natural_join();
  void set_allocated_natural_join(::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* natural_join);
  private:
  const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& _internal_natural_join() const;
  ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* _internal_mutable_natural_join();
  public:
  void unsafe_arena_set_allocated_natural_join(
      ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* natural_join);
  ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* unsafe_arena_release_natural_join();

  // .io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest exact_join = 25;
  bool has_exact_join() const;
  private:
  bool _internal_has_exact_join() const;
  public:
  void clear_exact_join();
  const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& exact_join() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* release_exact_join();
  ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* mutable_exact_join();
  void set_allocated_exact_join(::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* exact_join);
  private:
  const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& _internal_exact_join() const;
  ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* _internal_mutable_exact_join();
  public:
  void unsafe_arena_set_allocated_exact_join(
      ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* exact_join);
  ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* unsafe_arena_release_exact_join();

  // .io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest left_join = 26;
  bool has_left_join() const;
  private:
  bool _internal_has_left_join() const;
  public:
  void clear_left_join();
  const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& left_join() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* release_left_join();
  ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* mutable_left_join();
  void set_allocated_left_join(::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* left_join);
  private:
  const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& _internal_left_join() const;
  ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* _internal_mutable_left_join();
  public:
  void unsafe_arena_set_allocated_left_join(
      ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* left_join);
  ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* unsafe_arena_release_left_join();

  // .io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest as_of_join = 27 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_as_of_join() const;
  private:
  bool _internal_has_as_of_join() const;
  public:
  PROTOBUF_DEPRECATED void clear_as_of_join();
  PROTOBUF_DEPRECATED const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& as_of_join() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* release_as_of_join();
  PROTOBUF_DEPRECATED ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* mutable_as_of_join();
  PROTOBUF_DEPRECATED void set_allocated_as_of_join(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* as_of_join);
  private:
  const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& _internal_as_of_join() const;
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* _internal_mutable_as_of_join();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_as_of_join(
      ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* as_of_join);
  PROTOBUF_DEPRECATED ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* unsafe_arena_release_as_of_join();

  // .io.deephaven.proto.backplane.grpc.FetchTableRequest fetch_table = 28;
  bool has_fetch_table() const;
  private:
  bool _internal_has_fetch_table() const;
  public:
  void clear_fetch_table();
  const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& fetch_table() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::FetchTableRequest* release_fetch_table();
  ::io::deephaven::proto::backplane::grpc::FetchTableRequest* mutable_fetch_table();
  void set_allocated_fetch_table(::io::deephaven::proto::backplane::grpc::FetchTableRequest* fetch_table);
  private:
  const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& _internal_fetch_table() const;
  ::io::deephaven::proto::backplane::grpc::FetchTableRequest* _internal_mutable_fetch_table();
  public:
  void unsafe_arena_set_allocated_fetch_table(
      ::io::deephaven::proto::backplane::grpc::FetchTableRequest* fetch_table);
  ::io::deephaven::proto::backplane::grpc::FetchTableRequest* unsafe_arena_release_fetch_table();

  // .io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest apply_preview_columns = 30;
  bool has_apply_preview_columns() const;
  private:
  bool _internal_has_apply_preview_columns() const;
  public:
  void clear_apply_preview_columns();
  const ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest& apply_preview_columns() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* release_apply_preview_columns();
  ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* mutable_apply_preview_columns();
  void set_allocated_apply_preview_columns(::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* apply_preview_columns);
  private:
  const ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest& _internal_apply_preview_columns() const;
  ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* _internal_mutable_apply_preview_columns();
  public:
  void unsafe_arena_set_allocated_apply_preview_columns(
      ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* apply_preview_columns);
  ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* unsafe_arena_release_apply_preview_columns();

  // .io.deephaven.proto.backplane.grpc.CreateInputTableRequest create_input_table = 31;
  bool has_create_input_table() const;
  private:
  bool _internal_has_create_input_table() const;
  public:
  void clear_create_input_table();
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest& create_input_table() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* release_create_input_table();
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* mutable_create_input_table();
  void set_allocated_create_input_table(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* create_input_table);
  private:
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest& _internal_create_input_table() const;
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* _internal_mutable_create_input_table();
  public:
  void unsafe_arena_set_allocated_create_input_table(
      ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* create_input_table);
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* unsafe_arena_release_create_input_table();

  // .io.deephaven.proto.backplane.grpc.UpdateByRequest update_by = 32;
  bool has_update_by() const;
  private:
  bool _internal_has_update_by() const;
  public:
  void clear_update_by();
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest& update_by() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest* release_update_by();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest* mutable_update_by();
  void set_allocated_update_by(::io::deephaven::proto::backplane::grpc::UpdateByRequest* update_by);
  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest& _internal_update_by() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest* _internal_mutable_update_by();
  public:
  void unsafe_arena_set_allocated_update_by(
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest* update_by);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest* unsafe_arena_release_update_by();

  // .io.deephaven.proto.backplane.grpc.WhereInRequest where_in = 33;
  bool has_where_in() const;
  private:
  bool _internal_has_where_in() const;
  public:
  void clear_where_in();
  const ::io::deephaven::proto::backplane::grpc::WhereInRequest& where_in() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::WhereInRequest* release_where_in();
  ::io::deephaven::proto::backplane::grpc::WhereInRequest* mutable_where_in();
  void set_allocated_where_in(::io::deephaven::proto::backplane::grpc::WhereInRequest* where_in);
  private:
  const ::io::deephaven::proto::backplane::grpc::WhereInRequest& _internal_where_in() const;
  ::io::deephaven::proto::backplane::grpc::WhereInRequest* _internal_mutable_where_in();
  public:
  void unsafe_arena_set_allocated_where_in(
      ::io::deephaven::proto::backplane::grpc::WhereInRequest* where_in);
  ::io::deephaven::proto::backplane::grpc::WhereInRequest* unsafe_arena_release_where_in();

  // .io.deephaven.proto.backplane.grpc.AggregateAllRequest aggregate_all = 34;
  bool has_aggregate_all() const;
  private:
  bool _internal_has_aggregate_all() const;
  public:
  void clear_aggregate_all();
  const ::io::deephaven::proto::backplane::grpc::AggregateAllRequest& aggregate_all() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* release_aggregate_all();
  ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* mutable_aggregate_all();
  void set_allocated_aggregate_all(::io::deephaven::proto::backplane::grpc::AggregateAllRequest* aggregate_all);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggregateAllRequest& _internal_aggregate_all() const;
  ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* _internal_mutable_aggregate_all();
  public:
  void unsafe_arena_set_allocated_aggregate_all(
      ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* aggregate_all);
  ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* unsafe_arena_release_aggregate_all();

  // .io.deephaven.proto.backplane.grpc.AggregateRequest aggregate = 35;
  bool has_aggregate() const;
  private:
  bool _internal_has_aggregate() const;
  public:
  void clear_aggregate();
  const ::io::deephaven::proto::backplane::grpc::AggregateRequest& aggregate() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggregateRequest* release_aggregate();
  ::io::deephaven::proto::backplane::grpc::AggregateRequest* mutable_aggregate();
  void set_allocated_aggregate(::io::deephaven::proto::backplane::grpc::AggregateRequest* aggregate);
  private:
  const ::io::deephaven::proto::backplane::grpc::AggregateRequest& _internal_aggregate() const;
  ::io::deephaven::proto::backplane::grpc::AggregateRequest* _internal_mutable_aggregate();
  public:
  void unsafe_arena_set_allocated_aggregate(
      ::io::deephaven::proto::backplane::grpc::AggregateRequest* aggregate);
  ::io::deephaven::proto::backplane::grpc::AggregateRequest* unsafe_arena_release_aggregate();

  // .io.deephaven.proto.backplane.grpc.SnapshotTableRequest snapshot = 36;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;
  public:
  void clear_snapshot();
  const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& snapshot() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* release_snapshot();
  ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* mutable_snapshot();
  void set_allocated_snapshot(::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* snapshot);
  private:
  const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& _internal_snapshot() const;
  ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* _internal_mutable_snapshot();
  public:
  void unsafe_arena_set_allocated_snapshot(
      ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* snapshot);
  ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* unsafe_arena_release_snapshot();

  // .io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest snapshot_when = 37;
  bool has_snapshot_when() const;
  private:
  bool _internal_has_snapshot_when() const;
  public:
  void clear_snapshot_when();
  const ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest& snapshot_when() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* release_snapshot_when();
  ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* mutable_snapshot_when();
  void set_allocated_snapshot_when(::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* snapshot_when);
  private:
  const ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest& _internal_snapshot_when() const;
  ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* _internal_mutable_snapshot_when();
  public:
  void unsafe_arena_set_allocated_snapshot_when(
      ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* snapshot_when);
  ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* unsafe_arena_release_snapshot_when();

  // .io.deephaven.proto.backplane.grpc.MetaTableRequest meta_table = 38;
  bool has_meta_table() const;
  private:
  bool _internal_has_meta_table() const;
  public:
  void clear_meta_table();
  const ::io::deephaven::proto::backplane::grpc::MetaTableRequest& meta_table() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::MetaTableRequest* release_meta_table();
  ::io::deephaven::proto::backplane::grpc::MetaTableRequest* mutable_meta_table();
  void set_allocated_meta_table(::io::deephaven::proto::backplane::grpc::MetaTableRequest* meta_table);
  private:
  const ::io::deephaven::proto::backplane::grpc::MetaTableRequest& _internal_meta_table() const;
  ::io::deephaven::proto::backplane::grpc::MetaTableRequest* _internal_mutable_meta_table();
  public:
  void unsafe_arena_set_allocated_meta_table(
      ::io::deephaven::proto::backplane::grpc::MetaTableRequest* meta_table);
  ::io::deephaven::proto::backplane::grpc::MetaTableRequest* unsafe_arena_release_meta_table();

  // .io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest range_join = 39;
  bool has_range_join() const;
  private:
  bool _internal_has_range_join() const;
  public:
  void clear_range_join();
  const ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest& range_join() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* release_range_join();
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* mutable_range_join();
  void set_allocated_range_join(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* range_join);
  private:
  const ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest& _internal_range_join() const;
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* _internal_mutable_range_join();
  public:
  void unsafe_arena_set_allocated_range_join(
      ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* range_join);
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* unsafe_arena_release_range_join();

  // .io.deephaven.proto.backplane.grpc.AjRajTablesRequest aj = 40;
  bool has_aj() const;
  private:
  bool _internal_has_aj() const;
  public:
  void clear_aj();
  const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& aj() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* release_aj();
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* mutable_aj();
  void set_allocated_aj(::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* aj);
  private:
  const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& _internal_aj() const;
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* _internal_mutable_aj();
  public:
  void unsafe_arena_set_allocated_aj(
      ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* aj);
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* unsafe_arena_release_aj();

  // .io.deephaven.proto.backplane.grpc.AjRajTablesRequest raj = 41;
  bool has_raj() const;
  private:
  bool _internal_has_raj() const;
  public:
  void clear_raj();
  const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& raj() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* release_raj();
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* mutable_raj();
  void set_allocated_raj(::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* raj);
  private:
  const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& _internal_raj() const;
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* _internal_mutable_raj();
  public:
  void unsafe_arena_set_allocated_raj(
      ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* raj);
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* unsafe_arena_release_raj();

  void clear_op();
  OpCase op_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation)
 private:
  class _Internal;
  void set_has_empty_table();
  void set_has_time_table();
  void set_has_drop_columns();
  void set_has_update();
  void set_has_lazy_update();
  void set_has_view();
  void set_has_update_view();
  void set_has_select();
  void set_has_select_distinct();
  void set_has_filter();
  void set_has_unstructured_filter();
  void set_has_sort();
  void set_has_head();
  void set_has_tail();
  void set_has_head_by();
  void set_has_tail_by();
  void set_has_ungroup();
  void set_has_merge();
  void set_has_combo_aggregate();
  void set_has_flatten();
  void set_has_run_chart_downsample();
  void set_has_cross_join();
  void set_has_natural_join();
  void set_has_exact_join();
  void set_has_left_join();
  void set_has_as_of_join();
  void set_has_fetch_table();
  void set_has_apply_preview_columns();
  void set_has_create_input_table();
  void set_has_update_by();
  void set_has_where_in();
  void set_has_aggregate_all();
  void set_has_aggregate();
  void set_has_snapshot();
  void set_has_snapshot_when();
  void set_has_meta_table();
  void set_has_range_join();
  void set_has_aj();
  void set_has_raj();

  inline bool has_op() const;
  inline void clear_has_op();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union OpUnion {
    constexpr OpUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* empty_table_;
    ::io::deephaven::proto::backplane::grpc::TimeTableRequest* time_table_;
    ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* drop_columns_;
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update_;
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* lazy_update_;
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* view_;
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update_view_;
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* select_;
    ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* select_distinct_;
    ::io::deephaven::proto::backplane::grpc::FilterTableRequest* filter_;
    ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* unstructured_filter_;
    ::io::deephaven::proto::backplane::grpc::SortTableRequest* sort_;
    ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* head_;
    ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* tail_;
    ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* head_by_;
    ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* tail_by_;
    ::io::deephaven::proto::backplane::grpc::UngroupRequest* ungroup_;
    ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* merge_;
    ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* combo_aggregate_;
    ::io::deephaven::proto::backplane::grpc::FlattenRequest* flatten_;
    ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* run_chart_downsample_;
    ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* cross_join_;
    ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* natural_join_;
    ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* exact_join_;
    ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* left_join_;
    ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* as_of_join_;
    ::io::deephaven::proto::backplane::grpc::FetchTableRequest* fetch_table_;
    ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* apply_preview_columns_;
    ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* create_input_table_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest* update_by_;
    ::io::deephaven::proto::backplane::grpc::WhereInRequest* where_in_;
    ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* aggregate_all_;
    ::io::deephaven::proto::backplane::grpc::AggregateRequest* aggregate_;
    ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* snapshot_;
    ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* snapshot_when_;
    ::io::deephaven::proto::backplane::grpc::MetaTableRequest* meta_table_;
    ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* range_join_;
    ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* aj_;
    ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* raj_;
  } op_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// -------------------------------------------------------------------

class BatchTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.BatchTableRequest) */ {
 public:
  inline BatchTableRequest() : BatchTableRequest(nullptr) {}
  ~BatchTableRequest() override;
  explicit PROTOBUF_CONSTEXPR BatchTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BatchTableRequest(const BatchTableRequest& from);
  BatchTableRequest(BatchTableRequest&& from) noexcept
    : BatchTableRequest() {
    *this = ::std::move(from);
  }

  inline BatchTableRequest& operator=(const BatchTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchTableRequest& operator=(BatchTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchTableRequest* internal_default_instance() {
    return reinterpret_cast<const BatchTableRequest*>(
               &_BatchTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(BatchTableRequest& a, BatchTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BatchTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BatchTableRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BatchTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.BatchTableRequest";
  }
  protected:
  explicit BatchTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef BatchTableRequest_Operation Operation;

  // accessors -------------------------------------------------------

  enum : int {
    kOpsFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation ops = 1;
  int ops_size() const;
  private:
  int _internal_ops_size() const;
  public:
  void clear_ops();
  ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* mutable_ops(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation >*
      mutable_ops();
  private:
  const ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation& _internal_ops(int index) const;
  ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* _internal_add_ops();
  public:
  const ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation& ops(int index) const;
  ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* add_ops();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation >&
      ops() const;

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.BatchTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation > ops_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TableReference

// .io.deephaven.proto.backplane.grpc.Ticket ticket = 1;
inline bool TableReference::_internal_has_ticket() const {
  return ref_case() == kTicket;
}
inline bool TableReference::has_ticket() const {
  return _internal_has_ticket();
}
inline void TableReference::set_has_ticket() {
  _oneof_case_[0] = kTicket;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TableReference::release_ticket() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.TableReference.ticket)
  if (_internal_has_ticket()) {
    clear_has_ref();
    ::io::deephaven::proto::backplane::grpc::Ticket* temp = ref_.ticket_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    ref_.ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& TableReference::_internal_ticket() const {
  return _internal_has_ticket()
      ? *ref_.ticket_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& TableReference::ticket() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TableReference.ticket)
  return _internal_ticket();
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TableReference::unsafe_arena_release_ticket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.TableReference.ticket)
  if (_internal_has_ticket()) {
    clear_has_ref();
    ::io::deephaven::proto::backplane::grpc::Ticket* temp = ref_.ticket_;
    ref_.ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TableReference::unsafe_arena_set_allocated_ticket(::io::deephaven::proto::backplane::grpc::Ticket* ticket) {
  clear_ref();
  if (ticket) {
    set_has_ticket();
    ref_.ticket_ = ticket;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.TableReference.ticket)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TableReference::_internal_mutable_ticket() {
  if (!_internal_has_ticket()) {
    clear_ref();
    set_has_ticket();
    ref_.ticket_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::Ticket >(GetArenaForAllocation());
  }
  return ref_.ticket_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TableReference::mutable_ticket() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_ticket();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.TableReference.ticket)
  return _msg;
}

// sint32 batch_offset = 2;
inline bool TableReference::_internal_has_batch_offset() const {
  return ref_case() == kBatchOffset;
}
inline bool TableReference::has_batch_offset() const {
  return _internal_has_batch_offset();
}
inline void TableReference::set_has_batch_offset() {
  _oneof_case_[0] = kBatchOffset;
}
inline void TableReference::clear_batch_offset() {
  if (_internal_has_batch_offset()) {
    ref_.batch_offset_ = 0;
    clear_has_ref();
  }
}
inline int32_t TableReference::_internal_batch_offset() const {
  if (_internal_has_batch_offset()) {
    return ref_.batch_offset_;
  }
  return 0;
}
inline void TableReference::_internal_set_batch_offset(int32_t value) {
  if (!_internal_has_batch_offset()) {
    clear_ref();
    set_has_batch_offset();
  }
  ref_.batch_offset_ = value;
}
inline int32_t TableReference::batch_offset() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TableReference.batch_offset)
  return _internal_batch_offset();
}
inline void TableReference::set_batch_offset(int32_t value) {
  _internal_set_batch_offset(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.TableReference.batch_offset)
}

inline bool TableReference::has_ref() const {
  return ref_case() != REF_NOT_SET;
}
inline void TableReference::clear_has_ref() {
  _oneof_case_[0] = REF_NOT_SET;
}
inline TableReference::RefCase TableReference::ref_case() const {
  return TableReference::RefCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExportedTableCreationResponse

// .io.deephaven.proto.backplane.grpc.TableReference result_id = 1;
inline bool ExportedTableCreationResponse::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool ExportedTableCreationResponse::has_result_id() const {
  return _internal_has_result_id();
}
inline void ExportedTableCreationResponse::clear_result_id() {
  if (GetArenaForAllocation() == nullptr && result_id_ != nullptr) {
    delete result_id_;
  }
  result_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExportedTableCreationResponse::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExportedTableCreationResponse::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
  return _internal_result_id();
}
inline void ExportedTableCreationResponse::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExportedTableCreationResponse::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExportedTableCreationResponse::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExportedTableCreationResponse::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExportedTableCreationResponse::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
  return _msg;
}
inline void ExportedTableCreationResponse::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::TableReference* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_id_;
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result_id);
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
}

// bool success = 2;
inline void ExportedTableCreationResponse::clear_success() {
  success_ = false;
}
inline bool ExportedTableCreationResponse::_internal_success() const {
  return success_;
}
inline bool ExportedTableCreationResponse::success() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.success)
  return _internal_success();
}
inline void ExportedTableCreationResponse::_internal_set_success(bool value) {
  
  success_ = value;
}
inline void ExportedTableCreationResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.success)
}

// string error_info = 3;
inline void ExportedTableCreationResponse::clear_error_info() {
  error_info_.ClearToEmpty();
}
inline const std::string& ExportedTableCreationResponse::error_info() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
  return _internal_error_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportedTableCreationResponse::set_error_info(ArgT0&& arg0, ArgT... args) {
 
 error_info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
}
inline std::string* ExportedTableCreationResponse::mutable_error_info() {
  std::string* _s = _internal_mutable_error_info();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
  return _s;
}
inline const std::string& ExportedTableCreationResponse::_internal_error_info() const {
  return error_info_.Get();
}
inline void ExportedTableCreationResponse::_internal_set_error_info(const std::string& value) {
  
  error_info_.Set(value, GetArenaForAllocation());
}
inline std::string* ExportedTableCreationResponse::_internal_mutable_error_info() {
  
  return error_info_.Mutable(GetArenaForAllocation());
}
inline std::string* ExportedTableCreationResponse::release_error_info() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
  return error_info_.Release();
}
inline void ExportedTableCreationResponse::set_allocated_error_info(std::string* error_info) {
  if (error_info != nullptr) {
    
  } else {
    
  }
  error_info_.SetAllocated(error_info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_info_.IsDefault()) {
    error_info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
}

// bytes schema_header = 4;
inline void ExportedTableCreationResponse::clear_schema_header() {
  schema_header_.ClearToEmpty();
}
inline const std::string& ExportedTableCreationResponse::schema_header() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
  return _internal_schema_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportedTableCreationResponse::set_schema_header(ArgT0&& arg0, ArgT... args) {
 
 schema_header_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
}
inline std::string* ExportedTableCreationResponse::mutable_schema_header() {
  std::string* _s = _internal_mutable_schema_header();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
  return _s;
}
inline const std::string& ExportedTableCreationResponse::_internal_schema_header() const {
  return schema_header_.Get();
}
inline void ExportedTableCreationResponse::_internal_set_schema_header(const std::string& value) {
  
  schema_header_.Set(value, GetArenaForAllocation());
}
inline std::string* ExportedTableCreationResponse::_internal_mutable_schema_header() {
  
  return schema_header_.Mutable(GetArenaForAllocation());
}
inline std::string* ExportedTableCreationResponse::release_schema_header() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
  return schema_header_.Release();
}
inline void ExportedTableCreationResponse::set_allocated_schema_header(std::string* schema_header) {
  if (schema_header != nullptr) {
    
  } else {
    
  }
  schema_header_.SetAllocated(schema_header, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schema_header_.IsDefault()) {
    schema_header_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
}

// bool is_static = 5;
inline void ExportedTableCreationResponse::clear_is_static() {
  is_static_ = false;
}
inline bool ExportedTableCreationResponse::_internal_is_static() const {
  return is_static_;
}
inline bool ExportedTableCreationResponse::is_static() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.is_static)
  return _internal_is_static();
}
inline void ExportedTableCreationResponse::_internal_set_is_static(bool value) {
  
  is_static_ = value;
}
inline void ExportedTableCreationResponse::set_is_static(bool value) {
  _internal_set_is_static(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.is_static)
}

// sint64 size = 6 [jstype = JS_STRING];
inline void ExportedTableCreationResponse::clear_size() {
  size_ = int64_t{0};
}
inline int64_t ExportedTableCreationResponse::_internal_size() const {
  return size_;
}
inline int64_t ExportedTableCreationResponse::size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.size)
  return _internal_size();
}
inline void ExportedTableCreationResponse::_internal_set_size(int64_t value) {
  
  size_ = value;
}
inline void ExportedTableCreationResponse::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.size)
}

// -------------------------------------------------------------------

// FetchTableRequest

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
inline bool FetchTableRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool FetchTableRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void FetchTableRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FetchTableRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FetchTableRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
  return _internal_source_id();
}
inline void FetchTableRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
  return _msg;
}
inline void FetchTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
inline bool FetchTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool FetchTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FetchTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FetchTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
  return _internal_result_id();
}
inline void FetchTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
  return _msg;
}
inline void FetchTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
}

// -------------------------------------------------------------------

// ApplyPreviewColumnsRequest

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
inline bool ApplyPreviewColumnsRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool ApplyPreviewColumnsRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void ApplyPreviewColumnsRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ApplyPreviewColumnsRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ApplyPreviewColumnsRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.source_id)
  return _internal_source_id();
}
inline void ApplyPreviewColumnsRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ApplyPreviewColumnsRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ApplyPreviewColumnsRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ApplyPreviewColumnsRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ApplyPreviewColumnsRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.source_id)
  return _msg;
}
inline void ApplyPreviewColumnsRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
inline bool ApplyPreviewColumnsRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool ApplyPreviewColumnsRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ApplyPreviewColumnsRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ApplyPreviewColumnsRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.result_id)
  return _internal_result_id();
}
inline void ApplyPreviewColumnsRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ApplyPreviewColumnsRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ApplyPreviewColumnsRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ApplyPreviewColumnsRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ApplyPreviewColumnsRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.result_id)
  return _msg;
}
inline void ApplyPreviewColumnsRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.result_id)
}

// -------------------------------------------------------------------

// ExportedTableUpdatesRequest

// -------------------------------------------------------------------

// ExportedTableUpdateMessage

// .io.deephaven.proto.backplane.grpc.Ticket export_id = 1;
inline bool ExportedTableUpdateMessage::_internal_has_export_id() const {
  return this != internal_default_instance() && export_id_ != nullptr;
}
inline bool ExportedTableUpdateMessage::has_export_id() const {
  return _internal_has_export_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExportedTableUpdateMessage::_internal_export_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = export_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExportedTableUpdateMessage::export_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
  return _internal_export_id();
}
inline void ExportedTableUpdateMessage::unsafe_arena_set_allocated_export_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* export_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(export_id_);
  }
  export_id_ = export_id;
  if (export_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExportedTableUpdateMessage::release_export_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = export_id_;
  export_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExportedTableUpdateMessage::unsafe_arena_release_export_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = export_id_;
  export_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExportedTableUpdateMessage::_internal_mutable_export_id() {
  
  if (export_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    export_id_ = p;
  }
  return export_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExportedTableUpdateMessage::mutable_export_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_export_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
  return _msg;
}
inline void ExportedTableUpdateMessage::set_allocated_export_id(::io::deephaven::proto::backplane::grpc::Ticket* export_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(export_id_);
  }
  if (export_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(export_id));
    if (message_arena != submessage_arena) {
      export_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, export_id, submessage_arena);
    }
    
  } else {
    
  }
  export_id_ = export_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
}

// sint64 size = 2 [jstype = JS_STRING];
inline void ExportedTableUpdateMessage::clear_size() {
  size_ = int64_t{0};
}
inline int64_t ExportedTableUpdateMessage::_internal_size() const {
  return size_;
}
inline int64_t ExportedTableUpdateMessage::size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.size)
  return _internal_size();
}
inline void ExportedTableUpdateMessage::_internal_set_size(int64_t value) {
  
  size_ = value;
}
inline void ExportedTableUpdateMessage::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.size)
}

// string update_failure_message = 3;
inline void ExportedTableUpdateMessage::clear_update_failure_message() {
  update_failure_message_.ClearToEmpty();
}
inline const std::string& ExportedTableUpdateMessage::update_failure_message() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
  return _internal_update_failure_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExportedTableUpdateMessage::set_update_failure_message(ArgT0&& arg0, ArgT... args) {
 
 update_failure_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
}
inline std::string* ExportedTableUpdateMessage::mutable_update_failure_message() {
  std::string* _s = _internal_mutable_update_failure_message();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
  return _s;
}
inline const std::string& ExportedTableUpdateMessage::_internal_update_failure_message() const {
  return update_failure_message_.Get();
}
inline void ExportedTableUpdateMessage::_internal_set_update_failure_message(const std::string& value) {
  
  update_failure_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ExportedTableUpdateMessage::_internal_mutable_update_failure_message() {
  
  return update_failure_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ExportedTableUpdateMessage::release_update_failure_message() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
  return update_failure_message_.Release();
}
inline void ExportedTableUpdateMessage::set_allocated_update_failure_message(std::string* update_failure_message) {
  if (update_failure_message != nullptr) {
    
  } else {
    
  }
  update_failure_message_.SetAllocated(update_failure_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (update_failure_message_.IsDefault()) {
    update_failure_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
}

// -------------------------------------------------------------------

// EmptyTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool EmptyTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool EmptyTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& EmptyTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& EmptyTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
  return _internal_result_id();
}
inline void EmptyTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* EmptyTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* EmptyTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* EmptyTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* EmptyTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
  return _msg;
}
inline void EmptyTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
}

// sint64 size = 2 [jstype = JS_STRING];
inline void EmptyTableRequest::clear_size() {
  size_ = int64_t{0};
}
inline int64_t EmptyTableRequest::_internal_size() const {
  return size_;
}
inline int64_t EmptyTableRequest::size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.EmptyTableRequest.size)
  return _internal_size();
}
inline void EmptyTableRequest::_internal_set_size(int64_t value) {
  
  size_ = value;
}
inline void EmptyTableRequest::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.EmptyTableRequest.size)
}

// -------------------------------------------------------------------

// TimeTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool TimeTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool TimeTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& TimeTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& TimeTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
  return _internal_result_id();
}
inline void TimeTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TimeTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TimeTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TimeTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TimeTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
  return _msg;
}
inline void TimeTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
}

// sint64 start_time_nanos = 2 [jstype = JS_STRING];
inline void TimeTableRequest::clear_start_time_nanos() {
  start_time_nanos_ = int64_t{0};
}
inline int64_t TimeTableRequest::_internal_start_time_nanos() const {
  return start_time_nanos_;
}
inline int64_t TimeTableRequest::start_time_nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TimeTableRequest.start_time_nanos)
  return _internal_start_time_nanos();
}
inline void TimeTableRequest::_internal_set_start_time_nanos(int64_t value) {
  
  start_time_nanos_ = value;
}
inline void TimeTableRequest::set_start_time_nanos(int64_t value) {
  _internal_set_start_time_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.TimeTableRequest.start_time_nanos)
}

// sint64 period_nanos = 3 [jstype = JS_STRING];
inline void TimeTableRequest::clear_period_nanos() {
  period_nanos_ = int64_t{0};
}
inline int64_t TimeTableRequest::_internal_period_nanos() const {
  return period_nanos_;
}
inline int64_t TimeTableRequest::period_nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TimeTableRequest.period_nanos)
  return _internal_period_nanos();
}
inline void TimeTableRequest::_internal_set_period_nanos(int64_t value) {
  
  period_nanos_ = value;
}
inline void TimeTableRequest::set_period_nanos(int64_t value) {
  _internal_set_period_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.TimeTableRequest.period_nanos)
}

// -------------------------------------------------------------------

// SelectOrUpdateRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SelectOrUpdateRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool SelectOrUpdateRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SelectOrUpdateRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SelectOrUpdateRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
  return _internal_result_id();
}
inline void SelectOrUpdateRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectOrUpdateRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectOrUpdateRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectOrUpdateRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectOrUpdateRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
  return _msg;
}
inline void SelectOrUpdateRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool SelectOrUpdateRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool SelectOrUpdateRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void SelectOrUpdateRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SelectOrUpdateRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SelectOrUpdateRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
  return _internal_source_id();
}
inline void SelectOrUpdateRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectOrUpdateRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectOrUpdateRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectOrUpdateRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectOrUpdateRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
  return _msg;
}
inline void SelectOrUpdateRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
}

// repeated string column_specs = 3;
inline int SelectOrUpdateRequest::_internal_column_specs_size() const {
  return column_specs_.size();
}
inline int SelectOrUpdateRequest::column_specs_size() const {
  return _internal_column_specs_size();
}
inline void SelectOrUpdateRequest::clear_column_specs() {
  column_specs_.Clear();
}
inline std::string* SelectOrUpdateRequest::add_column_specs() {
  std::string* _s = _internal_add_column_specs();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return _s;
}
inline const std::string& SelectOrUpdateRequest::_internal_column_specs(int index) const {
  return column_specs_.Get(index);
}
inline const std::string& SelectOrUpdateRequest::column_specs(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return _internal_column_specs(index);
}
inline std::string* SelectOrUpdateRequest::mutable_column_specs(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return column_specs_.Mutable(index);
}
inline void SelectOrUpdateRequest::set_column_specs(int index, const std::string& value) {
  column_specs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::set_column_specs(int index, std::string&& value) {
  column_specs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::set_column_specs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_specs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::set_column_specs(int index, const char* value, size_t size) {
  column_specs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline std::string* SelectOrUpdateRequest::_internal_add_column_specs() {
  return column_specs_.Add();
}
inline void SelectOrUpdateRequest::add_column_specs(const std::string& value) {
  column_specs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::add_column_specs(std::string&& value) {
  column_specs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::add_column_specs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_specs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::add_column_specs(const char* value, size_t size) {
  column_specs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SelectOrUpdateRequest::column_specs() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return column_specs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SelectOrUpdateRequest::mutable_column_specs() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return &column_specs_;
}

// -------------------------------------------------------------------

// MathContext

// sint32 precision = 1;
inline void MathContext::clear_precision() {
  precision_ = 0;
}
inline int32_t MathContext::_internal_precision() const {
  return precision_;
}
inline int32_t MathContext::precision() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MathContext.precision)
  return _internal_precision();
}
inline void MathContext::_internal_set_precision(int32_t value) {
  
  precision_ = value;
}
inline void MathContext::set_precision(int32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MathContext.precision)
}

// .io.deephaven.proto.backplane.grpc.MathContext.RoundingMode rounding_mode = 2;
inline void MathContext::clear_rounding_mode() {
  rounding_mode_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode MathContext::_internal_rounding_mode() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode >(rounding_mode_);
}
inline ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode MathContext::rounding_mode() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MathContext.rounding_mode)
  return _internal_rounding_mode();
}
inline void MathContext::_internal_set_rounding_mode(::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode value) {
  
  rounding_mode_ = value;
}
inline void MathContext::set_rounding_mode(::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode value) {
  _internal_set_rounding_mode(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MathContext.rounding_mode)
}

// -------------------------------------------------------------------

// UpdateByWindowScale_UpdateByWindowTicks

// double ticks = 1;
inline void UpdateByWindowScale_UpdateByWindowTicks::clear_ticks() {
  ticks_ = 0;
}
inline double UpdateByWindowScale_UpdateByWindowTicks::_internal_ticks() const {
  return ticks_;
}
inline double UpdateByWindowScale_UpdateByWindowTicks::ticks() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks.ticks)
  return _internal_ticks();
}
inline void UpdateByWindowScale_UpdateByWindowTicks::_internal_set_ticks(double value) {
  
  ticks_ = value;
}
inline void UpdateByWindowScale_UpdateByWindowTicks::set_ticks(double value) {
  _internal_set_ticks(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks.ticks)
}

// -------------------------------------------------------------------

// UpdateByWindowScale_UpdateByWindowTime

// string column = 1;
inline void UpdateByWindowScale_UpdateByWindowTime::clear_column() {
  column_.ClearToEmpty();
}
inline const std::string& UpdateByWindowScale_UpdateByWindowTime::column() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.column)
  return _internal_column();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateByWindowScale_UpdateByWindowTime::set_column(ArgT0&& arg0, ArgT... args) {
 
 column_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.column)
}
inline std::string* UpdateByWindowScale_UpdateByWindowTime::mutable_column() {
  std::string* _s = _internal_mutable_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.column)
  return _s;
}
inline const std::string& UpdateByWindowScale_UpdateByWindowTime::_internal_column() const {
  return column_.Get();
}
inline void UpdateByWindowScale_UpdateByWindowTime::_internal_set_column(const std::string& value) {
  
  column_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateByWindowScale_UpdateByWindowTime::_internal_mutable_column() {
  
  return column_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateByWindowScale_UpdateByWindowTime::release_column() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.column)
  return column_.Release();
}
inline void UpdateByWindowScale_UpdateByWindowTime::set_allocated_column(std::string* column) {
  if (column != nullptr) {
    
  } else {
    
  }
  column_.SetAllocated(column, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (column_.IsDefault()) {
    column_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.column)
}

// sint64 nanos = 2 [jstype = JS_STRING];
inline bool UpdateByWindowScale_UpdateByWindowTime::_internal_has_nanos() const {
  return window_case() == kNanos;
}
inline bool UpdateByWindowScale_UpdateByWindowTime::has_nanos() const {
  return _internal_has_nanos();
}
inline void UpdateByWindowScale_UpdateByWindowTime::set_has_nanos() {
  _oneof_case_[0] = kNanos;
}
inline void UpdateByWindowScale_UpdateByWindowTime::clear_nanos() {
  if (_internal_has_nanos()) {
    window_.nanos_ = int64_t{0};
    clear_has_window();
  }
}
inline int64_t UpdateByWindowScale_UpdateByWindowTime::_internal_nanos() const {
  if (_internal_has_nanos()) {
    return window_.nanos_;
  }
  return int64_t{0};
}
inline void UpdateByWindowScale_UpdateByWindowTime::_internal_set_nanos(int64_t value) {
  if (!_internal_has_nanos()) {
    clear_window();
    set_has_nanos();
  }
  window_.nanos_ = value;
}
inline int64_t UpdateByWindowScale_UpdateByWindowTime::nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.nanos)
  return _internal_nanos();
}
inline void UpdateByWindowScale_UpdateByWindowTime::set_nanos(int64_t value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.nanos)
}

// string duration_string = 3;
inline bool UpdateByWindowScale_UpdateByWindowTime::_internal_has_duration_string() const {
  return window_case() == kDurationString;
}
inline bool UpdateByWindowScale_UpdateByWindowTime::has_duration_string() const {
  return _internal_has_duration_string();
}
inline void UpdateByWindowScale_UpdateByWindowTime::set_has_duration_string() {
  _oneof_case_[0] = kDurationString;
}
inline void UpdateByWindowScale_UpdateByWindowTime::clear_duration_string() {
  if (_internal_has_duration_string()) {
    window_.duration_string_.Destroy();
    clear_has_window();
  }
}
inline const std::string& UpdateByWindowScale_UpdateByWindowTime::duration_string() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.duration_string)
  return _internal_duration_string();
}
template <typename ArgT0, typename... ArgT>
inline void UpdateByWindowScale_UpdateByWindowTime::set_duration_string(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_duration_string()) {
    clear_window();
    set_has_duration_string();
    window_.duration_string_.InitDefault();
  }
  window_.duration_string_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.duration_string)
}
inline std::string* UpdateByWindowScale_UpdateByWindowTime::mutable_duration_string() {
  std::string* _s = _internal_mutable_duration_string();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.duration_string)
  return _s;
}
inline const std::string& UpdateByWindowScale_UpdateByWindowTime::_internal_duration_string() const {
  if (_internal_has_duration_string()) {
    return window_.duration_string_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void UpdateByWindowScale_UpdateByWindowTime::_internal_set_duration_string(const std::string& value) {
  if (!_internal_has_duration_string()) {
    clear_window();
    set_has_duration_string();
    window_.duration_string_.InitDefault();
  }
  window_.duration_string_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateByWindowScale_UpdateByWindowTime::_internal_mutable_duration_string() {
  if (!_internal_has_duration_string()) {
    clear_window();
    set_has_duration_string();
    window_.duration_string_.InitDefault();
  }
  return window_.duration_string_.Mutable(      GetArenaForAllocation());
}
inline std::string* UpdateByWindowScale_UpdateByWindowTime::release_duration_string() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.duration_string)
  if (_internal_has_duration_string()) {
    clear_has_window();
    return window_.duration_string_.Release();
  } else {
    return nullptr;
  }
}
inline void UpdateByWindowScale_UpdateByWindowTime::set_allocated_duration_string(std::string* duration_string) {
  if (has_window()) {
    clear_window();
  }
  if (duration_string != nullptr) {
    set_has_duration_string();
    window_.duration_string_.InitAllocated(duration_string, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.duration_string)
}

inline bool UpdateByWindowScale_UpdateByWindowTime::has_window() const {
  return window_case() != WINDOW_NOT_SET;
}
inline void UpdateByWindowScale_UpdateByWindowTime::clear_has_window() {
  _oneof_case_[0] = WINDOW_NOT_SET;
}
inline UpdateByWindowScale_UpdateByWindowTime::WindowCase UpdateByWindowScale_UpdateByWindowTime::window_case() const {
  return UpdateByWindowScale_UpdateByWindowTime::WindowCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateByWindowScale

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks ticks = 1;
inline bool UpdateByWindowScale::_internal_has_ticks() const {
  return type_case() == kTicks;
}
inline bool UpdateByWindowScale::has_ticks() const {
  return _internal_has_ticks();
}
inline void UpdateByWindowScale::set_has_ticks() {
  _oneof_case_[0] = kTicks;
}
inline void UpdateByWindowScale::clear_ticks() {
  if (_internal_has_ticks()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.ticks_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* UpdateByWindowScale::release_ticks() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.ticks)
  if (_internal_has_ticks()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* temp = type_.ticks_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.ticks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks& UpdateByWindowScale::_internal_ticks() const {
  return _internal_has_ticks()
      ? *type_.ticks_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_UpdateByWindowTicks_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks& UpdateByWindowScale::ticks() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.ticks)
  return _internal_ticks();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* UpdateByWindowScale::unsafe_arena_release_ticks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.ticks)
  if (_internal_has_ticks()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* temp = type_.ticks_;
    type_.ticks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByWindowScale::unsafe_arena_set_allocated_ticks(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* ticks) {
  clear_type();
  if (ticks) {
    set_has_ticks();
    type_.ticks_ = ticks;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.ticks)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* UpdateByWindowScale::_internal_mutable_ticks() {
  if (!_internal_has_ticks()) {
    clear_type();
    set_has_ticks();
    type_.ticks_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks >(GetArenaForAllocation());
  }
  return type_.ticks_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* UpdateByWindowScale::mutable_ticks() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* _msg = _internal_mutable_ticks();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.ticks)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime time = 2;
inline bool UpdateByWindowScale::_internal_has_time() const {
  return type_case() == kTime;
}
inline bool UpdateByWindowScale::has_time() const {
  return _internal_has_time();
}
inline void UpdateByWindowScale::set_has_time() {
  _oneof_case_[0] = kTime;
}
inline void UpdateByWindowScale::clear_time() {
  if (_internal_has_time()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.time_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* UpdateByWindowScale::release_time() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.time)
  if (_internal_has_time()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* temp = type_.time_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime& UpdateByWindowScale::_internal_time() const {
  return _internal_has_time()
      ? *type_.time_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_UpdateByWindowTime_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime& UpdateByWindowScale::time() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.time)
  return _internal_time();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* UpdateByWindowScale::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.time)
  if (_internal_has_time()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* temp = type_.time_;
    type_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByWindowScale::unsafe_arena_set_allocated_time(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* time) {
  clear_type();
  if (time) {
    set_has_time();
    type_.time_ = time;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.time)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* UpdateByWindowScale::_internal_mutable_time() {
  if (!_internal_has_time()) {
    clear_type();
    set_has_time();
    type_.time_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime >(GetArenaForAllocation());
  }
  return type_.time_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* UpdateByWindowScale::mutable_time() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.time)
  return _msg;
}

inline bool UpdateByWindowScale::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void UpdateByWindowScale::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline UpdateByWindowScale::TypeCase UpdateByWindowScale::type_case() const {
  return UpdateByWindowScale::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateByEmOptions

// .io.deephaven.proto.backplane.grpc.BadDataBehavior on_null_value = 1;
inline void UpdateByEmOptions::clear_on_null_value() {
  on_null_value_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::_internal_on_null_value() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::BadDataBehavior >(on_null_value_);
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::on_null_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_null_value)
  return _internal_on_null_value();
}
inline void UpdateByEmOptions::_internal_set_on_null_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  
  on_null_value_ = value;
}
inline void UpdateByEmOptions::set_on_null_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  _internal_set_on_null_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_null_value)
}

// .io.deephaven.proto.backplane.grpc.BadDataBehavior on_nan_value = 2;
inline void UpdateByEmOptions::clear_on_nan_value() {
  on_nan_value_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::_internal_on_nan_value() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::BadDataBehavior >(on_nan_value_);
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::on_nan_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_nan_value)
  return _internal_on_nan_value();
}
inline void UpdateByEmOptions::_internal_set_on_nan_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  
  on_nan_value_ = value;
}
inline void UpdateByEmOptions::set_on_nan_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  _internal_set_on_nan_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_nan_value)
}

// .io.deephaven.proto.backplane.grpc.BadDataBehavior on_null_time = 3;
inline void UpdateByEmOptions::clear_on_null_time() {
  on_null_time_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::_internal_on_null_time() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::BadDataBehavior >(on_null_time_);
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::on_null_time() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_null_time)
  return _internal_on_null_time();
}
inline void UpdateByEmOptions::_internal_set_on_null_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  
  on_null_time_ = value;
}
inline void UpdateByEmOptions::set_on_null_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  _internal_set_on_null_time(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_null_time)
}

// .io.deephaven.proto.backplane.grpc.BadDataBehavior on_negative_delta_time = 4;
inline void UpdateByEmOptions::clear_on_negative_delta_time() {
  on_negative_delta_time_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::_internal_on_negative_delta_time() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::BadDataBehavior >(on_negative_delta_time_);
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::on_negative_delta_time() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_negative_delta_time)
  return _internal_on_negative_delta_time();
}
inline void UpdateByEmOptions::_internal_set_on_negative_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  
  on_negative_delta_time_ = value;
}
inline void UpdateByEmOptions::set_on_negative_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  _internal_set_on_negative_delta_time(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_negative_delta_time)
}

// .io.deephaven.proto.backplane.grpc.BadDataBehavior on_zero_delta_time = 5;
inline void UpdateByEmOptions::clear_on_zero_delta_time() {
  on_zero_delta_time_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::_internal_on_zero_delta_time() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::BadDataBehavior >(on_zero_delta_time_);
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::on_zero_delta_time() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_zero_delta_time)
  return _internal_on_zero_delta_time();
}
inline void UpdateByEmOptions::_internal_set_on_zero_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  
  on_zero_delta_time_ = value;
}
inline void UpdateByEmOptions::set_on_zero_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  _internal_set_on_zero_delta_time(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_zero_delta_time)
}

// .io.deephaven.proto.backplane.grpc.MathContext big_value_context = 6;
inline bool UpdateByEmOptions::_internal_has_big_value_context() const {
  return this != internal_default_instance() && big_value_context_ != nullptr;
}
inline bool UpdateByEmOptions::has_big_value_context() const {
  return _internal_has_big_value_context();
}
inline void UpdateByEmOptions::clear_big_value_context() {
  if (GetArenaForAllocation() == nullptr && big_value_context_ != nullptr) {
    delete big_value_context_;
  }
  big_value_context_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::MathContext& UpdateByEmOptions::_internal_big_value_context() const {
  const ::io::deephaven::proto::backplane::grpc::MathContext* p = big_value_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::MathContext&>(
      ::io::deephaven::proto::backplane::grpc::_MathContext_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MathContext& UpdateByEmOptions::big_value_context() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.big_value_context)
  return _internal_big_value_context();
}
inline void UpdateByEmOptions::unsafe_arena_set_allocated_big_value_context(
    ::io::deephaven::proto::backplane::grpc::MathContext* big_value_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(big_value_context_);
  }
  big_value_context_ = big_value_context;
  if (big_value_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.big_value_context)
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByEmOptions::release_big_value_context() {
  
  ::io::deephaven::proto::backplane::grpc::MathContext* temp = big_value_context_;
  big_value_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByEmOptions::unsafe_arena_release_big_value_context() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.big_value_context)
  
  ::io::deephaven::proto::backplane::grpc::MathContext* temp = big_value_context_;
  big_value_context_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByEmOptions::_internal_mutable_big_value_context() {
  
  if (big_value_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MathContext>(GetArenaForAllocation());
    big_value_context_ = p;
  }
  return big_value_context_;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByEmOptions::mutable_big_value_context() {
  ::io::deephaven::proto::backplane::grpc::MathContext* _msg = _internal_mutable_big_value_context();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.big_value_context)
  return _msg;
}
inline void UpdateByEmOptions::set_allocated_big_value_context(::io::deephaven::proto::backplane::grpc::MathContext* big_value_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete big_value_context_;
  }
  if (big_value_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(big_value_context);
    if (message_arena != submessage_arena) {
      big_value_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, big_value_context, submessage_arena);
    }
    
  } else {
    
  }
  big_value_context_ = big_value_context;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.big_value_context)
}

// -------------------------------------------------------------------

// UpdateByDeltaOptions

// .io.deephaven.proto.backplane.grpc.UpdateByNullBehavior null_behavior = 1;
inline void UpdateByDeltaOptions::clear_null_behavior() {
  null_behavior_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior UpdateByDeltaOptions::_internal_null_behavior() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior >(null_behavior_);
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior UpdateByDeltaOptions::null_behavior() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions.null_behavior)
  return _internal_null_behavior();
}
inline void UpdateByDeltaOptions::_internal_set_null_behavior(::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior value) {
  
  null_behavior_ = value;
}
inline void UpdateByDeltaOptions::set_null_behavior(::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior value) {
  _internal_set_null_behavior(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions.null_behavior)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOptions

// optional bool use_redirection = 1;
inline bool UpdateByRequest_UpdateByOptions::_internal_has_use_redirection() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UpdateByRequest_UpdateByOptions::has_use_redirection() const {
  return _internal_has_use_redirection();
}
inline void UpdateByRequest_UpdateByOptions::clear_use_redirection() {
  use_redirection_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool UpdateByRequest_UpdateByOptions::_internal_use_redirection() const {
  return use_redirection_;
}
inline bool UpdateByRequest_UpdateByOptions::use_redirection() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.use_redirection)
  return _internal_use_redirection();
}
inline void UpdateByRequest_UpdateByOptions::_internal_set_use_redirection(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_redirection_ = value;
}
inline void UpdateByRequest_UpdateByOptions::set_use_redirection(bool value) {
  _internal_set_use_redirection(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.use_redirection)
}

// optional int32 chunk_capacity = 2;
inline bool UpdateByRequest_UpdateByOptions::_internal_has_chunk_capacity() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UpdateByRequest_UpdateByOptions::has_chunk_capacity() const {
  return _internal_has_chunk_capacity();
}
inline void UpdateByRequest_UpdateByOptions::clear_chunk_capacity() {
  chunk_capacity_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t UpdateByRequest_UpdateByOptions::_internal_chunk_capacity() const {
  return chunk_capacity_;
}
inline int32_t UpdateByRequest_UpdateByOptions::chunk_capacity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.chunk_capacity)
  return _internal_chunk_capacity();
}
inline void UpdateByRequest_UpdateByOptions::_internal_set_chunk_capacity(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  chunk_capacity_ = value;
}
inline void UpdateByRequest_UpdateByOptions::set_chunk_capacity(int32_t value) {
  _internal_set_chunk_capacity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.chunk_capacity)
}

// optional double max_static_sparse_memory_overhead = 3;
inline bool UpdateByRequest_UpdateByOptions::_internal_has_max_static_sparse_memory_overhead() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool UpdateByRequest_UpdateByOptions::has_max_static_sparse_memory_overhead() const {
  return _internal_has_max_static_sparse_memory_overhead();
}
inline void UpdateByRequest_UpdateByOptions::clear_max_static_sparse_memory_overhead() {
  max_static_sparse_memory_overhead_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double UpdateByRequest_UpdateByOptions::_internal_max_static_sparse_memory_overhead() const {
  return max_static_sparse_memory_overhead_;
}
inline double UpdateByRequest_UpdateByOptions::max_static_sparse_memory_overhead() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.max_static_sparse_memory_overhead)
  return _internal_max_static_sparse_memory_overhead();
}
inline void UpdateByRequest_UpdateByOptions::_internal_set_max_static_sparse_memory_overhead(double value) {
  _has_bits_[0] |= 0x00000004u;
  max_static_sparse_memory_overhead_ = value;
}
inline void UpdateByRequest_UpdateByOptions::set_max_static_sparse_memory_overhead(double value) {
  _internal_set_max_static_sparse_memory_overhead(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.max_static_sparse_memory_overhead)
}

// optional int32 initial_hash_table_size = 4;
inline bool UpdateByRequest_UpdateByOptions::_internal_has_initial_hash_table_size() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool UpdateByRequest_UpdateByOptions::has_initial_hash_table_size() const {
  return _internal_has_initial_hash_table_size();
}
inline void UpdateByRequest_UpdateByOptions::clear_initial_hash_table_size() {
  initial_hash_table_size_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t UpdateByRequest_UpdateByOptions::_internal_initial_hash_table_size() const {
  return initial_hash_table_size_;
}
inline int32_t UpdateByRequest_UpdateByOptions::initial_hash_table_size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.initial_hash_table_size)
  return _internal_initial_hash_table_size();
}
inline void UpdateByRequest_UpdateByOptions::_internal_set_initial_hash_table_size(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  initial_hash_table_size_ = value;
}
inline void UpdateByRequest_UpdateByOptions::set_initial_hash_table_size(int32_t value) {
  _internal_set_initial_hash_table_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.initial_hash_table_size)
}

// optional double maximum_load_factor = 5;
inline bool UpdateByRequest_UpdateByOptions::_internal_has_maximum_load_factor() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool UpdateByRequest_UpdateByOptions::has_maximum_load_factor() const {
  return _internal_has_maximum_load_factor();
}
inline void UpdateByRequest_UpdateByOptions::clear_maximum_load_factor() {
  maximum_load_factor_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double UpdateByRequest_UpdateByOptions::_internal_maximum_load_factor() const {
  return maximum_load_factor_;
}
inline double UpdateByRequest_UpdateByOptions::maximum_load_factor() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.maximum_load_factor)
  return _internal_maximum_load_factor();
}
inline void UpdateByRequest_UpdateByOptions::_internal_set_maximum_load_factor(double value) {
  _has_bits_[0] |= 0x00000008u;
  maximum_load_factor_ = value;
}
inline void UpdateByRequest_UpdateByOptions::set_maximum_load_factor(double value) {
  _internal_set_maximum_load_factor(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.maximum_load_factor)
}

// optional double target_load_factor = 6;
inline bool UpdateByRequest_UpdateByOptions::_internal_has_target_load_factor() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool UpdateByRequest_UpdateByOptions::has_target_load_factor() const {
  return _internal_has_target_load_factor();
}
inline void UpdateByRequest_UpdateByOptions::clear_target_load_factor() {
  target_load_factor_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double UpdateByRequest_UpdateByOptions::_internal_target_load_factor() const {
  return target_load_factor_;
}
inline double UpdateByRequest_UpdateByOptions::target_load_factor() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.target_load_factor)
  return _internal_target_load_factor();
}
inline void UpdateByRequest_UpdateByOptions::_internal_set_target_load_factor(double value) {
  _has_bits_[0] |= 0x00000010u;
  target_load_factor_ = value;
}
inline void UpdateByRequest_UpdateByOptions::set_target_load_factor(double value) {
  _internal_set_target_load_factor(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.target_load_factor)
}

// .io.deephaven.proto.backplane.grpc.MathContext math_context = 7;
inline bool UpdateByRequest_UpdateByOptions::_internal_has_math_context() const {
  return this != internal_default_instance() && math_context_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOptions::has_math_context() const {
  return _internal_has_math_context();
}
inline void UpdateByRequest_UpdateByOptions::clear_math_context() {
  if (GetArenaForAllocation() == nullptr && math_context_ != nullptr) {
    delete math_context_;
  }
  math_context_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::MathContext& UpdateByRequest_UpdateByOptions::_internal_math_context() const {
  const ::io::deephaven::proto::backplane::grpc::MathContext* p = math_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::MathContext&>(
      ::io::deephaven::proto::backplane::grpc::_MathContext_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MathContext& UpdateByRequest_UpdateByOptions::math_context() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.math_context)
  return _internal_math_context();
}
inline void UpdateByRequest_UpdateByOptions::unsafe_arena_set_allocated_math_context(
    ::io::deephaven::proto::backplane::grpc::MathContext* math_context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(math_context_);
  }
  math_context_ = math_context;
  if (math_context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.math_context)
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByRequest_UpdateByOptions::release_math_context() {
  
  ::io::deephaven::proto::backplane::grpc::MathContext* temp = math_context_;
  math_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByRequest_UpdateByOptions::unsafe_arena_release_math_context() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.math_context)
  
  ::io::deephaven::proto::backplane::grpc::MathContext* temp = math_context_;
  math_context_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByRequest_UpdateByOptions::_internal_mutable_math_context() {
  
  if (math_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MathContext>(GetArenaForAllocation());
    math_context_ = p;
  }
  return math_context_;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByRequest_UpdateByOptions::mutable_math_context() {
  ::io::deephaven::proto::backplane::grpc::MathContext* _msg = _internal_mutable_math_context();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.math_context)
  return _msg;
}
inline void UpdateByRequest_UpdateByOptions::set_allocated_math_context(::io::deephaven::proto::backplane::grpc::MathContext* math_context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete math_context_;
  }
  if (math_context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(math_context);
    if (message_arena != submessage_arena) {
      math_context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, math_context, submessage_arena);
    }
    
  } else {
    
  }
  math_context_ = math_context;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.math_context)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma

// .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::has_options() const {
  return _internal_has_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::_internal_options() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByEmOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::options() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.options)
  return _internal_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::unsafe_arena_set_allocated_options(
    ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::release_options() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.options)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::mutable_options() {
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.options)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.options)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::_internal_has_window_scale() const {
  return this != internal_default_instance() && window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::has_window_scale() const {
  return _internal_has_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::clear_window_scale() {
  if (GetArenaForAllocation() == nullptr && window_scale_ != nullptr) {
    delete window_scale_;
  }
  window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::_internal_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.window_scale)
  return _internal_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::unsafe_arena_set_allocated_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_scale_);
  }
  window_scale_ = window_scale;
  if (window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::release_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = window_scale_;
  window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::unsafe_arena_release_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = window_scale_;
  window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::_internal_mutable_window_scale() {
  
  if (window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    window_scale_ = p;
  }
  return window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::mutable_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete window_scale_;
  }
  if (window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(window_scale);
    if (message_arena != submessage_arena) {
      window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_scale, submessage_arena);
    }
    
  } else {
    
  }
  window_scale_ = window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms

// .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::has_options() const {
  return _internal_has_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::_internal_options() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByEmOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::options() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.options)
  return _internal_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::unsafe_arena_set_allocated_options(
    ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::release_options() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.options)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::mutable_options() {
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.options)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.options)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::_internal_has_window_scale() const {
  return this != internal_default_instance() && window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::has_window_scale() const {
  return _internal_has_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::clear_window_scale() {
  if (GetArenaForAllocation() == nullptr && window_scale_ != nullptr) {
    delete window_scale_;
  }
  window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::_internal_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.window_scale)
  return _internal_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::unsafe_arena_set_allocated_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_scale_);
  }
  window_scale_ = window_scale;
  if (window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::release_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = window_scale_;
  window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::unsafe_arena_release_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = window_scale_;
  window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::_internal_mutable_window_scale() {
  
  if (window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    window_scale_ = p;
  }
  return window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::mutable_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete window_scale_;
  }
  if (window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(window_scale);
    if (message_arena != submessage_arena) {
      window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_scale, submessage_arena);
    }
    
  } else {
    
  }
  window_scale_ = window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin

// .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::has_options() const {
  return _internal_has_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::_internal_options() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByEmOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::options() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.options)
  return _internal_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::unsafe_arena_set_allocated_options(
    ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::release_options() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.options)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::mutable_options() {
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.options)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.options)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::_internal_has_window_scale() const {
  return this != internal_default_instance() && window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::has_window_scale() const {
  return _internal_has_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::clear_window_scale() {
  if (GetArenaForAllocation() == nullptr && window_scale_ != nullptr) {
    delete window_scale_;
  }
  window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::_internal_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.window_scale)
  return _internal_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::unsafe_arena_set_allocated_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_scale_);
  }
  window_scale_ = window_scale;
  if (window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::release_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = window_scale_;
  window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::unsafe_arena_release_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = window_scale_;
  window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::_internal_mutable_window_scale() {
  
  if (window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    window_scale_ = p;
  }
  return window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::mutable_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete window_scale_;
  }
  if (window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(window_scale);
    if (message_arena != submessage_arena) {
      window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_scale, submessage_arena);
    }
    
  } else {
    
  }
  window_scale_ = window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax

// .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::has_options() const {
  return _internal_has_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::_internal_options() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByEmOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::options() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.options)
  return _internal_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::unsafe_arena_set_allocated_options(
    ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::release_options() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.options)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::mutable_options() {
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.options)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.options)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::_internal_has_window_scale() const {
  return this != internal_default_instance() && window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::has_window_scale() const {
  return _internal_has_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::clear_window_scale() {
  if (GetArenaForAllocation() == nullptr && window_scale_ != nullptr) {
    delete window_scale_;
  }
  window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::_internal_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.window_scale)
  return _internal_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::unsafe_arena_set_allocated_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_scale_);
  }
  window_scale_ = window_scale;
  if (window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::release_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = window_scale_;
  window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::unsafe_arena_release_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = window_scale_;
  window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::_internal_mutable_window_scale() {
  
  if (window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    window_scale_ = p;
  }
  return window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::mutable_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete window_scale_;
  }
  if (window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(window_scale);
    if (message_arena != submessage_arena) {
      window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_scale, submessage_arena);
    }
    
  } else {
    
  }
  window_scale_ = window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd

// .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::has_options() const {
  return _internal_has_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::_internal_options() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByEmOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::options() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.options)
  return _internal_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::unsafe_arena_set_allocated_options(
    ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::release_options() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.options)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::mutable_options() {
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.options)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.options)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::_internal_has_window_scale() const {
  return this != internal_default_instance() && window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::has_window_scale() const {
  return _internal_has_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::clear_window_scale() {
  if (GetArenaForAllocation() == nullptr && window_scale_ != nullptr) {
    delete window_scale_;
  }
  window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::_internal_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.window_scale)
  return _internal_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::unsafe_arena_set_allocated_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(window_scale_);
  }
  window_scale_ = window_scale;
  if (window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::release_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = window_scale_;
  window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::unsafe_arena_release_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = window_scale_;
  window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::_internal_mutable_window_scale() {
  
  if (window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    window_scale_ = p;
  }
  return window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::mutable_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete window_scale_;
  }
  if (window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(window_scale);
    if (message_arena != submessage_arena) {
      window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, window_scale, submessage_arena);
    }
    
  } else {
    
  }
  window_scale_ = window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta

// .io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions options = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::has_options() const {
  return _internal_has_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::_internal_options() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByDeltaOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::options() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta.options)
  return _internal_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::unsafe_arena_set_allocated_options(
    ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::release_options() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta.options)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::mutable_options() {
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta.options)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta.options)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::_internal_has_reverse_window_scale() const {
  return this != internal_default_instance() && reverse_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::has_reverse_window_scale() const {
  return _internal_has_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::clear_reverse_window_scale() {
  if (GetArenaForAllocation() == nullptr && reverse_window_scale_ != nullptr) {
    delete reverse_window_scale_;
  }
  reverse_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::_internal_reverse_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::reverse_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::unsafe_arena_set_allocated_reverse_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reverse_window_scale_);
  }
  reverse_window_scale_ = reverse_window_scale;
  if (reverse_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::release_reverse_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::unsafe_arena_release_reverse_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.reverse_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::_internal_mutable_reverse_window_scale() {
  
  if (reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    reverse_window_scale_ = p;
  }
  return reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::mutable_reverse_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reverse_window_scale_;
  }
  if (reverse_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reverse_window_scale);
    if (message_arena != submessage_arena) {
      reverse_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reverse_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  reverse_window_scale_ = reverse_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::_internal_has_forward_window_scale() const {
  return this != internal_default_instance() && forward_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::has_forward_window_scale() const {
  return _internal_has_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::clear_forward_window_scale() {
  if (GetArenaForAllocation() == nullptr && forward_window_scale_ != nullptr) {
    delete forward_window_scale_;
  }
  forward_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::_internal_forward_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::forward_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::unsafe_arena_set_allocated_forward_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(forward_window_scale_);
  }
  forward_window_scale_ = forward_window_scale;
  if (forward_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::release_forward_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::unsafe_arena_release_forward_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.forward_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::_internal_mutable_forward_window_scale() {
  
  if (forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    forward_window_scale_ = p;
  }
  return forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::mutable_forward_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete forward_window_scale_;
  }
  if (forward_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forward_window_scale);
    if (message_arena != submessage_arena) {
      forward_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forward_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  forward_window_scale_ = forward_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::_internal_has_reverse_window_scale() const {
  return this != internal_default_instance() && reverse_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::has_reverse_window_scale() const {
  return _internal_has_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::clear_reverse_window_scale() {
  if (GetArenaForAllocation() == nullptr && reverse_window_scale_ != nullptr) {
    delete reverse_window_scale_;
  }
  reverse_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::_internal_reverse_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::reverse_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::unsafe_arena_set_allocated_reverse_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reverse_window_scale_);
  }
  reverse_window_scale_ = reverse_window_scale;
  if (reverse_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::release_reverse_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::unsafe_arena_release_reverse_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.reverse_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::_internal_mutable_reverse_window_scale() {
  
  if (reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    reverse_window_scale_ = p;
  }
  return reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::mutable_reverse_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reverse_window_scale_;
  }
  if (reverse_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reverse_window_scale);
    if (message_arena != submessage_arena) {
      reverse_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reverse_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  reverse_window_scale_ = reverse_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::_internal_has_forward_window_scale() const {
  return this != internal_default_instance() && forward_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::has_forward_window_scale() const {
  return _internal_has_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::clear_forward_window_scale() {
  if (GetArenaForAllocation() == nullptr && forward_window_scale_ != nullptr) {
    delete forward_window_scale_;
  }
  forward_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::_internal_forward_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::forward_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::unsafe_arena_set_allocated_forward_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(forward_window_scale_);
  }
  forward_window_scale_ = forward_window_scale;
  if (forward_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::release_forward_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::unsafe_arena_release_forward_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.forward_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::_internal_mutable_forward_window_scale() {
  
  if (forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    forward_window_scale_ = p;
  }
  return forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::mutable_forward_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete forward_window_scale_;
  }
  if (forward_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forward_window_scale);
    if (message_arena != submessage_arena) {
      forward_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forward_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  forward_window_scale_ = forward_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::_internal_has_reverse_window_scale() const {
  return this != internal_default_instance() && reverse_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::has_reverse_window_scale() const {
  return _internal_has_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::clear_reverse_window_scale() {
  if (GetArenaForAllocation() == nullptr && reverse_window_scale_ != nullptr) {
    delete reverse_window_scale_;
  }
  reverse_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::_internal_reverse_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::reverse_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::unsafe_arena_set_allocated_reverse_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reverse_window_scale_);
  }
  reverse_window_scale_ = reverse_window_scale;
  if (reverse_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::release_reverse_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::unsafe_arena_release_reverse_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.reverse_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::_internal_mutable_reverse_window_scale() {
  
  if (reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    reverse_window_scale_ = p;
  }
  return reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::mutable_reverse_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reverse_window_scale_;
  }
  if (reverse_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reverse_window_scale);
    if (message_arena != submessage_arena) {
      reverse_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reverse_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  reverse_window_scale_ = reverse_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::_internal_has_forward_window_scale() const {
  return this != internal_default_instance() && forward_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::has_forward_window_scale() const {
  return _internal_has_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::clear_forward_window_scale() {
  if (GetArenaForAllocation() == nullptr && forward_window_scale_ != nullptr) {
    delete forward_window_scale_;
  }
  forward_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::_internal_forward_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::forward_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::unsafe_arena_set_allocated_forward_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(forward_window_scale_);
  }
  forward_window_scale_ = forward_window_scale;
  if (forward_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::release_forward_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::unsafe_arena_release_forward_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.forward_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::_internal_mutable_forward_window_scale() {
  
  if (forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    forward_window_scale_ = p;
  }
  return forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::mutable_forward_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete forward_window_scale_;
  }
  if (forward_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forward_window_scale);
    if (message_arena != submessage_arena) {
      forward_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forward_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  forward_window_scale_ = forward_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::_internal_has_reverse_window_scale() const {
  return this != internal_default_instance() && reverse_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::has_reverse_window_scale() const {
  return _internal_has_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::clear_reverse_window_scale() {
  if (GetArenaForAllocation() == nullptr && reverse_window_scale_ != nullptr) {
    delete reverse_window_scale_;
  }
  reverse_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::_internal_reverse_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::reverse_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::unsafe_arena_set_allocated_reverse_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reverse_window_scale_);
  }
  reverse_window_scale_ = reverse_window_scale;
  if (reverse_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::release_reverse_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::unsafe_arena_release_reverse_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.reverse_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::_internal_mutable_reverse_window_scale() {
  
  if (reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    reverse_window_scale_ = p;
  }
  return reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::mutable_reverse_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reverse_window_scale_;
  }
  if (reverse_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reverse_window_scale);
    if (message_arena != submessage_arena) {
      reverse_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reverse_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  reverse_window_scale_ = reverse_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::_internal_has_forward_window_scale() const {
  return this != internal_default_instance() && forward_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::has_forward_window_scale() const {
  return _internal_has_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::clear_forward_window_scale() {
  if (GetArenaForAllocation() == nullptr && forward_window_scale_ != nullptr) {
    delete forward_window_scale_;
  }
  forward_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::_internal_forward_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::forward_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::unsafe_arena_set_allocated_forward_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(forward_window_scale_);
  }
  forward_window_scale_ = forward_window_scale;
  if (forward_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::release_forward_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::unsafe_arena_release_forward_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.forward_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::_internal_mutable_forward_window_scale() {
  
  if (forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    forward_window_scale_ = p;
  }
  return forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::mutable_forward_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete forward_window_scale_;
  }
  if (forward_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forward_window_scale);
    if (message_arena != submessage_arena) {
      forward_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forward_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  forward_window_scale_ = forward_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::_internal_has_reverse_window_scale() const {
  return this != internal_default_instance() && reverse_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::has_reverse_window_scale() const {
  return _internal_has_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::clear_reverse_window_scale() {
  if (GetArenaForAllocation() == nullptr && reverse_window_scale_ != nullptr) {
    delete reverse_window_scale_;
  }
  reverse_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::_internal_reverse_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::reverse_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::unsafe_arena_set_allocated_reverse_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reverse_window_scale_);
  }
  reverse_window_scale_ = reverse_window_scale;
  if (reverse_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::release_reverse_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::unsafe_arena_release_reverse_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.reverse_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::_internal_mutable_reverse_window_scale() {
  
  if (reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    reverse_window_scale_ = p;
  }
  return reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::mutable_reverse_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reverse_window_scale_;
  }
  if (reverse_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reverse_window_scale);
    if (message_arena != submessage_arena) {
      reverse_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reverse_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  reverse_window_scale_ = reverse_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::_internal_has_forward_window_scale() const {
  return this != internal_default_instance() && forward_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::has_forward_window_scale() const {
  return _internal_has_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::clear_forward_window_scale() {
  if (GetArenaForAllocation() == nullptr && forward_window_scale_ != nullptr) {
    delete forward_window_scale_;
  }
  forward_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::_internal_forward_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::forward_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::unsafe_arena_set_allocated_forward_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(forward_window_scale_);
  }
  forward_window_scale_ = forward_window_scale;
  if (forward_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::release_forward_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::unsafe_arena_release_forward_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.forward_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::_internal_mutable_forward_window_scale() {
  
  if (forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    forward_window_scale_ = p;
  }
  return forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::mutable_forward_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete forward_window_scale_;
  }
  if (forward_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forward_window_scale);
    if (message_arena != submessage_arena) {
      forward_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forward_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  forward_window_scale_ = forward_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::_internal_has_reverse_window_scale() const {
  return this != internal_default_instance() && reverse_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::has_reverse_window_scale() const {
  return _internal_has_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::clear_reverse_window_scale() {
  if (GetArenaForAllocation() == nullptr && reverse_window_scale_ != nullptr) {
    delete reverse_window_scale_;
  }
  reverse_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::_internal_reverse_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::reverse_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::unsafe_arena_set_allocated_reverse_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reverse_window_scale_);
  }
  reverse_window_scale_ = reverse_window_scale;
  if (reverse_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::release_reverse_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::unsafe_arena_release_reverse_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.reverse_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::_internal_mutable_reverse_window_scale() {
  
  if (reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    reverse_window_scale_ = p;
  }
  return reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::mutable_reverse_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reverse_window_scale_;
  }
  if (reverse_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reverse_window_scale);
    if (message_arena != submessage_arena) {
      reverse_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reverse_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  reverse_window_scale_ = reverse_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::_internal_has_forward_window_scale() const {
  return this != internal_default_instance() && forward_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::has_forward_window_scale() const {
  return _internal_has_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::clear_forward_window_scale() {
  if (GetArenaForAllocation() == nullptr && forward_window_scale_ != nullptr) {
    delete forward_window_scale_;
  }
  forward_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::_internal_forward_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::forward_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::unsafe_arena_set_allocated_forward_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(forward_window_scale_);
  }
  forward_window_scale_ = forward_window_scale;
  if (forward_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::release_forward_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::unsafe_arena_release_forward_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.forward_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::_internal_mutable_forward_window_scale() {
  
  if (forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    forward_window_scale_ = p;
  }
  return forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::mutable_forward_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete forward_window_scale_;
  }
  if (forward_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forward_window_scale);
    if (message_arena != submessage_arena) {
      forward_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forward_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  forward_window_scale_ = forward_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::_internal_has_reverse_window_scale() const {
  return this != internal_default_instance() && reverse_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::has_reverse_window_scale() const {
  return _internal_has_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::clear_reverse_window_scale() {
  if (GetArenaForAllocation() == nullptr && reverse_window_scale_ != nullptr) {
    delete reverse_window_scale_;
  }
  reverse_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::_internal_reverse_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::reverse_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::unsafe_arena_set_allocated_reverse_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reverse_window_scale_);
  }
  reverse_window_scale_ = reverse_window_scale;
  if (reverse_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::release_reverse_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::unsafe_arena_release_reverse_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.reverse_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::_internal_mutable_reverse_window_scale() {
  
  if (reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    reverse_window_scale_ = p;
  }
  return reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::mutable_reverse_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reverse_window_scale_;
  }
  if (reverse_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reverse_window_scale);
    if (message_arena != submessage_arena) {
      reverse_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reverse_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  reverse_window_scale_ = reverse_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::_internal_has_forward_window_scale() const {
  return this != internal_default_instance() && forward_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::has_forward_window_scale() const {
  return _internal_has_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::clear_forward_window_scale() {
  if (GetArenaForAllocation() == nullptr && forward_window_scale_ != nullptr) {
    delete forward_window_scale_;
  }
  forward_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::_internal_forward_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::forward_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::unsafe_arena_set_allocated_forward_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(forward_window_scale_);
  }
  forward_window_scale_ = forward_window_scale;
  if (forward_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::release_forward_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::unsafe_arena_release_forward_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.forward_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::_internal_mutable_forward_window_scale() {
  
  if (forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    forward_window_scale_ = p;
  }
  return forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::mutable_forward_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete forward_window_scale_;
  }
  if (forward_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forward_window_scale);
    if (message_arena != submessage_arena) {
      forward_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forward_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  forward_window_scale_ = forward_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::_internal_has_reverse_window_scale() const {
  return this != internal_default_instance() && reverse_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::has_reverse_window_scale() const {
  return _internal_has_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::clear_reverse_window_scale() {
  if (GetArenaForAllocation() == nullptr && reverse_window_scale_ != nullptr) {
    delete reverse_window_scale_;
  }
  reverse_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::_internal_reverse_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::reverse_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::unsafe_arena_set_allocated_reverse_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reverse_window_scale_);
  }
  reverse_window_scale_ = reverse_window_scale;
  if (reverse_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::release_reverse_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::unsafe_arena_release_reverse_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.reverse_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::_internal_mutable_reverse_window_scale() {
  
  if (reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    reverse_window_scale_ = p;
  }
  return reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::mutable_reverse_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reverse_window_scale_;
  }
  if (reverse_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reverse_window_scale);
    if (message_arena != submessage_arena) {
      reverse_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reverse_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  reverse_window_scale_ = reverse_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::_internal_has_forward_window_scale() const {
  return this != internal_default_instance() && forward_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::has_forward_window_scale() const {
  return _internal_has_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::clear_forward_window_scale() {
  if (GetArenaForAllocation() == nullptr && forward_window_scale_ != nullptr) {
    delete forward_window_scale_;
  }
  forward_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::_internal_forward_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::forward_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::unsafe_arena_set_allocated_forward_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(forward_window_scale_);
  }
  forward_window_scale_ = forward_window_scale;
  if (forward_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::release_forward_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::unsafe_arena_release_forward_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.forward_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::_internal_mutable_forward_window_scale() {
  
  if (forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    forward_window_scale_ = p;
  }
  return forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::mutable_forward_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete forward_window_scale_;
  }
  if (forward_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forward_window_scale);
    if (message_arena != submessage_arena) {
      forward_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forward_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  forward_window_scale_ = forward_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_has_reverse_window_scale() const {
  return this != internal_default_instance() && reverse_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::has_reverse_window_scale() const {
  return _internal_has_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::clear_reverse_window_scale() {
  if (GetArenaForAllocation() == nullptr && reverse_window_scale_ != nullptr) {
    delete reverse_window_scale_;
  }
  reverse_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_reverse_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::reverse_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::unsafe_arena_set_allocated_reverse_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reverse_window_scale_);
  }
  reverse_window_scale_ = reverse_window_scale;
  if (reverse_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::release_reverse_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::unsafe_arena_release_reverse_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.reverse_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = reverse_window_scale_;
  reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_mutable_reverse_window_scale() {
  
  if (reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    reverse_window_scale_ = p;
  }
  return reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::mutable_reverse_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reverse_window_scale_;
  }
  if (reverse_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reverse_window_scale);
    if (message_arena != submessage_arena) {
      reverse_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reverse_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  reverse_window_scale_ = reverse_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_has_forward_window_scale() const {
  return this != internal_default_instance() && forward_window_scale_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::has_forward_window_scale() const {
  return _internal_has_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::clear_forward_window_scale() {
  if (GetArenaForAllocation() == nullptr && forward_window_scale_ != nullptr) {
    delete forward_window_scale_;
  }
  forward_window_scale_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_forward_window_scale() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::forward_window_scale() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::unsafe_arena_set_allocated_forward_window_scale(
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(forward_window_scale_);
  }
  forward_window_scale_ = forward_window_scale;
  if (forward_window_scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::release_forward_window_scale() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::unsafe_arena_release_forward_window_scale() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.forward_window_scale)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = forward_window_scale_;
  forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_mutable_forward_window_scale() {
  
  if (forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArenaForAllocation());
    forward_window_scale_ = p;
  }
  return forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::mutable_forward_window_scale() {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete forward_window_scale_;
  }
  if (forward_window_scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(forward_window_scale);
    if (message_arena != submessage_arena) {
      forward_window_scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, forward_window_scale, submessage_arena);
    }
    
  } else {
    
  }
  forward_window_scale_ = forward_window_scale;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.forward_window_scale)
}

// string weight_column = 3;
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::clear_weight_column() {
  weight_column_.ClearToEmpty();
}
inline const std::string& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::weight_column() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.weight_column)
  return _internal_weight_column();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::set_weight_column(ArgT0&& arg0, ArgT... args) {
 
 weight_column_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.weight_column)
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::mutable_weight_column() {
  std::string* _s = _internal_mutable_weight_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.weight_column)
  return _s;
}
inline const std::string& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_weight_column() const {
  return weight_column_.Get();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_set_weight_column(const std::string& value) {
  
  weight_column_.Set(value, GetArenaForAllocation());
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_mutable_weight_column() {
  
  return weight_column_.Mutable(GetArenaForAllocation());
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::release_weight_column() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.weight_column)
  return weight_column_.Release();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::set_allocated_weight_column(std::string* weight_column) {
  if (weight_column != nullptr) {
    
  } else {
    
  }
  weight_column_.SetAllocated(weight_column, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (weight_column_.IsDefault()) {
    weight_column_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.weight_column)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeSum sum = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_sum() const {
  return type_case() == kSum;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_sum() const {
  return _internal_has_sum();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_sum() {
  _oneof_case_[0] = kSum;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_sum() {
  if (_internal_has_sum()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.sum_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_sum() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.sum)
  if (_internal_has_sum()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* temp = type_.sum_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_sum() const {
  return _internal_has_sum()
      ? *type_.sum_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::sum() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.sum)
  return _internal_sum();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.sum)
  if (_internal_has_sum()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* temp = type_.sum_;
    type_.sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_sum(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* sum) {
  clear_type();
  if (sum) {
    set_has_sum();
    type_.sum_ = sum;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.sum)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_sum() {
  if (!_internal_has_sum()) {
    clear_type();
    set_has_sum();
    type_.sum_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum >(GetArenaForAllocation());
  }
  return type_.sum_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_sum() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* _msg = _internal_mutable_sum();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.sum)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMin min = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_min() const {
  return type_case() == kMin;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_min() const {
  return _internal_has_min();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_min() {
  _oneof_case_[0] = kMin;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_min() {
  if (_internal_has_min()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.min_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_min() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.min)
  if (_internal_has_min()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* temp = type_.min_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_min() const {
  return _internal_has_min()
      ? *type_.min_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::min() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.min)
  return _internal_min();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_min() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.min)
  if (_internal_has_min()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* temp = type_.min_;
    type_.min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* min) {
  clear_type();
  if (min) {
    set_has_min();
    type_.min_ = min;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.min)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_min() {
  if (!_internal_has_min()) {
    clear_type();
    set_has_min();
    type_.min_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin >(GetArenaForAllocation());
  }
  return type_.min_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_min() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.min)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMax max = 3;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_max() const {
  return type_case() == kMax;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_max() const {
  return _internal_has_max();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_max() {
  _oneof_case_[0] = kMax;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_max() {
  if (_internal_has_max()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.max_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_max() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.max)
  if (_internal_has_max()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* temp = type_.max_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_max() const {
  return _internal_has_max()
      ? *type_.max_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::max() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.max)
  return _internal_max();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_max() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.max)
  if (_internal_has_max()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* temp = type_.max_;
    type_.max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* max) {
  clear_type();
  if (max) {
    set_has_max();
    type_.max_ = max;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.max)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_max() {
  if (!_internal_has_max()) {
    clear_type();
    set_has_max();
    type_.max_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax >(GetArenaForAllocation());
  }
  return type_.max_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_max() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.max)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeProduct product = 4;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_product() const {
  return type_case() == kProduct;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_product() const {
  return _internal_has_product();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_product() {
  _oneof_case_[0] = kProduct;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_product() {
  if (_internal_has_product()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.product_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_product() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.product)
  if (_internal_has_product()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* temp = type_.product_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_product() const {
  return _internal_has_product()
      ? *type_.product_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::product() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.product)
  return _internal_product();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_product() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.product)
  if (_internal_has_product()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* temp = type_.product_;
    type_.product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_product(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* product) {
  clear_type();
  if (product) {
    set_has_product();
    type_.product_ = product;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.product)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_product() {
  if (!_internal_has_product()) {
    clear_type();
    set_has_product();
    type_.product_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct >(GetArenaForAllocation());
  }
  return type_.product_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_product() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.product)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByFill fill = 5;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_fill() const {
  return type_case() == kFill;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_fill() const {
  return _internal_has_fill();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_fill() {
  _oneof_case_[0] = kFill;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_fill() {
  if (_internal_has_fill()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.fill_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_fill() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.fill)
  if (_internal_has_fill()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* temp = type_.fill_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.fill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_fill() const {
  return _internal_has_fill()
      ? *type_.fill_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::fill() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.fill)
  return _internal_fill();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_fill() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.fill)
  if (_internal_has_fill()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* temp = type_.fill_;
    type_.fill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_fill(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* fill) {
  clear_type();
  if (fill) {
    set_has_fill();
    type_.fill_ = fill;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.fill)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_fill() {
  if (!_internal_has_fill()) {
    clear_type();
    set_has_fill();
    type_.fill_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill >(GetArenaForAllocation());
  }
  return type_.fill_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_fill() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* _msg = _internal_mutable_fill();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.fill)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma ema = 6;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_ema() const {
  return type_case() == kEma;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_ema() const {
  return _internal_has_ema();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_ema() {
  _oneof_case_[0] = kEma;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_ema() {
  if (_internal_has_ema()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.ema_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_ema() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ema)
  if (_internal_has_ema()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* temp = type_.ema_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.ema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_ema() const {
  return _internal_has_ema()
      ? *type_.ema_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::ema() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ema)
  return _internal_ema();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_ema() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ema)
  if (_internal_has_ema()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* temp = type_.ema_;
    type_.ema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_ema(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* ema) {
  clear_type();
  if (ema) {
    set_has_ema();
    type_.ema_ = ema;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ema)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_ema() {
  if (!_internal_has_ema()) {
    clear_type();
    set_has_ema();
    type_.ema_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma >(GetArenaForAllocation());
  }
  return type_.ema_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_ema() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* _msg = _internal_mutable_ema();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ema)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum rolling_sum = 7;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_sum() const {
  return type_case() == kRollingSum;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_sum() const {
  return _internal_has_rolling_sum();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_sum() {
  _oneof_case_[0] = kRollingSum;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_sum() {
  if (_internal_has_rolling_sum()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.rolling_sum_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_sum() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_sum)
  if (_internal_has_rolling_sum()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* temp = type_.rolling_sum_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.rolling_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_sum() const {
  return _internal_has_rolling_sum()
      ? *type_.rolling_sum_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_sum() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_sum)
  return _internal_rolling_sum();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_sum)
  if (_internal_has_rolling_sum()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* temp = type_.rolling_sum_;
    type_.rolling_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_sum(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* rolling_sum) {
  clear_type();
  if (rolling_sum) {
    set_has_rolling_sum();
    type_.rolling_sum_ = rolling_sum;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_sum)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_sum() {
  if (!_internal_has_rolling_sum()) {
    clear_type();
    set_has_rolling_sum();
    type_.rolling_sum_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum >(GetArenaForAllocation());
  }
  return type_.rolling_sum_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_sum() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* _msg = _internal_mutable_rolling_sum();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_sum)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup rolling_group = 8;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_group() const {
  return type_case() == kRollingGroup;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_group() const {
  return _internal_has_rolling_group();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_group() {
  _oneof_case_[0] = kRollingGroup;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_group() {
  if (_internal_has_rolling_group()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.rolling_group_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_group() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_group)
  if (_internal_has_rolling_group()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* temp = type_.rolling_group_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.rolling_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_group() const {
  return _internal_has_rolling_group()
      ? *type_.rolling_group_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_group() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_group)
  return _internal_rolling_group();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_group)
  if (_internal_has_rolling_group()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* temp = type_.rolling_group_;
    type_.rolling_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_group(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* rolling_group) {
  clear_type();
  if (rolling_group) {
    set_has_rolling_group();
    type_.rolling_group_ = rolling_group;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_group)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_group() {
  if (!_internal_has_rolling_group()) {
    clear_type();
    set_has_rolling_group();
    type_.rolling_group_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup >(GetArenaForAllocation());
  }
  return type_.rolling_group_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_group() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* _msg = _internal_mutable_rolling_group();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_group)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg rolling_avg = 9;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_avg() const {
  return type_case() == kRollingAvg;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_avg() const {
  return _internal_has_rolling_avg();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_avg() {
  _oneof_case_[0] = kRollingAvg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_avg() {
  if (_internal_has_rolling_avg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.rolling_avg_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_avg() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_avg)
  if (_internal_has_rolling_avg()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* temp = type_.rolling_avg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.rolling_avg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_avg() const {
  return _internal_has_rolling_avg()
      ? *type_.rolling_avg_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_avg() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_avg)
  return _internal_rolling_avg();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_avg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_avg)
  if (_internal_has_rolling_avg()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* temp = type_.rolling_avg_;
    type_.rolling_avg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_avg(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* rolling_avg) {
  clear_type();
  if (rolling_avg) {
    set_has_rolling_avg();
    type_.rolling_avg_ = rolling_avg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_avg)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_avg() {
  if (!_internal_has_rolling_avg()) {
    clear_type();
    set_has_rolling_avg();
    type_.rolling_avg_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg >(GetArenaForAllocation());
  }
  return type_.rolling_avg_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_avg() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* _msg = _internal_mutable_rolling_avg();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_avg)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin rolling_min = 10;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_min() const {
  return type_case() == kRollingMin;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_min() const {
  return _internal_has_rolling_min();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_min() {
  _oneof_case_[0] = kRollingMin;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_min() {
  if (_internal_has_rolling_min()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.rolling_min_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_min() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_min)
  if (_internal_has_rolling_min()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* temp = type_.rolling_min_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.rolling_min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_min() const {
  return _internal_has_rolling_min()
      ? *type_.rolling_min_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_min() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_min)
  return _internal_rolling_min();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_min() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_min)
  if (_internal_has_rolling_min()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* temp = type_.rolling_min_;
    type_.rolling_min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* rolling_min) {
  clear_type();
  if (rolling_min) {
    set_has_rolling_min();
    type_.rolling_min_ = rolling_min;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_min)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_min() {
  if (!_internal_has_rolling_min()) {
    clear_type();
    set_has_rolling_min();
    type_.rolling_min_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin >(GetArenaForAllocation());
  }
  return type_.rolling_min_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_min() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* _msg = _internal_mutable_rolling_min();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_min)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax rolling_max = 11;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_max() const {
  return type_case() == kRollingMax;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_max() const {
  return _internal_has_rolling_max();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_max() {
  _oneof_case_[0] = kRollingMax;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_max() {
  if (_internal_has_rolling_max()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.rolling_max_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_max() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_max)
  if (_internal_has_rolling_max()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* temp = type_.rolling_max_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.rolling_max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_max() const {
  return _internal_has_rolling_max()
      ? *type_.rolling_max_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_max() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_max)
  return _internal_rolling_max();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_max() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_max)
  if (_internal_has_rolling_max()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* temp = type_.rolling_max_;
    type_.rolling_max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* rolling_max) {
  clear_type();
  if (rolling_max) {
    set_has_rolling_max();
    type_.rolling_max_ = rolling_max;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_max)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_max() {
  if (!_internal_has_rolling_max()) {
    clear_type();
    set_has_rolling_max();
    type_.rolling_max_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax >(GetArenaForAllocation());
  }
  return type_.rolling_max_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_max() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* _msg = _internal_mutable_rolling_max();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_max)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct rolling_product = 12;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_product() const {
  return type_case() == kRollingProduct;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_product() const {
  return _internal_has_rolling_product();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_product() {
  _oneof_case_[0] = kRollingProduct;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_product() {
  if (_internal_has_rolling_product()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.rolling_product_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_product() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_product)
  if (_internal_has_rolling_product()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* temp = type_.rolling_product_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.rolling_product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_product() const {
  return _internal_has_rolling_product()
      ? *type_.rolling_product_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_product() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_product)
  return _internal_rolling_product();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_product() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_product)
  if (_internal_has_rolling_product()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* temp = type_.rolling_product_;
    type_.rolling_product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_product(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* rolling_product) {
  clear_type();
  if (rolling_product) {
    set_has_rolling_product();
    type_.rolling_product_ = rolling_product;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_product)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_product() {
  if (!_internal_has_rolling_product()) {
    clear_type();
    set_has_rolling_product();
    type_.rolling_product_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct >(GetArenaForAllocation());
  }
  return type_.rolling_product_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_product() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* _msg = _internal_mutable_rolling_product();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_product)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta delta = 13;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_delta() const {
  return type_case() == kDelta;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_delta() const {
  return _internal_has_delta();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_delta() {
  _oneof_case_[0] = kDelta;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_delta() {
  if (_internal_has_delta()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.delta_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_delta() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.delta)
  if (_internal_has_delta()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* temp = type_.delta_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.delta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_delta() const {
  return _internal_has_delta()
      ? *type_.delta_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::delta() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.delta)
  return _internal_delta();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_delta() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.delta)
  if (_internal_has_delta()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* temp = type_.delta_;
    type_.delta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_delta(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* delta) {
  clear_type();
  if (delta) {
    set_has_delta();
    type_.delta_ = delta;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.delta)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_delta() {
  if (!_internal_has_delta()) {
    clear_type();
    set_has_delta();
    type_.delta_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta >(GetArenaForAllocation());
  }
  return type_.delta_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_delta() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* _msg = _internal_mutable_delta();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.delta)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms ems = 14;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_ems() const {
  return type_case() == kEms;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_ems() const {
  return _internal_has_ems();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_ems() {
  _oneof_case_[0] = kEms;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_ems() {
  if (_internal_has_ems()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.ems_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_ems() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ems)
  if (_internal_has_ems()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* temp = type_.ems_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.ems_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_ems() const {
  return _internal_has_ems()
      ? *type_.ems_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::ems() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ems)
  return _internal_ems();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_ems() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ems)
  if (_internal_has_ems()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* temp = type_.ems_;
    type_.ems_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_ems(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* ems) {
  clear_type();
  if (ems) {
    set_has_ems();
    type_.ems_ = ems;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ems)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_ems() {
  if (!_internal_has_ems()) {
    clear_type();
    set_has_ems();
    type_.ems_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms >(GetArenaForAllocation());
  }
  return type_.ems_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_ems() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* _msg = _internal_mutable_ems();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ems)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin em_min = 15;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_em_min() const {
  return type_case() == kEmMin;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_em_min() const {
  return _internal_has_em_min();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_em_min() {
  _oneof_case_[0] = kEmMin;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_em_min() {
  if (_internal_has_em_min()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.em_min_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_em_min() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_min)
  if (_internal_has_em_min()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* temp = type_.em_min_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.em_min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_em_min() const {
  return _internal_has_em_min()
      ? *type_.em_min_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::em_min() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_min)
  return _internal_em_min();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_em_min() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_min)
  if (_internal_has_em_min()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* temp = type_.em_min_;
    type_.em_min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_em_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* em_min) {
  clear_type();
  if (em_min) {
    set_has_em_min();
    type_.em_min_ = em_min;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_min)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_em_min() {
  if (!_internal_has_em_min()) {
    clear_type();
    set_has_em_min();
    type_.em_min_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin >(GetArenaForAllocation());
  }
  return type_.em_min_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_em_min() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* _msg = _internal_mutable_em_min();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_min)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax em_max = 16;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_em_max() const {
  return type_case() == kEmMax;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_em_max() const {
  return _internal_has_em_max();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_em_max() {
  _oneof_case_[0] = kEmMax;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_em_max() {
  if (_internal_has_em_max()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.em_max_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_em_max() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_max)
  if (_internal_has_em_max()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* temp = type_.em_max_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.em_max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_em_max() const {
  return _internal_has_em_max()
      ? *type_.em_max_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::em_max() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_max)
  return _internal_em_max();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_em_max() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_max)
  if (_internal_has_em_max()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* temp = type_.em_max_;
    type_.em_max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_em_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* em_max) {
  clear_type();
  if (em_max) {
    set_has_em_max();
    type_.em_max_ = em_max;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_max)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_em_max() {
  if (!_internal_has_em_max()) {
    clear_type();
    set_has_em_max();
    type_.em_max_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax >(GetArenaForAllocation());
  }
  return type_.em_max_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_em_max() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* _msg = _internal_mutable_em_max();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_max)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd em_std = 17;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_em_std() const {
  return type_case() == kEmStd;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_em_std() const {
  return _internal_has_em_std();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_em_std() {
  _oneof_case_[0] = kEmStd;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_em_std() {
  if (_internal_has_em_std()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.em_std_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_em_std() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_std)
  if (_internal_has_em_std()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* temp = type_.em_std_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.em_std_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_em_std() const {
  return _internal_has_em_std()
      ? *type_.em_std_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::em_std() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_std)
  return _internal_em_std();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_em_std() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_std)
  if (_internal_has_em_std()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* temp = type_.em_std_;
    type_.em_std_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_em_std(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* em_std) {
  clear_type();
  if (em_std) {
    set_has_em_std();
    type_.em_std_ = em_std;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_std)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_em_std() {
  if (!_internal_has_em_std()) {
    clear_type();
    set_has_em_std();
    type_.em_std_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd >(GetArenaForAllocation());
  }
  return type_.em_std_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_em_std() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* _msg = _internal_mutable_em_std();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_std)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount rolling_count = 18;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_count() const {
  return type_case() == kRollingCount;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_count() const {
  return _internal_has_rolling_count();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_count() {
  _oneof_case_[0] = kRollingCount;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_count() {
  if (_internal_has_rolling_count()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.rolling_count_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_count() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_count)
  if (_internal_has_rolling_count()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* temp = type_.rolling_count_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.rolling_count_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_count() const {
  return _internal_has_rolling_count()
      ? *type_.rolling_count_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_count() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_count)
  return _internal_rolling_count();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_count() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_count)
  if (_internal_has_rolling_count()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* temp = type_.rolling_count_;
    type_.rolling_count_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_count(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* rolling_count) {
  clear_type();
  if (rolling_count) {
    set_has_rolling_count();
    type_.rolling_count_ = rolling_count;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_count)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_count() {
  if (!_internal_has_rolling_count()) {
    clear_type();
    set_has_rolling_count();
    type_.rolling_count_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount >(GetArenaForAllocation());
  }
  return type_.rolling_count_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_count() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* _msg = _internal_mutable_rolling_count();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_count)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd rolling_std = 19;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_std() const {
  return type_case() == kRollingStd;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_std() const {
  return _internal_has_rolling_std();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_std() {
  _oneof_case_[0] = kRollingStd;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_std() {
  if (_internal_has_rolling_std()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.rolling_std_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_std() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_std)
  if (_internal_has_rolling_std()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* temp = type_.rolling_std_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.rolling_std_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_std() const {
  return _internal_has_rolling_std()
      ? *type_.rolling_std_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_std() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_std)
  return _internal_rolling_std();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_std() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_std)
  if (_internal_has_rolling_std()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* temp = type_.rolling_std_;
    type_.rolling_std_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_std(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* rolling_std) {
  clear_type();
  if (rolling_std) {
    set_has_rolling_std();
    type_.rolling_std_ = rolling_std;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_std)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_std() {
  if (!_internal_has_rolling_std()) {
    clear_type();
    set_has_rolling_std();
    type_.rolling_std_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd >(GetArenaForAllocation());
  }
  return type_.rolling_std_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_std() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* _msg = _internal_mutable_rolling_std();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_std)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg rolling_wavg = 20;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_wavg() const {
  return type_case() == kRollingWavg;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_wavg() const {
  return _internal_has_rolling_wavg();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_wavg() {
  _oneof_case_[0] = kRollingWavg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_wavg() {
  if (_internal_has_rolling_wavg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.rolling_wavg_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_wavg() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_wavg)
  if (_internal_has_rolling_wavg()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* temp = type_.rolling_wavg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.rolling_wavg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_wavg() const {
  return _internal_has_rolling_wavg()
      ? *type_.rolling_wavg_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_wavg() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_wavg)
  return _internal_rolling_wavg();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_wavg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_wavg)
  if (_internal_has_rolling_wavg()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* temp = type_.rolling_wavg_;
    type_.rolling_wavg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_wavg(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* rolling_wavg) {
  clear_type();
  if (rolling_wavg) {
    set_has_rolling_wavg();
    type_.rolling_wavg_ = rolling_wavg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_wavg)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_wavg() {
  if (!_internal_has_rolling_wavg()) {
    clear_type();
    set_has_rolling_wavg();
    type_.rolling_wavg_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg >(GetArenaForAllocation());
  }
  return type_.rolling_wavg_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_wavg() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* _msg = _internal_mutable_rolling_wavg();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_wavg)
  return _msg;
}

inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::TypeCase UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::type_case() const {
  return UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec spec = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn::has_spec() const {
  return _internal_has_spec();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& UpdateByRequest_UpdateByOperation_UpdateByColumn::_internal_spec() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& UpdateByRequest_UpdateByOperation_UpdateByColumn::spec() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.spec)
  return _internal_spec();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::unsafe_arena_set_allocated_spec(
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.spec)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* UpdateByRequest_UpdateByOperation_UpdateByColumn::release_spec() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* UpdateByRequest_UpdateByOperation_UpdateByColumn::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.spec)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* UpdateByRequest_UpdateByOperation_UpdateByColumn::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* UpdateByRequest_UpdateByOperation_UpdateByColumn::mutable_spec() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.spec)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::set_allocated_spec(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.spec)
}

// repeated string match_pairs = 2;
inline int UpdateByRequest_UpdateByOperation_UpdateByColumn::_internal_match_pairs_size() const {
  return match_pairs_.size();
}
inline int UpdateByRequest_UpdateByOperation_UpdateByColumn::match_pairs_size() const {
  return _internal_match_pairs_size();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::clear_match_pairs() {
  match_pairs_.Clear();
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn::add_match_pairs() {
  std::string* _s = _internal_add_match_pairs();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
  return _s;
}
inline const std::string& UpdateByRequest_UpdateByOperation_UpdateByColumn::_internal_match_pairs(int index) const {
  return match_pairs_.Get(index);
}
inline const std::string& UpdateByRequest_UpdateByOperation_UpdateByColumn::match_pairs(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
  return _internal_match_pairs(index);
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn::mutable_match_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
  return match_pairs_.Mutable(index);
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::set_match_pairs(int index, const std::string& value) {
  match_pairs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::set_match_pairs(int index, std::string&& value) {
  match_pairs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::set_match_pairs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  match_pairs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::set_match_pairs(int index, const char* value, size_t size) {
  match_pairs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn::_internal_add_match_pairs() {
  return match_pairs_.Add();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::add_match_pairs(const std::string& value) {
  match_pairs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::add_match_pairs(std::string&& value) {
  match_pairs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::add_match_pairs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  match_pairs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::add_match_pairs(const char* value, size_t size) {
  match_pairs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateByRequest_UpdateByOperation_UpdateByColumn::match_pairs() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
  return match_pairs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateByRequest_UpdateByOperation_UpdateByColumn::mutable_match_pairs() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
  return &match_pairs_;
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn column = 1;
inline bool UpdateByRequest_UpdateByOperation::_internal_has_column() const {
  return type_case() == kColumn;
}
inline bool UpdateByRequest_UpdateByOperation::has_column() const {
  return _internal_has_column();
}
inline void UpdateByRequest_UpdateByOperation::set_has_column() {
  _oneof_case_[0] = kColumn;
}
inline void UpdateByRequest_UpdateByOperation::clear_column() {
  if (_internal_has_column()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.column_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* UpdateByRequest_UpdateByOperation::release_column() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.column)
  if (_internal_has_column()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* temp = type_.column_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.column_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn& UpdateByRequest_UpdateByOperation::_internal_column() const {
  return _internal_has_column()
      ? *type_.column_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn& UpdateByRequest_UpdateByOperation::column() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.column)
  return _internal_column();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* UpdateByRequest_UpdateByOperation::unsafe_arena_release_column() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.column)
  if (_internal_has_column()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* temp = type_.column_;
    type_.column_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation::unsafe_arena_set_allocated_column(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* column) {
  clear_type();
  if (column) {
    set_has_column();
    type_.column_ = column;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.column)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* UpdateByRequest_UpdateByOperation::_internal_mutable_column() {
  if (!_internal_has_column()) {
    clear_type();
    set_has_column();
    type_.column_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn >(GetArenaForAllocation());
  }
  return type_.column_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* UpdateByRequest_UpdateByOperation::mutable_column() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* _msg = _internal_mutable_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.column)
  return _msg;
}

inline bool UpdateByRequest_UpdateByOperation::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void UpdateByRequest_UpdateByOperation::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline UpdateByRequest_UpdateByOperation::TypeCase UpdateByRequest_UpdateByOperation::type_case() const {
  return UpdateByRequest_UpdateByOperation::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateByRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool UpdateByRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool UpdateByRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UpdateByRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UpdateByRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.result_id)
  return _internal_result_id();
}
inline void UpdateByRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UpdateByRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UpdateByRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UpdateByRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UpdateByRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.result_id)
  return _msg;
}
inline void UpdateByRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool UpdateByRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool UpdateByRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void UpdateByRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UpdateByRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UpdateByRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.source_id)
  return _internal_source_id();
}
inline void UpdateByRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UpdateByRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UpdateByRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UpdateByRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UpdateByRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.source_id)
  return _msg;
}
inline void UpdateByRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions options = 3;
inline bool UpdateByRequest::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool UpdateByRequest::has_options() const {
  return _internal_has_options();
}
inline void UpdateByRequest::clear_options() {
  if (GetArenaForAllocation() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions& UpdateByRequest::_internal_options() const {
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* p = options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions&>(
      ::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions& UpdateByRequest::options() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.options)
  return _internal_options();
}
inline void UpdateByRequest::unsafe_arena_set_allocated_options(
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* options) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(options_);
  }
  options_ = options;
  if (options) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* UpdateByRequest::release_options() {
  
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* temp = options_;
  options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* UpdateByRequest::unsafe_arena_release_options() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.options)
  
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* UpdateByRequest::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions>(GetArenaForAllocation());
    options_ = p;
  }
  return options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* UpdateByRequest::mutable_options() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.options)
  return _msg;
}
inline void UpdateByRequest::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(options);
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.options)
}

// repeated .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation operations = 4;
inline int UpdateByRequest::_internal_operations_size() const {
  return operations_.size();
}
inline int UpdateByRequest::operations_size() const {
  return _internal_operations_size();
}
inline void UpdateByRequest::clear_operations() {
  operations_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* UpdateByRequest::mutable_operations(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.operations)
  return operations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation >*
UpdateByRequest::mutable_operations() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.UpdateByRequest.operations)
  return &operations_;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation& UpdateByRequest::_internal_operations(int index) const {
  return operations_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation& UpdateByRequest::operations(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.operations)
  return _internal_operations(index);
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* UpdateByRequest::_internal_add_operations() {
  return operations_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* UpdateByRequest::add_operations() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* _add = _internal_add_operations();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UpdateByRequest.operations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation >&
UpdateByRequest::operations() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.UpdateByRequest.operations)
  return operations_;
}

// repeated string group_by_columns = 5;
inline int UpdateByRequest::_internal_group_by_columns_size() const {
  return group_by_columns_.size();
}
inline int UpdateByRequest::group_by_columns_size() const {
  return _internal_group_by_columns_size();
}
inline void UpdateByRequest::clear_group_by_columns() {
  group_by_columns_.Clear();
}
inline std::string* UpdateByRequest::add_group_by_columns() {
  std::string* _s = _internal_add_group_by_columns();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
  return _s;
}
inline const std::string& UpdateByRequest::_internal_group_by_columns(int index) const {
  return group_by_columns_.Get(index);
}
inline const std::string& UpdateByRequest::group_by_columns(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
  return _internal_group_by_columns(index);
}
inline std::string* UpdateByRequest::mutable_group_by_columns(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
  return group_by_columns_.Mutable(index);
}
inline void UpdateByRequest::set_group_by_columns(int index, const std::string& value) {
  group_by_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::set_group_by_columns(int index, std::string&& value) {
  group_by_columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::set_group_by_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::set_group_by_columns(int index, const char* value, size_t size) {
  group_by_columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline std::string* UpdateByRequest::_internal_add_group_by_columns() {
  return group_by_columns_.Add();
}
inline void UpdateByRequest::add_group_by_columns(const std::string& value) {
  group_by_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::add_group_by_columns(std::string&& value) {
  group_by_columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::add_group_by_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::add_group_by_columns(const char* value, size_t size) {
  group_by_columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UpdateByRequest::group_by_columns() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
  return group_by_columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UpdateByRequest::mutable_group_by_columns() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
  return &group_by_columns_;
}

// -------------------------------------------------------------------

// SelectDistinctRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SelectDistinctRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool SelectDistinctRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SelectDistinctRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SelectDistinctRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
  return _internal_result_id();
}
inline void SelectDistinctRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectDistinctRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectDistinctRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectDistinctRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectDistinctRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
  return _msg;
}
inline void SelectDistinctRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool SelectDistinctRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool SelectDistinctRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void SelectDistinctRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SelectDistinctRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SelectDistinctRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
  return _internal_source_id();
}
inline void SelectDistinctRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectDistinctRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectDistinctRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectDistinctRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectDistinctRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
  return _msg;
}
inline void SelectDistinctRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
}

// repeated string column_names = 3;
inline int SelectDistinctRequest::_internal_column_names_size() const {
  return column_names_.size();
}
inline int SelectDistinctRequest::column_names_size() const {
  return _internal_column_names_size();
}
inline void SelectDistinctRequest::clear_column_names() {
  column_names_.Clear();
}
inline std::string* SelectDistinctRequest::add_column_names() {
  std::string* _s = _internal_add_column_names();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return _s;
}
inline const std::string& SelectDistinctRequest::_internal_column_names(int index) const {
  return column_names_.Get(index);
}
inline const std::string& SelectDistinctRequest::column_names(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return _internal_column_names(index);
}
inline std::string* SelectDistinctRequest::mutable_column_names(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return column_names_.Mutable(index);
}
inline void SelectDistinctRequest::set_column_names(int index, const std::string& value) {
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::set_column_names(int index, std::string&& value) {
  column_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::set_column_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::set_column_names(int index, const char* value, size_t size) {
  column_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline std::string* SelectDistinctRequest::_internal_add_column_names() {
  return column_names_.Add();
}
inline void SelectDistinctRequest::add_column_names(const std::string& value) {
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::add_column_names(std::string&& value) {
  column_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::add_column_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::add_column_names(const char* value, size_t size) {
  column_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SelectDistinctRequest::column_names() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return column_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SelectDistinctRequest::mutable_column_names() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return &column_names_;
}

// -------------------------------------------------------------------

// DropColumnsRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool DropColumnsRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool DropColumnsRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& DropColumnsRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& DropColumnsRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
  return _internal_result_id();
}
inline void DropColumnsRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* DropColumnsRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* DropColumnsRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* DropColumnsRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* DropColumnsRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
  return _msg;
}
inline void DropColumnsRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool DropColumnsRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool DropColumnsRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void DropColumnsRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& DropColumnsRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& DropColumnsRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
  return _internal_source_id();
}
inline void DropColumnsRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* DropColumnsRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* DropColumnsRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* DropColumnsRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* DropColumnsRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
  return _msg;
}
inline void DropColumnsRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
}

// repeated string column_names = 3;
inline int DropColumnsRequest::_internal_column_names_size() const {
  return column_names_.size();
}
inline int DropColumnsRequest::column_names_size() const {
  return _internal_column_names_size();
}
inline void DropColumnsRequest::clear_column_names() {
  column_names_.Clear();
}
inline std::string* DropColumnsRequest::add_column_names() {
  std::string* _s = _internal_add_column_names();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return _s;
}
inline const std::string& DropColumnsRequest::_internal_column_names(int index) const {
  return column_names_.Get(index);
}
inline const std::string& DropColumnsRequest::column_names(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return _internal_column_names(index);
}
inline std::string* DropColumnsRequest::mutable_column_names(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return column_names_.Mutable(index);
}
inline void DropColumnsRequest::set_column_names(int index, const std::string& value) {
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::set_column_names(int index, std::string&& value) {
  column_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::set_column_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::set_column_names(int index, const char* value, size_t size) {
  column_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline std::string* DropColumnsRequest::_internal_add_column_names() {
  return column_names_.Add();
}
inline void DropColumnsRequest::add_column_names(const std::string& value) {
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::add_column_names(std::string&& value) {
  column_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::add_column_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::add_column_names(const char* value, size_t size) {
  column_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DropColumnsRequest::column_names() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return column_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DropColumnsRequest::mutable_column_names() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return &column_names_;
}

// -------------------------------------------------------------------

// UnstructuredFilterTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool UnstructuredFilterTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool UnstructuredFilterTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UnstructuredFilterTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UnstructuredFilterTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
  return _internal_result_id();
}
inline void UnstructuredFilterTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UnstructuredFilterTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UnstructuredFilterTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UnstructuredFilterTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UnstructuredFilterTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
  return _msg;
}
inline void UnstructuredFilterTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool UnstructuredFilterTableRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool UnstructuredFilterTableRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void UnstructuredFilterTableRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UnstructuredFilterTableRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UnstructuredFilterTableRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
  return _internal_source_id();
}
inline void UnstructuredFilterTableRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UnstructuredFilterTableRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UnstructuredFilterTableRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UnstructuredFilterTableRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UnstructuredFilterTableRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
  return _msg;
}
inline void UnstructuredFilterTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
}

// repeated string filters = 3;
inline int UnstructuredFilterTableRequest::_internal_filters_size() const {
  return filters_.size();
}
inline int UnstructuredFilterTableRequest::filters_size() const {
  return _internal_filters_size();
}
inline void UnstructuredFilterTableRequest::clear_filters() {
  filters_.Clear();
}
inline std::string* UnstructuredFilterTableRequest::add_filters() {
  std::string* _s = _internal_add_filters();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return _s;
}
inline const std::string& UnstructuredFilterTableRequest::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const std::string& UnstructuredFilterTableRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return _internal_filters(index);
}
inline std::string* UnstructuredFilterTableRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return filters_.Mutable(index);
}
inline void UnstructuredFilterTableRequest::set_filters(int index, const std::string& value) {
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::set_filters(int index, std::string&& value) {
  filters_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::set_filters(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::set_filters(int index, const char* value, size_t size) {
  filters_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline std::string* UnstructuredFilterTableRequest::_internal_add_filters() {
  return filters_.Add();
}
inline void UnstructuredFilterTableRequest::add_filters(const std::string& value) {
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::add_filters(std::string&& value) {
  filters_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::add_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filters_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::add_filters(const char* value, size_t size) {
  filters_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UnstructuredFilterTableRequest::filters() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return filters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UnstructuredFilterTableRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return &filters_;
}

// -------------------------------------------------------------------

// HeadOrTailRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool HeadOrTailRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool HeadOrTailRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& HeadOrTailRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& HeadOrTailRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
  return _internal_result_id();
}
inline void HeadOrTailRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
  return _msg;
}
inline void HeadOrTailRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool HeadOrTailRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool HeadOrTailRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void HeadOrTailRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& HeadOrTailRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& HeadOrTailRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
  return _internal_source_id();
}
inline void HeadOrTailRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
  return _msg;
}
inline void HeadOrTailRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
}

// sint64 num_rows = 3 [jstype = JS_STRING];
inline void HeadOrTailRequest::clear_num_rows() {
  num_rows_ = int64_t{0};
}
inline int64_t HeadOrTailRequest::_internal_num_rows() const {
  return num_rows_;
}
inline int64_t HeadOrTailRequest::num_rows() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.num_rows)
  return _internal_num_rows();
}
inline void HeadOrTailRequest::_internal_set_num_rows(int64_t value) {
  
  num_rows_ = value;
}
inline void HeadOrTailRequest::set_num_rows(int64_t value) {
  _internal_set_num_rows(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.num_rows)
}

// -------------------------------------------------------------------

// HeadOrTailByRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool HeadOrTailByRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool HeadOrTailByRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& HeadOrTailByRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& HeadOrTailByRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
  return _internal_result_id();
}
inline void HeadOrTailByRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailByRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailByRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailByRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailByRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
  return _msg;
}
inline void HeadOrTailByRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool HeadOrTailByRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool HeadOrTailByRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void HeadOrTailByRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& HeadOrTailByRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& HeadOrTailByRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
  return _internal_source_id();
}
inline void HeadOrTailByRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailByRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailByRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailByRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailByRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
  return _msg;
}
inline void HeadOrTailByRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
}

// sint64 num_rows = 3 [jstype = JS_STRING];
inline void HeadOrTailByRequest::clear_num_rows() {
  num_rows_ = int64_t{0};
}
inline int64_t HeadOrTailByRequest::_internal_num_rows() const {
  return num_rows_;
}
inline int64_t HeadOrTailByRequest::num_rows() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.num_rows)
  return _internal_num_rows();
}
inline void HeadOrTailByRequest::_internal_set_num_rows(int64_t value) {
  
  num_rows_ = value;
}
inline void HeadOrTailByRequest::set_num_rows(int64_t value) {
  _internal_set_num_rows(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.num_rows)
}

// repeated string group_by_column_specs = 4;
inline int HeadOrTailByRequest::_internal_group_by_column_specs_size() const {
  return group_by_column_specs_.size();
}
inline int HeadOrTailByRequest::group_by_column_specs_size() const {
  return _internal_group_by_column_specs_size();
}
inline void HeadOrTailByRequest::clear_group_by_column_specs() {
  group_by_column_specs_.Clear();
}
inline std::string* HeadOrTailByRequest::add_group_by_column_specs() {
  std::string* _s = _internal_add_group_by_column_specs();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return _s;
}
inline const std::string& HeadOrTailByRequest::_internal_group_by_column_specs(int index) const {
  return group_by_column_specs_.Get(index);
}
inline const std::string& HeadOrTailByRequest::group_by_column_specs(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return _internal_group_by_column_specs(index);
}
inline std::string* HeadOrTailByRequest::mutable_group_by_column_specs(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return group_by_column_specs_.Mutable(index);
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, const std::string& value) {
  group_by_column_specs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, std::string&& value) {
  group_by_column_specs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_column_specs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, const char* value, size_t size) {
  group_by_column_specs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline std::string* HeadOrTailByRequest::_internal_add_group_by_column_specs() {
  return group_by_column_specs_.Add();
}
inline void HeadOrTailByRequest::add_group_by_column_specs(const std::string& value) {
  group_by_column_specs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::add_group_by_column_specs(std::string&& value) {
  group_by_column_specs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::add_group_by_column_specs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_column_specs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::add_group_by_column_specs(const char* value, size_t size) {
  group_by_column_specs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
HeadOrTailByRequest::group_by_column_specs() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return group_by_column_specs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
HeadOrTailByRequest::mutable_group_by_column_specs() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return &group_by_column_specs_;
}

// -------------------------------------------------------------------

// UngroupRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool UngroupRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool UngroupRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UngroupRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UngroupRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
  return _internal_result_id();
}
inline void UngroupRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UngroupRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UngroupRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UngroupRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UngroupRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
  return _msg;
}
inline void UngroupRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool UngroupRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool UngroupRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void UngroupRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UngroupRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UngroupRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
  return _internal_source_id();
}
inline void UngroupRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UngroupRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UngroupRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UngroupRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UngroupRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
  return _msg;
}
inline void UngroupRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
}

// bool null_fill = 3;
inline void UngroupRequest::clear_null_fill() {
  null_fill_ = false;
}
inline bool UngroupRequest::_internal_null_fill() const {
  return null_fill_;
}
inline bool UngroupRequest::null_fill() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UngroupRequest.null_fill)
  return _internal_null_fill();
}
inline void UngroupRequest::_internal_set_null_fill(bool value) {
  
  null_fill_ = value;
}
inline void UngroupRequest::set_null_fill(bool value) {
  _internal_set_null_fill(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UngroupRequest.null_fill)
}

// repeated string columns_to_ungroup = 4;
inline int UngroupRequest::_internal_columns_to_ungroup_size() const {
  return columns_to_ungroup_.size();
}
inline int UngroupRequest::columns_to_ungroup_size() const {
  return _internal_columns_to_ungroup_size();
}
inline void UngroupRequest::clear_columns_to_ungroup() {
  columns_to_ungroup_.Clear();
}
inline std::string* UngroupRequest::add_columns_to_ungroup() {
  std::string* _s = _internal_add_columns_to_ungroup();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return _s;
}
inline const std::string& UngroupRequest::_internal_columns_to_ungroup(int index) const {
  return columns_to_ungroup_.Get(index);
}
inline const std::string& UngroupRequest::columns_to_ungroup(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return _internal_columns_to_ungroup(index);
}
inline std::string* UngroupRequest::mutable_columns_to_ungroup(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return columns_to_ungroup_.Mutable(index);
}
inline void UngroupRequest::set_columns_to_ungroup(int index, const std::string& value) {
  columns_to_ungroup_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::set_columns_to_ungroup(int index, std::string&& value) {
  columns_to_ungroup_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::set_columns_to_ungroup(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_ungroup_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::set_columns_to_ungroup(int index, const char* value, size_t size) {
  columns_to_ungroup_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline std::string* UngroupRequest::_internal_add_columns_to_ungroup() {
  return columns_to_ungroup_.Add();
}
inline void UngroupRequest::add_columns_to_ungroup(const std::string& value) {
  columns_to_ungroup_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::add_columns_to_ungroup(std::string&& value) {
  columns_to_ungroup_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::add_columns_to_ungroup(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_ungroup_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::add_columns_to_ungroup(const char* value, size_t size) {
  columns_to_ungroup_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
UngroupRequest::columns_to_ungroup() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return columns_to_ungroup_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
UngroupRequest::mutable_columns_to_ungroup() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return &columns_to_ungroup_;
}

// -------------------------------------------------------------------

// MergeTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool MergeTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool MergeTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& MergeTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& MergeTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
  return _internal_result_id();
}
inline void MergeTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MergeTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MergeTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MergeTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MergeTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
  return _msg;
}
inline void MergeTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
}

// repeated .io.deephaven.proto.backplane.grpc.TableReference source_ids = 2;
inline int MergeTablesRequest::_internal_source_ids_size() const {
  return source_ids_.size();
}
inline int MergeTablesRequest::source_ids_size() const {
  return _internal_source_ids_size();
}
inline void MergeTablesRequest::clear_source_ids() {
  source_ids_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MergeTablesRequest::mutable_source_ids(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return source_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference >*
MergeTablesRequest::mutable_source_ids() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return &source_ids_;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& MergeTablesRequest::_internal_source_ids(int index) const {
  return source_ids_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& MergeTablesRequest::source_ids(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return _internal_source_ids(index);
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MergeTablesRequest::_internal_add_source_ids() {
  return source_ids_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MergeTablesRequest::add_source_ids() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _add = _internal_add_source_ids();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference >&
MergeTablesRequest::source_ids() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return source_ids_;
}

// string key_column = 3;
inline void MergeTablesRequest::clear_key_column() {
  key_column_.ClearToEmpty();
}
inline const std::string& MergeTablesRequest::key_column() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
  return _internal_key_column();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MergeTablesRequest::set_key_column(ArgT0&& arg0, ArgT... args) {
 
 key_column_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
}
inline std::string* MergeTablesRequest::mutable_key_column() {
  std::string* _s = _internal_mutable_key_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
  return _s;
}
inline const std::string& MergeTablesRequest::_internal_key_column() const {
  return key_column_.Get();
}
inline void MergeTablesRequest::_internal_set_key_column(const std::string& value) {
  
  key_column_.Set(value, GetArenaForAllocation());
}
inline std::string* MergeTablesRequest::_internal_mutable_key_column() {
  
  return key_column_.Mutable(GetArenaForAllocation());
}
inline std::string* MergeTablesRequest::release_key_column() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
  return key_column_.Release();
}
inline void MergeTablesRequest::set_allocated_key_column(std::string* key_column) {
  if (key_column != nullptr) {
    
  } else {
    
  }
  key_column_.SetAllocated(key_column, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_column_.IsDefault()) {
    key_column_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
}

// -------------------------------------------------------------------

// SnapshotTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SnapshotTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool SnapshotTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SnapshotTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SnapshotTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
  return _internal_result_id();
}
inline void SnapshotTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
  return _msg;
}
inline void SnapshotTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool SnapshotTableRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool SnapshotTableRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void SnapshotTableRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotTableRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotTableRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.source_id)
  return _internal_source_id();
}
inline void SnapshotTableRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.source_id)
  return _msg;
}
inline void SnapshotTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.source_id)
}

// -------------------------------------------------------------------

// SnapshotWhenTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SnapshotWhenTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool SnapshotWhenTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SnapshotWhenTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SnapshotWhenTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.result_id)
  return _internal_result_id();
}
inline void SnapshotWhenTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotWhenTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotWhenTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotWhenTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotWhenTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.result_id)
  return _msg;
}
inline void SnapshotWhenTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference base_id = 2;
inline bool SnapshotWhenTableRequest::_internal_has_base_id() const {
  return this != internal_default_instance() && base_id_ != nullptr;
}
inline bool SnapshotWhenTableRequest::has_base_id() const {
  return _internal_has_base_id();
}
inline void SnapshotWhenTableRequest::clear_base_id() {
  if (GetArenaForAllocation() == nullptr && base_id_ != nullptr) {
    delete base_id_;
  }
  base_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotWhenTableRequest::_internal_base_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = base_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotWhenTableRequest::base_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.base_id)
  return _internal_base_id();
}
inline void SnapshotWhenTableRequest::unsafe_arena_set_allocated_base_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* base_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_id_);
  }
  base_id_ = base_id;
  if (base_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.base_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::release_base_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = base_id_;
  base_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::unsafe_arena_release_base_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.base_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = base_id_;
  base_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::_internal_mutable_base_id() {
  
  if (base_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    base_id_ = p;
  }
  return base_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::mutable_base_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_base_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.base_id)
  return _msg;
}
inline void SnapshotWhenTableRequest::set_allocated_base_id(::io::deephaven::proto::backplane::grpc::TableReference* base_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete base_id_;
  }
  if (base_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(base_id);
    if (message_arena != submessage_arena) {
      base_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base_id, submessage_arena);
    }
    
  } else {
    
  }
  base_id_ = base_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.base_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference trigger_id = 3;
inline bool SnapshotWhenTableRequest::_internal_has_trigger_id() const {
  return this != internal_default_instance() && trigger_id_ != nullptr;
}
inline bool SnapshotWhenTableRequest::has_trigger_id() const {
  return _internal_has_trigger_id();
}
inline void SnapshotWhenTableRequest::clear_trigger_id() {
  if (GetArenaForAllocation() == nullptr && trigger_id_ != nullptr) {
    delete trigger_id_;
  }
  trigger_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotWhenTableRequest::_internal_trigger_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = trigger_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotWhenTableRequest::trigger_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.trigger_id)
  return _internal_trigger_id();
}
inline void SnapshotWhenTableRequest::unsafe_arena_set_allocated_trigger_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* trigger_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trigger_id_);
  }
  trigger_id_ = trigger_id;
  if (trigger_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.trigger_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::release_trigger_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = trigger_id_;
  trigger_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::unsafe_arena_release_trigger_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.trigger_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = trigger_id_;
  trigger_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::_internal_mutable_trigger_id() {
  
  if (trigger_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    trigger_id_ = p;
  }
  return trigger_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::mutable_trigger_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_trigger_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.trigger_id)
  return _msg;
}
inline void SnapshotWhenTableRequest::set_allocated_trigger_id(::io::deephaven::proto::backplane::grpc::TableReference* trigger_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete trigger_id_;
  }
  if (trigger_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(trigger_id);
    if (message_arena != submessage_arena) {
      trigger_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trigger_id, submessage_arena);
    }
    
  } else {
    
  }
  trigger_id_ = trigger_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.trigger_id)
}

// bool initial = 4;
inline void SnapshotWhenTableRequest::clear_initial() {
  initial_ = false;
}
inline bool SnapshotWhenTableRequest::_internal_initial() const {
  return initial_;
}
inline bool SnapshotWhenTableRequest::initial() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.initial)
  return _internal_initial();
}
inline void SnapshotWhenTableRequest::_internal_set_initial(bool value) {
  
  initial_ = value;
}
inline void SnapshotWhenTableRequest::set_initial(bool value) {
  _internal_set_initial(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.initial)
}

// bool incremental = 5;
inline void SnapshotWhenTableRequest::clear_incremental() {
  incremental_ = false;
}
inline bool SnapshotWhenTableRequest::_internal_incremental() const {
  return incremental_;
}
inline bool SnapshotWhenTableRequest::incremental() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.incremental)
  return _internal_incremental();
}
inline void SnapshotWhenTableRequest::_internal_set_incremental(bool value) {
  
  incremental_ = value;
}
inline void SnapshotWhenTableRequest::set_incremental(bool value) {
  _internal_set_incremental(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.incremental)
}

// bool history = 6;
inline void SnapshotWhenTableRequest::clear_history() {
  history_ = false;
}
inline bool SnapshotWhenTableRequest::_internal_history() const {
  return history_;
}
inline bool SnapshotWhenTableRequest::history() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.history)
  return _internal_history();
}
inline void SnapshotWhenTableRequest::_internal_set_history(bool value) {
  
  history_ = value;
}
inline void SnapshotWhenTableRequest::set_history(bool value) {
  _internal_set_history(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.history)
}

// repeated string stamp_columns = 7;
inline int SnapshotWhenTableRequest::_internal_stamp_columns_size() const {
  return stamp_columns_.size();
}
inline int SnapshotWhenTableRequest::stamp_columns_size() const {
  return _internal_stamp_columns_size();
}
inline void SnapshotWhenTableRequest::clear_stamp_columns() {
  stamp_columns_.Clear();
}
inline std::string* SnapshotWhenTableRequest::add_stamp_columns() {
  std::string* _s = _internal_add_stamp_columns();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
  return _s;
}
inline const std::string& SnapshotWhenTableRequest::_internal_stamp_columns(int index) const {
  return stamp_columns_.Get(index);
}
inline const std::string& SnapshotWhenTableRequest::stamp_columns(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
  return _internal_stamp_columns(index);
}
inline std::string* SnapshotWhenTableRequest::mutable_stamp_columns(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
  return stamp_columns_.Mutable(index);
}
inline void SnapshotWhenTableRequest::set_stamp_columns(int index, const std::string& value) {
  stamp_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::set_stamp_columns(int index, std::string&& value) {
  stamp_columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::set_stamp_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  stamp_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::set_stamp_columns(int index, const char* value, size_t size) {
  stamp_columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline std::string* SnapshotWhenTableRequest::_internal_add_stamp_columns() {
  return stamp_columns_.Add();
}
inline void SnapshotWhenTableRequest::add_stamp_columns(const std::string& value) {
  stamp_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::add_stamp_columns(std::string&& value) {
  stamp_columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::add_stamp_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  stamp_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::add_stamp_columns(const char* value, size_t size) {
  stamp_columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SnapshotWhenTableRequest::stamp_columns() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
  return stamp_columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SnapshotWhenTableRequest::mutable_stamp_columns() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
  return &stamp_columns_;
}

// -------------------------------------------------------------------

// CrossJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool CrossJoinTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool CrossJoinTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CrossJoinTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CrossJoinTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void CrossJoinTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CrossJoinTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CrossJoinTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CrossJoinTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CrossJoinTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
  return _msg;
}
inline void CrossJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool CrossJoinTablesRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool CrossJoinTablesRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void CrossJoinTablesRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CrossJoinTablesRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CrossJoinTablesRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void CrossJoinTablesRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
  return _msg;
}
inline void CrossJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool CrossJoinTablesRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool CrossJoinTablesRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void CrossJoinTablesRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CrossJoinTablesRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CrossJoinTablesRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void CrossJoinTablesRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
  return _msg;
}
inline void CrossJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int CrossJoinTablesRequest::_internal_columns_to_match_size() const {
  return columns_to_match_.size();
}
inline int CrossJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void CrossJoinTablesRequest::clear_columns_to_match() {
  columns_to_match_.Clear();
}
inline std::string* CrossJoinTablesRequest::add_columns_to_match() {
  std::string* _s = _internal_add_columns_to_match();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& CrossJoinTablesRequest::_internal_columns_to_match(int index) const {
  return columns_to_match_.Get(index);
}
inline const std::string& CrossJoinTablesRequest::columns_to_match(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match(index);
}
inline std::string* CrossJoinTablesRequest::mutable_columns_to_match(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return columns_to_match_.Mutable(index);
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  columns_to_match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, const char* value, size_t size) {
  columns_to_match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline std::string* CrossJoinTablesRequest::_internal_add_columns_to_match() {
  return columns_to_match_.Add();
}
inline void CrossJoinTablesRequest::add_columns_to_match(const std::string& value) {
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::add_columns_to_match(std::string&& value) {
  columns_to_match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::add_columns_to_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::add_columns_to_match(const char* value, size_t size) {
  columns_to_match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CrossJoinTablesRequest::columns_to_match() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return columns_to_match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CrossJoinTablesRequest::mutable_columns_to_match() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return &columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int CrossJoinTablesRequest::_internal_columns_to_add_size() const {
  return columns_to_add_.size();
}
inline int CrossJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void CrossJoinTablesRequest::clear_columns_to_add() {
  columns_to_add_.Clear();
}
inline std::string* CrossJoinTablesRequest::add_columns_to_add() {
  std::string* _s = _internal_add_columns_to_add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& CrossJoinTablesRequest::_internal_columns_to_add(int index) const {
  return columns_to_add_.Get(index);
}
inline const std::string& CrossJoinTablesRequest::columns_to_add(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add(index);
}
inline std::string* CrossJoinTablesRequest::mutable_columns_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return columns_to_add_.Mutable(index);
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  columns_to_add_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, const char* value, size_t size) {
  columns_to_add_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline std::string* CrossJoinTablesRequest::_internal_add_columns_to_add() {
  return columns_to_add_.Add();
}
inline void CrossJoinTablesRequest::add_columns_to_add(const std::string& value) {
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::add_columns_to_add(std::string&& value) {
  columns_to_add_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::add_columns_to_add(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::add_columns_to_add(const char* value, size_t size) {
  columns_to_add_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CrossJoinTablesRequest::columns_to_add() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return columns_to_add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CrossJoinTablesRequest::mutable_columns_to_add() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return &columns_to_add_;
}

// int32 reserve_bits = 6;
inline void CrossJoinTablesRequest::clear_reserve_bits() {
  reserve_bits_ = 0;
}
inline int32_t CrossJoinTablesRequest::_internal_reserve_bits() const {
  return reserve_bits_;
}
inline int32_t CrossJoinTablesRequest::reserve_bits() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.reserve_bits)
  return _internal_reserve_bits();
}
inline void CrossJoinTablesRequest::_internal_set_reserve_bits(int32_t value) {
  
  reserve_bits_ = value;
}
inline void CrossJoinTablesRequest::set_reserve_bits(int32_t value) {
  _internal_set_reserve_bits(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.reserve_bits)
}

// -------------------------------------------------------------------

// NaturalJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool NaturalJoinTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool NaturalJoinTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& NaturalJoinTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& NaturalJoinTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void NaturalJoinTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* NaturalJoinTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* NaturalJoinTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* NaturalJoinTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* NaturalJoinTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
  return _msg;
}
inline void NaturalJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool NaturalJoinTablesRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool NaturalJoinTablesRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void NaturalJoinTablesRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& NaturalJoinTablesRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& NaturalJoinTablesRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void NaturalJoinTablesRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
  return _msg;
}
inline void NaturalJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool NaturalJoinTablesRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool NaturalJoinTablesRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void NaturalJoinTablesRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& NaturalJoinTablesRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& NaturalJoinTablesRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void NaturalJoinTablesRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
  return _msg;
}
inline void NaturalJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int NaturalJoinTablesRequest::_internal_columns_to_match_size() const {
  return columns_to_match_.size();
}
inline int NaturalJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void NaturalJoinTablesRequest::clear_columns_to_match() {
  columns_to_match_.Clear();
}
inline std::string* NaturalJoinTablesRequest::add_columns_to_match() {
  std::string* _s = _internal_add_columns_to_match();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& NaturalJoinTablesRequest::_internal_columns_to_match(int index) const {
  return columns_to_match_.Get(index);
}
inline const std::string& NaturalJoinTablesRequest::columns_to_match(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match(index);
}
inline std::string* NaturalJoinTablesRequest::mutable_columns_to_match(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return columns_to_match_.Mutable(index);
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  columns_to_match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, const char* value, size_t size) {
  columns_to_match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline std::string* NaturalJoinTablesRequest::_internal_add_columns_to_match() {
  return columns_to_match_.Add();
}
inline void NaturalJoinTablesRequest::add_columns_to_match(const std::string& value) {
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::add_columns_to_match(std::string&& value) {
  columns_to_match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::add_columns_to_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::add_columns_to_match(const char* value, size_t size) {
  columns_to_match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NaturalJoinTablesRequest::columns_to_match() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return columns_to_match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NaturalJoinTablesRequest::mutable_columns_to_match() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return &columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int NaturalJoinTablesRequest::_internal_columns_to_add_size() const {
  return columns_to_add_.size();
}
inline int NaturalJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void NaturalJoinTablesRequest::clear_columns_to_add() {
  columns_to_add_.Clear();
}
inline std::string* NaturalJoinTablesRequest::add_columns_to_add() {
  std::string* _s = _internal_add_columns_to_add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& NaturalJoinTablesRequest::_internal_columns_to_add(int index) const {
  return columns_to_add_.Get(index);
}
inline const std::string& NaturalJoinTablesRequest::columns_to_add(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add(index);
}
inline std::string* NaturalJoinTablesRequest::mutable_columns_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return columns_to_add_.Mutable(index);
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  columns_to_add_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, const char* value, size_t size) {
  columns_to_add_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline std::string* NaturalJoinTablesRequest::_internal_add_columns_to_add() {
  return columns_to_add_.Add();
}
inline void NaturalJoinTablesRequest::add_columns_to_add(const std::string& value) {
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::add_columns_to_add(std::string&& value) {
  columns_to_add_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::add_columns_to_add(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::add_columns_to_add(const char* value, size_t size) {
  columns_to_add_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
NaturalJoinTablesRequest::columns_to_add() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return columns_to_add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
NaturalJoinTablesRequest::mutable_columns_to_add() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return &columns_to_add_;
}

// -------------------------------------------------------------------

// ExactJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool ExactJoinTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool ExactJoinTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExactJoinTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExactJoinTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void ExactJoinTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExactJoinTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExactJoinTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExactJoinTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExactJoinTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
  return _msg;
}
inline void ExactJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool ExactJoinTablesRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool ExactJoinTablesRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void ExactJoinTablesRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExactJoinTablesRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExactJoinTablesRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void ExactJoinTablesRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
  return _msg;
}
inline void ExactJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool ExactJoinTablesRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool ExactJoinTablesRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void ExactJoinTablesRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExactJoinTablesRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExactJoinTablesRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void ExactJoinTablesRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
  return _msg;
}
inline void ExactJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int ExactJoinTablesRequest::_internal_columns_to_match_size() const {
  return columns_to_match_.size();
}
inline int ExactJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void ExactJoinTablesRequest::clear_columns_to_match() {
  columns_to_match_.Clear();
}
inline std::string* ExactJoinTablesRequest::add_columns_to_match() {
  std::string* _s = _internal_add_columns_to_match();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& ExactJoinTablesRequest::_internal_columns_to_match(int index) const {
  return columns_to_match_.Get(index);
}
inline const std::string& ExactJoinTablesRequest::columns_to_match(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match(index);
}
inline std::string* ExactJoinTablesRequest::mutable_columns_to_match(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return columns_to_match_.Mutable(index);
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  columns_to_match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, const char* value, size_t size) {
  columns_to_match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline std::string* ExactJoinTablesRequest::_internal_add_columns_to_match() {
  return columns_to_match_.Add();
}
inline void ExactJoinTablesRequest::add_columns_to_match(const std::string& value) {
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::add_columns_to_match(std::string&& value) {
  columns_to_match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::add_columns_to_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::add_columns_to_match(const char* value, size_t size) {
  columns_to_match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExactJoinTablesRequest::columns_to_match() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return columns_to_match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExactJoinTablesRequest::mutable_columns_to_match() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return &columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int ExactJoinTablesRequest::_internal_columns_to_add_size() const {
  return columns_to_add_.size();
}
inline int ExactJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void ExactJoinTablesRequest::clear_columns_to_add() {
  columns_to_add_.Clear();
}
inline std::string* ExactJoinTablesRequest::add_columns_to_add() {
  std::string* _s = _internal_add_columns_to_add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& ExactJoinTablesRequest::_internal_columns_to_add(int index) const {
  return columns_to_add_.Get(index);
}
inline const std::string& ExactJoinTablesRequest::columns_to_add(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add(index);
}
inline std::string* ExactJoinTablesRequest::mutable_columns_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return columns_to_add_.Mutable(index);
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  columns_to_add_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, const char* value, size_t size) {
  columns_to_add_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline std::string* ExactJoinTablesRequest::_internal_add_columns_to_add() {
  return columns_to_add_.Add();
}
inline void ExactJoinTablesRequest::add_columns_to_add(const std::string& value) {
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::add_columns_to_add(std::string&& value) {
  columns_to_add_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::add_columns_to_add(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::add_columns_to_add(const char* value, size_t size) {
  columns_to_add_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ExactJoinTablesRequest::columns_to_add() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return columns_to_add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ExactJoinTablesRequest::mutable_columns_to_add() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return &columns_to_add_;
}

// -------------------------------------------------------------------

// LeftJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool LeftJoinTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool LeftJoinTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& LeftJoinTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& LeftJoinTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void LeftJoinTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* LeftJoinTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* LeftJoinTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* LeftJoinTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* LeftJoinTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
  return _msg;
}
inline void LeftJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool LeftJoinTablesRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool LeftJoinTablesRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void LeftJoinTablesRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& LeftJoinTablesRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& LeftJoinTablesRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void LeftJoinTablesRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
  return _msg;
}
inline void LeftJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool LeftJoinTablesRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool LeftJoinTablesRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void LeftJoinTablesRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& LeftJoinTablesRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& LeftJoinTablesRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void LeftJoinTablesRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
  return _msg;
}
inline void LeftJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int LeftJoinTablesRequest::_internal_columns_to_match_size() const {
  return columns_to_match_.size();
}
inline int LeftJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void LeftJoinTablesRequest::clear_columns_to_match() {
  columns_to_match_.Clear();
}
inline std::string* LeftJoinTablesRequest::add_columns_to_match() {
  std::string* _s = _internal_add_columns_to_match();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& LeftJoinTablesRequest::_internal_columns_to_match(int index) const {
  return columns_to_match_.Get(index);
}
inline const std::string& LeftJoinTablesRequest::columns_to_match(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match(index);
}
inline std::string* LeftJoinTablesRequest::mutable_columns_to_match(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return columns_to_match_.Mutable(index);
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  columns_to_match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, const char* value, size_t size) {
  columns_to_match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline std::string* LeftJoinTablesRequest::_internal_add_columns_to_match() {
  return columns_to_match_.Add();
}
inline void LeftJoinTablesRequest::add_columns_to_match(const std::string& value) {
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::add_columns_to_match(std::string&& value) {
  columns_to_match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::add_columns_to_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::add_columns_to_match(const char* value, size_t size) {
  columns_to_match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LeftJoinTablesRequest::columns_to_match() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return columns_to_match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LeftJoinTablesRequest::mutable_columns_to_match() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return &columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int LeftJoinTablesRequest::_internal_columns_to_add_size() const {
  return columns_to_add_.size();
}
inline int LeftJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void LeftJoinTablesRequest::clear_columns_to_add() {
  columns_to_add_.Clear();
}
inline std::string* LeftJoinTablesRequest::add_columns_to_add() {
  std::string* _s = _internal_add_columns_to_add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& LeftJoinTablesRequest::_internal_columns_to_add(int index) const {
  return columns_to_add_.Get(index);
}
inline const std::string& LeftJoinTablesRequest::columns_to_add(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add(index);
}
inline std::string* LeftJoinTablesRequest::mutable_columns_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return columns_to_add_.Mutable(index);
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  columns_to_add_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, const char* value, size_t size) {
  columns_to_add_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline std::string* LeftJoinTablesRequest::_internal_add_columns_to_add() {
  return columns_to_add_.Add();
}
inline void LeftJoinTablesRequest::add_columns_to_add(const std::string& value) {
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::add_columns_to_add(std::string&& value) {
  columns_to_add_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::add_columns_to_add(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::add_columns_to_add(const char* value, size_t size) {
  columns_to_add_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LeftJoinTablesRequest::columns_to_add() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return columns_to_add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LeftJoinTablesRequest::mutable_columns_to_add() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return &columns_to_add_;
}

// -------------------------------------------------------------------

// AsOfJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool AsOfJoinTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool AsOfJoinTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AsOfJoinTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AsOfJoinTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void AsOfJoinTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AsOfJoinTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AsOfJoinTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AsOfJoinTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AsOfJoinTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
  return _msg;
}
inline void AsOfJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool AsOfJoinTablesRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool AsOfJoinTablesRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void AsOfJoinTablesRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AsOfJoinTablesRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AsOfJoinTablesRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void AsOfJoinTablesRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
  return _msg;
}
inline void AsOfJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool AsOfJoinTablesRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool AsOfJoinTablesRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void AsOfJoinTablesRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AsOfJoinTablesRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AsOfJoinTablesRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void AsOfJoinTablesRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
  return _msg;
}
inline void AsOfJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int AsOfJoinTablesRequest::_internal_columns_to_match_size() const {
  return columns_to_match_.size();
}
inline int AsOfJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void AsOfJoinTablesRequest::clear_columns_to_match() {
  columns_to_match_.Clear();
}
inline std::string* AsOfJoinTablesRequest::add_columns_to_match() {
  std::string* _s = _internal_add_columns_to_match();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& AsOfJoinTablesRequest::_internal_columns_to_match(int index) const {
  return columns_to_match_.Get(index);
}
inline const std::string& AsOfJoinTablesRequest::columns_to_match(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match(index);
}
inline std::string* AsOfJoinTablesRequest::mutable_columns_to_match(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return columns_to_match_.Mutable(index);
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  columns_to_match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, const char* value, size_t size) {
  columns_to_match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline std::string* AsOfJoinTablesRequest::_internal_add_columns_to_match() {
  return columns_to_match_.Add();
}
inline void AsOfJoinTablesRequest::add_columns_to_match(const std::string& value) {
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::add_columns_to_match(std::string&& value) {
  columns_to_match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::add_columns_to_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::add_columns_to_match(const char* value, size_t size) {
  columns_to_match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AsOfJoinTablesRequest::columns_to_match() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return columns_to_match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AsOfJoinTablesRequest::mutable_columns_to_match() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return &columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int AsOfJoinTablesRequest::_internal_columns_to_add_size() const {
  return columns_to_add_.size();
}
inline int AsOfJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void AsOfJoinTablesRequest::clear_columns_to_add() {
  columns_to_add_.Clear();
}
inline std::string* AsOfJoinTablesRequest::add_columns_to_add() {
  std::string* _s = _internal_add_columns_to_add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& AsOfJoinTablesRequest::_internal_columns_to_add(int index) const {
  return columns_to_add_.Get(index);
}
inline const std::string& AsOfJoinTablesRequest::columns_to_add(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add(index);
}
inline std::string* AsOfJoinTablesRequest::mutable_columns_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return columns_to_add_.Mutable(index);
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  columns_to_add_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, const char* value, size_t size) {
  columns_to_add_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline std::string* AsOfJoinTablesRequest::_internal_add_columns_to_add() {
  return columns_to_add_.Add();
}
inline void AsOfJoinTablesRequest::add_columns_to_add(const std::string& value) {
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::add_columns_to_add(std::string&& value) {
  columns_to_add_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::add_columns_to_add(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::add_columns_to_add(const char* value, size_t size) {
  columns_to_add_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AsOfJoinTablesRequest::columns_to_add() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return columns_to_add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AsOfJoinTablesRequest::mutable_columns_to_add() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return &columns_to_add_;
}

// .io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.MatchRule as_of_match_rule = 7;
inline void AsOfJoinTablesRequest::clear_as_of_match_rule() {
  as_of_match_rule_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule AsOfJoinTablesRequest::_internal_as_of_match_rule() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule >(as_of_match_rule_);
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule AsOfJoinTablesRequest::as_of_match_rule() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.as_of_match_rule)
  return _internal_as_of_match_rule();
}
inline void AsOfJoinTablesRequest::_internal_set_as_of_match_rule(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule value) {
  
  as_of_match_rule_ = value;
}
inline void AsOfJoinTablesRequest::set_as_of_match_rule(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule value) {
  _internal_set_as_of_match_rule(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.as_of_match_rule)
}

// -------------------------------------------------------------------

// AjRajTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool AjRajTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool AjRajTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AjRajTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AjRajTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.result_id)
  return _internal_result_id();
}
inline void AjRajTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AjRajTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AjRajTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AjRajTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AjRajTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.result_id)
  return _msg;
}
inline void AjRajTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool AjRajTablesRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool AjRajTablesRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void AjRajTablesRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AjRajTablesRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AjRajTablesRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.left_id)
  return _internal_left_id();
}
inline void AjRajTablesRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.left_id)
  return _msg;
}
inline void AjRajTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool AjRajTablesRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool AjRajTablesRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void AjRajTablesRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AjRajTablesRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AjRajTablesRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.right_id)
  return _internal_right_id();
}
inline void AjRajTablesRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.right_id)
  return _msg;
}
inline void AjRajTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.right_id)
}

// repeated string exact_match_columns = 4;
inline int AjRajTablesRequest::_internal_exact_match_columns_size() const {
  return exact_match_columns_.size();
}
inline int AjRajTablesRequest::exact_match_columns_size() const {
  return _internal_exact_match_columns_size();
}
inline void AjRajTablesRequest::clear_exact_match_columns() {
  exact_match_columns_.Clear();
}
inline std::string* AjRajTablesRequest::add_exact_match_columns() {
  std::string* _s = _internal_add_exact_match_columns();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
  return _s;
}
inline const std::string& AjRajTablesRequest::_internal_exact_match_columns(int index) const {
  return exact_match_columns_.Get(index);
}
inline const std::string& AjRajTablesRequest::exact_match_columns(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
  return _internal_exact_match_columns(index);
}
inline std::string* AjRajTablesRequest::mutable_exact_match_columns(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
  return exact_match_columns_.Mutable(index);
}
inline void AjRajTablesRequest::set_exact_match_columns(int index, const std::string& value) {
  exact_match_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::set_exact_match_columns(int index, std::string&& value) {
  exact_match_columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::set_exact_match_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  exact_match_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::set_exact_match_columns(int index, const char* value, size_t size) {
  exact_match_columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline std::string* AjRajTablesRequest::_internal_add_exact_match_columns() {
  return exact_match_columns_.Add();
}
inline void AjRajTablesRequest::add_exact_match_columns(const std::string& value) {
  exact_match_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::add_exact_match_columns(std::string&& value) {
  exact_match_columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::add_exact_match_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  exact_match_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::add_exact_match_columns(const char* value, size_t size) {
  exact_match_columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AjRajTablesRequest::exact_match_columns() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
  return exact_match_columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AjRajTablesRequest::mutable_exact_match_columns() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
  return &exact_match_columns_;
}

// string as_of_column = 5;
inline void AjRajTablesRequest::clear_as_of_column() {
  as_of_column_.ClearToEmpty();
}
inline const std::string& AjRajTablesRequest::as_of_column() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.as_of_column)
  return _internal_as_of_column();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AjRajTablesRequest::set_as_of_column(ArgT0&& arg0, ArgT... args) {
 
 as_of_column_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.as_of_column)
}
inline std::string* AjRajTablesRequest::mutable_as_of_column() {
  std::string* _s = _internal_mutable_as_of_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.as_of_column)
  return _s;
}
inline const std::string& AjRajTablesRequest::_internal_as_of_column() const {
  return as_of_column_.Get();
}
inline void AjRajTablesRequest::_internal_set_as_of_column(const std::string& value) {
  
  as_of_column_.Set(value, GetArenaForAllocation());
}
inline std::string* AjRajTablesRequest::_internal_mutable_as_of_column() {
  
  return as_of_column_.Mutable(GetArenaForAllocation());
}
inline std::string* AjRajTablesRequest::release_as_of_column() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.as_of_column)
  return as_of_column_.Release();
}
inline void AjRajTablesRequest::set_allocated_as_of_column(std::string* as_of_column) {
  if (as_of_column != nullptr) {
    
  } else {
    
  }
  as_of_column_.SetAllocated(as_of_column, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (as_of_column_.IsDefault()) {
    as_of_column_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.as_of_column)
}

// repeated string columns_to_add = 6;
inline int AjRajTablesRequest::_internal_columns_to_add_size() const {
  return columns_to_add_.size();
}
inline int AjRajTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void AjRajTablesRequest::clear_columns_to_add() {
  columns_to_add_.Clear();
}
inline std::string* AjRajTablesRequest::add_columns_to_add() {
  std::string* _s = _internal_add_columns_to_add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& AjRajTablesRequest::_internal_columns_to_add(int index) const {
  return columns_to_add_.Get(index);
}
inline const std::string& AjRajTablesRequest::columns_to_add(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
  return _internal_columns_to_add(index);
}
inline std::string* AjRajTablesRequest::mutable_columns_to_add(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
  return columns_to_add_.Mutable(index);
}
inline void AjRajTablesRequest::set_columns_to_add(int index, const std::string& value) {
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::set_columns_to_add(int index, std::string&& value) {
  columns_to_add_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::set_columns_to_add(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::set_columns_to_add(int index, const char* value, size_t size) {
  columns_to_add_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline std::string* AjRajTablesRequest::_internal_add_columns_to_add() {
  return columns_to_add_.Add();
}
inline void AjRajTablesRequest::add_columns_to_add(const std::string& value) {
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::add_columns_to_add(std::string&& value) {
  columns_to_add_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::add_columns_to_add(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_add_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::add_columns_to_add(const char* value, size_t size) {
  columns_to_add_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AjRajTablesRequest::columns_to_add() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
  return columns_to_add_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AjRajTablesRequest::mutable_columns_to_add() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
  return &columns_to_add_;
}

// -------------------------------------------------------------------

// RangeJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool RangeJoinTablesRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool RangeJoinTablesRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& RangeJoinTablesRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& RangeJoinTablesRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void RangeJoinTablesRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RangeJoinTablesRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RangeJoinTablesRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RangeJoinTablesRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RangeJoinTablesRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.result_id)
  return _msg;
}
inline void RangeJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool RangeJoinTablesRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool RangeJoinTablesRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void RangeJoinTablesRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RangeJoinTablesRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RangeJoinTablesRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void RangeJoinTablesRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_id)
  return _msg;
}
inline void RangeJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool RangeJoinTablesRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool RangeJoinTablesRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void RangeJoinTablesRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RangeJoinTablesRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RangeJoinTablesRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void RangeJoinTablesRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_id)
  return _msg;
}
inline void RangeJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_id)
}

// repeated string exact_match_columns = 4;
inline int RangeJoinTablesRequest::_internal_exact_match_columns_size() const {
  return exact_match_columns_.size();
}
inline int RangeJoinTablesRequest::exact_match_columns_size() const {
  return _internal_exact_match_columns_size();
}
inline void RangeJoinTablesRequest::clear_exact_match_columns() {
  exact_match_columns_.Clear();
}
inline std::string* RangeJoinTablesRequest::add_exact_match_columns() {
  std::string* _s = _internal_add_exact_match_columns();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
  return _s;
}
inline const std::string& RangeJoinTablesRequest::_internal_exact_match_columns(int index) const {
  return exact_match_columns_.Get(index);
}
inline const std::string& RangeJoinTablesRequest::exact_match_columns(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
  return _internal_exact_match_columns(index);
}
inline std::string* RangeJoinTablesRequest::mutable_exact_match_columns(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
  return exact_match_columns_.Mutable(index);
}
inline void RangeJoinTablesRequest::set_exact_match_columns(int index, const std::string& value) {
  exact_match_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::set_exact_match_columns(int index, std::string&& value) {
  exact_match_columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::set_exact_match_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  exact_match_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::set_exact_match_columns(int index, const char* value, size_t size) {
  exact_match_columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline std::string* RangeJoinTablesRequest::_internal_add_exact_match_columns() {
  return exact_match_columns_.Add();
}
inline void RangeJoinTablesRequest::add_exact_match_columns(const std::string& value) {
  exact_match_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::add_exact_match_columns(std::string&& value) {
  exact_match_columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::add_exact_match_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  exact_match_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::add_exact_match_columns(const char* value, size_t size) {
  exact_match_columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RangeJoinTablesRequest::exact_match_columns() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
  return exact_match_columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RangeJoinTablesRequest::mutable_exact_match_columns() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
  return &exact_match_columns_;
}

// string left_start_column = 5;
inline void RangeJoinTablesRequest::clear_left_start_column() {
  left_start_column_.ClearToEmpty();
}
inline const std::string& RangeJoinTablesRequest::left_start_column() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_start_column)
  return _internal_left_start_column();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeJoinTablesRequest::set_left_start_column(ArgT0&& arg0, ArgT... args) {
 
 left_start_column_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_start_column)
}
inline std::string* RangeJoinTablesRequest::mutable_left_start_column() {
  std::string* _s = _internal_mutable_left_start_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_start_column)
  return _s;
}
inline const std::string& RangeJoinTablesRequest::_internal_left_start_column() const {
  return left_start_column_.Get();
}
inline void RangeJoinTablesRequest::_internal_set_left_start_column(const std::string& value) {
  
  left_start_column_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeJoinTablesRequest::_internal_mutable_left_start_column() {
  
  return left_start_column_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeJoinTablesRequest::release_left_start_column() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_start_column)
  return left_start_column_.Release();
}
inline void RangeJoinTablesRequest::set_allocated_left_start_column(std::string* left_start_column) {
  if (left_start_column != nullptr) {
    
  } else {
    
  }
  left_start_column_.SetAllocated(left_start_column, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (left_start_column_.IsDefault()) {
    left_start_column_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_start_column)
}

// .io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.RangeStartRule range_start_rule = 6;
inline void RangeJoinTablesRequest::clear_range_start_rule() {
  range_start_rule_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule RangeJoinTablesRequest::_internal_range_start_rule() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule >(range_start_rule_);
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule RangeJoinTablesRequest::range_start_rule() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_start_rule)
  return _internal_range_start_rule();
}
inline void RangeJoinTablesRequest::_internal_set_range_start_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule value) {
  
  range_start_rule_ = value;
}
inline void RangeJoinTablesRequest::set_range_start_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule value) {
  _internal_set_range_start_rule(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_start_rule)
}

// string right_range_column = 7;
inline void RangeJoinTablesRequest::clear_right_range_column() {
  right_range_column_.ClearToEmpty();
}
inline const std::string& RangeJoinTablesRequest::right_range_column() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_range_column)
  return _internal_right_range_column();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeJoinTablesRequest::set_right_range_column(ArgT0&& arg0, ArgT... args) {
 
 right_range_column_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_range_column)
}
inline std::string* RangeJoinTablesRequest::mutable_right_range_column() {
  std::string* _s = _internal_mutable_right_range_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_range_column)
  return _s;
}
inline const std::string& RangeJoinTablesRequest::_internal_right_range_column() const {
  return right_range_column_.Get();
}
inline void RangeJoinTablesRequest::_internal_set_right_range_column(const std::string& value) {
  
  right_range_column_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeJoinTablesRequest::_internal_mutable_right_range_column() {
  
  return right_range_column_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeJoinTablesRequest::release_right_range_column() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_range_column)
  return right_range_column_.Release();
}
inline void RangeJoinTablesRequest::set_allocated_right_range_column(std::string* right_range_column) {
  if (right_range_column != nullptr) {
    
  } else {
    
  }
  right_range_column_.SetAllocated(right_range_column, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (right_range_column_.IsDefault()) {
    right_range_column_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_range_column)
}

// .io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.RangeEndRule range_end_rule = 8;
inline void RangeJoinTablesRequest::clear_range_end_rule() {
  range_end_rule_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule RangeJoinTablesRequest::_internal_range_end_rule() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule >(range_end_rule_);
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule RangeJoinTablesRequest::range_end_rule() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_end_rule)
  return _internal_range_end_rule();
}
inline void RangeJoinTablesRequest::_internal_set_range_end_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule value) {
  
  range_end_rule_ = value;
}
inline void RangeJoinTablesRequest::set_range_end_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule value) {
  _internal_set_range_end_rule(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_end_rule)
}

// string left_end_column = 9;
inline void RangeJoinTablesRequest::clear_left_end_column() {
  left_end_column_.ClearToEmpty();
}
inline const std::string& RangeJoinTablesRequest::left_end_column() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_end_column)
  return _internal_left_end_column();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RangeJoinTablesRequest::set_left_end_column(ArgT0&& arg0, ArgT... args) {
 
 left_end_column_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_end_column)
}
inline std::string* RangeJoinTablesRequest::mutable_left_end_column() {
  std::string* _s = _internal_mutable_left_end_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_end_column)
  return _s;
}
inline const std::string& RangeJoinTablesRequest::_internal_left_end_column() const {
  return left_end_column_.Get();
}
inline void RangeJoinTablesRequest::_internal_set_left_end_column(const std::string& value) {
  
  left_end_column_.Set(value, GetArenaForAllocation());
}
inline std::string* RangeJoinTablesRequest::_internal_mutable_left_end_column() {
  
  return left_end_column_.Mutable(GetArenaForAllocation());
}
inline std::string* RangeJoinTablesRequest::release_left_end_column() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_end_column)
  return left_end_column_.Release();
}
inline void RangeJoinTablesRequest::set_allocated_left_end_column(std::string* left_end_column) {
  if (left_end_column != nullptr) {
    
  } else {
    
  }
  left_end_column_.SetAllocated(left_end_column, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (left_end_column_.IsDefault()) {
    left_end_column_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_end_column)
}

// repeated .io.deephaven.proto.backplane.grpc.Aggregation aggregations = 10;
inline int RangeJoinTablesRequest::_internal_aggregations_size() const {
  return aggregations_.size();
}
inline int RangeJoinTablesRequest::aggregations_size() const {
  return _internal_aggregations_size();
}
inline void RangeJoinTablesRequest::clear_aggregations() {
  aggregations_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation* RangeJoinTablesRequest::mutable_aggregations(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.aggregations)
  return aggregations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation >*
RangeJoinTablesRequest::mutable_aggregations() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.aggregations)
  return &aggregations_;
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation& RangeJoinTablesRequest::_internal_aggregations(int index) const {
  return aggregations_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation& RangeJoinTablesRequest::aggregations(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.aggregations)
  return _internal_aggregations(index);
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation* RangeJoinTablesRequest::_internal_add_aggregations() {
  return aggregations_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation* RangeJoinTablesRequest::add_aggregations() {
  ::io::deephaven::proto::backplane::grpc::Aggregation* _add = _internal_add_aggregations();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.aggregations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation >&
RangeJoinTablesRequest::aggregations() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.aggregations)
  return aggregations_;
}

// -------------------------------------------------------------------

// ComboAggregateRequest_Aggregate

// .io.deephaven.proto.backplane.grpc.ComboAggregateRequest.AggType type = 1;
inline void ComboAggregateRequest_Aggregate::clear_type() {
  type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType ComboAggregateRequest_Aggregate::_internal_type() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType >(type_);
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType ComboAggregateRequest_Aggregate::type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.type)
  return _internal_type();
}
inline void ComboAggregateRequest_Aggregate::_internal_set_type(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType value) {
  
  type_ = value;
}
inline void ComboAggregateRequest_Aggregate::set_type(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.type)
}

// repeated string match_pairs = 2;
inline int ComboAggregateRequest_Aggregate::_internal_match_pairs_size() const {
  return match_pairs_.size();
}
inline int ComboAggregateRequest_Aggregate::match_pairs_size() const {
  return _internal_match_pairs_size();
}
inline void ComboAggregateRequest_Aggregate::clear_match_pairs() {
  match_pairs_.Clear();
}
inline std::string* ComboAggregateRequest_Aggregate::add_match_pairs() {
  std::string* _s = _internal_add_match_pairs();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return _s;
}
inline const std::string& ComboAggregateRequest_Aggregate::_internal_match_pairs(int index) const {
  return match_pairs_.Get(index);
}
inline const std::string& ComboAggregateRequest_Aggregate::match_pairs(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return _internal_match_pairs(index);
}
inline std::string* ComboAggregateRequest_Aggregate::mutable_match_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return match_pairs_.Mutable(index);
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, const std::string& value) {
  match_pairs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, std::string&& value) {
  match_pairs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  match_pairs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, const char* value, size_t size) {
  match_pairs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline std::string* ComboAggregateRequest_Aggregate::_internal_add_match_pairs() {
  return match_pairs_.Add();
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(const std::string& value) {
  match_pairs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(std::string&& value) {
  match_pairs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  match_pairs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(const char* value, size_t size) {
  match_pairs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ComboAggregateRequest_Aggregate::match_pairs() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return match_pairs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ComboAggregateRequest_Aggregate::mutable_match_pairs() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return &match_pairs_;
}

// string column_name = 3;
inline void ComboAggregateRequest_Aggregate::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& ComboAggregateRequest_Aggregate::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComboAggregateRequest_Aggregate::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
}
inline std::string* ComboAggregateRequest_Aggregate::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
  return _s;
}
inline const std::string& ComboAggregateRequest_Aggregate::_internal_column_name() const {
  return column_name_.Get();
}
inline void ComboAggregateRequest_Aggregate::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ComboAggregateRequest_Aggregate::_internal_mutable_column_name() {
  
  return column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ComboAggregateRequest_Aggregate::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
  return column_name_.Release();
}
inline void ComboAggregateRequest_Aggregate::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (column_name_.IsDefault()) {
    column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
}

// double percentile = 4;
inline void ComboAggregateRequest_Aggregate::clear_percentile() {
  percentile_ = 0;
}
inline double ComboAggregateRequest_Aggregate::_internal_percentile() const {
  return percentile_;
}
inline double ComboAggregateRequest_Aggregate::percentile() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.percentile)
  return _internal_percentile();
}
inline void ComboAggregateRequest_Aggregate::_internal_set_percentile(double value) {
  
  percentile_ = value;
}
inline void ComboAggregateRequest_Aggregate::set_percentile(double value) {
  _internal_set_percentile(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.percentile)
}

// bool avg_median = 5;
inline void ComboAggregateRequest_Aggregate::clear_avg_median() {
  avg_median_ = false;
}
inline bool ComboAggregateRequest_Aggregate::_internal_avg_median() const {
  return avg_median_;
}
inline bool ComboAggregateRequest_Aggregate::avg_median() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.avg_median)
  return _internal_avg_median();
}
inline void ComboAggregateRequest_Aggregate::_internal_set_avg_median(bool value) {
  
  avg_median_ = value;
}
inline void ComboAggregateRequest_Aggregate::set_avg_median(bool value) {
  _internal_set_avg_median(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.avg_median)
}

// -------------------------------------------------------------------

// ComboAggregateRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool ComboAggregateRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool ComboAggregateRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ComboAggregateRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ComboAggregateRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
  return _internal_result_id();
}
inline void ComboAggregateRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ComboAggregateRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ComboAggregateRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ComboAggregateRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ComboAggregateRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
  return _msg;
}
inline void ComboAggregateRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool ComboAggregateRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool ComboAggregateRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void ComboAggregateRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ComboAggregateRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ComboAggregateRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
  return _internal_source_id();
}
inline void ComboAggregateRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ComboAggregateRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ComboAggregateRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ComboAggregateRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ComboAggregateRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
  return _msg;
}
inline void ComboAggregateRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
}

// repeated .io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate aggregates = 3;
inline int ComboAggregateRequest::_internal_aggregates_size() const {
  return aggregates_.size();
}
inline int ComboAggregateRequest::aggregates_size() const {
  return _internal_aggregates_size();
}
inline void ComboAggregateRequest::clear_aggregates() {
  aggregates_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* ComboAggregateRequest::mutable_aggregates(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return aggregates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate >*
ComboAggregateRequest::mutable_aggregates() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return &aggregates_;
}
inline const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate& ComboAggregateRequest::_internal_aggregates(int index) const {
  return aggregates_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate& ComboAggregateRequest::aggregates(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return _internal_aggregates(index);
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* ComboAggregateRequest::_internal_add_aggregates() {
  return aggregates_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* ComboAggregateRequest::add_aggregates() {
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* _add = _internal_add_aggregates();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate >&
ComboAggregateRequest::aggregates() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return aggregates_;
}

// repeated string group_by_columns = 4;
inline int ComboAggregateRequest::_internal_group_by_columns_size() const {
  return group_by_columns_.size();
}
inline int ComboAggregateRequest::group_by_columns_size() const {
  return _internal_group_by_columns_size();
}
inline void ComboAggregateRequest::clear_group_by_columns() {
  group_by_columns_.Clear();
}
inline std::string* ComboAggregateRequest::add_group_by_columns() {
  std::string* _s = _internal_add_group_by_columns();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return _s;
}
inline const std::string& ComboAggregateRequest::_internal_group_by_columns(int index) const {
  return group_by_columns_.Get(index);
}
inline const std::string& ComboAggregateRequest::group_by_columns(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return _internal_group_by_columns(index);
}
inline std::string* ComboAggregateRequest::mutable_group_by_columns(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return group_by_columns_.Mutable(index);
}
inline void ComboAggregateRequest::set_group_by_columns(int index, const std::string& value) {
  group_by_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::set_group_by_columns(int index, std::string&& value) {
  group_by_columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::set_group_by_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::set_group_by_columns(int index, const char* value, size_t size) {
  group_by_columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline std::string* ComboAggregateRequest::_internal_add_group_by_columns() {
  return group_by_columns_.Add();
}
inline void ComboAggregateRequest::add_group_by_columns(const std::string& value) {
  group_by_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::add_group_by_columns(std::string&& value) {
  group_by_columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::add_group_by_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::add_group_by_columns(const char* value, size_t size) {
  group_by_columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ComboAggregateRequest::group_by_columns() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return group_by_columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ComboAggregateRequest::mutable_group_by_columns() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return &group_by_columns_;
}

// bool force_combo = 5;
inline void ComboAggregateRequest::clear_force_combo() {
  force_combo_ = false;
}
inline bool ComboAggregateRequest::_internal_force_combo() const {
  return force_combo_;
}
inline bool ComboAggregateRequest::force_combo() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.force_combo)
  return _internal_force_combo();
}
inline void ComboAggregateRequest::_internal_set_force_combo(bool value) {
  
  force_combo_ = value;
}
inline void ComboAggregateRequest::set_force_combo(bool value) {
  _internal_set_force_combo(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.force_combo)
}

// -------------------------------------------------------------------

// AggregateAllRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool AggregateAllRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool AggregateAllRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AggregateAllRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AggregateAllRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateAllRequest.result_id)
  return _internal_result_id();
}
inline void AggregateAllRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggregateAllRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateAllRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateAllRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggregateAllRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateAllRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateAllRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateAllRequest.result_id)
  return _msg;
}
inline void AggregateAllRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggregateAllRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool AggregateAllRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool AggregateAllRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void AggregateAllRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AggregateAllRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AggregateAllRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateAllRequest.source_id)
  return _internal_source_id();
}
inline void AggregateAllRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggregateAllRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateAllRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateAllRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggregateAllRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateAllRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateAllRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateAllRequest.source_id)
  return _msg;
}
inline void AggregateAllRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggregateAllRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.AggSpec spec = 3;
inline bool AggregateAllRequest::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool AggregateAllRequest::has_spec() const {
  return _internal_has_spec();
}
inline void AggregateAllRequest::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec& AggregateAllRequest::_internal_spec() const {
  const ::io::deephaven::proto::backplane::grpc::AggSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::AggSpec&>(
      ::io::deephaven::proto::backplane::grpc::_AggSpec_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec& AggregateAllRequest::spec() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateAllRequest.spec)
  return _internal_spec();
}
inline void AggregateAllRequest::unsafe_arena_set_allocated_spec(
    ::io::deephaven::proto::backplane::grpc::AggSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggregateAllRequest.spec)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* AggregateAllRequest::release_spec() {
  
  ::io::deephaven::proto::backplane::grpc::AggSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* AggregateAllRequest::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggregateAllRequest.spec)
  
  ::io::deephaven::proto::backplane::grpc::AggSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* AggregateAllRequest::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* AggregateAllRequest::mutable_spec() {
  ::io::deephaven::proto::backplane::grpc::AggSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateAllRequest.spec)
  return _msg;
}
inline void AggregateAllRequest::set_allocated_spec(::io::deephaven::proto::backplane::grpc::AggSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggregateAllRequest.spec)
}

// repeated string group_by_columns = 4;
inline int AggregateAllRequest::_internal_group_by_columns_size() const {
  return group_by_columns_.size();
}
inline int AggregateAllRequest::group_by_columns_size() const {
  return _internal_group_by_columns_size();
}
inline void AggregateAllRequest::clear_group_by_columns() {
  group_by_columns_.Clear();
}
inline std::string* AggregateAllRequest::add_group_by_columns() {
  std::string* _s = _internal_add_group_by_columns();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
  return _s;
}
inline const std::string& AggregateAllRequest::_internal_group_by_columns(int index) const {
  return group_by_columns_.Get(index);
}
inline const std::string& AggregateAllRequest::group_by_columns(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
  return _internal_group_by_columns(index);
}
inline std::string* AggregateAllRequest::mutable_group_by_columns(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
  return group_by_columns_.Mutable(index);
}
inline void AggregateAllRequest::set_group_by_columns(int index, const std::string& value) {
  group_by_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::set_group_by_columns(int index, std::string&& value) {
  group_by_columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::set_group_by_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::set_group_by_columns(int index, const char* value, size_t size) {
  group_by_columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline std::string* AggregateAllRequest::_internal_add_group_by_columns() {
  return group_by_columns_.Add();
}
inline void AggregateAllRequest::add_group_by_columns(const std::string& value) {
  group_by_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::add_group_by_columns(std::string&& value) {
  group_by_columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::add_group_by_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::add_group_by_columns(const char* value, size_t size) {
  group_by_columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AggregateAllRequest::group_by_columns() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
  return group_by_columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AggregateAllRequest::mutable_group_by_columns() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
  return &group_by_columns_;
}

// -------------------------------------------------------------------

// AggSpec_AggSpecApproximatePercentile

// double percentile = 1;
inline void AggSpec_AggSpecApproximatePercentile::clear_percentile() {
  percentile_ = 0;
}
inline double AggSpec_AggSpecApproximatePercentile::_internal_percentile() const {
  return percentile_;
}
inline double AggSpec_AggSpecApproximatePercentile::percentile() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile.percentile)
  return _internal_percentile();
}
inline void AggSpec_AggSpecApproximatePercentile::_internal_set_percentile(double value) {
  
  percentile_ = value;
}
inline void AggSpec_AggSpecApproximatePercentile::set_percentile(double value) {
  _internal_set_percentile(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile.percentile)
}

// optional double compression = 2;
inline bool AggSpec_AggSpecApproximatePercentile::_internal_has_compression() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AggSpec_AggSpecApproximatePercentile::has_compression() const {
  return _internal_has_compression();
}
inline void AggSpec_AggSpecApproximatePercentile::clear_compression() {
  compression_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double AggSpec_AggSpecApproximatePercentile::_internal_compression() const {
  return compression_;
}
inline double AggSpec_AggSpecApproximatePercentile::compression() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile.compression)
  return _internal_compression();
}
inline void AggSpec_AggSpecApproximatePercentile::_internal_set_compression(double value) {
  _has_bits_[0] |= 0x00000001u;
  compression_ = value;
}
inline void AggSpec_AggSpecApproximatePercentile::set_compression(double value) {
  _internal_set_compression(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile.compression)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecCountDistinct

// bool count_nulls = 1;
inline void AggSpec_AggSpecCountDistinct::clear_count_nulls() {
  count_nulls_ = false;
}
inline bool AggSpec_AggSpecCountDistinct::_internal_count_nulls() const {
  return count_nulls_;
}
inline bool AggSpec_AggSpecCountDistinct::count_nulls() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct.count_nulls)
  return _internal_count_nulls();
}
inline void AggSpec_AggSpecCountDistinct::_internal_set_count_nulls(bool value) {
  
  count_nulls_ = value;
}
inline void AggSpec_AggSpecCountDistinct::set_count_nulls(bool value) {
  _internal_set_count_nulls(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct.count_nulls)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecDistinct

// bool include_nulls = 1;
inline void AggSpec_AggSpecDistinct::clear_include_nulls() {
  include_nulls_ = false;
}
inline bool AggSpec_AggSpecDistinct::_internal_include_nulls() const {
  return include_nulls_;
}
inline bool AggSpec_AggSpecDistinct::include_nulls() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct.include_nulls)
  return _internal_include_nulls();
}
inline void AggSpec_AggSpecDistinct::_internal_set_include_nulls(bool value) {
  
  include_nulls_ = value;
}
inline void AggSpec_AggSpecDistinct::set_include_nulls(bool value) {
  _internal_set_include_nulls(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct.include_nulls)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecFormula

// string formula = 1;
inline void AggSpec_AggSpecFormula::clear_formula() {
  formula_.ClearToEmpty();
}
inline const std::string& AggSpec_AggSpecFormula::formula() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.formula)
  return _internal_formula();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggSpec_AggSpecFormula::set_formula(ArgT0&& arg0, ArgT... args) {
 
 formula_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.formula)
}
inline std::string* AggSpec_AggSpecFormula::mutable_formula() {
  std::string* _s = _internal_mutable_formula();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.formula)
  return _s;
}
inline const std::string& AggSpec_AggSpecFormula::_internal_formula() const {
  return formula_.Get();
}
inline void AggSpec_AggSpecFormula::_internal_set_formula(const std::string& value) {
  
  formula_.Set(value, GetArenaForAllocation());
}
inline std::string* AggSpec_AggSpecFormula::_internal_mutable_formula() {
  
  return formula_.Mutable(GetArenaForAllocation());
}
inline std::string* AggSpec_AggSpecFormula::release_formula() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.formula)
  return formula_.Release();
}
inline void AggSpec_AggSpecFormula::set_allocated_formula(std::string* formula) {
  if (formula != nullptr) {
    
  } else {
    
  }
  formula_.SetAllocated(formula, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (formula_.IsDefault()) {
    formula_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.formula)
}

// string param_token = 2;
inline void AggSpec_AggSpecFormula::clear_param_token() {
  param_token_.ClearToEmpty();
}
inline const std::string& AggSpec_AggSpecFormula::param_token() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.param_token)
  return _internal_param_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggSpec_AggSpecFormula::set_param_token(ArgT0&& arg0, ArgT... args) {
 
 param_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.param_token)
}
inline std::string* AggSpec_AggSpecFormula::mutable_param_token() {
  std::string* _s = _internal_mutable_param_token();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.param_token)
  return _s;
}
inline const std::string& AggSpec_AggSpecFormula::_internal_param_token() const {
  return param_token_.Get();
}
inline void AggSpec_AggSpecFormula::_internal_set_param_token(const std::string& value) {
  
  param_token_.Set(value, GetArenaForAllocation());
}
inline std::string* AggSpec_AggSpecFormula::_internal_mutable_param_token() {
  
  return param_token_.Mutable(GetArenaForAllocation());
}
inline std::string* AggSpec_AggSpecFormula::release_param_token() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.param_token)
  return param_token_.Release();
}
inline void AggSpec_AggSpecFormula::set_allocated_param_token(std::string* param_token) {
  if (param_token != nullptr) {
    
  } else {
    
  }
  param_token_.SetAllocated(param_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (param_token_.IsDefault()) {
    param_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.param_token)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecMedian

// bool average_evenly_divided = 1;
inline void AggSpec_AggSpecMedian::clear_average_evenly_divided() {
  average_evenly_divided_ = false;
}
inline bool AggSpec_AggSpecMedian::_internal_average_evenly_divided() const {
  return average_evenly_divided_;
}
inline bool AggSpec_AggSpecMedian::average_evenly_divided() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian.average_evenly_divided)
  return _internal_average_evenly_divided();
}
inline void AggSpec_AggSpecMedian::_internal_set_average_evenly_divided(bool value) {
  
  average_evenly_divided_ = value;
}
inline void AggSpec_AggSpecMedian::set_average_evenly_divided(bool value) {
  _internal_set_average_evenly_divided(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian.average_evenly_divided)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecPercentile

// double percentile = 1;
inline void AggSpec_AggSpecPercentile::clear_percentile() {
  percentile_ = 0;
}
inline double AggSpec_AggSpecPercentile::_internal_percentile() const {
  return percentile_;
}
inline double AggSpec_AggSpecPercentile::percentile() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile.percentile)
  return _internal_percentile();
}
inline void AggSpec_AggSpecPercentile::_internal_set_percentile(double value) {
  
  percentile_ = value;
}
inline void AggSpec_AggSpecPercentile::set_percentile(double value) {
  _internal_set_percentile(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile.percentile)
}

// bool average_evenly_divided = 2;
inline void AggSpec_AggSpecPercentile::clear_average_evenly_divided() {
  average_evenly_divided_ = false;
}
inline bool AggSpec_AggSpecPercentile::_internal_average_evenly_divided() const {
  return average_evenly_divided_;
}
inline bool AggSpec_AggSpecPercentile::average_evenly_divided() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile.average_evenly_divided)
  return _internal_average_evenly_divided();
}
inline void AggSpec_AggSpecPercentile::_internal_set_average_evenly_divided(bool value) {
  
  average_evenly_divided_ = value;
}
inline void AggSpec_AggSpecPercentile::set_average_evenly_divided(bool value) {
  _internal_set_average_evenly_divided(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile.average_evenly_divided)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecSorted

// repeated .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn columns = 1;
inline int AggSpec_AggSpecSorted::_internal_columns_size() const {
  return columns_.size();
}
inline int AggSpec_AggSpecSorted::columns_size() const {
  return _internal_columns_size();
}
inline void AggSpec_AggSpecSorted::clear_columns() {
  columns_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* AggSpec_AggSpecSorted::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted.columns)
  return columns_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn >*
AggSpec_AggSpecSorted::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted.columns)
  return &columns_;
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn& AggSpec_AggSpecSorted::_internal_columns(int index) const {
  return columns_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn& AggSpec_AggSpecSorted::columns(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted.columns)
  return _internal_columns(index);
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* AggSpec_AggSpecSorted::_internal_add_columns() {
  return columns_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* AggSpec_AggSpecSorted::add_columns() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* _add = _internal_add_columns();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted.columns)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn >&
AggSpec_AggSpecSorted::columns() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted.columns)
  return columns_;
}

// -------------------------------------------------------------------

// AggSpec_AggSpecSortedColumn

// string column_name = 1;
inline void AggSpec_AggSpecSortedColumn::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& AggSpec_AggSpecSortedColumn::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggSpec_AggSpecSortedColumn::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn.column_name)
}
inline std::string* AggSpec_AggSpecSortedColumn::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn.column_name)
  return _s;
}
inline const std::string& AggSpec_AggSpecSortedColumn::_internal_column_name() const {
  return column_name_.Get();
}
inline void AggSpec_AggSpecSortedColumn::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AggSpec_AggSpecSortedColumn::_internal_mutable_column_name() {
  
  return column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AggSpec_AggSpecSortedColumn::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn.column_name)
  return column_name_.Release();
}
inline void AggSpec_AggSpecSortedColumn::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (column_name_.IsDefault()) {
    column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn.column_name)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecTDigest

// optional double compression = 1;
inline bool AggSpec_AggSpecTDigest::_internal_has_compression() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AggSpec_AggSpecTDigest::has_compression() const {
  return _internal_has_compression();
}
inline void AggSpec_AggSpecTDigest::clear_compression() {
  compression_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double AggSpec_AggSpecTDigest::_internal_compression() const {
  return compression_;
}
inline double AggSpec_AggSpecTDigest::compression() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest.compression)
  return _internal_compression();
}
inline void AggSpec_AggSpecTDigest::_internal_set_compression(double value) {
  _has_bits_[0] |= 0x00000001u;
  compression_ = value;
}
inline void AggSpec_AggSpecTDigest::set_compression(double value) {
  _internal_set_compression(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest.compression)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecUnique

// bool include_nulls = 1;
inline void AggSpec_AggSpecUnique::clear_include_nulls() {
  include_nulls_ = false;
}
inline bool AggSpec_AggSpecUnique::_internal_include_nulls() const {
  return include_nulls_;
}
inline bool AggSpec_AggSpecUnique::include_nulls() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.include_nulls)
  return _internal_include_nulls();
}
inline void AggSpec_AggSpecUnique::_internal_set_include_nulls(bool value) {
  
  include_nulls_ = value;
}
inline void AggSpec_AggSpecUnique::set_include_nulls(bool value) {
  _internal_set_include_nulls(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.include_nulls)
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel non_unique_sentinel = 2;
inline bool AggSpec_AggSpecUnique::_internal_has_non_unique_sentinel() const {
  return this != internal_default_instance() && non_unique_sentinel_ != nullptr;
}
inline bool AggSpec_AggSpecUnique::has_non_unique_sentinel() const {
  return _internal_has_non_unique_sentinel();
}
inline void AggSpec_AggSpecUnique::clear_non_unique_sentinel() {
  if (GetArenaForAllocation() == nullptr && non_unique_sentinel_ != nullptr) {
    delete non_unique_sentinel_;
  }
  non_unique_sentinel_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel& AggSpec_AggSpecUnique::_internal_non_unique_sentinel() const {
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* p = non_unique_sentinel_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel&>(
      ::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecNonUniqueSentinel_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel& AggSpec_AggSpecUnique::non_unique_sentinel() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.non_unique_sentinel)
  return _internal_non_unique_sentinel();
}
inline void AggSpec_AggSpecUnique::unsafe_arena_set_allocated_non_unique_sentinel(
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* non_unique_sentinel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(non_unique_sentinel_);
  }
  non_unique_sentinel_ = non_unique_sentinel;
  if (non_unique_sentinel) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.non_unique_sentinel)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* AggSpec_AggSpecUnique::release_non_unique_sentinel() {
  
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* temp = non_unique_sentinel_;
  non_unique_sentinel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* AggSpec_AggSpecUnique::unsafe_arena_release_non_unique_sentinel() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.non_unique_sentinel)
  
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* temp = non_unique_sentinel_;
  non_unique_sentinel_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* AggSpec_AggSpecUnique::_internal_mutable_non_unique_sentinel() {
  
  if (non_unique_sentinel_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel>(GetArenaForAllocation());
    non_unique_sentinel_ = p;
  }
  return non_unique_sentinel_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* AggSpec_AggSpecUnique::mutable_non_unique_sentinel() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* _msg = _internal_mutable_non_unique_sentinel();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.non_unique_sentinel)
  return _msg;
}
inline void AggSpec_AggSpecUnique::set_allocated_non_unique_sentinel(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* non_unique_sentinel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete non_unique_sentinel_;
  }
  if (non_unique_sentinel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(non_unique_sentinel);
    if (message_arena != submessage_arena) {
      non_unique_sentinel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, non_unique_sentinel, submessage_arena);
    }
    
  } else {
    
  }
  non_unique_sentinel_ = non_unique_sentinel;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.non_unique_sentinel)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecNonUniqueSentinel

// .io.deephaven.proto.backplane.grpc.NullValue null_value = 1;
inline bool AggSpec_AggSpecNonUniqueSentinel::_internal_has_null_value() const {
  return type_case() == kNullValue;
}
inline bool AggSpec_AggSpecNonUniqueSentinel::has_null_value() const {
  return _internal_has_null_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_null_value() {
  _oneof_case_[0] = kNullValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_null_value() {
  if (_internal_has_null_value()) {
    type_.null_value_ = 0;
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::NullValue AggSpec_AggSpecNonUniqueSentinel::_internal_null_value() const {
  if (_internal_has_null_value()) {
    return static_cast< ::io::deephaven::proto::backplane::grpc::NullValue >(type_.null_value_);
  }
  return static_cast< ::io::deephaven::proto::backplane::grpc::NullValue >(0);
}
inline ::io::deephaven::proto::backplane::grpc::NullValue AggSpec_AggSpecNonUniqueSentinel::null_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.null_value)
  return _internal_null_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_null_value(::io::deephaven::proto::backplane::grpc::NullValue value) {
  if (!_internal_has_null_value()) {
    clear_type();
    set_has_null_value();
  }
  type_.null_value_ = value;
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_null_value(::io::deephaven::proto::backplane::grpc::NullValue value) {
  _internal_set_null_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.null_value)
}

// string string_value = 2;
inline bool AggSpec_AggSpecNonUniqueSentinel::_internal_has_string_value() const {
  return type_case() == kStringValue;
}
inline bool AggSpec_AggSpecNonUniqueSentinel::has_string_value() const {
  return _internal_has_string_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_string_value() {
  if (_internal_has_string_value()) {
    type_.string_value_.Destroy();
    clear_has_type();
  }
}
inline const std::string& AggSpec_AggSpecNonUniqueSentinel::string_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.string_value)
  return _internal_string_value();
}
template <typename ArgT0, typename... ArgT>
inline void AggSpec_AggSpecNonUniqueSentinel::set_string_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_value()) {
    clear_type();
    set_has_string_value();
    type_.string_value_.InitDefault();
  }
  type_.string_value_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.string_value)
}
inline std::string* AggSpec_AggSpecNonUniqueSentinel::mutable_string_value() {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.string_value)
  return _s;
}
inline const std::string& AggSpec_AggSpecNonUniqueSentinel::_internal_string_value() const {
  if (_internal_has_string_value()) {
    return type_.string_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_string_value(const std::string& value) {
  if (!_internal_has_string_value()) {
    clear_type();
    set_has_string_value();
    type_.string_value_.InitDefault();
  }
  type_.string_value_.Set(value, GetArenaForAllocation());
}
inline std::string* AggSpec_AggSpecNonUniqueSentinel::_internal_mutable_string_value() {
  if (!_internal_has_string_value()) {
    clear_type();
    set_has_string_value();
    type_.string_value_.InitDefault();
  }
  return type_.string_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* AggSpec_AggSpecNonUniqueSentinel::release_string_value() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.string_value)
  if (_internal_has_string_value()) {
    clear_has_type();
    return type_.string_value_.Release();
  } else {
    return nullptr;
  }
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_allocated_string_value(std::string* string_value) {
  if (has_type()) {
    clear_type();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    type_.string_value_.InitAllocated(string_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.string_value)
}

// sint32 int_value = 3;
inline bool AggSpec_AggSpecNonUniqueSentinel::_internal_has_int_value() const {
  return type_case() == kIntValue;
}
inline bool AggSpec_AggSpecNonUniqueSentinel::has_int_value() const {
  return _internal_has_int_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_int_value() {
  _oneof_case_[0] = kIntValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_int_value() {
  if (_internal_has_int_value()) {
    type_.int_value_ = 0;
    clear_has_type();
  }
}
inline int32_t AggSpec_AggSpecNonUniqueSentinel::_internal_int_value() const {
  if (_internal_has_int_value()) {
    return type_.int_value_;
  }
  return 0;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_int_value(int32_t value) {
  if (!_internal_has_int_value()) {
    clear_type();
    set_has_int_value();
  }
  type_.int_value_ = value;
}
inline int32_t AggSpec_AggSpecNonUniqueSentinel::int_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.int_value)
  return _internal_int_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_int_value(int32_t value) {
  _internal_set_int_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.int_value)
}

// sint64 long_value = 4 [jstype = JS_STRING];
inline bool AggSpec_AggSpecNonUniqueSentinel::_internal_has_long_value() const {
  return type_case() == kLongValue;
}
inline bool AggSpec_AggSpecNonUniqueSentinel::has_long_value() const {
  return _internal_has_long_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_long_value() {
  _oneof_case_[0] = kLongValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_long_value() {
  if (_internal_has_long_value()) {
    type_.long_value_ = int64_t{0};
    clear_has_type();
  }
}
inline int64_t AggSpec_AggSpecNonUniqueSentinel::_internal_long_value() const {
  if (_internal_has_long_value()) {
    return type_.long_value_;
  }
  return int64_t{0};
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_long_value(int64_t value) {
  if (!_internal_has_long_value()) {
    clear_type();
    set_has_long_value();
  }
  type_.long_value_ = value;
}
inline int64_t AggSpec_AggSpecNonUniqueSentinel::long_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.long_value)
  return _internal_long_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_long_value(int64_t value) {
  _internal_set_long_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.long_value)
}

// float float_value = 5;
inline bool AggSpec_AggSpecNonUniqueSentinel::_internal_has_float_value() const {
  return type_case() == kFloatValue;
}
inline bool AggSpec_AggSpecNonUniqueSentinel::has_float_value() const {
  return _internal_has_float_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_float_value() {
  if (_internal_has_float_value()) {
    type_.float_value_ = 0;
    clear_has_type();
  }
}
inline float AggSpec_AggSpecNonUniqueSentinel::_internal_float_value() const {
  if (_internal_has_float_value()) {
    return type_.float_value_;
  }
  return 0;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_float_value(float value) {
  if (!_internal_has_float_value()) {
    clear_type();
    set_has_float_value();
  }
  type_.float_value_ = value;
}
inline float AggSpec_AggSpecNonUniqueSentinel::float_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.float_value)
  return _internal_float_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_float_value(float value) {
  _internal_set_float_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.float_value)
}

// double double_value = 6;
inline bool AggSpec_AggSpecNonUniqueSentinel::_internal_has_double_value() const {
  return type_case() == kDoubleValue;
}
inline bool AggSpec_AggSpecNonUniqueSentinel::has_double_value() const {
  return _internal_has_double_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_double_value() {
  if (_internal_has_double_value()) {
    type_.double_value_ = 0;
    clear_has_type();
  }
}
inline double AggSpec_AggSpecNonUniqueSentinel::_internal_double_value() const {
  if (_internal_has_double_value()) {
    return type_.double_value_;
  }
  return 0;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_double_value(double value) {
  if (!_internal_has_double_value()) {
    clear_type();
    set_has_double_value();
  }
  type_.double_value_ = value;
}
inline double AggSpec_AggSpecNonUniqueSentinel::double_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.double_value)
  return _internal_double_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.double_value)
}

// bool bool_value = 7;
inline bool AggSpec_AggSpecNonUniqueSentinel::_internal_has_bool_value() const {
  return type_case() == kBoolValue;
}
inline bool AggSpec_AggSpecNonUniqueSentinel::has_bool_value() const {
  return _internal_has_bool_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_bool_value() {
  _oneof_case_[0] = kBoolValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_bool_value() {
  if (_internal_has_bool_value()) {
    type_.bool_value_ = false;
    clear_has_type();
  }
}
inline bool AggSpec_AggSpecNonUniqueSentinel::_internal_bool_value() const {
  if (_internal_has_bool_value()) {
    return type_.bool_value_;
  }
  return false;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_bool_value(bool value) {
  if (!_internal_has_bool_value()) {
    clear_type();
    set_has_bool_value();
  }
  type_.bool_value_ = value;
}
inline bool AggSpec_AggSpecNonUniqueSentinel::bool_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.bool_value)
  return _internal_bool_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.bool_value)
}

// sint32 byte_value = 8;
inline bool AggSpec_AggSpecNonUniqueSentinel::_internal_has_byte_value() const {
  return type_case() == kByteValue;
}
inline bool AggSpec_AggSpecNonUniqueSentinel::has_byte_value() const {
  return _internal_has_byte_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_byte_value() {
  _oneof_case_[0] = kByteValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_byte_value() {
  if (_internal_has_byte_value()) {
    type_.byte_value_ = 0;
    clear_has_type();
  }
}
inline int32_t AggSpec_AggSpecNonUniqueSentinel::_internal_byte_value() const {
  if (_internal_has_byte_value()) {
    return type_.byte_value_;
  }
  return 0;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_byte_value(int32_t value) {
  if (!_internal_has_byte_value()) {
    clear_type();
    set_has_byte_value();
  }
  type_.byte_value_ = value;
}
inline int32_t AggSpec_AggSpecNonUniqueSentinel::byte_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.byte_value)
  return _internal_byte_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_byte_value(int32_t value) {
  _internal_set_byte_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.byte_value)
}

// sint32 short_value = 9;
inline bool AggSpec_AggSpecNonUniqueSentinel::_internal_has_short_value() const {
  return type_case() == kShortValue;
}
inline bool AggSpec_AggSpecNonUniqueSentinel::has_short_value() const {
  return _internal_has_short_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_short_value() {
  _oneof_case_[0] = kShortValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_short_value() {
  if (_internal_has_short_value()) {
    type_.short_value_ = 0;
    clear_has_type();
  }
}
inline int32_t AggSpec_AggSpecNonUniqueSentinel::_internal_short_value() const {
  if (_internal_has_short_value()) {
    return type_.short_value_;
  }
  return 0;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_short_value(int32_t value) {
  if (!_internal_has_short_value()) {
    clear_type();
    set_has_short_value();
  }
  type_.short_value_ = value;
}
inline int32_t AggSpec_AggSpecNonUniqueSentinel::short_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.short_value)
  return _internal_short_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_short_value(int32_t value) {
  _internal_set_short_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.short_value)
}

// sint32 char_value = 10;
inline bool AggSpec_AggSpecNonUniqueSentinel::_internal_has_char_value() const {
  return type_case() == kCharValue;
}
inline bool AggSpec_AggSpecNonUniqueSentinel::has_char_value() const {
  return _internal_has_char_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_char_value() {
  _oneof_case_[0] = kCharValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_char_value() {
  if (_internal_has_char_value()) {
    type_.char_value_ = 0;
    clear_has_type();
  }
}
inline int32_t AggSpec_AggSpecNonUniqueSentinel::_internal_char_value() const {
  if (_internal_has_char_value()) {
    return type_.char_value_;
  }
  return 0;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_char_value(int32_t value) {
  if (!_internal_has_char_value()) {
    clear_type();
    set_has_char_value();
  }
  type_.char_value_ = value;
}
inline int32_t AggSpec_AggSpecNonUniqueSentinel::char_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.char_value)
  return _internal_char_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_char_value(int32_t value) {
  _internal_set_char_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.char_value)
}

inline bool AggSpec_AggSpecNonUniqueSentinel::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline AggSpec_AggSpecNonUniqueSentinel::TypeCase AggSpec_AggSpecNonUniqueSentinel::type_case() const {
  return AggSpec_AggSpecNonUniqueSentinel::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AggSpec_AggSpecWeighted

// string weight_column = 1;
inline void AggSpec_AggSpecWeighted::clear_weight_column() {
  weight_column_.ClearToEmpty();
}
inline const std::string& AggSpec_AggSpecWeighted::weight_column() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted.weight_column)
  return _internal_weight_column();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AggSpec_AggSpecWeighted::set_weight_column(ArgT0&& arg0, ArgT... args) {
 
 weight_column_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted.weight_column)
}
inline std::string* AggSpec_AggSpecWeighted::mutable_weight_column() {
  std::string* _s = _internal_mutable_weight_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted.weight_column)
  return _s;
}
inline const std::string& AggSpec_AggSpecWeighted::_internal_weight_column() const {
  return weight_column_.Get();
}
inline void AggSpec_AggSpecWeighted::_internal_set_weight_column(const std::string& value) {
  
  weight_column_.Set(value, GetArenaForAllocation());
}
inline std::string* AggSpec_AggSpecWeighted::_internal_mutable_weight_column() {
  
  return weight_column_.Mutable(GetArenaForAllocation());
}
inline std::string* AggSpec_AggSpecWeighted::release_weight_column() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted.weight_column)
  return weight_column_.Release();
}
inline void AggSpec_AggSpecWeighted::set_allocated_weight_column(std::string* weight_column) {
  if (weight_column != nullptr) {
    
  } else {
    
  }
  weight_column_.SetAllocated(weight_column, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (weight_column_.IsDefault()) {
    weight_column_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted.weight_column)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecAbsSum

// -------------------------------------------------------------------

// AggSpec_AggSpecAvg

// -------------------------------------------------------------------

// AggSpec_AggSpecFirst

// -------------------------------------------------------------------

// AggSpec_AggSpecFreeze

// -------------------------------------------------------------------

// AggSpec_AggSpecGroup

// -------------------------------------------------------------------

// AggSpec_AggSpecLast

// -------------------------------------------------------------------

// AggSpec_AggSpecMax

// -------------------------------------------------------------------

// AggSpec_AggSpecMin

// -------------------------------------------------------------------

// AggSpec_AggSpecStd

// -------------------------------------------------------------------

// AggSpec_AggSpecSum

// -------------------------------------------------------------------

// AggSpec_AggSpecVar

// -------------------------------------------------------------------

// AggSpec

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAbsSum abs_sum = 1;
inline bool AggSpec::_internal_has_abs_sum() const {
  return type_case() == kAbsSum;
}
inline bool AggSpec::has_abs_sum() const {
  return _internal_has_abs_sum();
}
inline void AggSpec::set_has_abs_sum() {
  _oneof_case_[0] = kAbsSum;
}
inline void AggSpec::clear_abs_sum() {
  if (_internal_has_abs_sum()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.abs_sum_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* AggSpec::release_abs_sum() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.abs_sum)
  if (_internal_has_abs_sum()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* temp = type_.abs_sum_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.abs_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum& AggSpec::_internal_abs_sum() const {
  return _internal_has_abs_sum()
      ? *type_.abs_sum_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecAbsSum_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum& AggSpec::abs_sum() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.abs_sum)
  return _internal_abs_sum();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* AggSpec::unsafe_arena_release_abs_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.abs_sum)
  if (_internal_has_abs_sum()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* temp = type_.abs_sum_;
    type_.abs_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_abs_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* abs_sum) {
  clear_type();
  if (abs_sum) {
    set_has_abs_sum();
    type_.abs_sum_ = abs_sum;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.abs_sum)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* AggSpec::_internal_mutable_abs_sum() {
  if (!_internal_has_abs_sum()) {
    clear_type();
    set_has_abs_sum();
    type_.abs_sum_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum >(GetArenaForAllocation());
  }
  return type_.abs_sum_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* AggSpec::mutable_abs_sum() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* _msg = _internal_mutable_abs_sum();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.abs_sum)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile approximate_percentile = 2;
inline bool AggSpec::_internal_has_approximate_percentile() const {
  return type_case() == kApproximatePercentile;
}
inline bool AggSpec::has_approximate_percentile() const {
  return _internal_has_approximate_percentile();
}
inline void AggSpec::set_has_approximate_percentile() {
  _oneof_case_[0] = kApproximatePercentile;
}
inline void AggSpec::clear_approximate_percentile() {
  if (_internal_has_approximate_percentile()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.approximate_percentile_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* AggSpec::release_approximate_percentile() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.approximate_percentile)
  if (_internal_has_approximate_percentile()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* temp = type_.approximate_percentile_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.approximate_percentile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile& AggSpec::_internal_approximate_percentile() const {
  return _internal_has_approximate_percentile()
      ? *type_.approximate_percentile_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecApproximatePercentile_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile& AggSpec::approximate_percentile() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.approximate_percentile)
  return _internal_approximate_percentile();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* AggSpec::unsafe_arena_release_approximate_percentile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.approximate_percentile)
  if (_internal_has_approximate_percentile()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* temp = type_.approximate_percentile_;
    type_.approximate_percentile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_approximate_percentile(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* approximate_percentile) {
  clear_type();
  if (approximate_percentile) {
    set_has_approximate_percentile();
    type_.approximate_percentile_ = approximate_percentile;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.approximate_percentile)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* AggSpec::_internal_mutable_approximate_percentile() {
  if (!_internal_has_approximate_percentile()) {
    clear_type();
    set_has_approximate_percentile();
    type_.approximate_percentile_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile >(GetArenaForAllocation());
  }
  return type_.approximate_percentile_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* AggSpec::mutable_approximate_percentile() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* _msg = _internal_mutable_approximate_percentile();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.approximate_percentile)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAvg avg = 3;
inline bool AggSpec::_internal_has_avg() const {
  return type_case() == kAvg;
}
inline bool AggSpec::has_avg() const {
  return _internal_has_avg();
}
inline void AggSpec::set_has_avg() {
  _oneof_case_[0] = kAvg;
}
inline void AggSpec::clear_avg() {
  if (_internal_has_avg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.avg_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* AggSpec::release_avg() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.avg)
  if (_internal_has_avg()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* temp = type_.avg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.avg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg& AggSpec::_internal_avg() const {
  return _internal_has_avg()
      ? *type_.avg_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecAvg_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg& AggSpec::avg() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.avg)
  return _internal_avg();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* AggSpec::unsafe_arena_release_avg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.avg)
  if (_internal_has_avg()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* temp = type_.avg_;
    type_.avg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_avg(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* avg) {
  clear_type();
  if (avg) {
    set_has_avg();
    type_.avg_ = avg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.avg)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* AggSpec::_internal_mutable_avg() {
  if (!_internal_has_avg()) {
    clear_type();
    set_has_avg();
    type_.avg_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg >(GetArenaForAllocation());
  }
  return type_.avg_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* AggSpec::mutable_avg() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* _msg = _internal_mutable_avg();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.avg)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct count_distinct = 4;
inline bool AggSpec::_internal_has_count_distinct() const {
  return type_case() == kCountDistinct;
}
inline bool AggSpec::has_count_distinct() const {
  return _internal_has_count_distinct();
}
inline void AggSpec::set_has_count_distinct() {
  _oneof_case_[0] = kCountDistinct;
}
inline void AggSpec::clear_count_distinct() {
  if (_internal_has_count_distinct()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.count_distinct_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* AggSpec::release_count_distinct() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.count_distinct)
  if (_internal_has_count_distinct()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* temp = type_.count_distinct_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.count_distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct& AggSpec::_internal_count_distinct() const {
  return _internal_has_count_distinct()
      ? *type_.count_distinct_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecCountDistinct_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct& AggSpec::count_distinct() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.count_distinct)
  return _internal_count_distinct();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* AggSpec::unsafe_arena_release_count_distinct() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.count_distinct)
  if (_internal_has_count_distinct()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* temp = type_.count_distinct_;
    type_.count_distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_count_distinct(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* count_distinct) {
  clear_type();
  if (count_distinct) {
    set_has_count_distinct();
    type_.count_distinct_ = count_distinct;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.count_distinct)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* AggSpec::_internal_mutable_count_distinct() {
  if (!_internal_has_count_distinct()) {
    clear_type();
    set_has_count_distinct();
    type_.count_distinct_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct >(GetArenaForAllocation());
  }
  return type_.count_distinct_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* AggSpec::mutable_count_distinct() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* _msg = _internal_mutable_count_distinct();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.count_distinct)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct distinct = 5;
inline bool AggSpec::_internal_has_distinct() const {
  return type_case() == kDistinct;
}
inline bool AggSpec::has_distinct() const {
  return _internal_has_distinct();
}
inline void AggSpec::set_has_distinct() {
  _oneof_case_[0] = kDistinct;
}
inline void AggSpec::clear_distinct() {
  if (_internal_has_distinct()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.distinct_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* AggSpec::release_distinct() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.distinct)
  if (_internal_has_distinct()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* temp = type_.distinct_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct& AggSpec::_internal_distinct() const {
  return _internal_has_distinct()
      ? *type_.distinct_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecDistinct_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct& AggSpec::distinct() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.distinct)
  return _internal_distinct();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* AggSpec::unsafe_arena_release_distinct() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.distinct)
  if (_internal_has_distinct()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* temp = type_.distinct_;
    type_.distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_distinct(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* distinct) {
  clear_type();
  if (distinct) {
    set_has_distinct();
    type_.distinct_ = distinct;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.distinct)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* AggSpec::_internal_mutable_distinct() {
  if (!_internal_has_distinct()) {
    clear_type();
    set_has_distinct();
    type_.distinct_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct >(GetArenaForAllocation());
  }
  return type_.distinct_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* AggSpec::mutable_distinct() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* _msg = _internal_mutable_distinct();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.distinct)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFirst first = 6;
inline bool AggSpec::_internal_has_first() const {
  return type_case() == kFirst;
}
inline bool AggSpec::has_first() const {
  return _internal_has_first();
}
inline void AggSpec::set_has_first() {
  _oneof_case_[0] = kFirst;
}
inline void AggSpec::clear_first() {
  if (_internal_has_first()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.first_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* AggSpec::release_first() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.first)
  if (_internal_has_first()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* temp = type_.first_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst& AggSpec::_internal_first() const {
  return _internal_has_first()
      ? *type_.first_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecFirst_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst& AggSpec::first() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.first)
  return _internal_first();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* AggSpec::unsafe_arena_release_first() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.first)
  if (_internal_has_first()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* temp = type_.first_;
    type_.first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_first(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* first) {
  clear_type();
  if (first) {
    set_has_first();
    type_.first_ = first;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.first)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* AggSpec::_internal_mutable_first() {
  if (!_internal_has_first()) {
    clear_type();
    set_has_first();
    type_.first_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst >(GetArenaForAllocation());
  }
  return type_.first_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* AggSpec::mutable_first() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* _msg = _internal_mutable_first();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.first)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula formula = 7;
inline bool AggSpec::_internal_has_formula() const {
  return type_case() == kFormula;
}
inline bool AggSpec::has_formula() const {
  return _internal_has_formula();
}
inline void AggSpec::set_has_formula() {
  _oneof_case_[0] = kFormula;
}
inline void AggSpec::clear_formula() {
  if (_internal_has_formula()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.formula_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* AggSpec::release_formula() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.formula)
  if (_internal_has_formula()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* temp = type_.formula_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.formula_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula& AggSpec::_internal_formula() const {
  return _internal_has_formula()
      ? *type_.formula_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecFormula_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula& AggSpec::formula() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.formula)
  return _internal_formula();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* AggSpec::unsafe_arena_release_formula() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.formula)
  if (_internal_has_formula()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* temp = type_.formula_;
    type_.formula_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_formula(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* formula) {
  clear_type();
  if (formula) {
    set_has_formula();
    type_.formula_ = formula;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.formula)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* AggSpec::_internal_mutable_formula() {
  if (!_internal_has_formula()) {
    clear_type();
    set_has_formula();
    type_.formula_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula >(GetArenaForAllocation());
  }
  return type_.formula_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* AggSpec::mutable_formula() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* _msg = _internal_mutable_formula();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.formula)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFreeze freeze = 8;
inline bool AggSpec::_internal_has_freeze() const {
  return type_case() == kFreeze;
}
inline bool AggSpec::has_freeze() const {
  return _internal_has_freeze();
}
inline void AggSpec::set_has_freeze() {
  _oneof_case_[0] = kFreeze;
}
inline void AggSpec::clear_freeze() {
  if (_internal_has_freeze()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.freeze_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* AggSpec::release_freeze() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.freeze)
  if (_internal_has_freeze()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* temp = type_.freeze_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.freeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze& AggSpec::_internal_freeze() const {
  return _internal_has_freeze()
      ? *type_.freeze_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecFreeze_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze& AggSpec::freeze() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.freeze)
  return _internal_freeze();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* AggSpec::unsafe_arena_release_freeze() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.freeze)
  if (_internal_has_freeze()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* temp = type_.freeze_;
    type_.freeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_freeze(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* freeze) {
  clear_type();
  if (freeze) {
    set_has_freeze();
    type_.freeze_ = freeze;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.freeze)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* AggSpec::_internal_mutable_freeze() {
  if (!_internal_has_freeze()) {
    clear_type();
    set_has_freeze();
    type_.freeze_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze >(GetArenaForAllocation());
  }
  return type_.freeze_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* AggSpec::mutable_freeze() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* _msg = _internal_mutable_freeze();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.freeze)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecGroup group = 9;
inline bool AggSpec::_internal_has_group() const {
  return type_case() == kGroup;
}
inline bool AggSpec::has_group() const {
  return _internal_has_group();
}
inline void AggSpec::set_has_group() {
  _oneof_case_[0] = kGroup;
}
inline void AggSpec::clear_group() {
  if (_internal_has_group()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.group_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* AggSpec::release_group() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.group)
  if (_internal_has_group()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* temp = type_.group_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup& AggSpec::_internal_group() const {
  return _internal_has_group()
      ? *type_.group_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecGroup_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup& AggSpec::group() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.group)
  return _internal_group();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* AggSpec::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.group)
  if (_internal_has_group()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* temp = type_.group_;
    type_.group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_group(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* group) {
  clear_type();
  if (group) {
    set_has_group();
    type_.group_ = group;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.group)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* AggSpec::_internal_mutable_group() {
  if (!_internal_has_group()) {
    clear_type();
    set_has_group();
    type_.group_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup >(GetArenaForAllocation());
  }
  return type_.group_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* AggSpec::mutable_group() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.group)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecLast last = 10;
inline bool AggSpec::_internal_has_last() const {
  return type_case() == kLast;
}
inline bool AggSpec::has_last() const {
  return _internal_has_last();
}
inline void AggSpec::set_has_last() {
  _oneof_case_[0] = kLast;
}
inline void AggSpec::clear_last() {
  if (_internal_has_last()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.last_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* AggSpec::release_last() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.last)
  if (_internal_has_last()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* temp = type_.last_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.last_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast& AggSpec::_internal_last() const {
  return _internal_has_last()
      ? *type_.last_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecLast_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast& AggSpec::last() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.last)
  return _internal_last();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* AggSpec::unsafe_arena_release_last() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.last)
  if (_internal_has_last()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* temp = type_.last_;
    type_.last_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_last(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* last) {
  clear_type();
  if (last) {
    set_has_last();
    type_.last_ = last;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.last)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* AggSpec::_internal_mutable_last() {
  if (!_internal_has_last()) {
    clear_type();
    set_has_last();
    type_.last_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast >(GetArenaForAllocation());
  }
  return type_.last_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* AggSpec::mutable_last() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* _msg = _internal_mutable_last();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.last)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMax max = 11;
inline bool AggSpec::_internal_has_max() const {
  return type_case() == kMax;
}
inline bool AggSpec::has_max() const {
  return _internal_has_max();
}
inline void AggSpec::set_has_max() {
  _oneof_case_[0] = kMax;
}
inline void AggSpec::clear_max() {
  if (_internal_has_max()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.max_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* AggSpec::release_max() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.max)
  if (_internal_has_max()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* temp = type_.max_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax& AggSpec::_internal_max() const {
  return _internal_has_max()
      ? *type_.max_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecMax_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax& AggSpec::max() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.max)
  return _internal_max();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* AggSpec::unsafe_arena_release_max() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.max)
  if (_internal_has_max()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* temp = type_.max_;
    type_.max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_max(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* max) {
  clear_type();
  if (max) {
    set_has_max();
    type_.max_ = max;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.max)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* AggSpec::_internal_mutable_max() {
  if (!_internal_has_max()) {
    clear_type();
    set_has_max();
    type_.max_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax >(GetArenaForAllocation());
  }
  return type_.max_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* AggSpec::mutable_max() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.max)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian median = 12;
inline bool AggSpec::_internal_has_median() const {
  return type_case() == kMedian;
}
inline bool AggSpec::has_median() const {
  return _internal_has_median();
}
inline void AggSpec::set_has_median() {
  _oneof_case_[0] = kMedian;
}
inline void AggSpec::clear_median() {
  if (_internal_has_median()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.median_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* AggSpec::release_median() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.median)
  if (_internal_has_median()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* temp = type_.median_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.median_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian& AggSpec::_internal_median() const {
  return _internal_has_median()
      ? *type_.median_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecMedian_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian& AggSpec::median() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.median)
  return _internal_median();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* AggSpec::unsafe_arena_release_median() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.median)
  if (_internal_has_median()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* temp = type_.median_;
    type_.median_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_median(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* median) {
  clear_type();
  if (median) {
    set_has_median();
    type_.median_ = median;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.median)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* AggSpec::_internal_mutable_median() {
  if (!_internal_has_median()) {
    clear_type();
    set_has_median();
    type_.median_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian >(GetArenaForAllocation());
  }
  return type_.median_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* AggSpec::mutable_median() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* _msg = _internal_mutable_median();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.median)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMin min = 13;
inline bool AggSpec::_internal_has_min() const {
  return type_case() == kMin;
}
inline bool AggSpec::has_min() const {
  return _internal_has_min();
}
inline void AggSpec::set_has_min() {
  _oneof_case_[0] = kMin;
}
inline void AggSpec::clear_min() {
  if (_internal_has_min()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.min_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* AggSpec::release_min() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.min)
  if (_internal_has_min()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* temp = type_.min_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin& AggSpec::_internal_min() const {
  return _internal_has_min()
      ? *type_.min_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecMin_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin& AggSpec::min() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.min)
  return _internal_min();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* AggSpec::unsafe_arena_release_min() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.min)
  if (_internal_has_min()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* temp = type_.min_;
    type_.min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_min(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* min) {
  clear_type();
  if (min) {
    set_has_min();
    type_.min_ = min;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.min)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* AggSpec::_internal_mutable_min() {
  if (!_internal_has_min()) {
    clear_type();
    set_has_min();
    type_.min_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin >(GetArenaForAllocation());
  }
  return type_.min_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* AggSpec::mutable_min() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.min)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile percentile = 14;
inline bool AggSpec::_internal_has_percentile() const {
  return type_case() == kPercentile;
}
inline bool AggSpec::has_percentile() const {
  return _internal_has_percentile();
}
inline void AggSpec::set_has_percentile() {
  _oneof_case_[0] = kPercentile;
}
inline void AggSpec::clear_percentile() {
  if (_internal_has_percentile()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.percentile_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* AggSpec::release_percentile() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.percentile)
  if (_internal_has_percentile()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* temp = type_.percentile_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.percentile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile& AggSpec::_internal_percentile() const {
  return _internal_has_percentile()
      ? *type_.percentile_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecPercentile_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile& AggSpec::percentile() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.percentile)
  return _internal_percentile();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* AggSpec::unsafe_arena_release_percentile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.percentile)
  if (_internal_has_percentile()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* temp = type_.percentile_;
    type_.percentile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_percentile(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* percentile) {
  clear_type();
  if (percentile) {
    set_has_percentile();
    type_.percentile_ = percentile;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.percentile)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* AggSpec::_internal_mutable_percentile() {
  if (!_internal_has_percentile()) {
    clear_type();
    set_has_percentile();
    type_.percentile_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile >(GetArenaForAllocation());
  }
  return type_.percentile_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* AggSpec::mutable_percentile() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* _msg = _internal_mutable_percentile();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.percentile)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted sorted_first = 15;
inline bool AggSpec::_internal_has_sorted_first() const {
  return type_case() == kSortedFirst;
}
inline bool AggSpec::has_sorted_first() const {
  return _internal_has_sorted_first();
}
inline void AggSpec::set_has_sorted_first() {
  _oneof_case_[0] = kSortedFirst;
}
inline void AggSpec::clear_sorted_first() {
  if (_internal_has_sorted_first()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.sorted_first_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::release_sorted_first() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.sorted_first)
  if (_internal_has_sorted_first()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* temp = type_.sorted_first_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.sorted_first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& AggSpec::_internal_sorted_first() const {
  return _internal_has_sorted_first()
      ? *type_.sorted_first_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecSorted_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& AggSpec::sorted_first() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.sorted_first)
  return _internal_sorted_first();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::unsafe_arena_release_sorted_first() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.sorted_first)
  if (_internal_has_sorted_first()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* temp = type_.sorted_first_;
    type_.sorted_first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_sorted_first(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* sorted_first) {
  clear_type();
  if (sorted_first) {
    set_has_sorted_first();
    type_.sorted_first_ = sorted_first;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.sorted_first)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::_internal_mutable_sorted_first() {
  if (!_internal_has_sorted_first()) {
    clear_type();
    set_has_sorted_first();
    type_.sorted_first_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted >(GetArenaForAllocation());
  }
  return type_.sorted_first_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::mutable_sorted_first() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* _msg = _internal_mutable_sorted_first();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.sorted_first)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted sorted_last = 16;
inline bool AggSpec::_internal_has_sorted_last() const {
  return type_case() == kSortedLast;
}
inline bool AggSpec::has_sorted_last() const {
  return _internal_has_sorted_last();
}
inline void AggSpec::set_has_sorted_last() {
  _oneof_case_[0] = kSortedLast;
}
inline void AggSpec::clear_sorted_last() {
  if (_internal_has_sorted_last()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.sorted_last_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::release_sorted_last() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.sorted_last)
  if (_internal_has_sorted_last()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* temp = type_.sorted_last_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.sorted_last_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& AggSpec::_internal_sorted_last() const {
  return _internal_has_sorted_last()
      ? *type_.sorted_last_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecSorted_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& AggSpec::sorted_last() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.sorted_last)
  return _internal_sorted_last();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::unsafe_arena_release_sorted_last() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.sorted_last)
  if (_internal_has_sorted_last()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* temp = type_.sorted_last_;
    type_.sorted_last_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_sorted_last(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* sorted_last) {
  clear_type();
  if (sorted_last) {
    set_has_sorted_last();
    type_.sorted_last_ = sorted_last;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.sorted_last)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::_internal_mutable_sorted_last() {
  if (!_internal_has_sorted_last()) {
    clear_type();
    set_has_sorted_last();
    type_.sorted_last_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted >(GetArenaForAllocation());
  }
  return type_.sorted_last_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::mutable_sorted_last() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* _msg = _internal_mutable_sorted_last();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.sorted_last)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecStd std = 17;
inline bool AggSpec::_internal_has_std() const {
  return type_case() == kStd;
}
inline bool AggSpec::has_std() const {
  return _internal_has_std();
}
inline void AggSpec::set_has_std() {
  _oneof_case_[0] = kStd;
}
inline void AggSpec::clear_std() {
  if (_internal_has_std()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.std_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* AggSpec::release_std() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.std)
  if (_internal_has_std()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* temp = type_.std_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.std_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd& AggSpec::_internal_std() const {
  return _internal_has_std()
      ? *type_.std_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecStd_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd& AggSpec::std() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.std)
  return _internal_std();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* AggSpec::unsafe_arena_release_std() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.std)
  if (_internal_has_std()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* temp = type_.std_;
    type_.std_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_std(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* std) {
  clear_type();
  if (std) {
    set_has_std();
    type_.std_ = std;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.std)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* AggSpec::_internal_mutable_std() {
  if (!_internal_has_std()) {
    clear_type();
    set_has_std();
    type_.std_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd >(GetArenaForAllocation());
  }
  return type_.std_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* AggSpec::mutable_std() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* _msg = _internal_mutable_std();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.std)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSum sum = 18;
inline bool AggSpec::_internal_has_sum() const {
  return type_case() == kSum;
}
inline bool AggSpec::has_sum() const {
  return _internal_has_sum();
}
inline void AggSpec::set_has_sum() {
  _oneof_case_[0] = kSum;
}
inline void AggSpec::clear_sum() {
  if (_internal_has_sum()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.sum_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* AggSpec::release_sum() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.sum)
  if (_internal_has_sum()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* temp = type_.sum_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum& AggSpec::_internal_sum() const {
  return _internal_has_sum()
      ? *type_.sum_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecSum_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum& AggSpec::sum() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.sum)
  return _internal_sum();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* AggSpec::unsafe_arena_release_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.sum)
  if (_internal_has_sum()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* temp = type_.sum_;
    type_.sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* sum) {
  clear_type();
  if (sum) {
    set_has_sum();
    type_.sum_ = sum;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.sum)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* AggSpec::_internal_mutable_sum() {
  if (!_internal_has_sum()) {
    clear_type();
    set_has_sum();
    type_.sum_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum >(GetArenaForAllocation());
  }
  return type_.sum_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* AggSpec::mutable_sum() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* _msg = _internal_mutable_sum();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.sum)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest t_digest = 19;
inline bool AggSpec::_internal_has_t_digest() const {
  return type_case() == kTDigest;
}
inline bool AggSpec::has_t_digest() const {
  return _internal_has_t_digest();
}
inline void AggSpec::set_has_t_digest() {
  _oneof_case_[0] = kTDigest;
}
inline void AggSpec::clear_t_digest() {
  if (_internal_has_t_digest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.t_digest_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* AggSpec::release_t_digest() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.t_digest)
  if (_internal_has_t_digest()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* temp = type_.t_digest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.t_digest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest& AggSpec::_internal_t_digest() const {
  return _internal_has_t_digest()
      ? *type_.t_digest_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecTDigest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest& AggSpec::t_digest() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.t_digest)
  return _internal_t_digest();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* AggSpec::unsafe_arena_release_t_digest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.t_digest)
  if (_internal_has_t_digest()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* temp = type_.t_digest_;
    type_.t_digest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_t_digest(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* t_digest) {
  clear_type();
  if (t_digest) {
    set_has_t_digest();
    type_.t_digest_ = t_digest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.t_digest)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* AggSpec::_internal_mutable_t_digest() {
  if (!_internal_has_t_digest()) {
    clear_type();
    set_has_t_digest();
    type_.t_digest_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest >(GetArenaForAllocation());
  }
  return type_.t_digest_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* AggSpec::mutable_t_digest() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* _msg = _internal_mutable_t_digest();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.t_digest)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique unique = 20;
inline bool AggSpec::_internal_has_unique() const {
  return type_case() == kUnique;
}
inline bool AggSpec::has_unique() const {
  return _internal_has_unique();
}
inline void AggSpec::set_has_unique() {
  _oneof_case_[0] = kUnique;
}
inline void AggSpec::clear_unique() {
  if (_internal_has_unique()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.unique_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* AggSpec::release_unique() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.unique)
  if (_internal_has_unique()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* temp = type_.unique_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.unique_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique& AggSpec::_internal_unique() const {
  return _internal_has_unique()
      ? *type_.unique_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecUnique_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique& AggSpec::unique() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.unique)
  return _internal_unique();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* AggSpec::unsafe_arena_release_unique() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.unique)
  if (_internal_has_unique()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* temp = type_.unique_;
    type_.unique_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_unique(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* unique) {
  clear_type();
  if (unique) {
    set_has_unique();
    type_.unique_ = unique;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.unique)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* AggSpec::_internal_mutable_unique() {
  if (!_internal_has_unique()) {
    clear_type();
    set_has_unique();
    type_.unique_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique >(GetArenaForAllocation());
  }
  return type_.unique_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* AggSpec::mutable_unique() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* _msg = _internal_mutable_unique();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.unique)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted weighted_avg = 21;
inline bool AggSpec::_internal_has_weighted_avg() const {
  return type_case() == kWeightedAvg;
}
inline bool AggSpec::has_weighted_avg() const {
  return _internal_has_weighted_avg();
}
inline void AggSpec::set_has_weighted_avg() {
  _oneof_case_[0] = kWeightedAvg;
}
inline void AggSpec::clear_weighted_avg() {
  if (_internal_has_weighted_avg()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.weighted_avg_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::release_weighted_avg() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.weighted_avg)
  if (_internal_has_weighted_avg()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* temp = type_.weighted_avg_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.weighted_avg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& AggSpec::_internal_weighted_avg() const {
  return _internal_has_weighted_avg()
      ? *type_.weighted_avg_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecWeighted_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& AggSpec::weighted_avg() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.weighted_avg)
  return _internal_weighted_avg();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::unsafe_arena_release_weighted_avg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.weighted_avg)
  if (_internal_has_weighted_avg()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* temp = type_.weighted_avg_;
    type_.weighted_avg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_weighted_avg(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* weighted_avg) {
  clear_type();
  if (weighted_avg) {
    set_has_weighted_avg();
    type_.weighted_avg_ = weighted_avg;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.weighted_avg)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::_internal_mutable_weighted_avg() {
  if (!_internal_has_weighted_avg()) {
    clear_type();
    set_has_weighted_avg();
    type_.weighted_avg_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted >(GetArenaForAllocation());
  }
  return type_.weighted_avg_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::mutable_weighted_avg() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* _msg = _internal_mutable_weighted_avg();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.weighted_avg)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted weighted_sum = 22;
inline bool AggSpec::_internal_has_weighted_sum() const {
  return type_case() == kWeightedSum;
}
inline bool AggSpec::has_weighted_sum() const {
  return _internal_has_weighted_sum();
}
inline void AggSpec::set_has_weighted_sum() {
  _oneof_case_[0] = kWeightedSum;
}
inline void AggSpec::clear_weighted_sum() {
  if (_internal_has_weighted_sum()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.weighted_sum_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::release_weighted_sum() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.weighted_sum)
  if (_internal_has_weighted_sum()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* temp = type_.weighted_sum_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.weighted_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& AggSpec::_internal_weighted_sum() const {
  return _internal_has_weighted_sum()
      ? *type_.weighted_sum_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecWeighted_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& AggSpec::weighted_sum() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.weighted_sum)
  return _internal_weighted_sum();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::unsafe_arena_release_weighted_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.weighted_sum)
  if (_internal_has_weighted_sum()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* temp = type_.weighted_sum_;
    type_.weighted_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_weighted_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* weighted_sum) {
  clear_type();
  if (weighted_sum) {
    set_has_weighted_sum();
    type_.weighted_sum_ = weighted_sum;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.weighted_sum)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::_internal_mutable_weighted_sum() {
  if (!_internal_has_weighted_sum()) {
    clear_type();
    set_has_weighted_sum();
    type_.weighted_sum_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted >(GetArenaForAllocation());
  }
  return type_.weighted_sum_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::mutable_weighted_sum() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* _msg = _internal_mutable_weighted_sum();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.weighted_sum)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecVar var = 23;
inline bool AggSpec::_internal_has_var() const {
  return type_case() == kVar;
}
inline bool AggSpec::has_var() const {
  return _internal_has_var();
}
inline void AggSpec::set_has_var() {
  _oneof_case_[0] = kVar;
}
inline void AggSpec::clear_var() {
  if (_internal_has_var()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.var_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* AggSpec::release_var() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.var)
  if (_internal_has_var()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* temp = type_.var_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.var_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar& AggSpec::_internal_var() const {
  return _internal_has_var()
      ? *type_.var_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecVar_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar& AggSpec::var() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.var)
  return _internal_var();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* AggSpec::unsafe_arena_release_var() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.var)
  if (_internal_has_var()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* temp = type_.var_;
    type_.var_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_var(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* var) {
  clear_type();
  if (var) {
    set_has_var();
    type_.var_ = var;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.var)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* AggSpec::_internal_mutable_var() {
  if (!_internal_has_var()) {
    clear_type();
    set_has_var();
    type_.var_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar >(GetArenaForAllocation());
  }
  return type_.var_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* AggSpec::mutable_var() {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* _msg = _internal_mutable_var();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.var)
  return _msg;
}

inline bool AggSpec::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void AggSpec::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline AggSpec::TypeCase AggSpec::type_case() const {
  return AggSpec::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AggregateRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool AggregateRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool AggregateRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AggregateRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AggregateRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateRequest.result_id)
  return _internal_result_id();
}
inline void AggregateRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggregateRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggregateRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateRequest.result_id)
  return _msg;
}
inline void AggregateRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggregateRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool AggregateRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool AggregateRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void AggregateRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AggregateRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AggregateRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateRequest.source_id)
  return _internal_source_id();
}
inline void AggregateRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggregateRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggregateRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateRequest.source_id)
  return _msg;
}
inline void AggregateRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggregateRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference initial_groups_id = 3;
inline bool AggregateRequest::_internal_has_initial_groups_id() const {
  return this != internal_default_instance() && initial_groups_id_ != nullptr;
}
inline bool AggregateRequest::has_initial_groups_id() const {
  return _internal_has_initial_groups_id();
}
inline void AggregateRequest::clear_initial_groups_id() {
  if (GetArenaForAllocation() == nullptr && initial_groups_id_ != nullptr) {
    delete initial_groups_id_;
  }
  initial_groups_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AggregateRequest::_internal_initial_groups_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = initial_groups_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AggregateRequest::initial_groups_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateRequest.initial_groups_id)
  return _internal_initial_groups_id();
}
inline void AggregateRequest::unsafe_arena_set_allocated_initial_groups_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* initial_groups_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initial_groups_id_);
  }
  initial_groups_id_ = initial_groups_id;
  if (initial_groups_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggregateRequest.initial_groups_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::release_initial_groups_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = initial_groups_id_;
  initial_groups_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::unsafe_arena_release_initial_groups_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggregateRequest.initial_groups_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = initial_groups_id_;
  initial_groups_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::_internal_mutable_initial_groups_id() {
  
  if (initial_groups_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    initial_groups_id_ = p;
  }
  return initial_groups_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::mutable_initial_groups_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_initial_groups_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateRequest.initial_groups_id)
  return _msg;
}
inline void AggregateRequest::set_allocated_initial_groups_id(::io::deephaven::proto::backplane::grpc::TableReference* initial_groups_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete initial_groups_id_;
  }
  if (initial_groups_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(initial_groups_id);
    if (message_arena != submessage_arena) {
      initial_groups_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initial_groups_id, submessage_arena);
    }
    
  } else {
    
  }
  initial_groups_id_ = initial_groups_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggregateRequest.initial_groups_id)
}

// bool preserve_empty = 4;
inline void AggregateRequest::clear_preserve_empty() {
  preserve_empty_ = false;
}
inline bool AggregateRequest::_internal_preserve_empty() const {
  return preserve_empty_;
}
inline bool AggregateRequest::preserve_empty() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateRequest.preserve_empty)
  return _internal_preserve_empty();
}
inline void AggregateRequest::_internal_set_preserve_empty(bool value) {
  
  preserve_empty_ = value;
}
inline void AggregateRequest::set_preserve_empty(bool value) {
  _internal_set_preserve_empty(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggregateRequest.preserve_empty)
}

// repeated .io.deephaven.proto.backplane.grpc.Aggregation aggregations = 5;
inline int AggregateRequest::_internal_aggregations_size() const {
  return aggregations_.size();
}
inline int AggregateRequest::aggregations_size() const {
  return _internal_aggregations_size();
}
inline void AggregateRequest::clear_aggregations() {
  aggregations_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation* AggregateRequest::mutable_aggregations(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateRequest.aggregations)
  return aggregations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation >*
AggregateRequest::mutable_aggregations() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AggregateRequest.aggregations)
  return &aggregations_;
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation& AggregateRequest::_internal_aggregations(int index) const {
  return aggregations_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation& AggregateRequest::aggregations(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateRequest.aggregations)
  return _internal_aggregations(index);
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation* AggregateRequest::_internal_add_aggregations() {
  return aggregations_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation* AggregateRequest::add_aggregations() {
  ::io::deephaven::proto::backplane::grpc::Aggregation* _add = _internal_add_aggregations();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AggregateRequest.aggregations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation >&
AggregateRequest::aggregations() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AggregateRequest.aggregations)
  return aggregations_;
}

// repeated string group_by_columns = 6;
inline int AggregateRequest::_internal_group_by_columns_size() const {
  return group_by_columns_.size();
}
inline int AggregateRequest::group_by_columns_size() const {
  return _internal_group_by_columns_size();
}
inline void AggregateRequest::clear_group_by_columns() {
  group_by_columns_.Clear();
}
inline std::string* AggregateRequest::add_group_by_columns() {
  std::string* _s = _internal_add_group_by_columns();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
  return _s;
}
inline const std::string& AggregateRequest::_internal_group_by_columns(int index) const {
  return group_by_columns_.Get(index);
}
inline const std::string& AggregateRequest::group_by_columns(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
  return _internal_group_by_columns(index);
}
inline std::string* AggregateRequest::mutable_group_by_columns(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
  return group_by_columns_.Mutable(index);
}
inline void AggregateRequest::set_group_by_columns(int index, const std::string& value) {
  group_by_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::set_group_by_columns(int index, std::string&& value) {
  group_by_columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::set_group_by_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::set_group_by_columns(int index, const char* value, size_t size) {
  group_by_columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline std::string* AggregateRequest::_internal_add_group_by_columns() {
  return group_by_columns_.Add();
}
inline void AggregateRequest::add_group_by_columns(const std::string& value) {
  group_by_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::add_group_by_columns(std::string&& value) {
  group_by_columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::add_group_by_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  group_by_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::add_group_by_columns(const char* value, size_t size) {
  group_by_columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
AggregateRequest::group_by_columns() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
  return group_by_columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
AggregateRequest::mutable_group_by_columns() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
  return &group_by_columns_;
}

// -------------------------------------------------------------------

// Aggregation_AggregationColumns

// .io.deephaven.proto.backplane.grpc.AggSpec spec = 1;
inline bool Aggregation_AggregationColumns::_internal_has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline bool Aggregation_AggregationColumns::has_spec() const {
  return _internal_has_spec();
}
inline void Aggregation_AggregationColumns::clear_spec() {
  if (GetArenaForAllocation() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec& Aggregation_AggregationColumns::_internal_spec() const {
  const ::io::deephaven::proto::backplane::grpc::AggSpec* p = spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::AggSpec&>(
      ::io::deephaven::proto::backplane::grpc::_AggSpec_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec& Aggregation_AggregationColumns::spec() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.spec)
  return _internal_spec();
}
inline void Aggregation_AggregationColumns::unsafe_arena_set_allocated_spec(
    ::io::deephaven::proto::backplane::grpc::AggSpec* spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  spec_ = spec;
  if (spec) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.spec)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* Aggregation_AggregationColumns::release_spec() {
  
  ::io::deephaven::proto::backplane::grpc::AggSpec* temp = spec_;
  spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* Aggregation_AggregationColumns::unsafe_arena_release_spec() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.spec)
  
  ::io::deephaven::proto::backplane::grpc::AggSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* Aggregation_AggregationColumns::_internal_mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec>(GetArenaForAllocation());
    spec_ = p;
  }
  return spec_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* Aggregation_AggregationColumns::mutable_spec() {
  ::io::deephaven::proto::backplane::grpc::AggSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.spec)
  return _msg;
}
inline void Aggregation_AggregationColumns::set_allocated_spec(::io::deephaven::proto::backplane::grpc::AggSpec* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(spec);
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.spec)
}

// repeated string match_pairs = 2;
inline int Aggregation_AggregationColumns::_internal_match_pairs_size() const {
  return match_pairs_.size();
}
inline int Aggregation_AggregationColumns::match_pairs_size() const {
  return _internal_match_pairs_size();
}
inline void Aggregation_AggregationColumns::clear_match_pairs() {
  match_pairs_.Clear();
}
inline std::string* Aggregation_AggregationColumns::add_match_pairs() {
  std::string* _s = _internal_add_match_pairs();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
  return _s;
}
inline const std::string& Aggregation_AggregationColumns::_internal_match_pairs(int index) const {
  return match_pairs_.Get(index);
}
inline const std::string& Aggregation_AggregationColumns::match_pairs(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
  return _internal_match_pairs(index);
}
inline std::string* Aggregation_AggregationColumns::mutable_match_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
  return match_pairs_.Mutable(index);
}
inline void Aggregation_AggregationColumns::set_match_pairs(int index, const std::string& value) {
  match_pairs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::set_match_pairs(int index, std::string&& value) {
  match_pairs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::set_match_pairs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  match_pairs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::set_match_pairs(int index, const char* value, size_t size) {
  match_pairs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline std::string* Aggregation_AggregationColumns::_internal_add_match_pairs() {
  return match_pairs_.Add();
}
inline void Aggregation_AggregationColumns::add_match_pairs(const std::string& value) {
  match_pairs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::add_match_pairs(std::string&& value) {
  match_pairs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::add_match_pairs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  match_pairs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::add_match_pairs(const char* value, size_t size) {
  match_pairs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Aggregation_AggregationColumns::match_pairs() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
  return match_pairs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Aggregation_AggregationColumns::mutable_match_pairs() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
  return &match_pairs_;
}

// -------------------------------------------------------------------

// Aggregation_AggregationCount

// string column_name = 1;
inline void Aggregation_AggregationCount::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& Aggregation_AggregationCount::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aggregation_AggregationCount::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount.column_name)
}
inline std::string* Aggregation_AggregationCount::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount.column_name)
  return _s;
}
inline const std::string& Aggregation_AggregationCount::_internal_column_name() const {
  return column_name_.Get();
}
inline void Aggregation_AggregationCount::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Aggregation_AggregationCount::_internal_mutable_column_name() {
  
  return column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Aggregation_AggregationCount::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount.column_name)
  return column_name_.Release();
}
inline void Aggregation_AggregationCount::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (column_name_.IsDefault()) {
    column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount.column_name)
}

// -------------------------------------------------------------------

// Aggregation_AggregationRowKey

// string column_name = 1;
inline void Aggregation_AggregationRowKey::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& Aggregation_AggregationRowKey::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aggregation_AggregationRowKey::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey.column_name)
}
inline std::string* Aggregation_AggregationRowKey::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey.column_name)
  return _s;
}
inline const std::string& Aggregation_AggregationRowKey::_internal_column_name() const {
  return column_name_.Get();
}
inline void Aggregation_AggregationRowKey::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Aggregation_AggregationRowKey::_internal_mutable_column_name() {
  
  return column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Aggregation_AggregationRowKey::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey.column_name)
  return column_name_.Release();
}
inline void Aggregation_AggregationRowKey::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (column_name_.IsDefault()) {
    column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey.column_name)
}

// -------------------------------------------------------------------

// Aggregation_AggregationPartition

// string column_name = 1;
inline void Aggregation_AggregationPartition::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& Aggregation_AggregationPartition::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Aggregation_AggregationPartition::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.column_name)
}
inline std::string* Aggregation_AggregationPartition::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.column_name)
  return _s;
}
inline const std::string& Aggregation_AggregationPartition::_internal_column_name() const {
  return column_name_.Get();
}
inline void Aggregation_AggregationPartition::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Aggregation_AggregationPartition::_internal_mutable_column_name() {
  
  return column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Aggregation_AggregationPartition::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.column_name)
  return column_name_.Release();
}
inline void Aggregation_AggregationPartition::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (column_name_.IsDefault()) {
    column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.column_name)
}

// bool include_group_by_columns = 2;
inline void Aggregation_AggregationPartition::clear_include_group_by_columns() {
  include_group_by_columns_ = false;
}
inline bool Aggregation_AggregationPartition::_internal_include_group_by_columns() const {
  return include_group_by_columns_;
}
inline bool Aggregation_AggregationPartition::include_group_by_columns() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.include_group_by_columns)
  return _internal_include_group_by_columns();
}
inline void Aggregation_AggregationPartition::_internal_set_include_group_by_columns(bool value) {
  
  include_group_by_columns_ = value;
}
inline void Aggregation_AggregationPartition::set_include_group_by_columns(bool value) {
  _internal_set_include_group_by_columns(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.include_group_by_columns)
}

// -------------------------------------------------------------------

// Aggregation

// .io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns columns = 1;
inline bool Aggregation::_internal_has_columns() const {
  return type_case() == kColumns;
}
inline bool Aggregation::has_columns() const {
  return _internal_has_columns();
}
inline void Aggregation::set_has_columns() {
  _oneof_case_[0] = kColumns;
}
inline void Aggregation::clear_columns() {
  if (_internal_has_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.columns_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* Aggregation::release_columns() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.columns)
  if (_internal_has_columns()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* temp = type_.columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns& Aggregation::_internal_columns() const {
  return _internal_has_columns()
      ? *type_.columns_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns&>(::io::deephaven::proto::backplane::grpc::_Aggregation_AggregationColumns_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns& Aggregation::columns() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.columns)
  return _internal_columns();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* Aggregation::unsafe_arena_release_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Aggregation.columns)
  if (_internal_has_columns()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* temp = type_.columns_;
    type_.columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Aggregation::unsafe_arena_set_allocated_columns(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* columns) {
  clear_type();
  if (columns) {
    set_has_columns();
    type_.columns_ = columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.columns)
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* Aggregation::_internal_mutable_columns() {
  if (!_internal_has_columns()) {
    clear_type();
    set_has_columns();
    type_.columns_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns >(GetArenaForAllocation());
  }
  return type_.columns_;
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* Aggregation::mutable_columns() {
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* _msg = _internal_mutable_columns();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.columns)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount count = 2;
inline bool Aggregation::_internal_has_count() const {
  return type_case() == kCount;
}
inline bool Aggregation::has_count() const {
  return _internal_has_count();
}
inline void Aggregation::set_has_count() {
  _oneof_case_[0] = kCount;
}
inline void Aggregation::clear_count() {
  if (_internal_has_count()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.count_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* Aggregation::release_count() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.count)
  if (_internal_has_count()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* temp = type_.count_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.count_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount& Aggregation::_internal_count() const {
  return _internal_has_count()
      ? *type_.count_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount&>(::io::deephaven::proto::backplane::grpc::_Aggregation_AggregationCount_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount& Aggregation::count() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.count)
  return _internal_count();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* Aggregation::unsafe_arena_release_count() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Aggregation.count)
  if (_internal_has_count()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* temp = type_.count_;
    type_.count_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Aggregation::unsafe_arena_set_allocated_count(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* count) {
  clear_type();
  if (count) {
    set_has_count();
    type_.count_ = count;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.count)
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* Aggregation::_internal_mutable_count() {
  if (!_internal_has_count()) {
    clear_type();
    set_has_count();
    type_.count_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount >(GetArenaForAllocation());
  }
  return type_.count_;
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* Aggregation::mutable_count() {
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* _msg = _internal_mutable_count();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.count)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey first_row_key = 3;
inline bool Aggregation::_internal_has_first_row_key() const {
  return type_case() == kFirstRowKey;
}
inline bool Aggregation::has_first_row_key() const {
  return _internal_has_first_row_key();
}
inline void Aggregation::set_has_first_row_key() {
  _oneof_case_[0] = kFirstRowKey;
}
inline void Aggregation::clear_first_row_key() {
  if (_internal_has_first_row_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.first_row_key_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::release_first_row_key() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.first_row_key)
  if (_internal_has_first_row_key()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* temp = type_.first_row_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.first_row_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& Aggregation::_internal_first_row_key() const {
  return _internal_has_first_row_key()
      ? *type_.first_row_key_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey&>(::io::deephaven::proto::backplane::grpc::_Aggregation_AggregationRowKey_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& Aggregation::first_row_key() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.first_row_key)
  return _internal_first_row_key();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::unsafe_arena_release_first_row_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Aggregation.first_row_key)
  if (_internal_has_first_row_key()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* temp = type_.first_row_key_;
    type_.first_row_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Aggregation::unsafe_arena_set_allocated_first_row_key(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* first_row_key) {
  clear_type();
  if (first_row_key) {
    set_has_first_row_key();
    type_.first_row_key_ = first_row_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.first_row_key)
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::_internal_mutable_first_row_key() {
  if (!_internal_has_first_row_key()) {
    clear_type();
    set_has_first_row_key();
    type_.first_row_key_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey >(GetArenaForAllocation());
  }
  return type_.first_row_key_;
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::mutable_first_row_key() {
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* _msg = _internal_mutable_first_row_key();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.first_row_key)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey last_row_key = 4;
inline bool Aggregation::_internal_has_last_row_key() const {
  return type_case() == kLastRowKey;
}
inline bool Aggregation::has_last_row_key() const {
  return _internal_has_last_row_key();
}
inline void Aggregation::set_has_last_row_key() {
  _oneof_case_[0] = kLastRowKey;
}
inline void Aggregation::clear_last_row_key() {
  if (_internal_has_last_row_key()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.last_row_key_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::release_last_row_key() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.last_row_key)
  if (_internal_has_last_row_key()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* temp = type_.last_row_key_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.last_row_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& Aggregation::_internal_last_row_key() const {
  return _internal_has_last_row_key()
      ? *type_.last_row_key_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey&>(::io::deephaven::proto::backplane::grpc::_Aggregation_AggregationRowKey_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& Aggregation::last_row_key() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.last_row_key)
  return _internal_last_row_key();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::unsafe_arena_release_last_row_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Aggregation.last_row_key)
  if (_internal_has_last_row_key()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* temp = type_.last_row_key_;
    type_.last_row_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Aggregation::unsafe_arena_set_allocated_last_row_key(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* last_row_key) {
  clear_type();
  if (last_row_key) {
    set_has_last_row_key();
    type_.last_row_key_ = last_row_key;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.last_row_key)
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::_internal_mutable_last_row_key() {
  if (!_internal_has_last_row_key()) {
    clear_type();
    set_has_last_row_key();
    type_.last_row_key_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey >(GetArenaForAllocation());
  }
  return type_.last_row_key_;
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::mutable_last_row_key() {
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* _msg = _internal_mutable_last_row_key();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.last_row_key)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition partition = 5;
inline bool Aggregation::_internal_has_partition() const {
  return type_case() == kPartition;
}
inline bool Aggregation::has_partition() const {
  return _internal_has_partition();
}
inline void Aggregation::set_has_partition() {
  _oneof_case_[0] = kPartition;
}
inline void Aggregation::clear_partition() {
  if (_internal_has_partition()) {
    if (GetArenaForAllocation() == nullptr) {
      delete type_.partition_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* Aggregation::release_partition() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.partition)
  if (_internal_has_partition()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* temp = type_.partition_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.partition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition& Aggregation::_internal_partition() const {
  return _internal_has_partition()
      ? *type_.partition_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition&>(::io::deephaven::proto::backplane::grpc::_Aggregation_AggregationPartition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition& Aggregation::partition() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.partition)
  return _internal_partition();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* Aggregation::unsafe_arena_release_partition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Aggregation.partition)
  if (_internal_has_partition()) {
    clear_has_type();
    ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* temp = type_.partition_;
    type_.partition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Aggregation::unsafe_arena_set_allocated_partition(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* partition) {
  clear_type();
  if (partition) {
    set_has_partition();
    type_.partition_ = partition;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.partition)
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* Aggregation::_internal_mutable_partition() {
  if (!_internal_has_partition()) {
    clear_type();
    set_has_partition();
    type_.partition_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition >(GetArenaForAllocation());
  }
  return type_.partition_;
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* Aggregation::mutable_partition() {
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* _msg = _internal_mutable_partition();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.partition)
  return _msg;
}

inline bool Aggregation::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Aggregation::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Aggregation::TypeCase Aggregation::type_case() const {
  return Aggregation::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SortDescriptor

// string column_name = 1;
inline void SortDescriptor::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& SortDescriptor::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SortDescriptor::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
}
inline std::string* SortDescriptor::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
  return _s;
}
inline const std::string& SortDescriptor::_internal_column_name() const {
  return column_name_.Get();
}
inline void SortDescriptor::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SortDescriptor::_internal_mutable_column_name() {
  
  return column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SortDescriptor::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
  return column_name_.Release();
}
inline void SortDescriptor::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (column_name_.IsDefault()) {
    column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
}

// bool is_absolute = 2;
inline void SortDescriptor::clear_is_absolute() {
  is_absolute_ = false;
}
inline bool SortDescriptor::_internal_is_absolute() const {
  return is_absolute_;
}
inline bool SortDescriptor::is_absolute() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortDescriptor.is_absolute)
  return _internal_is_absolute();
}
inline void SortDescriptor::_internal_set_is_absolute(bool value) {
  
  is_absolute_ = value;
}
inline void SortDescriptor::set_is_absolute(bool value) {
  _internal_set_is_absolute(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SortDescriptor.is_absolute)
}

// .io.deephaven.proto.backplane.grpc.SortDescriptor.SortDirection direction = 3;
inline void SortDescriptor::clear_direction() {
  direction_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection SortDescriptor::_internal_direction() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection >(direction_);
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection SortDescriptor::direction() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortDescriptor.direction)
  return _internal_direction();
}
inline void SortDescriptor::_internal_set_direction(::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection value) {
  
  direction_ = value;
}
inline void SortDescriptor::set_direction(::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SortDescriptor.direction)
}

// -------------------------------------------------------------------

// SortTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SortTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool SortTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SortTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SortTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
  return _internal_result_id();
}
inline void SortTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SortTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SortTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SortTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SortTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
  return _msg;
}
inline void SortTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool SortTableRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool SortTableRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void SortTableRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SortTableRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SortTableRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
  return _internal_source_id();
}
inline void SortTableRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SortTableRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SortTableRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SortTableRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SortTableRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
  return _msg;
}
inline void SortTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
}

// repeated .io.deephaven.proto.backplane.grpc.SortDescriptor sorts = 3;
inline int SortTableRequest::_internal_sorts_size() const {
  return sorts_.size();
}
inline int SortTableRequest::sorts_size() const {
  return _internal_sorts_size();
}
inline void SortTableRequest::clear_sorts() {
  sorts_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor* SortTableRequest::mutable_sorts(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return sorts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor >*
SortTableRequest::mutable_sorts() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return &sorts_;
}
inline const ::io::deephaven::proto::backplane::grpc::SortDescriptor& SortTableRequest::_internal_sorts(int index) const {
  return sorts_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::SortDescriptor& SortTableRequest::sorts(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return _internal_sorts(index);
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor* SortTableRequest::_internal_add_sorts() {
  return sorts_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor* SortTableRequest::add_sorts() {
  ::io::deephaven::proto::backplane::grpc::SortDescriptor* _add = _internal_add_sorts();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor >&
SortTableRequest::sorts() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return sorts_;
}

// -------------------------------------------------------------------

// FilterTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool FilterTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool FilterTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FilterTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FilterTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
  return _internal_result_id();
}
inline void FilterTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FilterTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FilterTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FilterTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FilterTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
  return _msg;
}
inline void FilterTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool FilterTableRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool FilterTableRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void FilterTableRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FilterTableRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FilterTableRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
  return _internal_source_id();
}
inline void FilterTableRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FilterTableRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FilterTableRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FilterTableRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FilterTableRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
  return _msg;
}
inline void FilterTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
}

// repeated .io.deephaven.proto.backplane.grpc.Condition filters = 3;
inline int FilterTableRequest::_internal_filters_size() const {
  return filters_.size();
}
inline int FilterTableRequest::filters_size() const {
  return _internal_filters_size();
}
inline void FilterTableRequest::clear_filters() {
  filters_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* FilterTableRequest::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
FilterTableRequest::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return &filters_;
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& FilterTableRequest::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& FilterTableRequest::filters(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return _internal_filters(index);
}
inline ::io::deephaven::proto::backplane::grpc::Condition* FilterTableRequest::_internal_add_filters() {
  return filters_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* FilterTableRequest::add_filters() {
  ::io::deephaven::proto::backplane::grpc::Condition* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
FilterTableRequest::filters() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return filters_;
}

// -------------------------------------------------------------------

// SeekRowRequest

// .io.deephaven.proto.backplane.grpc.Ticket source_id = 1;
inline bool SeekRowRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool SeekRowRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SeekRowRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SeekRowRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.source_id)
  return _internal_source_id();
}
inline void SeekRowRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SeekRowRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SeekRowRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SeekRowRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SeekRowRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SeekRowRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SeekRowRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SeekRowRequest.source_id)
  return _msg;
}
inline void SeekRowRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::Ticket* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id));
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SeekRowRequest.source_id)
}

// sint64 starting_row = 2 [jstype = JS_STRING];
inline void SeekRowRequest::clear_starting_row() {
  starting_row_ = int64_t{0};
}
inline int64_t SeekRowRequest::_internal_starting_row() const {
  return starting_row_;
}
inline int64_t SeekRowRequest::starting_row() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.starting_row)
  return _internal_starting_row();
}
inline void SeekRowRequest::_internal_set_starting_row(int64_t value) {
  
  starting_row_ = value;
}
inline void SeekRowRequest::set_starting_row(int64_t value) {
  _internal_set_starting_row(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SeekRowRequest.starting_row)
}

// string column_name = 3;
inline void SeekRowRequest::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& SeekRowRequest::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SeekRowRequest::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SeekRowRequest.column_name)
}
inline std::string* SeekRowRequest::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SeekRowRequest.column_name)
  return _s;
}
inline const std::string& SeekRowRequest::_internal_column_name() const {
  return column_name_.Get();
}
inline void SeekRowRequest::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SeekRowRequest::_internal_mutable_column_name() {
  
  return column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SeekRowRequest::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SeekRowRequest.column_name)
  return column_name_.Release();
}
inline void SeekRowRequest::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (column_name_.IsDefault()) {
    column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SeekRowRequest.column_name)
}

// .io.deephaven.proto.backplane.grpc.Literal seek_value = 4;
inline bool SeekRowRequest::_internal_has_seek_value() const {
  return this != internal_default_instance() && seek_value_ != nullptr;
}
inline bool SeekRowRequest::has_seek_value() const {
  return _internal_has_seek_value();
}
inline void SeekRowRequest::clear_seek_value() {
  if (GetArenaForAllocation() == nullptr && seek_value_ != nullptr) {
    delete seek_value_;
  }
  seek_value_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Literal& SeekRowRequest::_internal_seek_value() const {
  const ::io::deephaven::proto::backplane::grpc::Literal* p = seek_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Literal&>(
      ::io::deephaven::proto::backplane::grpc::_Literal_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Literal& SeekRowRequest::seek_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.seek_value)
  return _internal_seek_value();
}
inline void SeekRowRequest::unsafe_arena_set_allocated_seek_value(
    ::io::deephaven::proto::backplane::grpc::Literal* seek_value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(seek_value_);
  }
  seek_value_ = seek_value;
  if (seek_value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SeekRowRequest.seek_value)
}
inline ::io::deephaven::proto::backplane::grpc::Literal* SeekRowRequest::release_seek_value() {
  
  ::io::deephaven::proto::backplane::grpc::Literal* temp = seek_value_;
  seek_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Literal* SeekRowRequest::unsafe_arena_release_seek_value() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SeekRowRequest.seek_value)
  
  ::io::deephaven::proto::backplane::grpc::Literal* temp = seek_value_;
  seek_value_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Literal* SeekRowRequest::_internal_mutable_seek_value() {
  
  if (seek_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Literal>(GetArenaForAllocation());
    seek_value_ = p;
  }
  return seek_value_;
}
inline ::io::deephaven::proto::backplane::grpc::Literal* SeekRowRequest::mutable_seek_value() {
  ::io::deephaven::proto::backplane::grpc::Literal* _msg = _internal_mutable_seek_value();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SeekRowRequest.seek_value)
  return _msg;
}
inline void SeekRowRequest::set_allocated_seek_value(::io::deephaven::proto::backplane::grpc::Literal* seek_value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete seek_value_;
  }
  if (seek_value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seek_value);
    if (message_arena != submessage_arena) {
      seek_value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seek_value, submessage_arena);
    }
    
  } else {
    
  }
  seek_value_ = seek_value;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SeekRowRequest.seek_value)
}

// bool insensitive = 5;
inline void SeekRowRequest::clear_insensitive() {
  insensitive_ = false;
}
inline bool SeekRowRequest::_internal_insensitive() const {
  return insensitive_;
}
inline bool SeekRowRequest::insensitive() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.insensitive)
  return _internal_insensitive();
}
inline void SeekRowRequest::_internal_set_insensitive(bool value) {
  
  insensitive_ = value;
}
inline void SeekRowRequest::set_insensitive(bool value) {
  _internal_set_insensitive(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SeekRowRequest.insensitive)
}

// bool contains = 6;
inline void SeekRowRequest::clear_contains() {
  contains_ = false;
}
inline bool SeekRowRequest::_internal_contains() const {
  return contains_;
}
inline bool SeekRowRequest::contains() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.contains)
  return _internal_contains();
}
inline void SeekRowRequest::_internal_set_contains(bool value) {
  
  contains_ = value;
}
inline void SeekRowRequest::set_contains(bool value) {
  _internal_set_contains(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SeekRowRequest.contains)
}

// bool is_backward = 7;
inline void SeekRowRequest::clear_is_backward() {
  is_backward_ = false;
}
inline bool SeekRowRequest::_internal_is_backward() const {
  return is_backward_;
}
inline bool SeekRowRequest::is_backward() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.is_backward)
  return _internal_is_backward();
}
inline void SeekRowRequest::_internal_set_is_backward(bool value) {
  
  is_backward_ = value;
}
inline void SeekRowRequest::set_is_backward(bool value) {
  _internal_set_is_backward(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SeekRowRequest.is_backward)
}

// -------------------------------------------------------------------

// SeekRowResponse

// sint64 result_row = 1 [jstype = JS_STRING];
inline void SeekRowResponse::clear_result_row() {
  result_row_ = int64_t{0};
}
inline int64_t SeekRowResponse::_internal_result_row() const {
  return result_row_;
}
inline int64_t SeekRowResponse::result_row() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowResponse.result_row)
  return _internal_result_row();
}
inline void SeekRowResponse::_internal_set_result_row(int64_t value) {
  
  result_row_ = value;
}
inline void SeekRowResponse::set_result_row(int64_t value) {
  _internal_set_result_row(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SeekRowResponse.result_row)
}

// -------------------------------------------------------------------

// Reference

// string column_name = 1;
inline void Reference::clear_column_name() {
  column_name_.ClearToEmpty();
}
inline const std::string& Reference::column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Reference.column_name)
  return _internal_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Reference::set_column_name(ArgT0&& arg0, ArgT... args) {
 
 column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Reference.column_name)
}
inline std::string* Reference::mutable_column_name() {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Reference.column_name)
  return _s;
}
inline const std::string& Reference::_internal_column_name() const {
  return column_name_.Get();
}
inline void Reference::_internal_set_column_name(const std::string& value) {
  
  column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Reference::_internal_mutable_column_name() {
  
  return column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Reference::release_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Reference.column_name)
  return column_name_.Release();
}
inline void Reference::set_allocated_column_name(std::string* column_name) {
  if (column_name != nullptr) {
    
  } else {
    
  }
  column_name_.SetAllocated(column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (column_name_.IsDefault()) {
    column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Reference.column_name)
}

// -------------------------------------------------------------------

// Literal

// string string_value = 1;
inline bool Literal::_internal_has_string_value() const {
  return value_case() == kStringValue;
}
inline bool Literal::has_string_value() const {
  return _internal_has_string_value();
}
inline void Literal::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void Literal::clear_string_value() {
  if (_internal_has_string_value()) {
    value_.string_value_.Destroy();
    clear_has_value();
  }
}
inline const std::string& Literal::string_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.string_value)
  return _internal_string_value();
}
template <typename ArgT0, typename... ArgT>
inline void Literal::set_string_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.InitDefault();
  }
  value_.string_value_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.string_value)
}
inline std::string* Literal::mutable_string_value() {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Literal.string_value)
  return _s;
}
inline const std::string& Literal::_internal_string_value() const {
  if (_internal_has_string_value()) {
    return value_.string_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Literal::_internal_set_string_value(const std::string& value) {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.InitDefault();
  }
  value_.string_value_.Set(value, GetArenaForAllocation());
}
inline std::string* Literal::_internal_mutable_string_value() {
  if (!_internal_has_string_value()) {
    clear_value();
    set_has_string_value();
    value_.string_value_.InitDefault();
  }
  return value_.string_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* Literal::release_string_value() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Literal.string_value)
  if (_internal_has_string_value()) {
    clear_has_value();
    return value_.string_value_.Release();
  } else {
    return nullptr;
  }
}
inline void Literal::set_allocated_string_value(std::string* string_value) {
  if (has_value()) {
    clear_value();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    value_.string_value_.InitAllocated(string_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Literal.string_value)
}

// double double_value = 2;
inline bool Literal::_internal_has_double_value() const {
  return value_case() == kDoubleValue;
}
inline bool Literal::has_double_value() const {
  return _internal_has_double_value();
}
inline void Literal::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void Literal::clear_double_value() {
  if (_internal_has_double_value()) {
    value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double Literal::_internal_double_value() const {
  if (_internal_has_double_value()) {
    return value_.double_value_;
  }
  return 0;
}
inline void Literal::_internal_set_double_value(double value) {
  if (!_internal_has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  value_.double_value_ = value;
}
inline double Literal::double_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.double_value)
  return _internal_double_value();
}
inline void Literal::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.double_value)
}

// bool bool_value = 3;
inline bool Literal::_internal_has_bool_value() const {
  return value_case() == kBoolValue;
}
inline bool Literal::has_bool_value() const {
  return _internal_has_bool_value();
}
inline void Literal::set_has_bool_value() {
  _oneof_case_[0] = kBoolValue;
}
inline void Literal::clear_bool_value() {
  if (_internal_has_bool_value()) {
    value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool Literal::_internal_bool_value() const {
  if (_internal_has_bool_value()) {
    return value_.bool_value_;
  }
  return false;
}
inline void Literal::_internal_set_bool_value(bool value) {
  if (!_internal_has_bool_value()) {
    clear_value();
    set_has_bool_value();
  }
  value_.bool_value_ = value;
}
inline bool Literal::bool_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.bool_value)
  return _internal_bool_value();
}
inline void Literal::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.bool_value)
}

// sint64 long_value = 4 [jstype = JS_STRING];
inline bool Literal::_internal_has_long_value() const {
  return value_case() == kLongValue;
}
inline bool Literal::has_long_value() const {
  return _internal_has_long_value();
}
inline void Literal::set_has_long_value() {
  _oneof_case_[0] = kLongValue;
}
inline void Literal::clear_long_value() {
  if (_internal_has_long_value()) {
    value_.long_value_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t Literal::_internal_long_value() const {
  if (_internal_has_long_value()) {
    return value_.long_value_;
  }
  return int64_t{0};
}
inline void Literal::_internal_set_long_value(int64_t value) {
  if (!_internal_has_long_value()) {
    clear_value();
    set_has_long_value();
  }
  value_.long_value_ = value;
}
inline int64_t Literal::long_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.long_value)
  return _internal_long_value();
}
inline void Literal::set_long_value(int64_t value) {
  _internal_set_long_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.long_value)
}

// sint64 nano_time_value = 5 [jstype = JS_STRING];
inline bool Literal::_internal_has_nano_time_value() const {
  return value_case() == kNanoTimeValue;
}
inline bool Literal::has_nano_time_value() const {
  return _internal_has_nano_time_value();
}
inline void Literal::set_has_nano_time_value() {
  _oneof_case_[0] = kNanoTimeValue;
}
inline void Literal::clear_nano_time_value() {
  if (_internal_has_nano_time_value()) {
    value_.nano_time_value_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t Literal::_internal_nano_time_value() const {
  if (_internal_has_nano_time_value()) {
    return value_.nano_time_value_;
  }
  return int64_t{0};
}
inline void Literal::_internal_set_nano_time_value(int64_t value) {
  if (!_internal_has_nano_time_value()) {
    clear_value();
    set_has_nano_time_value();
  }
  value_.nano_time_value_ = value;
}
inline int64_t Literal::nano_time_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.nano_time_value)
  return _internal_nano_time_value();
}
inline void Literal::set_nano_time_value(int64_t value) {
  _internal_set_nano_time_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.nano_time_value)
}

inline bool Literal::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Literal::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Literal::ValueCase Literal::value_case() const {
  return Literal::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Value

// .io.deephaven.proto.backplane.grpc.Reference reference = 1;
inline bool Value::_internal_has_reference() const {
  return data_case() == kReference;
}
inline bool Value::has_reference() const {
  return _internal_has_reference();
}
inline void Value::set_has_reference() {
  _oneof_case_[0] = kReference;
}
inline void Value::clear_reference() {
  if (_internal_has_reference()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.reference_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Reference* Value::release_reference() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Value.reference)
  if (_internal_has_reference()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::Reference* temp = data_.reference_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& Value::_internal_reference() const {
  return _internal_has_reference()
      ? *data_.reference_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::Reference&>(::io::deephaven::proto::backplane::grpc::_Reference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& Value::reference() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Value.reference)
  return _internal_reference();
}
inline ::io::deephaven::proto::backplane::grpc::Reference* Value::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Value.reference)
  if (_internal_has_reference()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::Reference* temp = data_.reference_;
    data_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference) {
  clear_data();
  if (reference) {
    set_has_reference();
    data_.reference_ = reference;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Value.reference)
}
inline ::io::deephaven::proto::backplane::grpc::Reference* Value::_internal_mutable_reference() {
  if (!_internal_has_reference()) {
    clear_data();
    set_has_reference();
    data_.reference_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::Reference >(GetArenaForAllocation());
  }
  return data_.reference_;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* Value::mutable_reference() {
  ::io::deephaven::proto::backplane::grpc::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Value.reference)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.Literal literal = 2;
inline bool Value::_internal_has_literal() const {
  return data_case() == kLiteral;
}
inline bool Value::has_literal() const {
  return _internal_has_literal();
}
inline void Value::set_has_literal() {
  _oneof_case_[0] = kLiteral;
}
inline void Value::clear_literal() {
  if (_internal_has_literal()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.literal_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Literal* Value::release_literal() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Value.literal)
  if (_internal_has_literal()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::Literal* temp = data_.literal_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.literal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Literal& Value::_internal_literal() const {
  return _internal_has_literal()
      ? *data_.literal_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::Literal&>(::io::deephaven::proto::backplane::grpc::_Literal_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Literal& Value::literal() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Value.literal)
  return _internal_literal();
}
inline ::io::deephaven::proto::backplane::grpc::Literal* Value::unsafe_arena_release_literal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Value.literal)
  if (_internal_has_literal()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::Literal* temp = data_.literal_;
    data_.literal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_literal(::io::deephaven::proto::backplane::grpc::Literal* literal) {
  clear_data();
  if (literal) {
    set_has_literal();
    data_.literal_ = literal;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Value.literal)
}
inline ::io::deephaven::proto::backplane::grpc::Literal* Value::_internal_mutable_literal() {
  if (!_internal_has_literal()) {
    clear_data();
    set_has_literal();
    data_.literal_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::Literal >(GetArenaForAllocation());
  }
  return data_.literal_;
}
inline ::io::deephaven::proto::backplane::grpc::Literal* Value::mutable_literal() {
  ::io::deephaven::proto::backplane::grpc::Literal* _msg = _internal_mutable_literal();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Value.literal)
  return _msg;
}

inline bool Value::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Value::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline Value::DataCase Value::data_case() const {
  return Value::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Condition

// .io.deephaven.proto.backplane.grpc.AndCondition and = 1;
inline bool Condition::_internal_has_and_() const {
  return data_case() == kAnd;
}
inline bool Condition::has_and_() const {
  return _internal_has_and_();
}
inline void Condition::set_has_and_() {
  _oneof_case_[0] = kAnd;
}
inline void Condition::clear_and_() {
  if (_internal_has_and_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.and__;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AndCondition* Condition::release_and_() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.and)
  if (_internal_has_and_()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::AndCondition* temp = data_.and__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.and__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AndCondition& Condition::_internal_and_() const {
  return _internal_has_and_()
      ? *data_.and__
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AndCondition&>(::io::deephaven::proto::backplane::grpc::_AndCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AndCondition& Condition::and_() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.and)
  return _internal_and_();
}
inline ::io::deephaven::proto::backplane::grpc::AndCondition* Condition::unsafe_arena_release_and_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.and)
  if (_internal_has_and_()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::AndCondition* temp = data_.and__;
    data_.and__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_and_(::io::deephaven::proto::backplane::grpc::AndCondition* and_) {
  clear_data();
  if (and_) {
    set_has_and_();
    data_.and__ = and_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.and)
}
inline ::io::deephaven::proto::backplane::grpc::AndCondition* Condition::_internal_mutable_and_() {
  if (!_internal_has_and_()) {
    clear_data();
    set_has_and_();
    data_.and__ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AndCondition >(GetArenaForAllocation());
  }
  return data_.and__;
}
inline ::io::deephaven::proto::backplane::grpc::AndCondition* Condition::mutable_and_() {
  ::io::deephaven::proto::backplane::grpc::AndCondition* _msg = _internal_mutable_and_();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.and)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.OrCondition or = 2;
inline bool Condition::_internal_has_or_() const {
  return data_case() == kOr;
}
inline bool Condition::has_or_() const {
  return _internal_has_or_();
}
inline void Condition::set_has_or_() {
  _oneof_case_[0] = kOr;
}
inline void Condition::clear_or_() {
  if (_internal_has_or_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.or__;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::OrCondition* Condition::release_or_() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.or)
  if (_internal_has_or_()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::OrCondition* temp = data_.or__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.or__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::OrCondition& Condition::_internal_or_() const {
  return _internal_has_or_()
      ? *data_.or__
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::OrCondition&>(::io::deephaven::proto::backplane::grpc::_OrCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::OrCondition& Condition::or_() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.or)
  return _internal_or_();
}
inline ::io::deephaven::proto::backplane::grpc::OrCondition* Condition::unsafe_arena_release_or_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.or)
  if (_internal_has_or_()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::OrCondition* temp = data_.or__;
    data_.or__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_or_(::io::deephaven::proto::backplane::grpc::OrCondition* or_) {
  clear_data();
  if (or_) {
    set_has_or_();
    data_.or__ = or_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.or)
}
inline ::io::deephaven::proto::backplane::grpc::OrCondition* Condition::_internal_mutable_or_() {
  if (!_internal_has_or_()) {
    clear_data();
    set_has_or_();
    data_.or__ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::OrCondition >(GetArenaForAllocation());
  }
  return data_.or__;
}
inline ::io::deephaven::proto::backplane::grpc::OrCondition* Condition::mutable_or_() {
  ::io::deephaven::proto::backplane::grpc::OrCondition* _msg = _internal_mutable_or_();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.or)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.NotCondition not = 3;
inline bool Condition::_internal_has_not_() const {
  return data_case() == kNot;
}
inline bool Condition::has_not_() const {
  return _internal_has_not_();
}
inline void Condition::set_has_not_() {
  _oneof_case_[0] = kNot;
}
inline void Condition::clear_not_() {
  if (_internal_has_not_()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.not__;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::NotCondition* Condition::release_not_() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.not)
  if (_internal_has_not_()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::NotCondition* temp = data_.not__;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.not__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::NotCondition& Condition::_internal_not_() const {
  return _internal_has_not_()
      ? *data_.not__
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::NotCondition&>(::io::deephaven::proto::backplane::grpc::_NotCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::NotCondition& Condition::not_() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.not)
  return _internal_not_();
}
inline ::io::deephaven::proto::backplane::grpc::NotCondition* Condition::unsafe_arena_release_not_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.not)
  if (_internal_has_not_()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::NotCondition* temp = data_.not__;
    data_.not__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_not_(::io::deephaven::proto::backplane::grpc::NotCondition* not_) {
  clear_data();
  if (not_) {
    set_has_not_();
    data_.not__ = not_;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.not)
}
inline ::io::deephaven::proto::backplane::grpc::NotCondition* Condition::_internal_mutable_not_() {
  if (!_internal_has_not_()) {
    clear_data();
    set_has_not_();
    data_.not__ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::NotCondition >(GetArenaForAllocation());
  }
  return data_.not__;
}
inline ::io::deephaven::proto::backplane::grpc::NotCondition* Condition::mutable_not_() {
  ::io::deephaven::proto::backplane::grpc::NotCondition* _msg = _internal_mutable_not_();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.not)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.CompareCondition compare = 4;
inline bool Condition::_internal_has_compare() const {
  return data_case() == kCompare;
}
inline bool Condition::has_compare() const {
  return _internal_has_compare();
}
inline void Condition::set_has_compare() {
  _oneof_case_[0] = kCompare;
}
inline void Condition::clear_compare() {
  if (_internal_has_compare()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.compare_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition* Condition::release_compare() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.compare)
  if (_internal_has_compare()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::CompareCondition* temp = data_.compare_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.compare_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CompareCondition& Condition::_internal_compare() const {
  return _internal_has_compare()
      ? *data_.compare_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::CompareCondition&>(::io::deephaven::proto::backplane::grpc::_CompareCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CompareCondition& Condition::compare() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.compare)
  return _internal_compare();
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition* Condition::unsafe_arena_release_compare() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.compare)
  if (_internal_has_compare()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::CompareCondition* temp = data_.compare_;
    data_.compare_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_compare(::io::deephaven::proto::backplane::grpc::CompareCondition* compare) {
  clear_data();
  if (compare) {
    set_has_compare();
    data_.compare_ = compare;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.compare)
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition* Condition::_internal_mutable_compare() {
  if (!_internal_has_compare()) {
    clear_data();
    set_has_compare();
    data_.compare_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::CompareCondition >(GetArenaForAllocation());
  }
  return data_.compare_;
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition* Condition::mutable_compare() {
  ::io::deephaven::proto::backplane::grpc::CompareCondition* _msg = _internal_mutable_compare();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.compare)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.InCondition in = 5;
inline bool Condition::_internal_has_in() const {
  return data_case() == kIn;
}
inline bool Condition::has_in() const {
  return _internal_has_in();
}
inline void Condition::set_has_in() {
  _oneof_case_[0] = kIn;
}
inline void Condition::clear_in() {
  if (_internal_has_in()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.in_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::InCondition* Condition::release_in() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.in)
  if (_internal_has_in()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::InCondition* temp = data_.in_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::InCondition& Condition::_internal_in() const {
  return _internal_has_in()
      ? *data_.in_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::InCondition&>(::io::deephaven::proto::backplane::grpc::_InCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::InCondition& Condition::in() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.in)
  return _internal_in();
}
inline ::io::deephaven::proto::backplane::grpc::InCondition* Condition::unsafe_arena_release_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.in)
  if (_internal_has_in()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::InCondition* temp = data_.in_;
    data_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_in(::io::deephaven::proto::backplane::grpc::InCondition* in) {
  clear_data();
  if (in) {
    set_has_in();
    data_.in_ = in;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.in)
}
inline ::io::deephaven::proto::backplane::grpc::InCondition* Condition::_internal_mutable_in() {
  if (!_internal_has_in()) {
    clear_data();
    set_has_in();
    data_.in_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::InCondition >(GetArenaForAllocation());
  }
  return data_.in_;
}
inline ::io::deephaven::proto::backplane::grpc::InCondition* Condition::mutable_in() {
  ::io::deephaven::proto::backplane::grpc::InCondition* _msg = _internal_mutable_in();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.in)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.InvokeCondition invoke = 6;
inline bool Condition::_internal_has_invoke() const {
  return data_case() == kInvoke;
}
inline bool Condition::has_invoke() const {
  return _internal_has_invoke();
}
inline void Condition::set_has_invoke() {
  _oneof_case_[0] = kInvoke;
}
inline void Condition::clear_invoke() {
  if (_internal_has_invoke()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.invoke_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::InvokeCondition* Condition::release_invoke() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.invoke)
  if (_internal_has_invoke()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::InvokeCondition* temp = data_.invoke_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.invoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::InvokeCondition& Condition::_internal_invoke() const {
  return _internal_has_invoke()
      ? *data_.invoke_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::InvokeCondition&>(::io::deephaven::proto::backplane::grpc::_InvokeCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::InvokeCondition& Condition::invoke() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.invoke)
  return _internal_invoke();
}
inline ::io::deephaven::proto::backplane::grpc::InvokeCondition* Condition::unsafe_arena_release_invoke() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.invoke)
  if (_internal_has_invoke()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::InvokeCondition* temp = data_.invoke_;
    data_.invoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_invoke(::io::deephaven::proto::backplane::grpc::InvokeCondition* invoke) {
  clear_data();
  if (invoke) {
    set_has_invoke();
    data_.invoke_ = invoke;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.invoke)
}
inline ::io::deephaven::proto::backplane::grpc::InvokeCondition* Condition::_internal_mutable_invoke() {
  if (!_internal_has_invoke()) {
    clear_data();
    set_has_invoke();
    data_.invoke_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::InvokeCondition >(GetArenaForAllocation());
  }
  return data_.invoke_;
}
inline ::io::deephaven::proto::backplane::grpc::InvokeCondition* Condition::mutable_invoke() {
  ::io::deephaven::proto::backplane::grpc::InvokeCondition* _msg = _internal_mutable_invoke();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.invoke)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.IsNullCondition is_null = 7;
inline bool Condition::_internal_has_is_null() const {
  return data_case() == kIsNull;
}
inline bool Condition::has_is_null() const {
  return _internal_has_is_null();
}
inline void Condition::set_has_is_null() {
  _oneof_case_[0] = kIsNull;
}
inline void Condition::clear_is_null() {
  if (_internal_has_is_null()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.is_null_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::IsNullCondition* Condition::release_is_null() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.is_null)
  if (_internal_has_is_null()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::IsNullCondition* temp = data_.is_null_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.is_null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::IsNullCondition& Condition::_internal_is_null() const {
  return _internal_has_is_null()
      ? *data_.is_null_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::IsNullCondition&>(::io::deephaven::proto::backplane::grpc::_IsNullCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::IsNullCondition& Condition::is_null() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.is_null)
  return _internal_is_null();
}
inline ::io::deephaven::proto::backplane::grpc::IsNullCondition* Condition::unsafe_arena_release_is_null() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.is_null)
  if (_internal_has_is_null()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::IsNullCondition* temp = data_.is_null_;
    data_.is_null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_is_null(::io::deephaven::proto::backplane::grpc::IsNullCondition* is_null) {
  clear_data();
  if (is_null) {
    set_has_is_null();
    data_.is_null_ = is_null;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.is_null)
}
inline ::io::deephaven::proto::backplane::grpc::IsNullCondition* Condition::_internal_mutable_is_null() {
  if (!_internal_has_is_null()) {
    clear_data();
    set_has_is_null();
    data_.is_null_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::IsNullCondition >(GetArenaForAllocation());
  }
  return data_.is_null_;
}
inline ::io::deephaven::proto::backplane::grpc::IsNullCondition* Condition::mutable_is_null() {
  ::io::deephaven::proto::backplane::grpc::IsNullCondition* _msg = _internal_mutable_is_null();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.is_null)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.MatchesCondition matches = 8;
inline bool Condition::_internal_has_matches() const {
  return data_case() == kMatches;
}
inline bool Condition::has_matches() const {
  return _internal_has_matches();
}
inline void Condition::set_has_matches() {
  _oneof_case_[0] = kMatches;
}
inline void Condition::clear_matches() {
  if (_internal_has_matches()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.matches_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::MatchesCondition* Condition::release_matches() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.matches)
  if (_internal_has_matches()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::MatchesCondition* temp = data_.matches_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.matches_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::MatchesCondition& Condition::_internal_matches() const {
  return _internal_has_matches()
      ? *data_.matches_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::MatchesCondition&>(::io::deephaven::proto::backplane::grpc::_MatchesCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MatchesCondition& Condition::matches() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.matches)
  return _internal_matches();
}
inline ::io::deephaven::proto::backplane::grpc::MatchesCondition* Condition::unsafe_arena_release_matches() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.matches)
  if (_internal_has_matches()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::MatchesCondition* temp = data_.matches_;
    data_.matches_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_matches(::io::deephaven::proto::backplane::grpc::MatchesCondition* matches) {
  clear_data();
  if (matches) {
    set_has_matches();
    data_.matches_ = matches;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.matches)
}
inline ::io::deephaven::proto::backplane::grpc::MatchesCondition* Condition::_internal_mutable_matches() {
  if (!_internal_has_matches()) {
    clear_data();
    set_has_matches();
    data_.matches_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::MatchesCondition >(GetArenaForAllocation());
  }
  return data_.matches_;
}
inline ::io::deephaven::proto::backplane::grpc::MatchesCondition* Condition::mutable_matches() {
  ::io::deephaven::proto::backplane::grpc::MatchesCondition* _msg = _internal_mutable_matches();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.matches)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.ContainsCondition contains = 9;
inline bool Condition::_internal_has_contains() const {
  return data_case() == kContains;
}
inline bool Condition::has_contains() const {
  return _internal_has_contains();
}
inline void Condition::set_has_contains() {
  _oneof_case_[0] = kContains;
}
inline void Condition::clear_contains() {
  if (_internal_has_contains()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.contains_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::ContainsCondition* Condition::release_contains() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.contains)
  if (_internal_has_contains()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::ContainsCondition* temp = data_.contains_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.contains_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::ContainsCondition& Condition::_internal_contains() const {
  return _internal_has_contains()
      ? *data_.contains_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::ContainsCondition&>(::io::deephaven::proto::backplane::grpc::_ContainsCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::ContainsCondition& Condition::contains() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.contains)
  return _internal_contains();
}
inline ::io::deephaven::proto::backplane::grpc::ContainsCondition* Condition::unsafe_arena_release_contains() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.contains)
  if (_internal_has_contains()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::ContainsCondition* temp = data_.contains_;
    data_.contains_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_contains(::io::deephaven::proto::backplane::grpc::ContainsCondition* contains) {
  clear_data();
  if (contains) {
    set_has_contains();
    data_.contains_ = contains;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.contains)
}
inline ::io::deephaven::proto::backplane::grpc::ContainsCondition* Condition::_internal_mutable_contains() {
  if (!_internal_has_contains()) {
    clear_data();
    set_has_contains();
    data_.contains_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::ContainsCondition >(GetArenaForAllocation());
  }
  return data_.contains_;
}
inline ::io::deephaven::proto::backplane::grpc::ContainsCondition* Condition::mutable_contains() {
  ::io::deephaven::proto::backplane::grpc::ContainsCondition* _msg = _internal_mutable_contains();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.contains)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SearchCondition search = 10;
inline bool Condition::_internal_has_search() const {
  return data_case() == kSearch;
}
inline bool Condition::has_search() const {
  return _internal_has_search();
}
inline void Condition::set_has_search() {
  _oneof_case_[0] = kSearch;
}
inline void Condition::clear_search() {
  if (_internal_has_search()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.search_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SearchCondition* Condition::release_search() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.search)
  if (_internal_has_search()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::SearchCondition* temp = data_.search_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.search_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SearchCondition& Condition::_internal_search() const {
  return _internal_has_search()
      ? *data_.search_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SearchCondition&>(::io::deephaven::proto::backplane::grpc::_SearchCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SearchCondition& Condition::search() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.search)
  return _internal_search();
}
inline ::io::deephaven::proto::backplane::grpc::SearchCondition* Condition::unsafe_arena_release_search() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.search)
  if (_internal_has_search()) {
    clear_has_data();
    ::io::deephaven::proto::backplane::grpc::SearchCondition* temp = data_.search_;
    data_.search_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_search(::io::deephaven::proto::backplane::grpc::SearchCondition* search) {
  clear_data();
  if (search) {
    set_has_search();
    data_.search_ = search;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.search)
}
inline ::io::deephaven::proto::backplane::grpc::SearchCondition* Condition::_internal_mutable_search() {
  if (!_internal_has_search()) {
    clear_data();
    set_has_search();
    data_.search_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SearchCondition >(GetArenaForAllocation());
  }
  return data_.search_;
}
inline ::io::deephaven::proto::backplane::grpc::SearchCondition* Condition::mutable_search() {
  ::io::deephaven::proto::backplane::grpc::SearchCondition* _msg = _internal_mutable_search();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.search)
  return _msg;
}

inline bool Condition::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Condition::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline Condition::DataCase Condition::data_case() const {
  return Condition::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AndCondition

// repeated .io.deephaven.proto.backplane.grpc.Condition filters = 1;
inline int AndCondition::_internal_filters_size() const {
  return filters_.size();
}
inline int AndCondition::filters_size() const {
  return _internal_filters_size();
}
inline void AndCondition::clear_filters() {
  filters_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* AndCondition::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
AndCondition::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return &filters_;
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& AndCondition::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& AndCondition::filters(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return _internal_filters(index);
}
inline ::io::deephaven::proto::backplane::grpc::Condition* AndCondition::_internal_add_filters() {
  return filters_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* AndCondition::add_filters() {
  ::io::deephaven::proto::backplane::grpc::Condition* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
AndCondition::filters() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return filters_;
}

// -------------------------------------------------------------------

// OrCondition

// repeated .io.deephaven.proto.backplane.grpc.Condition filters = 1;
inline int OrCondition::_internal_filters_size() const {
  return filters_.size();
}
inline int OrCondition::filters_size() const {
  return _internal_filters_size();
}
inline void OrCondition::clear_filters() {
  filters_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* OrCondition::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
OrCondition::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return &filters_;
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& OrCondition::_internal_filters(int index) const {
  return filters_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& OrCondition::filters(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return _internal_filters(index);
}
inline ::io::deephaven::proto::backplane::grpc::Condition* OrCondition::_internal_add_filters() {
  return filters_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* OrCondition::add_filters() {
  ::io::deephaven::proto::backplane::grpc::Condition* _add = _internal_add_filters();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
OrCondition::filters() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return filters_;
}

// -------------------------------------------------------------------

// NotCondition

// .io.deephaven.proto.backplane.grpc.Condition filter = 1;
inline bool NotCondition::_internal_has_filter() const {
  return this != internal_default_instance() && filter_ != nullptr;
}
inline bool NotCondition::has_filter() const {
  return _internal_has_filter();
}
inline void NotCondition::clear_filter() {
  if (GetArenaForAllocation() == nullptr && filter_ != nullptr) {
    delete filter_;
  }
  filter_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& NotCondition::_internal_filter() const {
  const ::io::deephaven::proto::backplane::grpc::Condition* p = filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Condition&>(
      ::io::deephaven::proto::backplane::grpc::_Condition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& NotCondition::filter() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NotCondition.filter)
  return _internal_filter();
}
inline void NotCondition::unsafe_arena_set_allocated_filter(
    ::io::deephaven::proto::backplane::grpc::Condition* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  filter_ = filter;
  if (filter) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.NotCondition.filter)
}
inline ::io::deephaven::proto::backplane::grpc::Condition* NotCondition::release_filter() {
  
  ::io::deephaven::proto::backplane::grpc::Condition* temp = filter_;
  filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Condition* NotCondition::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.NotCondition.filter)
  
  ::io::deephaven::proto::backplane::grpc::Condition* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Condition* NotCondition::_internal_mutable_filter() {
  
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Condition>(GetArenaForAllocation());
    filter_ = p;
  }
  return filter_;
}
inline ::io::deephaven::proto::backplane::grpc::Condition* NotCondition::mutable_filter() {
  ::io::deephaven::proto::backplane::grpc::Condition* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NotCondition.filter)
  return _msg;
}
inline void NotCondition::set_allocated_filter(::io::deephaven::proto::backplane::grpc::Condition* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    
  } else {
    
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.NotCondition.filter)
}

// -------------------------------------------------------------------

// CompareCondition

// .io.deephaven.proto.backplane.grpc.CompareCondition.CompareOperation operation = 1;
inline void CompareCondition::clear_operation() {
  operation_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation CompareCondition::_internal_operation() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation >(operation_);
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation CompareCondition::operation() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CompareCondition.operation)
  return _internal_operation();
}
inline void CompareCondition::_internal_set_operation(::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation value) {
  
  operation_ = value;
}
inline void CompareCondition::set_operation(::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CompareCondition.operation)
}

// .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 2;
inline void CompareCondition::clear_case_sensitivity() {
  case_sensitivity_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity CompareCondition::_internal_case_sensitivity() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::CaseSensitivity >(case_sensitivity_);
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity CompareCondition::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CompareCondition.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void CompareCondition::_internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  
  case_sensitivity_ = value;
}
inline void CompareCondition::set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CompareCondition.case_sensitivity)
}

// .io.deephaven.proto.backplane.grpc.Value lhs = 3;
inline bool CompareCondition::_internal_has_lhs() const {
  return this != internal_default_instance() && lhs_ != nullptr;
}
inline bool CompareCondition::has_lhs() const {
  return _internal_has_lhs();
}
inline void CompareCondition::clear_lhs() {
  if (GetArenaForAllocation() == nullptr && lhs_ != nullptr) {
    delete lhs_;
  }
  lhs_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& CompareCondition::_internal_lhs() const {
  const ::io::deephaven::proto::backplane::grpc::Value* p = lhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Value&>(
      ::io::deephaven::proto::backplane::grpc::_Value_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& CompareCondition::lhs() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
  return _internal_lhs();
}
inline void CompareCondition::unsafe_arena_set_allocated_lhs(
    ::io::deephaven::proto::backplane::grpc::Value* lhs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lhs_);
  }
  lhs_ = lhs;
  if (lhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::release_lhs() {
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = lhs_;
  lhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::unsafe_arena_release_lhs() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = lhs_;
  lhs_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::_internal_mutable_lhs() {
  
  if (lhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(GetArenaForAllocation());
    lhs_ = p;
  }
  return lhs_;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::mutable_lhs() {
  ::io::deephaven::proto::backplane::grpc::Value* _msg = _internal_mutable_lhs();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
  return _msg;
}
inline void CompareCondition::set_allocated_lhs(::io::deephaven::proto::backplane::grpc::Value* lhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete lhs_;
  }
  if (lhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(lhs);
    if (message_arena != submessage_arena) {
      lhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lhs, submessage_arena);
    }
    
  } else {
    
  }
  lhs_ = lhs;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
}

// .io.deephaven.proto.backplane.grpc.Value rhs = 4;
inline bool CompareCondition::_internal_has_rhs() const {
  return this != internal_default_instance() && rhs_ != nullptr;
}
inline bool CompareCondition::has_rhs() const {
  return _internal_has_rhs();
}
inline void CompareCondition::clear_rhs() {
  if (GetArenaForAllocation() == nullptr && rhs_ != nullptr) {
    delete rhs_;
  }
  rhs_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& CompareCondition::_internal_rhs() const {
  const ::io::deephaven::proto::backplane::grpc::Value* p = rhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Value&>(
      ::io::deephaven::proto::backplane::grpc::_Value_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& CompareCondition::rhs() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
  return _internal_rhs();
}
inline void CompareCondition::unsafe_arena_set_allocated_rhs(
    ::io::deephaven::proto::backplane::grpc::Value* rhs) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rhs_);
  }
  rhs_ = rhs;
  if (rhs) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::release_rhs() {
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = rhs_;
  rhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::unsafe_arena_release_rhs() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = rhs_;
  rhs_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::_internal_mutable_rhs() {
  
  if (rhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(GetArenaForAllocation());
    rhs_ = p;
  }
  return rhs_;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::mutable_rhs() {
  ::io::deephaven::proto::backplane::grpc::Value* _msg = _internal_mutable_rhs();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
  return _msg;
}
inline void CompareCondition::set_allocated_rhs(::io::deephaven::proto::backplane::grpc::Value* rhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete rhs_;
  }
  if (rhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rhs);
    if (message_arena != submessage_arena) {
      rhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rhs, submessage_arena);
    }
    
  } else {
    
  }
  rhs_ = rhs;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
}

// -------------------------------------------------------------------

// InCondition

// .io.deephaven.proto.backplane.grpc.Value target = 1;
inline bool InCondition::_internal_has_target() const {
  return this != internal_default_instance() && target_ != nullptr;
}
inline bool InCondition::has_target() const {
  return _internal_has_target();
}
inline void InCondition::clear_target() {
  if (GetArenaForAllocation() == nullptr && target_ != nullptr) {
    delete target_;
  }
  target_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InCondition::_internal_target() const {
  const ::io::deephaven::proto::backplane::grpc::Value* p = target_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Value&>(
      ::io::deephaven::proto::backplane::grpc::_Value_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InCondition::target() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InCondition.target)
  return _internal_target();
}
inline void InCondition::unsafe_arena_set_allocated_target(
    ::io::deephaven::proto::backplane::grpc::Value* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_);
  }
  target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.InCondition.target)
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::release_target() {
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = target_;
  target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.InCondition.target)
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = target_;
  target_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::_internal_mutable_target() {
  
  if (target_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(GetArenaForAllocation());
    target_ = p;
  }
  return target_;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::mutable_target() {
  ::io::deephaven::proto::backplane::grpc::Value* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InCondition.target)
  return _msg;
}
inline void InCondition::set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.InCondition.target)
}

// repeated .io.deephaven.proto.backplane.grpc.Value candidates = 2;
inline int InCondition::_internal_candidates_size() const {
  return candidates_.size();
}
inline int InCondition::candidates_size() const {
  return _internal_candidates_size();
}
inline void InCondition::clear_candidates() {
  candidates_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::mutable_candidates(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return candidates_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >*
InCondition::mutable_candidates() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return &candidates_;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InCondition::_internal_candidates(int index) const {
  return candidates_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InCondition::candidates(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return _internal_candidates(index);
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::_internal_add_candidates() {
  return candidates_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::add_candidates() {
  ::io::deephaven::proto::backplane::grpc::Value* _add = _internal_add_candidates();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >&
InCondition::candidates() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return candidates_;
}

// .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
inline void InCondition::clear_case_sensitivity() {
  case_sensitivity_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity InCondition::_internal_case_sensitivity() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::CaseSensitivity >(case_sensitivity_);
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity InCondition::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InCondition.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void InCondition::_internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  
  case_sensitivity_ = value;
}
inline void InCondition::set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.InCondition.case_sensitivity)
}

// .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
inline void InCondition::clear_match_type() {
  match_type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::MatchType InCondition::_internal_match_type() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::MatchType >(match_type_);
}
inline ::io::deephaven::proto::backplane::grpc::MatchType InCondition::match_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InCondition.match_type)
  return _internal_match_type();
}
inline void InCondition::_internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  
  match_type_ = value;
}
inline void InCondition::set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  _internal_set_match_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.InCondition.match_type)
}

// -------------------------------------------------------------------

// InvokeCondition

// string method = 1;
inline void InvokeCondition::clear_method() {
  method_.ClearToEmpty();
}
inline const std::string& InvokeCondition::method() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
  return _internal_method();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InvokeCondition::set_method(ArgT0&& arg0, ArgT... args) {
 
 method_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
}
inline std::string* InvokeCondition::mutable_method() {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
  return _s;
}
inline const std::string& InvokeCondition::_internal_method() const {
  return method_.Get();
}
inline void InvokeCondition::_internal_set_method(const std::string& value) {
  
  method_.Set(value, GetArenaForAllocation());
}
inline std::string* InvokeCondition::_internal_mutable_method() {
  
  return method_.Mutable(GetArenaForAllocation());
}
inline std::string* InvokeCondition::release_method() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
  return method_.Release();
}
inline void InvokeCondition::set_allocated_method(std::string* method) {
  if (method != nullptr) {
    
  } else {
    
  }
  method_.SetAllocated(method, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (method_.IsDefault()) {
    method_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
}

// .io.deephaven.proto.backplane.grpc.Value target = 2;
inline bool InvokeCondition::_internal_has_target() const {
  return this != internal_default_instance() && target_ != nullptr;
}
inline bool InvokeCondition::has_target() const {
  return _internal_has_target();
}
inline void InvokeCondition::clear_target() {
  if (GetArenaForAllocation() == nullptr && target_ != nullptr) {
    delete target_;
  }
  target_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InvokeCondition::_internal_target() const {
  const ::io::deephaven::proto::backplane::grpc::Value* p = target_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Value&>(
      ::io::deephaven::proto::backplane::grpc::_Value_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InvokeCondition::target() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
  return _internal_target();
}
inline void InvokeCondition::unsafe_arena_set_allocated_target(
    ::io::deephaven::proto::backplane::grpc::Value* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target_);
  }
  target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::release_target() {
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = target_;
  target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
  
  ::io::deephaven::proto::backplane::grpc::Value* temp = target_;
  target_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::_internal_mutable_target() {
  
  if (target_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(GetArenaForAllocation());
    target_ = p;
  }
  return target_;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::mutable_target() {
  ::io::deephaven::proto::backplane::grpc::Value* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
  return _msg;
}
inline void InvokeCondition::set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete target_;
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(target);
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  target_ = target;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
}

// repeated .io.deephaven.proto.backplane.grpc.Value arguments = 3;
inline int InvokeCondition::_internal_arguments_size() const {
  return arguments_.size();
}
inline int InvokeCondition::arguments_size() const {
  return _internal_arguments_size();
}
inline void InvokeCondition::clear_arguments() {
  arguments_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return arguments_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >*
InvokeCondition::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return &arguments_;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InvokeCondition::_internal_arguments(int index) const {
  return arguments_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InvokeCondition::arguments(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return _internal_arguments(index);
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::_internal_add_arguments() {
  return arguments_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::add_arguments() {
  ::io::deephaven::proto::backplane::grpc::Value* _add = _internal_add_arguments();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >&
InvokeCondition::arguments() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return arguments_;
}

// -------------------------------------------------------------------

// IsNullCondition

// .io.deephaven.proto.backplane.grpc.Reference reference = 1;
inline bool IsNullCondition::_internal_has_reference() const {
  return this != internal_default_instance() && reference_ != nullptr;
}
inline bool IsNullCondition::has_reference() const {
  return _internal_has_reference();
}
inline void IsNullCondition::clear_reference() {
  if (GetArenaForAllocation() == nullptr && reference_ != nullptr) {
    delete reference_;
  }
  reference_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& IsNullCondition::_internal_reference() const {
  const ::io::deephaven::proto::backplane::grpc::Reference* p = reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Reference&>(
      ::io::deephaven::proto::backplane::grpc::_Reference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& IsNullCondition::reference() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
  return _internal_reference();
}
inline void IsNullCondition::unsafe_arena_set_allocated_reference(
    ::io::deephaven::proto::backplane::grpc::Reference* reference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_);
  }
  reference_ = reference;
  if (reference) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
}
inline ::io::deephaven::proto::backplane::grpc::Reference* IsNullCondition::release_reference() {
  
  ::io::deephaven::proto::backplane::grpc::Reference* temp = reference_;
  reference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* IsNullCondition::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
  
  ::io::deephaven::proto::backplane::grpc::Reference* temp = reference_;
  reference_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* IsNullCondition::_internal_mutable_reference() {
  
  if (reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Reference>(GetArenaForAllocation());
    reference_ = p;
  }
  return reference_;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* IsNullCondition::mutable_reference() {
  ::io::deephaven::proto::backplane::grpc::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
  return _msg;
}
inline void IsNullCondition::set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reference_;
  }
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    
  } else {
    
  }
  reference_ = reference;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
}

// -------------------------------------------------------------------

// MatchesCondition

// .io.deephaven.proto.backplane.grpc.Reference reference = 1;
inline bool MatchesCondition::_internal_has_reference() const {
  return this != internal_default_instance() && reference_ != nullptr;
}
inline bool MatchesCondition::has_reference() const {
  return _internal_has_reference();
}
inline void MatchesCondition::clear_reference() {
  if (GetArenaForAllocation() == nullptr && reference_ != nullptr) {
    delete reference_;
  }
  reference_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& MatchesCondition::_internal_reference() const {
  const ::io::deephaven::proto::backplane::grpc::Reference* p = reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Reference&>(
      ::io::deephaven::proto::backplane::grpc::_Reference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& MatchesCondition::reference() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
  return _internal_reference();
}
inline void MatchesCondition::unsafe_arena_set_allocated_reference(
    ::io::deephaven::proto::backplane::grpc::Reference* reference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_);
  }
  reference_ = reference;
  if (reference) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
}
inline ::io::deephaven::proto::backplane::grpc::Reference* MatchesCondition::release_reference() {
  
  ::io::deephaven::proto::backplane::grpc::Reference* temp = reference_;
  reference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* MatchesCondition::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
  
  ::io::deephaven::proto::backplane::grpc::Reference* temp = reference_;
  reference_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* MatchesCondition::_internal_mutable_reference() {
  
  if (reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Reference>(GetArenaForAllocation());
    reference_ = p;
  }
  return reference_;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* MatchesCondition::mutable_reference() {
  ::io::deephaven::proto::backplane::grpc::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
  return _msg;
}
inline void MatchesCondition::set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reference_;
  }
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    
  } else {
    
  }
  reference_ = reference;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
}

// string regex = 2;
inline void MatchesCondition::clear_regex() {
  regex_.ClearToEmpty();
}
inline const std::string& MatchesCondition::regex() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
  return _internal_regex();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MatchesCondition::set_regex(ArgT0&& arg0, ArgT... args) {
 
 regex_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
}
inline std::string* MatchesCondition::mutable_regex() {
  std::string* _s = _internal_mutable_regex();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
  return _s;
}
inline const std::string& MatchesCondition::_internal_regex() const {
  return regex_.Get();
}
inline void MatchesCondition::_internal_set_regex(const std::string& value) {
  
  regex_.Set(value, GetArenaForAllocation());
}
inline std::string* MatchesCondition::_internal_mutable_regex() {
  
  return regex_.Mutable(GetArenaForAllocation());
}
inline std::string* MatchesCondition::release_regex() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
  return regex_.Release();
}
inline void MatchesCondition::set_allocated_regex(std::string* regex) {
  if (regex != nullptr) {
    
  } else {
    
  }
  regex_.SetAllocated(regex, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (regex_.IsDefault()) {
    regex_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
}

// .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
inline void MatchesCondition::clear_case_sensitivity() {
  case_sensitivity_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity MatchesCondition::_internal_case_sensitivity() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::CaseSensitivity >(case_sensitivity_);
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity MatchesCondition::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MatchesCondition.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void MatchesCondition::_internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  
  case_sensitivity_ = value;
}
inline void MatchesCondition::set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MatchesCondition.case_sensitivity)
}

// .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
inline void MatchesCondition::clear_match_type() {
  match_type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::MatchType MatchesCondition::_internal_match_type() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::MatchType >(match_type_);
}
inline ::io::deephaven::proto::backplane::grpc::MatchType MatchesCondition::match_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MatchesCondition.match_type)
  return _internal_match_type();
}
inline void MatchesCondition::_internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  
  match_type_ = value;
}
inline void MatchesCondition::set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  _internal_set_match_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MatchesCondition.match_type)
}

// -------------------------------------------------------------------

// ContainsCondition

// .io.deephaven.proto.backplane.grpc.Reference reference = 1;
inline bool ContainsCondition::_internal_has_reference() const {
  return this != internal_default_instance() && reference_ != nullptr;
}
inline bool ContainsCondition::has_reference() const {
  return _internal_has_reference();
}
inline void ContainsCondition::clear_reference() {
  if (GetArenaForAllocation() == nullptr && reference_ != nullptr) {
    delete reference_;
  }
  reference_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& ContainsCondition::_internal_reference() const {
  const ::io::deephaven::proto::backplane::grpc::Reference* p = reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Reference&>(
      ::io::deephaven::proto::backplane::grpc::_Reference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& ContainsCondition::reference() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
  return _internal_reference();
}
inline void ContainsCondition::unsafe_arena_set_allocated_reference(
    ::io::deephaven::proto::backplane::grpc::Reference* reference) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reference_);
  }
  reference_ = reference;
  if (reference) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
}
inline ::io::deephaven::proto::backplane::grpc::Reference* ContainsCondition::release_reference() {
  
  ::io::deephaven::proto::backplane::grpc::Reference* temp = reference_;
  reference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* ContainsCondition::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
  
  ::io::deephaven::proto::backplane::grpc::Reference* temp = reference_;
  reference_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* ContainsCondition::_internal_mutable_reference() {
  
  if (reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Reference>(GetArenaForAllocation());
    reference_ = p;
  }
  return reference_;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* ContainsCondition::mutable_reference() {
  ::io::deephaven::proto::backplane::grpc::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
  return _msg;
}
inline void ContainsCondition::set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* reference) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reference_;
  }
  if (reference) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(reference);
    if (message_arena != submessage_arena) {
      reference = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reference, submessage_arena);
    }
    
  } else {
    
  }
  reference_ = reference;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
}

// string search_string = 2;
inline void ContainsCondition::clear_search_string() {
  search_string_.ClearToEmpty();
}
inline const std::string& ContainsCondition::search_string() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
  return _internal_search_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ContainsCondition::set_search_string(ArgT0&& arg0, ArgT... args) {
 
 search_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
}
inline std::string* ContainsCondition::mutable_search_string() {
  std::string* _s = _internal_mutable_search_string();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
  return _s;
}
inline const std::string& ContainsCondition::_internal_search_string() const {
  return search_string_.Get();
}
inline void ContainsCondition::_internal_set_search_string(const std::string& value) {
  
  search_string_.Set(value, GetArenaForAllocation());
}
inline std::string* ContainsCondition::_internal_mutable_search_string() {
  
  return search_string_.Mutable(GetArenaForAllocation());
}
inline std::string* ContainsCondition::release_search_string() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
  return search_string_.Release();
}
inline void ContainsCondition::set_allocated_search_string(std::string* search_string) {
  if (search_string != nullptr) {
    
  } else {
    
  }
  search_string_.SetAllocated(search_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (search_string_.IsDefault()) {
    search_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
}

// .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
inline void ContainsCondition::clear_case_sensitivity() {
  case_sensitivity_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity ContainsCondition::_internal_case_sensitivity() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::CaseSensitivity >(case_sensitivity_);
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity ContainsCondition::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ContainsCondition.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void ContainsCondition::_internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  
  case_sensitivity_ = value;
}
inline void ContainsCondition::set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ContainsCondition.case_sensitivity)
}

// .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
inline void ContainsCondition::clear_match_type() {
  match_type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::MatchType ContainsCondition::_internal_match_type() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::MatchType >(match_type_);
}
inline ::io::deephaven::proto::backplane::grpc::MatchType ContainsCondition::match_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ContainsCondition.match_type)
  return _internal_match_type();
}
inline void ContainsCondition::_internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  
  match_type_ = value;
}
inline void ContainsCondition::set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  _internal_set_match_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ContainsCondition.match_type)
}

// -------------------------------------------------------------------

// SearchCondition

// string search_string = 1;
inline void SearchCondition::clear_search_string() {
  search_string_.ClearToEmpty();
}
inline const std::string& SearchCondition::search_string() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
  return _internal_search_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SearchCondition::set_search_string(ArgT0&& arg0, ArgT... args) {
 
 search_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
}
inline std::string* SearchCondition::mutable_search_string() {
  std::string* _s = _internal_mutable_search_string();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
  return _s;
}
inline const std::string& SearchCondition::_internal_search_string() const {
  return search_string_.Get();
}
inline void SearchCondition::_internal_set_search_string(const std::string& value) {
  
  search_string_.Set(value, GetArenaForAllocation());
}
inline std::string* SearchCondition::_internal_mutable_search_string() {
  
  return search_string_.Mutable(GetArenaForAllocation());
}
inline std::string* SearchCondition::release_search_string() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
  return search_string_.Release();
}
inline void SearchCondition::set_allocated_search_string(std::string* search_string) {
  if (search_string != nullptr) {
    
  } else {
    
  }
  search_string_.SetAllocated(search_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (search_string_.IsDefault()) {
    search_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
}

// repeated .io.deephaven.proto.backplane.grpc.Reference optional_references = 2;
inline int SearchCondition::_internal_optional_references_size() const {
  return optional_references_.size();
}
inline int SearchCondition::optional_references_size() const {
  return _internal_optional_references_size();
}
inline void SearchCondition::clear_optional_references() {
  optional_references_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Reference* SearchCondition::mutable_optional_references(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return optional_references_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference >*
SearchCondition::mutable_optional_references() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return &optional_references_;
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& SearchCondition::_internal_optional_references(int index) const {
  return optional_references_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& SearchCondition::optional_references(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return _internal_optional_references(index);
}
inline ::io::deephaven::proto::backplane::grpc::Reference* SearchCondition::_internal_add_optional_references() {
  return optional_references_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::Reference* SearchCondition::add_optional_references() {
  ::io::deephaven::proto::backplane::grpc::Reference* _add = _internal_add_optional_references();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference >&
SearchCondition::optional_references() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return optional_references_;
}

// -------------------------------------------------------------------

// FlattenRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool FlattenRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool FlattenRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FlattenRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FlattenRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
  return _internal_result_id();
}
inline void FlattenRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FlattenRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FlattenRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FlattenRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FlattenRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
  return _msg;
}
inline void FlattenRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool FlattenRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool FlattenRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void FlattenRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FlattenRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FlattenRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
  return _internal_source_id();
}
inline void FlattenRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FlattenRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FlattenRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FlattenRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FlattenRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
  return _msg;
}
inline void FlattenRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
}

// -------------------------------------------------------------------

// MetaTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool MetaTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool MetaTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& MetaTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& MetaTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MetaTableRequest.result_id)
  return _internal_result_id();
}
inline void MetaTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.MetaTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MetaTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MetaTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MetaTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MetaTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MetaTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MetaTableRequest.result_id)
  return _msg;
}
inline void MetaTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MetaTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool MetaTableRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool MetaTableRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void MetaTableRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& MetaTableRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& MetaTableRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MetaTableRequest.source_id)
  return _internal_source_id();
}
inline void MetaTableRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.MetaTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MetaTableRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MetaTableRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MetaTableRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MetaTableRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MetaTableRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MetaTableRequest.source_id)
  return _msg;
}
inline void MetaTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MetaTableRequest.source_id)
}

// -------------------------------------------------------------------

// RunChartDownsampleRequest_ZoomRange

// optional int64 min_date_nanos = 1 [jstype = JS_STRING];
inline bool RunChartDownsampleRequest_ZoomRange::_internal_has_min_date_nanos() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RunChartDownsampleRequest_ZoomRange::has_min_date_nanos() const {
  return _internal_has_min_date_nanos();
}
inline void RunChartDownsampleRequest_ZoomRange::clear_min_date_nanos() {
  min_date_nanos_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t RunChartDownsampleRequest_ZoomRange::_internal_min_date_nanos() const {
  return min_date_nanos_;
}
inline int64_t RunChartDownsampleRequest_ZoomRange::min_date_nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange.min_date_nanos)
  return _internal_min_date_nanos();
}
inline void RunChartDownsampleRequest_ZoomRange::_internal_set_min_date_nanos(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  min_date_nanos_ = value;
}
inline void RunChartDownsampleRequest_ZoomRange::set_min_date_nanos(int64_t value) {
  _internal_set_min_date_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange.min_date_nanos)
}

// optional int64 max_date_nanos = 2 [jstype = JS_STRING];
inline bool RunChartDownsampleRequest_ZoomRange::_internal_has_max_date_nanos() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RunChartDownsampleRequest_ZoomRange::has_max_date_nanos() const {
  return _internal_has_max_date_nanos();
}
inline void RunChartDownsampleRequest_ZoomRange::clear_max_date_nanos() {
  max_date_nanos_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t RunChartDownsampleRequest_ZoomRange::_internal_max_date_nanos() const {
  return max_date_nanos_;
}
inline int64_t RunChartDownsampleRequest_ZoomRange::max_date_nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange.max_date_nanos)
  return _internal_max_date_nanos();
}
inline void RunChartDownsampleRequest_ZoomRange::_internal_set_max_date_nanos(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  max_date_nanos_ = value;
}
inline void RunChartDownsampleRequest_ZoomRange::set_max_date_nanos(int64_t value) {
  _internal_set_max_date_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange.max_date_nanos)
}

// -------------------------------------------------------------------

// RunChartDownsampleRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool RunChartDownsampleRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool RunChartDownsampleRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& RunChartDownsampleRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& RunChartDownsampleRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
  return _internal_result_id();
}
inline void RunChartDownsampleRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RunChartDownsampleRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RunChartDownsampleRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RunChartDownsampleRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RunChartDownsampleRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
  return _msg;
}
inline void RunChartDownsampleRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool RunChartDownsampleRequest::_internal_has_source_id() const {
  return this != internal_default_instance() && source_id_ != nullptr;
}
inline bool RunChartDownsampleRequest::has_source_id() const {
  return _internal_has_source_id();
}
inline void RunChartDownsampleRequest::clear_source_id() {
  if (GetArenaForAllocation() == nullptr && source_id_ != nullptr) {
    delete source_id_;
  }
  source_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RunChartDownsampleRequest::_internal_source_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RunChartDownsampleRequest::source_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
  return _internal_source_id();
}
inline void RunChartDownsampleRequest::unsafe_arena_set_allocated_source_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_id_);
  }
  source_id_ = source_id;
  if (source_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RunChartDownsampleRequest::release_source_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RunChartDownsampleRequest::unsafe_arena_release_source_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = source_id_;
  source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RunChartDownsampleRequest::_internal_mutable_source_id() {
  
  if (source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    source_id_ = p;
  }
  return source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RunChartDownsampleRequest::mutable_source_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
  return _msg;
}
inline void RunChartDownsampleRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* source_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete source_id_;
  }
  if (source_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_id);
    if (message_arena != submessage_arena) {
      source_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_id, submessage_arena);
    }
    
  } else {
    
  }
  source_id_ = source_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
}

// int32 pixel_count = 3;
inline void RunChartDownsampleRequest::clear_pixel_count() {
  pixel_count_ = 0;
}
inline int32_t RunChartDownsampleRequest::_internal_pixel_count() const {
  return pixel_count_;
}
inline int32_t RunChartDownsampleRequest::pixel_count() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.pixel_count)
  return _internal_pixel_count();
}
inline void RunChartDownsampleRequest::_internal_set_pixel_count(int32_t value) {
  
  pixel_count_ = value;
}
inline void RunChartDownsampleRequest::set_pixel_count(int32_t value) {
  _internal_set_pixel_count(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.pixel_count)
}

// .io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange zoom_range = 4;
inline bool RunChartDownsampleRequest::_internal_has_zoom_range() const {
  return this != internal_default_instance() && zoom_range_ != nullptr;
}
inline bool RunChartDownsampleRequest::has_zoom_range() const {
  return _internal_has_zoom_range();
}
inline void RunChartDownsampleRequest::clear_zoom_range() {
  if (GetArenaForAllocation() == nullptr && zoom_range_ != nullptr) {
    delete zoom_range_;
  }
  zoom_range_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange& RunChartDownsampleRequest::_internal_zoom_range() const {
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* p = zoom_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange&>(
      ::io::deephaven::proto::backplane::grpc::_RunChartDownsampleRequest_ZoomRange_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange& RunChartDownsampleRequest::zoom_range() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
  return _internal_zoom_range();
}
inline void RunChartDownsampleRequest::unsafe_arena_set_allocated_zoom_range(
    ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* zoom_range) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(zoom_range_);
  }
  zoom_range_ = zoom_range;
  if (zoom_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* RunChartDownsampleRequest::release_zoom_range() {
  
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* temp = zoom_range_;
  zoom_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* RunChartDownsampleRequest::unsafe_arena_release_zoom_range() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
  
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* temp = zoom_range_;
  zoom_range_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* RunChartDownsampleRequest::_internal_mutable_zoom_range() {
  
  if (zoom_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange>(GetArenaForAllocation());
    zoom_range_ = p;
  }
  return zoom_range_;
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* RunChartDownsampleRequest::mutable_zoom_range() {
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* _msg = _internal_mutable_zoom_range();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
  return _msg;
}
inline void RunChartDownsampleRequest::set_allocated_zoom_range(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* zoom_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete zoom_range_;
  }
  if (zoom_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(zoom_range);
    if (message_arena != submessage_arena) {
      zoom_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zoom_range, submessage_arena);
    }
    
  } else {
    
  }
  zoom_range_ = zoom_range;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
}

// string x_column_name = 5;
inline void RunChartDownsampleRequest::clear_x_column_name() {
  x_column_name_.ClearToEmpty();
}
inline const std::string& RunChartDownsampleRequest::x_column_name() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
  return _internal_x_column_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RunChartDownsampleRequest::set_x_column_name(ArgT0&& arg0, ArgT... args) {
 
 x_column_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
}
inline std::string* RunChartDownsampleRequest::mutable_x_column_name() {
  std::string* _s = _internal_mutable_x_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
  return _s;
}
inline const std::string& RunChartDownsampleRequest::_internal_x_column_name() const {
  return x_column_name_.Get();
}
inline void RunChartDownsampleRequest::_internal_set_x_column_name(const std::string& value) {
  
  x_column_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RunChartDownsampleRequest::_internal_mutable_x_column_name() {
  
  return x_column_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RunChartDownsampleRequest::release_x_column_name() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
  return x_column_name_.Release();
}
inline void RunChartDownsampleRequest::set_allocated_x_column_name(std::string* x_column_name) {
  if (x_column_name != nullptr) {
    
  } else {
    
  }
  x_column_name_.SetAllocated(x_column_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (x_column_name_.IsDefault()) {
    x_column_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
}

// repeated string y_column_names = 6;
inline int RunChartDownsampleRequest::_internal_y_column_names_size() const {
  return y_column_names_.size();
}
inline int RunChartDownsampleRequest::y_column_names_size() const {
  return _internal_y_column_names_size();
}
inline void RunChartDownsampleRequest::clear_y_column_names() {
  y_column_names_.Clear();
}
inline std::string* RunChartDownsampleRequest::add_y_column_names() {
  std::string* _s = _internal_add_y_column_names();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return _s;
}
inline const std::string& RunChartDownsampleRequest::_internal_y_column_names(int index) const {
  return y_column_names_.Get(index);
}
inline const std::string& RunChartDownsampleRequest::y_column_names(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return _internal_y_column_names(index);
}
inline std::string* RunChartDownsampleRequest::mutable_y_column_names(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return y_column_names_.Mutable(index);
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, const std::string& value) {
  y_column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, std::string&& value) {
  y_column_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  y_column_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, const char* value, size_t size) {
  y_column_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline std::string* RunChartDownsampleRequest::_internal_add_y_column_names() {
  return y_column_names_.Add();
}
inline void RunChartDownsampleRequest::add_y_column_names(const std::string& value) {
  y_column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::add_y_column_names(std::string&& value) {
  y_column_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::add_y_column_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  y_column_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::add_y_column_names(const char* value, size_t size) {
  y_column_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
RunChartDownsampleRequest::y_column_names() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return y_column_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
RunChartDownsampleRequest::mutable_y_column_names() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return &y_column_names_;
}

// -------------------------------------------------------------------

// CreateInputTableRequest_InputTableKind_InMemoryAppendOnly

// -------------------------------------------------------------------

// CreateInputTableRequest_InputTableKind_InMemoryKeyBacked

// repeated string key_columns = 1;
inline int CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::_internal_key_columns_size() const {
  return key_columns_.size();
}
inline int CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::key_columns_size() const {
  return _internal_key_columns_size();
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::clear_key_columns() {
  key_columns_.Clear();
}
inline std::string* CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::add_key_columns() {
  std::string* _s = _internal_add_key_columns();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
  return _s;
}
inline const std::string& CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::_internal_key_columns(int index) const {
  return key_columns_.Get(index);
}
inline const std::string& CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::key_columns(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
  return _internal_key_columns(index);
}
inline std::string* CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::mutable_key_columns(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
  return key_columns_.Mutable(index);
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::set_key_columns(int index, const std::string& value) {
  key_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::set_key_columns(int index, std::string&& value) {
  key_columns_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::set_key_columns(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  key_columns_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::set_key_columns(int index, const char* value, size_t size) {
  key_columns_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline std::string* CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::_internal_add_key_columns() {
  return key_columns_.Add();
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::add_key_columns(const std::string& value) {
  key_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::add_key_columns(std::string&& value) {
  key_columns_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::add_key_columns(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  key_columns_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::add_key_columns(const char* value, size_t size) {
  key_columns_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::key_columns() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
  return key_columns_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::mutable_key_columns() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
  return &key_columns_;
}

// -------------------------------------------------------------------

// CreateInputTableRequest_InputTableKind

// .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryAppendOnly in_memory_append_only = 1;
inline bool CreateInputTableRequest_InputTableKind::_internal_has_in_memory_append_only() const {
  return kind_case() == kInMemoryAppendOnly;
}
inline bool CreateInputTableRequest_InputTableKind::has_in_memory_append_only() const {
  return _internal_has_in_memory_append_only();
}
inline void CreateInputTableRequest_InputTableKind::set_has_in_memory_append_only() {
  _oneof_case_[0] = kInMemoryAppendOnly;
}
inline void CreateInputTableRequest_InputTableKind::clear_in_memory_append_only() {
  if (_internal_has_in_memory_append_only()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.in_memory_append_only_;
    }
    clear_has_kind();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* CreateInputTableRequest_InputTableKind::release_in_memory_append_only() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_append_only)
  if (_internal_has_in_memory_append_only()) {
    clear_has_kind();
    ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* temp = kind_.in_memory_append_only_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.in_memory_append_only_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& CreateInputTableRequest_InputTableKind::_internal_in_memory_append_only() const {
  return _internal_has_in_memory_append_only()
      ? *kind_.in_memory_append_only_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly&>(::io::deephaven::proto::backplane::grpc::_CreateInputTableRequest_InputTableKind_InMemoryAppendOnly_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& CreateInputTableRequest_InputTableKind::in_memory_append_only() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_append_only)
  return _internal_in_memory_append_only();
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* CreateInputTableRequest_InputTableKind::unsafe_arena_release_in_memory_append_only() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_append_only)
  if (_internal_has_in_memory_append_only()) {
    clear_has_kind();
    ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* temp = kind_.in_memory_append_only_;
    kind_.in_memory_append_only_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateInputTableRequest_InputTableKind::unsafe_arena_set_allocated_in_memory_append_only(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* in_memory_append_only) {
  clear_kind();
  if (in_memory_append_only) {
    set_has_in_memory_append_only();
    kind_.in_memory_append_only_ = in_memory_append_only;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_append_only)
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* CreateInputTableRequest_InputTableKind::_internal_mutable_in_memory_append_only() {
  if (!_internal_has_in_memory_append_only()) {
    clear_kind();
    set_has_in_memory_append_only();
    kind_.in_memory_append_only_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly >(GetArenaForAllocation());
  }
  return kind_.in_memory_append_only_;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* CreateInputTableRequest_InputTableKind::mutable_in_memory_append_only() {
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* _msg = _internal_mutable_in_memory_append_only();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_append_only)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked in_memory_key_backed = 2;
inline bool CreateInputTableRequest_InputTableKind::_internal_has_in_memory_key_backed() const {
  return kind_case() == kInMemoryKeyBacked;
}
inline bool CreateInputTableRequest_InputTableKind::has_in_memory_key_backed() const {
  return _internal_has_in_memory_key_backed();
}
inline void CreateInputTableRequest_InputTableKind::set_has_in_memory_key_backed() {
  _oneof_case_[0] = kInMemoryKeyBacked;
}
inline void CreateInputTableRequest_InputTableKind::clear_in_memory_key_backed() {
  if (_internal_has_in_memory_key_backed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete kind_.in_memory_key_backed_;
    }
    clear_has_kind();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* CreateInputTableRequest_InputTableKind::release_in_memory_key_backed() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_key_backed)
  if (_internal_has_in_memory_key_backed()) {
    clear_has_kind();
    ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* temp = kind_.in_memory_key_backed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    kind_.in_memory_key_backed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& CreateInputTableRequest_InputTableKind::_internal_in_memory_key_backed() const {
  return _internal_has_in_memory_key_backed()
      ? *kind_.in_memory_key_backed_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked&>(::io::deephaven::proto::backplane::grpc::_CreateInputTableRequest_InputTableKind_InMemoryKeyBacked_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& CreateInputTableRequest_InputTableKind::in_memory_key_backed() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_key_backed)
  return _internal_in_memory_key_backed();
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* CreateInputTableRequest_InputTableKind::unsafe_arena_release_in_memory_key_backed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_key_backed)
  if (_internal_has_in_memory_key_backed()) {
    clear_has_kind();
    ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* temp = kind_.in_memory_key_backed_;
    kind_.in_memory_key_backed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateInputTableRequest_InputTableKind::unsafe_arena_set_allocated_in_memory_key_backed(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* in_memory_key_backed) {
  clear_kind();
  if (in_memory_key_backed) {
    set_has_in_memory_key_backed();
    kind_.in_memory_key_backed_ = in_memory_key_backed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_key_backed)
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* CreateInputTableRequest_InputTableKind::_internal_mutable_in_memory_key_backed() {
  if (!_internal_has_in_memory_key_backed()) {
    clear_kind();
    set_has_in_memory_key_backed();
    kind_.in_memory_key_backed_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked >(GetArenaForAllocation());
  }
  return kind_.in_memory_key_backed_;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* CreateInputTableRequest_InputTableKind::mutable_in_memory_key_backed() {
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* _msg = _internal_mutable_in_memory_key_backed();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_key_backed)
  return _msg;
}

inline bool CreateInputTableRequest_InputTableKind::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void CreateInputTableRequest_InputTableKind::clear_has_kind() {
  _oneof_case_[0] = KIND_NOT_SET;
}
inline CreateInputTableRequest_InputTableKind::KindCase CreateInputTableRequest_InputTableKind::kind_case() const {
  return CreateInputTableRequest_InputTableKind::KindCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateInputTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool CreateInputTableRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool CreateInputTableRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CreateInputTableRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CreateInputTableRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.result_id)
  return _internal_result_id();
}
inline void CreateInputTableRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CreateInputTableRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CreateInputTableRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CreateInputTableRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CreateInputTableRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.result_id)
  return _msg;
}
inline void CreateInputTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_table_id = 2;
inline bool CreateInputTableRequest::_internal_has_source_table_id() const {
  return definition_case() == kSourceTableId;
}
inline bool CreateInputTableRequest::has_source_table_id() const {
  return _internal_has_source_table_id();
}
inline void CreateInputTableRequest::set_has_source_table_id() {
  _oneof_case_[0] = kSourceTableId;
}
inline void CreateInputTableRequest::clear_source_table_id() {
  if (_internal_has_source_table_id()) {
    if (GetArenaForAllocation() == nullptr) {
      delete definition_.source_table_id_;
    }
    clear_has_definition();
  }
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CreateInputTableRequest::release_source_table_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.source_table_id)
  if (_internal_has_source_table_id()) {
    clear_has_definition();
    ::io::deephaven::proto::backplane::grpc::TableReference* temp = definition_.source_table_id_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    definition_.source_table_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CreateInputTableRequest::_internal_source_table_id() const {
  return _internal_has_source_table_id()
      ? *definition_.source_table_id_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CreateInputTableRequest::source_table_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.source_table_id)
  return _internal_source_table_id();
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CreateInputTableRequest::unsafe_arena_release_source_table_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.source_table_id)
  if (_internal_has_source_table_id()) {
    clear_has_definition();
    ::io::deephaven::proto::backplane::grpc::TableReference* temp = definition_.source_table_id_;
    definition_.source_table_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateInputTableRequest::unsafe_arena_set_allocated_source_table_id(::io::deephaven::proto::backplane::grpc::TableReference* source_table_id) {
  clear_definition();
  if (source_table_id) {
    set_has_source_table_id();
    definition_.source_table_id_ = source_table_id;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.source_table_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CreateInputTableRequest::_internal_mutable_source_table_id() {
  if (!_internal_has_source_table_id()) {
    clear_definition();
    set_has_source_table_id();
    definition_.source_table_id_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::TableReference >(GetArenaForAllocation());
  }
  return definition_.source_table_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CreateInputTableRequest::mutable_source_table_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_table_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.source_table_id)
  return _msg;
}

// bytes schema = 3;
inline bool CreateInputTableRequest::_internal_has_schema() const {
  return definition_case() == kSchema;
}
inline bool CreateInputTableRequest::has_schema() const {
  return _internal_has_schema();
}
inline void CreateInputTableRequest::set_has_schema() {
  _oneof_case_[0] = kSchema;
}
inline void CreateInputTableRequest::clear_schema() {
  if (_internal_has_schema()) {
    definition_.schema_.Destroy();
    clear_has_definition();
  }
}
inline const std::string& CreateInputTableRequest::schema() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.schema)
  return _internal_schema();
}
template <typename ArgT0, typename... ArgT>
inline void CreateInputTableRequest::set_schema(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_schema()) {
    clear_definition();
    set_has_schema();
    definition_.schema_.InitDefault();
  }
  definition_.schema_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.schema)
}
inline std::string* CreateInputTableRequest::mutable_schema() {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.schema)
  return _s;
}
inline const std::string& CreateInputTableRequest::_internal_schema() const {
  if (_internal_has_schema()) {
    return definition_.schema_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CreateInputTableRequest::_internal_set_schema(const std::string& value) {
  if (!_internal_has_schema()) {
    clear_definition();
    set_has_schema();
    definition_.schema_.InitDefault();
  }
  definition_.schema_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateInputTableRequest::_internal_mutable_schema() {
  if (!_internal_has_schema()) {
    clear_definition();
    set_has_schema();
    definition_.schema_.InitDefault();
  }
  return definition_.schema_.Mutable(      GetArenaForAllocation());
}
inline std::string* CreateInputTableRequest::release_schema() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.schema)
  if (_internal_has_schema()) {
    clear_has_definition();
    return definition_.schema_.Release();
  } else {
    return nullptr;
  }
}
inline void CreateInputTableRequest::set_allocated_schema(std::string* schema) {
  if (has_definition()) {
    clear_definition();
  }
  if (schema != nullptr) {
    set_has_schema();
    definition_.schema_.InitAllocated(schema, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.schema)
}

// .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind kind = 4;
inline bool CreateInputTableRequest::_internal_has_kind() const {
  return this != internal_default_instance() && kind_ != nullptr;
}
inline bool CreateInputTableRequest::has_kind() const {
  return _internal_has_kind();
}
inline void CreateInputTableRequest::clear_kind() {
  if (GetArenaForAllocation() == nullptr && kind_ != nullptr) {
    delete kind_;
  }
  kind_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind& CreateInputTableRequest::_internal_kind() const {
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* p = kind_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind&>(
      ::io::deephaven::proto::backplane::grpc::_CreateInputTableRequest_InputTableKind_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind& CreateInputTableRequest::kind() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.kind)
  return _internal_kind();
}
inline void CreateInputTableRequest::unsafe_arena_set_allocated_kind(
    ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* kind) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(kind_);
  }
  kind_ = kind;
  if (kind) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.kind)
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* CreateInputTableRequest::release_kind() {
  
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* temp = kind_;
  kind_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* CreateInputTableRequest::unsafe_arena_release_kind() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.kind)
  
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* temp = kind_;
  kind_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* CreateInputTableRequest::_internal_mutable_kind() {
  
  if (kind_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind>(GetArenaForAllocation());
    kind_ = p;
  }
  return kind_;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* CreateInputTableRequest::mutable_kind() {
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* _msg = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.kind)
  return _msg;
}
inline void CreateInputTableRequest::set_allocated_kind(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* kind) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete kind_;
  }
  if (kind) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(kind);
    if (message_arena != submessage_arena) {
      kind = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, kind, submessage_arena);
    }
    
  } else {
    
  }
  kind_ = kind;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.kind)
}

inline bool CreateInputTableRequest::has_definition() const {
  return definition_case() != DEFINITION_NOT_SET;
}
inline void CreateInputTableRequest::clear_has_definition() {
  _oneof_case_[0] = DEFINITION_NOT_SET;
}
inline CreateInputTableRequest::DefinitionCase CreateInputTableRequest::definition_case() const {
  return CreateInputTableRequest::DefinitionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WhereInRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool WhereInRequest::_internal_has_result_id() const {
  return this != internal_default_instance() && result_id_ != nullptr;
}
inline bool WhereInRequest::has_result_id() const {
  return _internal_has_result_id();
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& WhereInRequest::_internal_result_id() const {
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(
      ::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& WhereInRequest::result_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.WhereInRequest.result_id)
  return _internal_result_id();
}
inline void WhereInRequest::unsafe_arena_set_allocated_result_id(
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  result_id_ = result_id;
  if (result_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.WhereInRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* WhereInRequest::release_result_id() {
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* WhereInRequest::unsafe_arena_release_result_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.WhereInRequest.result_id)
  
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = result_id_;
  result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* WhereInRequest::_internal_mutable_result_id() {
  
  if (result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArenaForAllocation());
    result_id_ = p;
  }
  return result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* WhereInRequest::mutable_result_id() {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.WhereInRequest.result_id)
  return _msg;
}
inline void WhereInRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* result_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id_);
  }
  if (result_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_id));
    if (message_arena != submessage_arena) {
      result_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result_id, submessage_arena);
    }
    
  } else {
    
  }
  result_id_ = result_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.WhereInRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool WhereInRequest::_internal_has_left_id() const {
  return this != internal_default_instance() && left_id_ != nullptr;
}
inline bool WhereInRequest::has_left_id() const {
  return _internal_has_left_id();
}
inline void WhereInRequest::clear_left_id() {
  if (GetArenaForAllocation() == nullptr && left_id_ != nullptr) {
    delete left_id_;
  }
  left_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& WhereInRequest::_internal_left_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& WhereInRequest::left_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.WhereInRequest.left_id)
  return _internal_left_id();
}
inline void WhereInRequest::unsafe_arena_set_allocated_left_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_id_);
  }
  left_id_ = left_id;
  if (left_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.WhereInRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::release_left_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::unsafe_arena_release_left_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.WhereInRequest.left_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = left_id_;
  left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::_internal_mutable_left_id() {
  
  if (left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    left_id_ = p;
  }
  return left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::mutable_left_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.WhereInRequest.left_id)
  return _msg;
}
inline void WhereInRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* left_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_id_;
  }
  if (left_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_id);
    if (message_arena != submessage_arena) {
      left_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_id, submessage_arena);
    }
    
  } else {
    
  }
  left_id_ = left_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.WhereInRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool WhereInRequest::_internal_has_right_id() const {
  return this != internal_default_instance() && right_id_ != nullptr;
}
inline bool WhereInRequest::has_right_id() const {
  return _internal_has_right_id();
}
inline void WhereInRequest::clear_right_id() {
  if (GetArenaForAllocation() == nullptr && right_id_ != nullptr) {
    delete right_id_;
  }
  right_id_ = nullptr;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& WhereInRequest::_internal_right_id() const {
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(
      ::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& WhereInRequest::right_id() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.WhereInRequest.right_id)
  return _internal_right_id();
}
inline void WhereInRequest::unsafe_arena_set_allocated_right_id(
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_id_);
  }
  right_id_ = right_id;
  if (right_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.WhereInRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::release_right_id() {
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::unsafe_arena_release_right_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.WhereInRequest.right_id)
  
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = right_id_;
  right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::_internal_mutable_right_id() {
  
  if (right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArenaForAllocation());
    right_id_ = p;
  }
  return right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::mutable_right_id() {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.WhereInRequest.right_id)
  return _msg;
}
inline void WhereInRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* right_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_id_;
  }
  if (right_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_id);
    if (message_arena != submessage_arena) {
      right_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_id, submessage_arena);
    }
    
  } else {
    
  }
  right_id_ = right_id;
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.WhereInRequest.right_id)
}

// bool inverted = 4;
inline void WhereInRequest::clear_inverted() {
  inverted_ = false;
}
inline bool WhereInRequest::_internal_inverted() const {
  return inverted_;
}
inline bool WhereInRequest::inverted() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.WhereInRequest.inverted)
  return _internal_inverted();
}
inline void WhereInRequest::_internal_set_inverted(bool value) {
  
  inverted_ = value;
}
inline void WhereInRequest::set_inverted(bool value) {
  _internal_set_inverted(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.WhereInRequest.inverted)
}

// repeated string columns_to_match = 5;
inline int WhereInRequest::_internal_columns_to_match_size() const {
  return columns_to_match_.size();
}
inline int WhereInRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void WhereInRequest::clear_columns_to_match() {
  columns_to_match_.Clear();
}
inline std::string* WhereInRequest::add_columns_to_match() {
  std::string* _s = _internal_add_columns_to_match();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
  return _s;
}
inline const std::string& WhereInRequest::_internal_columns_to_match(int index) const {
  return columns_to_match_.Get(index);
}
inline const std::string& WhereInRequest::columns_to_match(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
  return _internal_columns_to_match(index);
}
inline std::string* WhereInRequest::mutable_columns_to_match(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
  return columns_to_match_.Mutable(index);
}
inline void WhereInRequest::set_columns_to_match(int index, const std::string& value) {
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::set_columns_to_match(int index, std::string&& value) {
  columns_to_match_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::set_columns_to_match(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::set_columns_to_match(int index, const char* value, size_t size) {
  columns_to_match_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline std::string* WhereInRequest::_internal_add_columns_to_match() {
  return columns_to_match_.Add();
}
inline void WhereInRequest::add_columns_to_match(const std::string& value) {
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::add_columns_to_match(std::string&& value) {
  columns_to_match_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::add_columns_to_match(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  columns_to_match_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::add_columns_to_match(const char* value, size_t size) {
  columns_to_match_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WhereInRequest::columns_to_match() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
  return columns_to_match_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WhereInRequest::mutable_columns_to_match() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
  return &columns_to_match_;
}

// -------------------------------------------------------------------

// BatchTableRequest_Operation

// .io.deephaven.proto.backplane.grpc.EmptyTableRequest empty_table = 1;
inline bool BatchTableRequest_Operation::_internal_has_empty_table() const {
  return op_case() == kEmptyTable;
}
inline bool BatchTableRequest_Operation::has_empty_table() const {
  return _internal_has_empty_table();
}
inline void BatchTableRequest_Operation::set_has_empty_table() {
  _oneof_case_[0] = kEmptyTable;
}
inline void BatchTableRequest_Operation::clear_empty_table() {
  if (_internal_has_empty_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.empty_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* BatchTableRequest_Operation::release_empty_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
  if (_internal_has_empty_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* temp = op_.empty_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.empty_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& BatchTableRequest_Operation::_internal_empty_table() const {
  return _internal_has_empty_table()
      ? *op_.empty_table_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::EmptyTableRequest&>(::io::deephaven::proto::backplane::grpc::_EmptyTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& BatchTableRequest_Operation::empty_table() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
  return _internal_empty_table();
}
inline ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* BatchTableRequest_Operation::unsafe_arena_release_empty_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
  if (_internal_has_empty_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* temp = op_.empty_table_;
    op_.empty_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_empty_table(::io::deephaven::proto::backplane::grpc::EmptyTableRequest* empty_table) {
  clear_op();
  if (empty_table) {
    set_has_empty_table();
    op_.empty_table_ = empty_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
}
inline ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* BatchTableRequest_Operation::_internal_mutable_empty_table() {
  if (!_internal_has_empty_table()) {
    clear_op();
    set_has_empty_table();
    op_.empty_table_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::EmptyTableRequest >(GetArenaForAllocation());
  }
  return op_.empty_table_;
}
inline ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* BatchTableRequest_Operation::mutable_empty_table() {
  ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* _msg = _internal_mutable_empty_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.TimeTableRequest time_table = 2;
inline bool BatchTableRequest_Operation::_internal_has_time_table() const {
  return op_case() == kTimeTable;
}
inline bool BatchTableRequest_Operation::has_time_table() const {
  return _internal_has_time_table();
}
inline void BatchTableRequest_Operation::set_has_time_table() {
  _oneof_case_[0] = kTimeTable;
}
inline void BatchTableRequest_Operation::clear_time_table() {
  if (_internal_has_time_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.time_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::TimeTableRequest* BatchTableRequest_Operation::release_time_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
  if (_internal_has_time_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::TimeTableRequest* temp = op_.time_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.time_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& BatchTableRequest_Operation::_internal_time_table() const {
  return _internal_has_time_table()
      ? *op_.time_table_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::TimeTableRequest&>(::io::deephaven::proto::backplane::grpc::_TimeTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& BatchTableRequest_Operation::time_table() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
  return _internal_time_table();
}
inline ::io::deephaven::proto::backplane::grpc::TimeTableRequest* BatchTableRequest_Operation::unsafe_arena_release_time_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
  if (_internal_has_time_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::TimeTableRequest* temp = op_.time_table_;
    op_.time_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_time_table(::io::deephaven::proto::backplane::grpc::TimeTableRequest* time_table) {
  clear_op();
  if (time_table) {
    set_has_time_table();
    op_.time_table_ = time_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
}
inline ::io::deephaven::proto::backplane::grpc::TimeTableRequest* BatchTableRequest_Operation::_internal_mutable_time_table() {
  if (!_internal_has_time_table()) {
    clear_op();
    set_has_time_table();
    op_.time_table_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::TimeTableRequest >(GetArenaForAllocation());
  }
  return op_.time_table_;
}
inline ::io::deephaven::proto::backplane::grpc::TimeTableRequest* BatchTableRequest_Operation::mutable_time_table() {
  ::io::deephaven::proto::backplane::grpc::TimeTableRequest* _msg = _internal_mutable_time_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.DropColumnsRequest drop_columns = 3;
inline bool BatchTableRequest_Operation::_internal_has_drop_columns() const {
  return op_case() == kDropColumns;
}
inline bool BatchTableRequest_Operation::has_drop_columns() const {
  return _internal_has_drop_columns();
}
inline void BatchTableRequest_Operation::set_has_drop_columns() {
  _oneof_case_[0] = kDropColumns;
}
inline void BatchTableRequest_Operation::clear_drop_columns() {
  if (_internal_has_drop_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.drop_columns_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* BatchTableRequest_Operation::release_drop_columns() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* temp = op_.drop_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& BatchTableRequest_Operation::_internal_drop_columns() const {
  return _internal_has_drop_columns()
      ? *op_.drop_columns_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::DropColumnsRequest&>(::io::deephaven::proto::backplane::grpc::_DropColumnsRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& BatchTableRequest_Operation::drop_columns() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
  return _internal_drop_columns();
}
inline ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* BatchTableRequest_Operation::unsafe_arena_release_drop_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
  if (_internal_has_drop_columns()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* temp = op_.drop_columns_;
    op_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_drop_columns(::io::deephaven::proto::backplane::grpc::DropColumnsRequest* drop_columns) {
  clear_op();
  if (drop_columns) {
    set_has_drop_columns();
    op_.drop_columns_ = drop_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
}
inline ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* BatchTableRequest_Operation::_internal_mutable_drop_columns() {
  if (!_internal_has_drop_columns()) {
    clear_op();
    set_has_drop_columns();
    op_.drop_columns_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::DropColumnsRequest >(GetArenaForAllocation());
  }
  return op_.drop_columns_;
}
inline ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* BatchTableRequest_Operation::mutable_drop_columns() {
  ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* _msg = _internal_mutable_drop_columns();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest update = 4;
inline bool BatchTableRequest_Operation::_internal_has_update() const {
  return op_case() == kUpdate;
}
inline bool BatchTableRequest_Operation::has_update() const {
  return _internal_has_update();
}
inline void BatchTableRequest_Operation::set_has_update() {
  _oneof_case_[0] = kUpdate;
}
inline void BatchTableRequest_Operation::clear_update() {
  if (_internal_has_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.update_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_update() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
  if (_internal_has_update()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_update() const {
  return _internal_has_update()
      ? *op_.update_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::update() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
  return _internal_update();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
  if (_internal_has_update()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.update_;
    op_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update) {
  clear_op();
  if (update) {
    set_has_update();
    op_.update_ = update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_update() {
  if (!_internal_has_update()) {
    clear_op();
    set_has_update();
    op_.update_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest >(GetArenaForAllocation());
  }
  return op_.update_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_update() {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest lazy_update = 5;
inline bool BatchTableRequest_Operation::_internal_has_lazy_update() const {
  return op_case() == kLazyUpdate;
}
inline bool BatchTableRequest_Operation::has_lazy_update() const {
  return _internal_has_lazy_update();
}
inline void BatchTableRequest_Operation::set_has_lazy_update() {
  _oneof_case_[0] = kLazyUpdate;
}
inline void BatchTableRequest_Operation::clear_lazy_update() {
  if (_internal_has_lazy_update()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.lazy_update_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_lazy_update() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
  if (_internal_has_lazy_update()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.lazy_update_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.lazy_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_lazy_update() const {
  return _internal_has_lazy_update()
      ? *op_.lazy_update_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::lazy_update() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
  return _internal_lazy_update();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_lazy_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
  if (_internal_has_lazy_update()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.lazy_update_;
    op_.lazy_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_lazy_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* lazy_update) {
  clear_op();
  if (lazy_update) {
    set_has_lazy_update();
    op_.lazy_update_ = lazy_update;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_lazy_update() {
  if (!_internal_has_lazy_update()) {
    clear_op();
    set_has_lazy_update();
    op_.lazy_update_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest >(GetArenaForAllocation());
  }
  return op_.lazy_update_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_lazy_update() {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_lazy_update();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest view = 6;
inline bool BatchTableRequest_Operation::_internal_has_view() const {
  return op_case() == kView;
}
inline bool BatchTableRequest_Operation::has_view() const {
  return _internal_has_view();
}
inline void BatchTableRequest_Operation::set_has_view() {
  _oneof_case_[0] = kView;
}
inline void BatchTableRequest_Operation::clear_view() {
  if (_internal_has_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.view_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_view() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
  if (_internal_has_view()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_view() const {
  return _internal_has_view()
      ? *op_.view_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::view() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
  return _internal_view();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
  if (_internal_has_view()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.view_;
    op_.view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* view) {
  clear_op();
  if (view) {
    set_has_view();
    op_.view_ = view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_view() {
  if (!_internal_has_view()) {
    clear_op();
    set_has_view();
    op_.view_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest >(GetArenaForAllocation());
  }
  return op_.view_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_view() {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_view();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest update_view = 7;
inline bool BatchTableRequest_Operation::_internal_has_update_view() const {
  return op_case() == kUpdateView;
}
inline bool BatchTableRequest_Operation::has_update_view() const {
  return _internal_has_update_view();
}
inline void BatchTableRequest_Operation::set_has_update_view() {
  _oneof_case_[0] = kUpdateView;
}
inline void BatchTableRequest_Operation::clear_update_view() {
  if (_internal_has_update_view()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.update_view_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_update_view() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
  if (_internal_has_update_view()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.update_view_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.update_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_update_view() const {
  return _internal_has_update_view()
      ? *op_.update_view_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::update_view() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
  return _internal_update_view();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_update_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
  if (_internal_has_update_view()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.update_view_;
    op_.update_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_update_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update_view) {
  clear_op();
  if (update_view) {
    set_has_update_view();
    op_.update_view_ = update_view;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_update_view() {
  if (!_internal_has_update_view()) {
    clear_op();
    set_has_update_view();
    op_.update_view_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest >(GetArenaForAllocation());
  }
  return op_.update_view_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_update_view() {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_update_view();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest select = 8;
inline bool BatchTableRequest_Operation::_internal_has_select() const {
  return op_case() == kSelect;
}
inline bool BatchTableRequest_Operation::has_select() const {
  return _internal_has_select();
}
inline void BatchTableRequest_Operation::set_has_select() {
  _oneof_case_[0] = kSelect;
}
inline void BatchTableRequest_Operation::clear_select() {
  if (_internal_has_select()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.select_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_select() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
  if (_internal_has_select()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.select_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.select_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_select() const {
  return _internal_has_select()
      ? *op_.select_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::select() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
  return _internal_select();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_select() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
  if (_internal_has_select()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* temp = op_.select_;
    op_.select_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_select(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* select) {
  clear_op();
  if (select) {
    set_has_select();
    op_.select_ = select;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_select() {
  if (!_internal_has_select()) {
    clear_op();
    set_has_select();
    op_.select_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest >(GetArenaForAllocation());
  }
  return op_.select_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_select() {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_select();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectDistinctRequest select_distinct = 9;
inline bool BatchTableRequest_Operation::_internal_has_select_distinct() const {
  return op_case() == kSelectDistinct;
}
inline bool BatchTableRequest_Operation::has_select_distinct() const {
  return _internal_has_select_distinct();
}
inline void BatchTableRequest_Operation::set_has_select_distinct() {
  _oneof_case_[0] = kSelectDistinct;
}
inline void BatchTableRequest_Operation::clear_select_distinct() {
  if (_internal_has_select_distinct()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.select_distinct_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* BatchTableRequest_Operation::release_select_distinct() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
  if (_internal_has_select_distinct()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* temp = op_.select_distinct_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.select_distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& BatchTableRequest_Operation::_internal_select_distinct() const {
  return _internal_has_select_distinct()
      ? *op_.select_distinct_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest&>(::io::deephaven::proto::backplane::grpc::_SelectDistinctRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& BatchTableRequest_Operation::select_distinct() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
  return _internal_select_distinct();
}
inline ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* BatchTableRequest_Operation::unsafe_arena_release_select_distinct() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
  if (_internal_has_select_distinct()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* temp = op_.select_distinct_;
    op_.select_distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_select_distinct(::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* select_distinct) {
  clear_op();
  if (select_distinct) {
    set_has_select_distinct();
    op_.select_distinct_ = select_distinct;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
}
inline ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* BatchTableRequest_Operation::_internal_mutable_select_distinct() {
  if (!_internal_has_select_distinct()) {
    clear_op();
    set_has_select_distinct();
    op_.select_distinct_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest >(GetArenaForAllocation());
  }
  return op_.select_distinct_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* BatchTableRequest_Operation::mutable_select_distinct() {
  ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* _msg = _internal_mutable_select_distinct();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.FilterTableRequest filter = 10;
inline bool BatchTableRequest_Operation::_internal_has_filter() const {
  return op_case() == kFilter;
}
inline bool BatchTableRequest_Operation::has_filter() const {
  return _internal_has_filter();
}
inline void BatchTableRequest_Operation::set_has_filter() {
  _oneof_case_[0] = kFilter;
}
inline void BatchTableRequest_Operation::clear_filter() {
  if (_internal_has_filter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.filter_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::FilterTableRequest* BatchTableRequest_Operation::release_filter() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
  if (_internal_has_filter()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::FilterTableRequest* temp = op_.filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& BatchTableRequest_Operation::_internal_filter() const {
  return _internal_has_filter()
      ? *op_.filter_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::FilterTableRequest&>(::io::deephaven::proto::backplane::grpc::_FilterTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& BatchTableRequest_Operation::filter() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
  return _internal_filter();
}
inline ::io::deephaven::proto::backplane::grpc::FilterTableRequest* BatchTableRequest_Operation::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
  if (_internal_has_filter()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::FilterTableRequest* temp = op_.filter_;
    op_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_filter(::io::deephaven::proto::backplane::grpc::FilterTableRequest* filter) {
  clear_op();
  if (filter) {
    set_has_filter();
    op_.filter_ = filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
}
inline ::io::deephaven::proto::backplane::grpc::FilterTableRequest* BatchTableRequest_Operation::_internal_mutable_filter() {
  if (!_internal_has_filter()) {
    clear_op();
    set_has_filter();
    op_.filter_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::FilterTableRequest >(GetArenaForAllocation());
  }
  return op_.filter_;
}
inline ::io::deephaven::proto::backplane::grpc::FilterTableRequest* BatchTableRequest_Operation::mutable_filter() {
  ::io::deephaven::proto::backplane::grpc::FilterTableRequest* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest unstructured_filter = 11;
inline bool BatchTableRequest_Operation::_internal_has_unstructured_filter() const {
  return op_case() == kUnstructuredFilter;
}
inline bool BatchTableRequest_Operation::has_unstructured_filter() const {
  return _internal_has_unstructured_filter();
}
inline void BatchTableRequest_Operation::set_has_unstructured_filter() {
  _oneof_case_[0] = kUnstructuredFilter;
}
inline void BatchTableRequest_Operation::clear_unstructured_filter() {
  if (_internal_has_unstructured_filter()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.unstructured_filter_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* BatchTableRequest_Operation::release_unstructured_filter() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
  if (_internal_has_unstructured_filter()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* temp = op_.unstructured_filter_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.unstructured_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& BatchTableRequest_Operation::_internal_unstructured_filter() const {
  return _internal_has_unstructured_filter()
      ? *op_.unstructured_filter_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest&>(::io::deephaven::proto::backplane::grpc::_UnstructuredFilterTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& BatchTableRequest_Operation::unstructured_filter() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
  return _internal_unstructured_filter();
}
inline ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* BatchTableRequest_Operation::unsafe_arena_release_unstructured_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
  if (_internal_has_unstructured_filter()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* temp = op_.unstructured_filter_;
    op_.unstructured_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_unstructured_filter(::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* unstructured_filter) {
  clear_op();
  if (unstructured_filter) {
    set_has_unstructured_filter();
    op_.unstructured_filter_ = unstructured_filter;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
}
inline ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* BatchTableRequest_Operation::_internal_mutable_unstructured_filter() {
  if (!_internal_has_unstructured_filter()) {
    clear_op();
    set_has_unstructured_filter();
    op_.unstructured_filter_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest >(GetArenaForAllocation());
  }
  return op_.unstructured_filter_;
}
inline ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* BatchTableRequest_Operation::mutable_unstructured_filter() {
  ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* _msg = _internal_mutable_unstructured_filter();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SortTableRequest sort = 12;
inline bool BatchTableRequest_Operation::_internal_has_sort() const {
  return op_case() == kSort;
}
inline bool BatchTableRequest_Operation::has_sort() const {
  return _internal_has_sort();
}
inline void BatchTableRequest_Operation::set_has_sort() {
  _oneof_case_[0] = kSort;
}
inline void BatchTableRequest_Operation::clear_sort() {
  if (_internal_has_sort()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.sort_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SortTableRequest* BatchTableRequest_Operation::release_sort() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
  if (_internal_has_sort()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SortTableRequest* temp = op_.sort_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.sort_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SortTableRequest& BatchTableRequest_Operation::_internal_sort() const {
  return _internal_has_sort()
      ? *op_.sort_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SortTableRequest&>(::io::deephaven::proto::backplane::grpc::_SortTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SortTableRequest& BatchTableRequest_Operation::sort() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
  return _internal_sort();
}
inline ::io::deephaven::proto::backplane::grpc::SortTableRequest* BatchTableRequest_Operation::unsafe_arena_release_sort() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
  if (_internal_has_sort()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SortTableRequest* temp = op_.sort_;
    op_.sort_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_sort(::io::deephaven::proto::backplane::grpc::SortTableRequest* sort) {
  clear_op();
  if (sort) {
    set_has_sort();
    op_.sort_ = sort;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
}
inline ::io::deephaven::proto::backplane::grpc::SortTableRequest* BatchTableRequest_Operation::_internal_mutable_sort() {
  if (!_internal_has_sort()) {
    clear_op();
    set_has_sort();
    op_.sort_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SortTableRequest >(GetArenaForAllocation());
  }
  return op_.sort_;
}
inline ::io::deephaven::proto::backplane::grpc::SortTableRequest* BatchTableRequest_Operation::mutable_sort() {
  ::io::deephaven::proto::backplane::grpc::SortTableRequest* _msg = _internal_mutable_sort();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.HeadOrTailRequest head = 13;
inline bool BatchTableRequest_Operation::_internal_has_head() const {
  return op_case() == kHead;
}
inline bool BatchTableRequest_Operation::has_head() const {
  return _internal_has_head();
}
inline void BatchTableRequest_Operation::set_has_head() {
  _oneof_case_[0] = kHead;
}
inline void BatchTableRequest_Operation::clear_head() {
  if (_internal_has_head()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.head_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::release_head() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
  if (_internal_has_head()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* temp = op_.head_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.head_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& BatchTableRequest_Operation::_internal_head() const {
  return _internal_has_head()
      ? *op_.head_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest&>(::io::deephaven::proto::backplane::grpc::_HeadOrTailRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& BatchTableRequest_Operation::head() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
  return _internal_head();
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
  if (_internal_has_head()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* temp = op_.head_;
    op_.head_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_head(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* head) {
  clear_op();
  if (head) {
    set_has_head();
    op_.head_ = head;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::_internal_mutable_head() {
  if (!_internal_has_head()) {
    clear_op();
    set_has_head();
    op_.head_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest >(GetArenaForAllocation());
  }
  return op_.head_;
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::mutable_head() {
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.HeadOrTailRequest tail = 14;
inline bool BatchTableRequest_Operation::_internal_has_tail() const {
  return op_case() == kTail;
}
inline bool BatchTableRequest_Operation::has_tail() const {
  return _internal_has_tail();
}
inline void BatchTableRequest_Operation::set_has_tail() {
  _oneof_case_[0] = kTail;
}
inline void BatchTableRequest_Operation::clear_tail() {
  if (_internal_has_tail()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.tail_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::release_tail() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
  if (_internal_has_tail()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* temp = op_.tail_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.tail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& BatchTableRequest_Operation::_internal_tail() const {
  return _internal_has_tail()
      ? *op_.tail_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest&>(::io::deephaven::proto::backplane::grpc::_HeadOrTailRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& BatchTableRequest_Operation::tail() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
  return _internal_tail();
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::unsafe_arena_release_tail() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
  if (_internal_has_tail()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* temp = op_.tail_;
    op_.tail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_tail(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* tail) {
  clear_op();
  if (tail) {
    set_has_tail();
    op_.tail_ = tail;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::_internal_mutable_tail() {
  if (!_internal_has_tail()) {
    clear_op();
    set_has_tail();
    op_.tail_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest >(GetArenaForAllocation());
  }
  return op_.tail_;
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::mutable_tail() {
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* _msg = _internal_mutable_tail();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.HeadOrTailByRequest head_by = 15;
inline bool BatchTableRequest_Operation::_internal_has_head_by() const {
  return op_case() == kHeadBy;
}
inline bool BatchTableRequest_Operation::has_head_by() const {
  return _internal_has_head_by();
}
inline void BatchTableRequest_Operation::set_has_head_by() {
  _oneof_case_[0] = kHeadBy;
}
inline void BatchTableRequest_Operation::clear_head_by() {
  if (_internal_has_head_by()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.head_by_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::release_head_by() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
  if (_internal_has_head_by()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* temp = op_.head_by_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.head_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& BatchTableRequest_Operation::_internal_head_by() const {
  return _internal_has_head_by()
      ? *op_.head_by_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest&>(::io::deephaven::proto::backplane::grpc::_HeadOrTailByRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& BatchTableRequest_Operation::head_by() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
  return _internal_head_by();
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::unsafe_arena_release_head_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
  if (_internal_has_head_by()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* temp = op_.head_by_;
    op_.head_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_head_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* head_by) {
  clear_op();
  if (head_by) {
    set_has_head_by();
    op_.head_by_ = head_by;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::_internal_mutable_head_by() {
  if (!_internal_has_head_by()) {
    clear_op();
    set_has_head_by();
    op_.head_by_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest >(GetArenaForAllocation());
  }
  return op_.head_by_;
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::mutable_head_by() {
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* _msg = _internal_mutable_head_by();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.HeadOrTailByRequest tail_by = 16;
inline bool BatchTableRequest_Operation::_internal_has_tail_by() const {
  return op_case() == kTailBy;
}
inline bool BatchTableRequest_Operation::has_tail_by() const {
  return _internal_has_tail_by();
}
inline void BatchTableRequest_Operation::set_has_tail_by() {
  _oneof_case_[0] = kTailBy;
}
inline void BatchTableRequest_Operation::clear_tail_by() {
  if (_internal_has_tail_by()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.tail_by_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::release_tail_by() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
  if (_internal_has_tail_by()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* temp = op_.tail_by_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.tail_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& BatchTableRequest_Operation::_internal_tail_by() const {
  return _internal_has_tail_by()
      ? *op_.tail_by_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest&>(::io::deephaven::proto::backplane::grpc::_HeadOrTailByRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& BatchTableRequest_Operation::tail_by() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
  return _internal_tail_by();
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::unsafe_arena_release_tail_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
  if (_internal_has_tail_by()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* temp = op_.tail_by_;
    op_.tail_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_tail_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* tail_by) {
  clear_op();
  if (tail_by) {
    set_has_tail_by();
    op_.tail_by_ = tail_by;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::_internal_mutable_tail_by() {
  if (!_internal_has_tail_by()) {
    clear_op();
    set_has_tail_by();
    op_.tail_by_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest >(GetArenaForAllocation());
  }
  return op_.tail_by_;
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::mutable_tail_by() {
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* _msg = _internal_mutable_tail_by();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UngroupRequest ungroup = 17;
inline bool BatchTableRequest_Operation::_internal_has_ungroup() const {
  return op_case() == kUngroup;
}
inline bool BatchTableRequest_Operation::has_ungroup() const {
  return _internal_has_ungroup();
}
inline void BatchTableRequest_Operation::set_has_ungroup() {
  _oneof_case_[0] = kUngroup;
}
inline void BatchTableRequest_Operation::clear_ungroup() {
  if (_internal_has_ungroup()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.ungroup_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UngroupRequest* BatchTableRequest_Operation::release_ungroup() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
  if (_internal_has_ungroup()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::UngroupRequest* temp = op_.ungroup_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.ungroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UngroupRequest& BatchTableRequest_Operation::_internal_ungroup() const {
  return _internal_has_ungroup()
      ? *op_.ungroup_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UngroupRequest&>(::io::deephaven::proto::backplane::grpc::_UngroupRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UngroupRequest& BatchTableRequest_Operation::ungroup() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
  return _internal_ungroup();
}
inline ::io::deephaven::proto::backplane::grpc::UngroupRequest* BatchTableRequest_Operation::unsafe_arena_release_ungroup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
  if (_internal_has_ungroup()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::UngroupRequest* temp = op_.ungroup_;
    op_.ungroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_ungroup(::io::deephaven::proto::backplane::grpc::UngroupRequest* ungroup) {
  clear_op();
  if (ungroup) {
    set_has_ungroup();
    op_.ungroup_ = ungroup;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
}
inline ::io::deephaven::proto::backplane::grpc::UngroupRequest* BatchTableRequest_Operation::_internal_mutable_ungroup() {
  if (!_internal_has_ungroup()) {
    clear_op();
    set_has_ungroup();
    op_.ungroup_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UngroupRequest >(GetArenaForAllocation());
  }
  return op_.ungroup_;
}
inline ::io::deephaven::proto::backplane::grpc::UngroupRequest* BatchTableRequest_Operation::mutable_ungroup() {
  ::io::deephaven::proto::backplane::grpc::UngroupRequest* _msg = _internal_mutable_ungroup();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.MergeTablesRequest merge = 18;
inline bool BatchTableRequest_Operation::_internal_has_merge() const {
  return op_case() == kMerge;
}
inline bool BatchTableRequest_Operation::has_merge() const {
  return _internal_has_merge();
}
inline void BatchTableRequest_Operation::set_has_merge() {
  _oneof_case_[0] = kMerge;
}
inline void BatchTableRequest_Operation::clear_merge() {
  if (_internal_has_merge()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.merge_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* BatchTableRequest_Operation::release_merge() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
  if (_internal_has_merge()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* temp = op_.merge_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.merge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& BatchTableRequest_Operation::_internal_merge() const {
  return _internal_has_merge()
      ? *op_.merge_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::MergeTablesRequest&>(::io::deephaven::proto::backplane::grpc::_MergeTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& BatchTableRequest_Operation::merge() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
  return _internal_merge();
}
inline ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_merge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
  if (_internal_has_merge()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* temp = op_.merge_;
    op_.merge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_merge(::io::deephaven::proto::backplane::grpc::MergeTablesRequest* merge) {
  clear_op();
  if (merge) {
    set_has_merge();
    op_.merge_ = merge;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
}
inline ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* BatchTableRequest_Operation::_internal_mutable_merge() {
  if (!_internal_has_merge()) {
    clear_op();
    set_has_merge();
    op_.merge_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::MergeTablesRequest >(GetArenaForAllocation());
  }
  return op_.merge_;
}
inline ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* BatchTableRequest_Operation::mutable_merge() {
  ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* _msg = _internal_mutable_merge();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.ComboAggregateRequest combo_aggregate = 19;
inline bool BatchTableRequest_Operation::_internal_has_combo_aggregate() const {
  return op_case() == kComboAggregate;
}
inline bool BatchTableRequest_Operation::has_combo_aggregate() const {
  return _internal_has_combo_aggregate();
}
inline void BatchTableRequest_Operation::set_has_combo_aggregate() {
  _oneof_case_[0] = kComboAggregate;
}
inline void BatchTableRequest_Operation::clear_combo_aggregate() {
  if (_internal_has_combo_aggregate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.combo_aggregate_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* BatchTableRequest_Operation::release_combo_aggregate() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
  if (_internal_has_combo_aggregate()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* temp = op_.combo_aggregate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.combo_aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& BatchTableRequest_Operation::_internal_combo_aggregate() const {
  return _internal_has_combo_aggregate()
      ? *op_.combo_aggregate_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest&>(::io::deephaven::proto::backplane::grpc::_ComboAggregateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& BatchTableRequest_Operation::combo_aggregate() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
  return _internal_combo_aggregate();
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* BatchTableRequest_Operation::unsafe_arena_release_combo_aggregate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
  if (_internal_has_combo_aggregate()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* temp = op_.combo_aggregate_;
    op_.combo_aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_combo_aggregate(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* combo_aggregate) {
  clear_op();
  if (combo_aggregate) {
    set_has_combo_aggregate();
    op_.combo_aggregate_ = combo_aggregate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* BatchTableRequest_Operation::_internal_mutable_combo_aggregate() {
  if (!_internal_has_combo_aggregate()) {
    clear_op();
    set_has_combo_aggregate();
    op_.combo_aggregate_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest >(GetArenaForAllocation());
  }
  return op_.combo_aggregate_;
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* BatchTableRequest_Operation::mutable_combo_aggregate() {
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* _msg = _internal_mutable_combo_aggregate();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.FlattenRequest flatten = 21;
inline bool BatchTableRequest_Operation::_internal_has_flatten() const {
  return op_case() == kFlatten;
}
inline bool BatchTableRequest_Operation::has_flatten() const {
  return _internal_has_flatten();
}
inline void BatchTableRequest_Operation::set_has_flatten() {
  _oneof_case_[0] = kFlatten;
}
inline void BatchTableRequest_Operation::clear_flatten() {
  if (_internal_has_flatten()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.flatten_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::FlattenRequest* BatchTableRequest_Operation::release_flatten() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
  if (_internal_has_flatten()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::FlattenRequest* temp = op_.flatten_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.flatten_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::FlattenRequest& BatchTableRequest_Operation::_internal_flatten() const {
  return _internal_has_flatten()
      ? *op_.flatten_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::FlattenRequest&>(::io::deephaven::proto::backplane::grpc::_FlattenRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::FlattenRequest& BatchTableRequest_Operation::flatten() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
  return _internal_flatten();
}
inline ::io::deephaven::proto::backplane::grpc::FlattenRequest* BatchTableRequest_Operation::unsafe_arena_release_flatten() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
  if (_internal_has_flatten()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::FlattenRequest* temp = op_.flatten_;
    op_.flatten_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_flatten(::io::deephaven::proto::backplane::grpc::FlattenRequest* flatten) {
  clear_op();
  if (flatten) {
    set_has_flatten();
    op_.flatten_ = flatten;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
}
inline ::io::deephaven::proto::backplane::grpc::FlattenRequest* BatchTableRequest_Operation::_internal_mutable_flatten() {
  if (!_internal_has_flatten()) {
    clear_op();
    set_has_flatten();
    op_.flatten_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::FlattenRequest >(GetArenaForAllocation());
  }
  return op_.flatten_;
}
inline ::io::deephaven::proto::backplane::grpc::FlattenRequest* BatchTableRequest_Operation::mutable_flatten() {
  ::io::deephaven::proto::backplane::grpc::FlattenRequest* _msg = _internal_mutable_flatten();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest run_chart_downsample = 22;
inline bool BatchTableRequest_Operation::_internal_has_run_chart_downsample() const {
  return op_case() == kRunChartDownsample;
}
inline bool BatchTableRequest_Operation::has_run_chart_downsample() const {
  return _internal_has_run_chart_downsample();
}
inline void BatchTableRequest_Operation::set_has_run_chart_downsample() {
  _oneof_case_[0] = kRunChartDownsample;
}
inline void BatchTableRequest_Operation::clear_run_chart_downsample() {
  if (_internal_has_run_chart_downsample()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.run_chart_downsample_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* BatchTableRequest_Operation::release_run_chart_downsample() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
  if (_internal_has_run_chart_downsample()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* temp = op_.run_chart_downsample_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.run_chart_downsample_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& BatchTableRequest_Operation::_internal_run_chart_downsample() const {
  return _internal_has_run_chart_downsample()
      ? *op_.run_chart_downsample_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest&>(::io::deephaven::proto::backplane::grpc::_RunChartDownsampleRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& BatchTableRequest_Operation::run_chart_downsample() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
  return _internal_run_chart_downsample();
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* BatchTableRequest_Operation::unsafe_arena_release_run_chart_downsample() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
  if (_internal_has_run_chart_downsample()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* temp = op_.run_chart_downsample_;
    op_.run_chart_downsample_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_run_chart_downsample(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* run_chart_downsample) {
  clear_op();
  if (run_chart_downsample) {
    set_has_run_chart_downsample();
    op_.run_chart_downsample_ = run_chart_downsample;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* BatchTableRequest_Operation::_internal_mutable_run_chart_downsample() {
  if (!_internal_has_run_chart_downsample()) {
    clear_op();
    set_has_run_chart_downsample();
    op_.run_chart_downsample_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest >(GetArenaForAllocation());
  }
  return op_.run_chart_downsample_;
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* BatchTableRequest_Operation::mutable_run_chart_downsample() {
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* _msg = _internal_mutable_run_chart_downsample();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest cross_join = 23;
inline bool BatchTableRequest_Operation::_internal_has_cross_join() const {
  return op_case() == kCrossJoin;
}
inline bool BatchTableRequest_Operation::has_cross_join() const {
  return _internal_has_cross_join();
}
inline void BatchTableRequest_Operation::set_has_cross_join() {
  _oneof_case_[0] = kCrossJoin;
}
inline void BatchTableRequest_Operation::clear_cross_join() {
  if (_internal_has_cross_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.cross_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* BatchTableRequest_Operation::release_cross_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
  if (_internal_has_cross_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* temp = op_.cross_join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.cross_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& BatchTableRequest_Operation::_internal_cross_join() const {
  return _internal_has_cross_join()
      ? *op_.cross_join_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_CrossJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& BatchTableRequest_Operation::cross_join() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
  return _internal_cross_join();
}
inline ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_cross_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
  if (_internal_has_cross_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* temp = op_.cross_join_;
    op_.cross_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_cross_join(::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* cross_join) {
  clear_op();
  if (cross_join) {
    set_has_cross_join();
    op_.cross_join_ = cross_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
}
inline ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_cross_join() {
  if (!_internal_has_cross_join()) {
    clear_op();
    set_has_cross_join();
    op_.cross_join_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest >(GetArenaForAllocation());
  }
  return op_.cross_join_;
}
inline ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* BatchTableRequest_Operation::mutable_cross_join() {
  ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* _msg = _internal_mutable_cross_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest natural_join = 24;
inline bool BatchTableRequest_Operation::_internal_has_natural_join() const {
  return op_case() == kNaturalJoin;
}
inline bool BatchTableRequest_Operation::has_natural_join() const {
  return _internal_has_natural_join();
}
inline void BatchTableRequest_Operation::set_has_natural_join() {
  _oneof_case_[0] = kNaturalJoin;
}
inline void BatchTableRequest_Operation::clear_natural_join() {
  if (_internal_has_natural_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.natural_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* BatchTableRequest_Operation::release_natural_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
  if (_internal_has_natural_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* temp = op_.natural_join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.natural_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& BatchTableRequest_Operation::_internal_natural_join() const {
  return _internal_has_natural_join()
      ? *op_.natural_join_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_NaturalJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& BatchTableRequest_Operation::natural_join() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
  return _internal_natural_join();
}
inline ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_natural_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
  if (_internal_has_natural_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* temp = op_.natural_join_;
    op_.natural_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_natural_join(::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* natural_join) {
  clear_op();
  if (natural_join) {
    set_has_natural_join();
    op_.natural_join_ = natural_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
}
inline ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_natural_join() {
  if (!_internal_has_natural_join()) {
    clear_op();
    set_has_natural_join();
    op_.natural_join_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest >(GetArenaForAllocation());
  }
  return op_.natural_join_;
}
inline ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* BatchTableRequest_Operation::mutable_natural_join() {
  ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* _msg = _internal_mutable_natural_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest exact_join = 25;
inline bool BatchTableRequest_Operation::_internal_has_exact_join() const {
  return op_case() == kExactJoin;
}
inline bool BatchTableRequest_Operation::has_exact_join() const {
  return _internal_has_exact_join();
}
inline void BatchTableRequest_Operation::set_has_exact_join() {
  _oneof_case_[0] = kExactJoin;
}
inline void BatchTableRequest_Operation::clear_exact_join() {
  if (_internal_has_exact_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.exact_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* BatchTableRequest_Operation::release_exact_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
  if (_internal_has_exact_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* temp = op_.exact_join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.exact_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& BatchTableRequest_Operation::_internal_exact_join() const {
  return _internal_has_exact_join()
      ? *op_.exact_join_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_ExactJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& BatchTableRequest_Operation::exact_join() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
  return _internal_exact_join();
}
inline ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_exact_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
  if (_internal_has_exact_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* temp = op_.exact_join_;
    op_.exact_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_exact_join(::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* exact_join) {
  clear_op();
  if (exact_join) {
    set_has_exact_join();
    op_.exact_join_ = exact_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
}
inline ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_exact_join() {
  if (!_internal_has_exact_join()) {
    clear_op();
    set_has_exact_join();
    op_.exact_join_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest >(GetArenaForAllocation());
  }
  return op_.exact_join_;
}
inline ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* BatchTableRequest_Operation::mutable_exact_join() {
  ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* _msg = _internal_mutable_exact_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest left_join = 26;
inline bool BatchTableRequest_Operation::_internal_has_left_join() const {
  return op_case() == kLeftJoin;
}
inline bool BatchTableRequest_Operation::has_left_join() const {
  return _internal_has_left_join();
}
inline void BatchTableRequest_Operation::set_has_left_join() {
  _oneof_case_[0] = kLeftJoin;
}
inline void BatchTableRequest_Operation::clear_left_join() {
  if (_internal_has_left_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.left_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* BatchTableRequest_Operation::release_left_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
  if (_internal_has_left_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* temp = op_.left_join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.left_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& BatchTableRequest_Operation::_internal_left_join() const {
  return _internal_has_left_join()
      ? *op_.left_join_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_LeftJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& BatchTableRequest_Operation::left_join() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
  return _internal_left_join();
}
inline ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_left_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
  if (_internal_has_left_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* temp = op_.left_join_;
    op_.left_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_left_join(::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* left_join) {
  clear_op();
  if (left_join) {
    set_has_left_join();
    op_.left_join_ = left_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
}
inline ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_left_join() {
  if (!_internal_has_left_join()) {
    clear_op();
    set_has_left_join();
    op_.left_join_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest >(GetArenaForAllocation());
  }
  return op_.left_join_;
}
inline ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* BatchTableRequest_Operation::mutable_left_join() {
  ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* _msg = _internal_mutable_left_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest as_of_join = 27 [deprecated = true];
inline bool BatchTableRequest_Operation::_internal_has_as_of_join() const {
  return op_case() == kAsOfJoin;
}
inline bool BatchTableRequest_Operation::has_as_of_join() const {
  return _internal_has_as_of_join();
}
inline void BatchTableRequest_Operation::set_has_as_of_join() {
  _oneof_case_[0] = kAsOfJoin;
}
inline void BatchTableRequest_Operation::clear_as_of_join() {
  if (_internal_has_as_of_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.as_of_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* BatchTableRequest_Operation::release_as_of_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
  if (_internal_has_as_of_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* temp = op_.as_of_join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.as_of_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& BatchTableRequest_Operation::_internal_as_of_join() const {
  return _internal_has_as_of_join()
      ? *op_.as_of_join_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_AsOfJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& BatchTableRequest_Operation::as_of_join() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
  return _internal_as_of_join();
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_as_of_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
  if (_internal_has_as_of_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* temp = op_.as_of_join_;
    op_.as_of_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_as_of_join(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* as_of_join) {
  clear_op();
  if (as_of_join) {
    set_has_as_of_join();
    op_.as_of_join_ = as_of_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_as_of_join() {
  if (!_internal_has_as_of_join()) {
    clear_op();
    set_has_as_of_join();
    op_.as_of_join_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest >(GetArenaForAllocation());
  }
  return op_.as_of_join_;
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* BatchTableRequest_Operation::mutable_as_of_join() {
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* _msg = _internal_mutable_as_of_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.FetchTableRequest fetch_table = 28;
inline bool BatchTableRequest_Operation::_internal_has_fetch_table() const {
  return op_case() == kFetchTable;
}
inline bool BatchTableRequest_Operation::has_fetch_table() const {
  return _internal_has_fetch_table();
}
inline void BatchTableRequest_Operation::set_has_fetch_table() {
  _oneof_case_[0] = kFetchTable;
}
inline void BatchTableRequest_Operation::clear_fetch_table() {
  if (_internal_has_fetch_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.fetch_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::FetchTableRequest* BatchTableRequest_Operation::release_fetch_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
  if (_internal_has_fetch_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::FetchTableRequest* temp = op_.fetch_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.fetch_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& BatchTableRequest_Operation::_internal_fetch_table() const {
  return _internal_has_fetch_table()
      ? *op_.fetch_table_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::FetchTableRequest&>(::io::deephaven::proto::backplane::grpc::_FetchTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& BatchTableRequest_Operation::fetch_table() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
  return _internal_fetch_table();
}
inline ::io::deephaven::proto::backplane::grpc::FetchTableRequest* BatchTableRequest_Operation::unsafe_arena_release_fetch_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
  if (_internal_has_fetch_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::FetchTableRequest* temp = op_.fetch_table_;
    op_.fetch_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_fetch_table(::io::deephaven::proto::backplane::grpc::FetchTableRequest* fetch_table) {
  clear_op();
  if (fetch_table) {
    set_has_fetch_table();
    op_.fetch_table_ = fetch_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
}
inline ::io::deephaven::proto::backplane::grpc::FetchTableRequest* BatchTableRequest_Operation::_internal_mutable_fetch_table() {
  if (!_internal_has_fetch_table()) {
    clear_op();
    set_has_fetch_table();
    op_.fetch_table_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::FetchTableRequest >(GetArenaForAllocation());
  }
  return op_.fetch_table_;
}
inline ::io::deephaven::proto::backplane::grpc::FetchTableRequest* BatchTableRequest_Operation::mutable_fetch_table() {
  ::io::deephaven::proto::backplane::grpc::FetchTableRequest* _msg = _internal_mutable_fetch_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest apply_preview_columns = 30;
inline bool BatchTableRequest_Operation::_internal_has_apply_preview_columns() const {
  return op_case() == kApplyPreviewColumns;
}
inline bool BatchTableRequest_Operation::has_apply_preview_columns() const {
  return _internal_has_apply_preview_columns();
}
inline void BatchTableRequest_Operation::set_has_apply_preview_columns() {
  _oneof_case_[0] = kApplyPreviewColumns;
}
inline void BatchTableRequest_Operation::clear_apply_preview_columns() {
  if (_internal_has_apply_preview_columns()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.apply_preview_columns_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* BatchTableRequest_Operation::release_apply_preview_columns() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.apply_preview_columns)
  if (_internal_has_apply_preview_columns()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* temp = op_.apply_preview_columns_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.apply_preview_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest& BatchTableRequest_Operation::_internal_apply_preview_columns() const {
  return _internal_has_apply_preview_columns()
      ? *op_.apply_preview_columns_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest&>(::io::deephaven::proto::backplane::grpc::_ApplyPreviewColumnsRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest& BatchTableRequest_Operation::apply_preview_columns() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.apply_preview_columns)
  return _internal_apply_preview_columns();
}
inline ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* BatchTableRequest_Operation::unsafe_arena_release_apply_preview_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.apply_preview_columns)
  if (_internal_has_apply_preview_columns()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* temp = op_.apply_preview_columns_;
    op_.apply_preview_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_apply_preview_columns(::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* apply_preview_columns) {
  clear_op();
  if (apply_preview_columns) {
    set_has_apply_preview_columns();
    op_.apply_preview_columns_ = apply_preview_columns;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.apply_preview_columns)
}
inline ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* BatchTableRequest_Operation::_internal_mutable_apply_preview_columns() {
  if (!_internal_has_apply_preview_columns()) {
    clear_op();
    set_has_apply_preview_columns();
    op_.apply_preview_columns_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest >(GetArenaForAllocation());
  }
  return op_.apply_preview_columns_;
}
inline ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* BatchTableRequest_Operation::mutable_apply_preview_columns() {
  ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* _msg = _internal_mutable_apply_preview_columns();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.apply_preview_columns)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.CreateInputTableRequest create_input_table = 31;
inline bool BatchTableRequest_Operation::_internal_has_create_input_table() const {
  return op_case() == kCreateInputTable;
}
inline bool BatchTableRequest_Operation::has_create_input_table() const {
  return _internal_has_create_input_table();
}
inline void BatchTableRequest_Operation::set_has_create_input_table() {
  _oneof_case_[0] = kCreateInputTable;
}
inline void BatchTableRequest_Operation::clear_create_input_table() {
  if (_internal_has_create_input_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.create_input_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* BatchTableRequest_Operation::release_create_input_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.create_input_table)
  if (_internal_has_create_input_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* temp = op_.create_input_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.create_input_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest& BatchTableRequest_Operation::_internal_create_input_table() const {
  return _internal_has_create_input_table()
      ? *op_.create_input_table_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest&>(::io::deephaven::proto::backplane::grpc::_CreateInputTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest& BatchTableRequest_Operation::create_input_table() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.create_input_table)
  return _internal_create_input_table();
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* BatchTableRequest_Operation::unsafe_arena_release_create_input_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.create_input_table)
  if (_internal_has_create_input_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* temp = op_.create_input_table_;
    op_.create_input_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_create_input_table(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* create_input_table) {
  clear_op();
  if (create_input_table) {
    set_has_create_input_table();
    op_.create_input_table_ = create_input_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.create_input_table)
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* BatchTableRequest_Operation::_internal_mutable_create_input_table() {
  if (!_internal_has_create_input_table()) {
    clear_op();
    set_has_create_input_table();
    op_.create_input_table_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest >(GetArenaForAllocation());
  }
  return op_.create_input_table_;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* BatchTableRequest_Operation::mutable_create_input_table() {
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* _msg = _internal_mutable_create_input_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.create_input_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest update_by = 32;
inline bool BatchTableRequest_Operation::_internal_has_update_by() const {
  return op_case() == kUpdateBy;
}
inline bool BatchTableRequest_Operation::has_update_by() const {
  return _internal_has_update_by();
}
inline void BatchTableRequest_Operation::set_has_update_by() {
  _oneof_case_[0] = kUpdateBy;
}
inline void BatchTableRequest_Operation::clear_update_by() {
  if (_internal_has_update_by()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.update_by_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest* BatchTableRequest_Operation::release_update_by() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_by)
  if (_internal_has_update_by()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest* temp = op_.update_by_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.update_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest& BatchTableRequest_Operation::_internal_update_by() const {
  return _internal_has_update_by()
      ? *op_.update_by_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::UpdateByRequest&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest& BatchTableRequest_Operation::update_by() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_by)
  return _internal_update_by();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest* BatchTableRequest_Operation::unsafe_arena_release_update_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_by)
  if (_internal_has_update_by()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest* temp = op_.update_by_;
    op_.update_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_update_by(::io::deephaven::proto::backplane::grpc::UpdateByRequest* update_by) {
  clear_op();
  if (update_by) {
    set_has_update_by();
    op_.update_by_ = update_by;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_by)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest* BatchTableRequest_Operation::_internal_mutable_update_by() {
  if (!_internal_has_update_by()) {
    clear_op();
    set_has_update_by();
    op_.update_by_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::UpdateByRequest >(GetArenaForAllocation());
  }
  return op_.update_by_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest* BatchTableRequest_Operation::mutable_update_by() {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest* _msg = _internal_mutable_update_by();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_by)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.WhereInRequest where_in = 33;
inline bool BatchTableRequest_Operation::_internal_has_where_in() const {
  return op_case() == kWhereIn;
}
inline bool BatchTableRequest_Operation::has_where_in() const {
  return _internal_has_where_in();
}
inline void BatchTableRequest_Operation::set_has_where_in() {
  _oneof_case_[0] = kWhereIn;
}
inline void BatchTableRequest_Operation::clear_where_in() {
  if (_internal_has_where_in()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.where_in_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::WhereInRequest* BatchTableRequest_Operation::release_where_in() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.where_in)
  if (_internal_has_where_in()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::WhereInRequest* temp = op_.where_in_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.where_in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::WhereInRequest& BatchTableRequest_Operation::_internal_where_in() const {
  return _internal_has_where_in()
      ? *op_.where_in_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::WhereInRequest&>(::io::deephaven::proto::backplane::grpc::_WhereInRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::WhereInRequest& BatchTableRequest_Operation::where_in() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.where_in)
  return _internal_where_in();
}
inline ::io::deephaven::proto::backplane::grpc::WhereInRequest* BatchTableRequest_Operation::unsafe_arena_release_where_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.where_in)
  if (_internal_has_where_in()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::WhereInRequest* temp = op_.where_in_;
    op_.where_in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_where_in(::io::deephaven::proto::backplane::grpc::WhereInRequest* where_in) {
  clear_op();
  if (where_in) {
    set_has_where_in();
    op_.where_in_ = where_in;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.where_in)
}
inline ::io::deephaven::proto::backplane::grpc::WhereInRequest* BatchTableRequest_Operation::_internal_mutable_where_in() {
  if (!_internal_has_where_in()) {
    clear_op();
    set_has_where_in();
    op_.where_in_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::WhereInRequest >(GetArenaForAllocation());
  }
  return op_.where_in_;
}
inline ::io::deephaven::proto::backplane::grpc::WhereInRequest* BatchTableRequest_Operation::mutable_where_in() {
  ::io::deephaven::proto::backplane::grpc::WhereInRequest* _msg = _internal_mutable_where_in();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.where_in)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggregateAllRequest aggregate_all = 34;
inline bool BatchTableRequest_Operation::_internal_has_aggregate_all() const {
  return op_case() == kAggregateAll;
}
inline bool BatchTableRequest_Operation::has_aggregate_all() const {
  return _internal_has_aggregate_all();
}
inline void BatchTableRequest_Operation::set_has_aggregate_all() {
  _oneof_case_[0] = kAggregateAll;
}
inline void BatchTableRequest_Operation::clear_aggregate_all() {
  if (_internal_has_aggregate_all()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.aggregate_all_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* BatchTableRequest_Operation::release_aggregate_all() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate_all)
  if (_internal_has_aggregate_all()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* temp = op_.aggregate_all_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.aggregate_all_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggregateAllRequest& BatchTableRequest_Operation::_internal_aggregate_all() const {
  return _internal_has_aggregate_all()
      ? *op_.aggregate_all_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggregateAllRequest&>(::io::deephaven::proto::backplane::grpc::_AggregateAllRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggregateAllRequest& BatchTableRequest_Operation::aggregate_all() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate_all)
  return _internal_aggregate_all();
}
inline ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* BatchTableRequest_Operation::unsafe_arena_release_aggregate_all() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate_all)
  if (_internal_has_aggregate_all()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* temp = op_.aggregate_all_;
    op_.aggregate_all_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_aggregate_all(::io::deephaven::proto::backplane::grpc::AggregateAllRequest* aggregate_all) {
  clear_op();
  if (aggregate_all) {
    set_has_aggregate_all();
    op_.aggregate_all_ = aggregate_all;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate_all)
}
inline ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* BatchTableRequest_Operation::_internal_mutable_aggregate_all() {
  if (!_internal_has_aggregate_all()) {
    clear_op();
    set_has_aggregate_all();
    op_.aggregate_all_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggregateAllRequest >(GetArenaForAllocation());
  }
  return op_.aggregate_all_;
}
inline ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* BatchTableRequest_Operation::mutable_aggregate_all() {
  ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* _msg = _internal_mutable_aggregate_all();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate_all)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggregateRequest aggregate = 35;
inline bool BatchTableRequest_Operation::_internal_has_aggregate() const {
  return op_case() == kAggregate;
}
inline bool BatchTableRequest_Operation::has_aggregate() const {
  return _internal_has_aggregate();
}
inline void BatchTableRequest_Operation::set_has_aggregate() {
  _oneof_case_[0] = kAggregate;
}
inline void BatchTableRequest_Operation::clear_aggregate() {
  if (_internal_has_aggregate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.aggregate_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggregateRequest* BatchTableRequest_Operation::release_aggregate() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate)
  if (_internal_has_aggregate()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::AggregateRequest* temp = op_.aggregate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggregateRequest& BatchTableRequest_Operation::_internal_aggregate() const {
  return _internal_has_aggregate()
      ? *op_.aggregate_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AggregateRequest&>(::io::deephaven::proto::backplane::grpc::_AggregateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggregateRequest& BatchTableRequest_Operation::aggregate() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate)
  return _internal_aggregate();
}
inline ::io::deephaven::proto::backplane::grpc::AggregateRequest* BatchTableRequest_Operation::unsafe_arena_release_aggregate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate)
  if (_internal_has_aggregate()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::AggregateRequest* temp = op_.aggregate_;
    op_.aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_aggregate(::io::deephaven::proto::backplane::grpc::AggregateRequest* aggregate) {
  clear_op();
  if (aggregate) {
    set_has_aggregate();
    op_.aggregate_ = aggregate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate)
}
inline ::io::deephaven::proto::backplane::grpc::AggregateRequest* BatchTableRequest_Operation::_internal_mutable_aggregate() {
  if (!_internal_has_aggregate()) {
    clear_op();
    set_has_aggregate();
    op_.aggregate_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AggregateRequest >(GetArenaForAllocation());
  }
  return op_.aggregate_;
}
inline ::io::deephaven::proto::backplane::grpc::AggregateRequest* BatchTableRequest_Operation::mutable_aggregate() {
  ::io::deephaven::proto::backplane::grpc::AggregateRequest* _msg = _internal_mutable_aggregate();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SnapshotTableRequest snapshot = 36;
inline bool BatchTableRequest_Operation::_internal_has_snapshot() const {
  return op_case() == kSnapshot;
}
inline bool BatchTableRequest_Operation::has_snapshot() const {
  return _internal_has_snapshot();
}
inline void BatchTableRequest_Operation::set_has_snapshot() {
  _oneof_case_[0] = kSnapshot;
}
inline void BatchTableRequest_Operation::clear_snapshot() {
  if (_internal_has_snapshot()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.snapshot_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* BatchTableRequest_Operation::release_snapshot() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
  if (_internal_has_snapshot()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* temp = op_.snapshot_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& BatchTableRequest_Operation::_internal_snapshot() const {
  return _internal_has_snapshot()
      ? *op_.snapshot_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest&>(::io::deephaven::proto::backplane::grpc::_SnapshotTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& BatchTableRequest_Operation::snapshot() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
  return _internal_snapshot();
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* BatchTableRequest_Operation::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
  if (_internal_has_snapshot()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* temp = op_.snapshot_;
    op_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_snapshot(::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* snapshot) {
  clear_op();
  if (snapshot) {
    set_has_snapshot();
    op_.snapshot_ = snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* BatchTableRequest_Operation::_internal_mutable_snapshot() {
  if (!_internal_has_snapshot()) {
    clear_op();
    set_has_snapshot();
    op_.snapshot_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest >(GetArenaForAllocation());
  }
  return op_.snapshot_;
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* BatchTableRequest_Operation::mutable_snapshot() {
  ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest snapshot_when = 37;
inline bool BatchTableRequest_Operation::_internal_has_snapshot_when() const {
  return op_case() == kSnapshotWhen;
}
inline bool BatchTableRequest_Operation::has_snapshot_when() const {
  return _internal_has_snapshot_when();
}
inline void BatchTableRequest_Operation::set_has_snapshot_when() {
  _oneof_case_[0] = kSnapshotWhen;
}
inline void BatchTableRequest_Operation::clear_snapshot_when() {
  if (_internal_has_snapshot_when()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.snapshot_when_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* BatchTableRequest_Operation::release_snapshot_when() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot_when)
  if (_internal_has_snapshot_when()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* temp = op_.snapshot_when_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.snapshot_when_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest& BatchTableRequest_Operation::_internal_snapshot_when() const {
  return _internal_has_snapshot_when()
      ? *op_.snapshot_when_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest&>(::io::deephaven::proto::backplane::grpc::_SnapshotWhenTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest& BatchTableRequest_Operation::snapshot_when() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot_when)
  return _internal_snapshot_when();
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* BatchTableRequest_Operation::unsafe_arena_release_snapshot_when() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot_when)
  if (_internal_has_snapshot_when()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* temp = op_.snapshot_when_;
    op_.snapshot_when_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_snapshot_when(::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* snapshot_when) {
  clear_op();
  if (snapshot_when) {
    set_has_snapshot_when();
    op_.snapshot_when_ = snapshot_when;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot_when)
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* BatchTableRequest_Operation::_internal_mutable_snapshot_when() {
  if (!_internal_has_snapshot_when()) {
    clear_op();
    set_has_snapshot_when();
    op_.snapshot_when_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest >(GetArenaForAllocation());
  }
  return op_.snapshot_when_;
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* BatchTableRequest_Operation::mutable_snapshot_when() {
  ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* _msg = _internal_mutable_snapshot_when();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot_when)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.MetaTableRequest meta_table = 38;
inline bool BatchTableRequest_Operation::_internal_has_meta_table() const {
  return op_case() == kMetaTable;
}
inline bool BatchTableRequest_Operation::has_meta_table() const {
  return _internal_has_meta_table();
}
inline void BatchTableRequest_Operation::set_has_meta_table() {
  _oneof_case_[0] = kMetaTable;
}
inline void BatchTableRequest_Operation::clear_meta_table() {
  if (_internal_has_meta_table()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.meta_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::MetaTableRequest* BatchTableRequest_Operation::release_meta_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.meta_table)
  if (_internal_has_meta_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::MetaTableRequest* temp = op_.meta_table_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.meta_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::MetaTableRequest& BatchTableRequest_Operation::_internal_meta_table() const {
  return _internal_has_meta_table()
      ? *op_.meta_table_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::MetaTableRequest&>(::io::deephaven::proto::backplane::grpc::_MetaTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MetaTableRequest& BatchTableRequest_Operation::meta_table() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.meta_table)
  return _internal_meta_table();
}
inline ::io::deephaven::proto::backplane::grpc::MetaTableRequest* BatchTableRequest_Operation::unsafe_arena_release_meta_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.meta_table)
  if (_internal_has_meta_table()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::MetaTableRequest* temp = op_.meta_table_;
    op_.meta_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_meta_table(::io::deephaven::proto::backplane::grpc::MetaTableRequest* meta_table) {
  clear_op();
  if (meta_table) {
    set_has_meta_table();
    op_.meta_table_ = meta_table;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.meta_table)
}
inline ::io::deephaven::proto::backplane::grpc::MetaTableRequest* BatchTableRequest_Operation::_internal_mutable_meta_table() {
  if (!_internal_has_meta_table()) {
    clear_op();
    set_has_meta_table();
    op_.meta_table_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::MetaTableRequest >(GetArenaForAllocation());
  }
  return op_.meta_table_;
}
inline ::io::deephaven::proto::backplane::grpc::MetaTableRequest* BatchTableRequest_Operation::mutable_meta_table() {
  ::io::deephaven::proto::backplane::grpc::MetaTableRequest* _msg = _internal_mutable_meta_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.meta_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest range_join = 39;
inline bool BatchTableRequest_Operation::_internal_has_range_join() const {
  return op_case() == kRangeJoin;
}
inline bool BatchTableRequest_Operation::has_range_join() const {
  return _internal_has_range_join();
}
inline void BatchTableRequest_Operation::set_has_range_join() {
  _oneof_case_[0] = kRangeJoin;
}
inline void BatchTableRequest_Operation::clear_range_join() {
  if (_internal_has_range_join()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.range_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* BatchTableRequest_Operation::release_range_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.range_join)
  if (_internal_has_range_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* temp = op_.range_join_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.range_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest& BatchTableRequest_Operation::_internal_range_join() const {
  return _internal_has_range_join()
      ? *op_.range_join_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_RangeJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest& BatchTableRequest_Operation::range_join() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.range_join)
  return _internal_range_join();
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_range_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.range_join)
  if (_internal_has_range_join()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* temp = op_.range_join_;
    op_.range_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_range_join(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* range_join) {
  clear_op();
  if (range_join) {
    set_has_range_join();
    op_.range_join_ = range_join;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.range_join)
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_range_join() {
  if (!_internal_has_range_join()) {
    clear_op();
    set_has_range_join();
    op_.range_join_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest >(GetArenaForAllocation());
  }
  return op_.range_join_;
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* BatchTableRequest_Operation::mutable_range_join() {
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* _msg = _internal_mutable_range_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.range_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AjRajTablesRequest aj = 40;
inline bool BatchTableRequest_Operation::_internal_has_aj() const {
  return op_case() == kAj;
}
inline bool BatchTableRequest_Operation::has_aj() const {
  return _internal_has_aj();
}
inline void BatchTableRequest_Operation::set_has_aj() {
  _oneof_case_[0] = kAj;
}
inline void BatchTableRequest_Operation::clear_aj() {
  if (_internal_has_aj()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.aj_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::release_aj() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aj)
  if (_internal_has_aj()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* temp = op_.aj_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.aj_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& BatchTableRequest_Operation::_internal_aj() const {
  return _internal_has_aj()
      ? *op_.aj_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest&>(::io::deephaven::proto::backplane::grpc::_AjRajTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& BatchTableRequest_Operation::aj() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aj)
  return _internal_aj();
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_aj() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aj)
  if (_internal_has_aj()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* temp = op_.aj_;
    op_.aj_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_aj(::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* aj) {
  clear_op();
  if (aj) {
    set_has_aj();
    op_.aj_ = aj;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aj)
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::_internal_mutable_aj() {
  if (!_internal_has_aj()) {
    clear_op();
    set_has_aj();
    op_.aj_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest >(GetArenaForAllocation());
  }
  return op_.aj_;
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::mutable_aj() {
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* _msg = _internal_mutable_aj();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aj)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AjRajTablesRequest raj = 41;
inline bool BatchTableRequest_Operation::_internal_has_raj() const {
  return op_case() == kRaj;
}
inline bool BatchTableRequest_Operation::has_raj() const {
  return _internal_has_raj();
}
inline void BatchTableRequest_Operation::set_has_raj() {
  _oneof_case_[0] = kRaj;
}
inline void BatchTableRequest_Operation::clear_raj() {
  if (_internal_has_raj()) {
    if (GetArenaForAllocation() == nullptr) {
      delete op_.raj_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::release_raj() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.raj)
  if (_internal_has_raj()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* temp = op_.raj_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    op_.raj_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& BatchTableRequest_Operation::_internal_raj() const {
  return _internal_has_raj()
      ? *op_.raj_
      : reinterpret_cast< ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest&>(::io::deephaven::proto::backplane::grpc::_AjRajTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& BatchTableRequest_Operation::raj() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.raj)
  return _internal_raj();
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_raj() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.raj)
  if (_internal_has_raj()) {
    clear_has_op();
    ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* temp = op_.raj_;
    op_.raj_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_raj(::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* raj) {
  clear_op();
  if (raj) {
    set_has_raj();
    op_.raj_ = raj;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.raj)
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::_internal_mutable_raj() {
  if (!_internal_has_raj()) {
    clear_op();
    set_has_raj();
    op_.raj_ = CreateMaybeMessage< ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest >(GetArenaForAllocation());
  }
  return op_.raj_;
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::mutable_raj() {
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* _msg = _internal_mutable_raj();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.raj)
  return _msg;
}

inline bool BatchTableRequest_Operation::has_op() const {
  return op_case() != OP_NOT_SET;
}
inline void BatchTableRequest_Operation::clear_has_op() {
  _oneof_case_[0] = OP_NOT_SET;
}
inline BatchTableRequest_Operation::OpCase BatchTableRequest_Operation::op_case() const {
  return BatchTableRequest_Operation::OpCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BatchTableRequest

// repeated .io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation ops = 1;
inline int BatchTableRequest::_internal_ops_size() const {
  return ops_.size();
}
inline int BatchTableRequest::ops_size() const {
  return _internal_ops_size();
}
inline void BatchTableRequest::clear_ops() {
  ops_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* BatchTableRequest::mutable_ops(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return ops_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation >*
BatchTableRequest::mutable_ops() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return &ops_;
}
inline const ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation& BatchTableRequest::_internal_ops(int index) const {
  return ops_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation& BatchTableRequest::ops(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return _internal_ops(index);
}
inline ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* BatchTableRequest::_internal_add_ops() {
  return ops_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* BatchTableRequest::add_ops() {
  ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* _add = _internal_add_ops();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation >&
BatchTableRequest::ops() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return ops_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace grpc
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode>() {
  return ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule>() {
  return ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule>() {
  return ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule>() {
  return ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType>() {
  return ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection>() {
  return ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation>() {
  return ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::BadDataBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::BadDataBehavior>() {
  return ::io::deephaven::proto::backplane::grpc::BadDataBehavior_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior>() {
  return ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::NullValue> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::NullValue>() {
  return ::io::deephaven::proto::backplane::grpc::NullValue_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::CaseSensitivity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::CaseSensitivity>() {
  return ::io::deephaven::proto::backplane::grpc::CaseSensitivity_descriptor();
}
template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::MatchType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::MatchType>() {
  return ::io::deephaven::proto::backplane::grpc::MatchType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2ftable_2eproto
