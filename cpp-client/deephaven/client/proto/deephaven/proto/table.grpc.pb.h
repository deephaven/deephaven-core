// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: deephaven/proto/table.proto
// Original file comments:
//
// Copyright (c) 2016-2021 Deephaven Data Labs and Patent Pending
//
#ifndef GRPC_deephaven_2fproto_2ftable_2eproto__INCLUDED
#define GRPC_deephaven_2fproto_2ftable_2eproto__INCLUDED

#include "deephaven/proto/table.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace grpc {

class TableService final {
 public:
  static constexpr char const* service_full_name() {
    return "io.deephaven.proto.backplane.grpc.TableService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    //
    // Request an ETCR for this ticket. Ticket must reference a Table.
    virtual ::grpc::Status GetExportedTableCreationResponse(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncGetExportedTableCreationResponse(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncGetExportedTableCreationResponseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncGetExportedTableCreationResponse(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncGetExportedTableCreationResponseRaw(context, request, cq));
    }
    //
    // Fetches a Table from an existing source ticket and exports it to the local session result ticket.
    virtual ::grpc::Status FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncFetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncFetchTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncFetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncFetchTableRaw(context, request, cq));
    }
    //
    // Fetches a pandas table from an existing source ticket and exports it to the local session result ticket.
    virtual ::grpc::Status FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncFetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncFetchPandasTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncFetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncFetchPandasTableRaw(context, request, cq));
    }
    //
    // Fetches a TableMap from an existing source ticket and exports it to the local session result ticket.
    virtual ::grpc::Status FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest& request, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>> AsyncFetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>>(AsyncFetchTableMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>> PrepareAsyncFetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>>(PrepareAsyncFetchTableMapRaw(context, request, cq));
    }
    //
    // Create an empty table with the given column names and types.
    virtual ::grpc::Status EmptyTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncEmptyTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncEmptyTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncEmptyTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncEmptyTableRaw(context, request, cq));
    }
    //
    // Create a time table with the given start time and period.
    virtual ::grpc::Status TimeTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncTimeTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncTimeTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncTimeTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncTimeTableRaw(context, request, cq));
    }
    //
    // Drop columns from the parent table.
    virtual ::grpc::Status DropColumns(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncDropColumns(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncDropColumnsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncDropColumns(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncDropColumnsRaw(context, request, cq));
    }
    //
    // Add columns to the given table using the given column specifications and the update table operation.
    virtual ::grpc::Status Update(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncUpdateRaw(context, request, cq));
    }
    //
    // Add columns to the given table using the given column specifications and the lazyUpdate table operation.
    virtual ::grpc::Status LazyUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncLazyUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncLazyUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncLazyUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncLazyUpdateRaw(context, request, cq));
    }
    //
    // Add columns to the given table using the given column specifications and the view table operation.
    virtual ::grpc::Status View(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncViewRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncViewRaw(context, request, cq));
    }
    //
    // Add columns to the given table using the given column specifications and the updateView table operation.
    virtual ::grpc::Status UpdateView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncUpdateView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncUpdateViewRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncUpdateView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncUpdateViewRaw(context, request, cq));
    }
    //
    // Select the given columns from the given table.
    virtual ::grpc::Status Select(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncSelect(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncSelectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncSelect(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncSelectRaw(context, request, cq));
    }
    //
    // Returns a new table definition with the unique tuples of the specified columns
    virtual ::grpc::Status SelectDistinct(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncSelectDistinct(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncSelectDistinctRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncSelectDistinct(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncSelectDistinctRaw(context, request, cq));
    }
    //
    // Filter parent table with structured filters.
    virtual ::grpc::Status Filter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncFilterRaw(context, request, cq));
    }
    //
    // Filter parent table with unstructured filters.
    virtual ::grpc::Status UnstructuredFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncUnstructuredFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncUnstructuredFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncUnstructuredFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncUnstructuredFilterRaw(context, request, cq));
    }
    //
    // Sort parent table via the provide sort descriptors.
    virtual ::grpc::Status Sort(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncSort(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncSortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncSort(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncSortRaw(context, request, cq));
    }
    //
    // Extract rows from the head of the parent table.
    virtual ::grpc::Status Head(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncHead(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncHeadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncHead(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncHeadRaw(context, request, cq));
    }
    //
    // Extract rows from the tail of the parent table.
    virtual ::grpc::Status Tail(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncTail(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncTailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncTail(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncTailRaw(context, request, cq));
    }
    //
    // Run the headBy table operation for the given group by columns on the given table.
    virtual ::grpc::Status HeadBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncHeadBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncHeadByRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncHeadBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncHeadByRaw(context, request, cq));
    }
    //
    // Run the tailBy operation for the given group by columns on the given table.
    virtual ::grpc::Status TailBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncTailBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncTailByRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncTailBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncTailByRaw(context, request, cq));
    }
    //
    // Ungroup the given columns (all columns will be ungrouped if columnsToUngroup is empty or unspecified).
    virtual ::grpc::Status Ungroup(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncUngroup(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncUngroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncUngroup(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncUngroupRaw(context, request, cq));
    }
    //
    // Create a merged table from the given input tables. If a key column is provided (not null), a sorted
    // merged will be performed using that column.
    virtual ::grpc::Status MergeTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncMergeTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncMergeTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncMergeTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncMergeTablesRaw(context, request, cq));
    }
    //
    // Returns the result of a cross join operation. Also known as the cartesian product.
    virtual ::grpc::Status CrossJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncCrossJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncCrossJoinTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncCrossJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncCrossJoinTablesRaw(context, request, cq));
    }
    //
    // Returns the result of a natural join operation.
    virtual ::grpc::Status NaturalJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncNaturalJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncNaturalJoinTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncNaturalJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncNaturalJoinTablesRaw(context, request, cq));
    }
    //
    // Returns the result of an exact join operation.
    virtual ::grpc::Status ExactJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncExactJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncExactJoinTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncExactJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncExactJoinTablesRaw(context, request, cq));
    }
    //
    // Returns the result of a left join operation.
    virtual ::grpc::Status LeftJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncLeftJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncLeftJoinTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncLeftJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncLeftJoinTablesRaw(context, request, cq));
    }
    //
    // Returns the result of an as of join operation.
    virtual ::grpc::Status AsOfJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncAsOfJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncAsOfJoinTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncAsOfJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncAsOfJoinTablesRaw(context, request, cq));
    }
    //
    // Returns the result of an aggregate table operation.
    virtual ::grpc::Status ComboAggregate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncComboAggregate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncComboAggregateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncComboAggregate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncComboAggregateRaw(context, request, cq));
    }
    //
    // Snapshot rightId, triggered by leftId, and export the resulting new Table.
    // The left table's change events cause a new snapshot to be taken. The result table includes a
    // "snapshot key" which is a subset (possibly all) of the left table's columns. The
    // remaining columns in the result table come from right table, the table being snapshotted.
    virtual ::grpc::Status Snapshot(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncSnapshot(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncSnapshot(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncSnapshotRaw(context, request, cq));
    }
    //
    // Returns a new table with a flattened index.
    virtual ::grpc::Status Flatten(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncFlatten(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncFlattenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncFlatten(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncFlattenRaw(context, request, cq));
    }
    // *
    // Downsamples a table assume its contents will be rendered in a run chart, with each subsequent row holding a later
    // X value (i.e., sorted on that column). Multiple Y columns can be specified, as can a range of values for the X
    // column to support zooming in.
    virtual ::grpc::Status RunChartDownsample(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncRunChartDownsample(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncRunChartDownsampleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncRunChartDownsample(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncRunChartDownsampleRaw(context, request, cq));
    }
    //
    // Batch a series of requests and send them all at once. This enables the user to create intermediate tables without
    // requiring them to be exported and managed by the client. The server will automatically release any tables when they
    // are no longer depended upon.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> Batch(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(BatchRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncBatch(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncBatchRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncBatch(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncBatchRaw(context, request, cq));
    }
    //
    // Establish a stream of table updates for cheap notifications of table size updates.
    //
    // New streams will flush updates for all existing table exports. An export id of zero will be sent to indicate all
    // exports have sent their refresh update. Table updates may be intermingled with initial refresh updates after their
    // initial update had been sent.
    std::unique_ptr< ::grpc::ClientReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>> ExportedTableUpdates(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>>(ExportedTableUpdatesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>> AsyncExportedTableUpdates(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>>(AsyncExportedTableUpdatesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>> PrepareAsyncExportedTableUpdates(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>>(PrepareAsyncExportedTableUpdatesRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      //
      // Request an ETCR for this ticket. Ticket must reference a Table.
      virtual void GetExportedTableCreationResponse(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetExportedTableCreationResponse(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetExportedTableCreationResponse(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Fetches a Table from an existing source ticket and exports it to the local session result ticket.
      virtual void FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Fetches a pandas table from an existing source ticket and exports it to the local session result ticket.
      virtual void FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Fetches a TableMap from an existing source ticket and exports it to the local session result ticket.
      virtual void FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Create an empty table with the given column names and types.
      virtual void EmptyTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void EmptyTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void EmptyTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Create a time table with the given start time and period.
      virtual void TimeTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TimeTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TimeTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Drop columns from the parent table.
      virtual void DropColumns(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DropColumns(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DropColumns(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Add columns to the given table using the given column specifications and the update table operation.
      virtual void Update(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Update(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Update(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Add columns to the given table using the given column specifications and the lazyUpdate table operation.
      virtual void LazyUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LazyUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LazyUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Add columns to the given table using the given column specifications and the view table operation.
      virtual void View(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void View(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void View(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Add columns to the given table using the given column specifications and the updateView table operation.
      virtual void UpdateView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UpdateView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UpdateView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Select the given columns from the given table.
      virtual void Select(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Select(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Select(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Returns a new table definition with the unique tuples of the specified columns
      virtual void SelectDistinct(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SelectDistinct(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SelectDistinct(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Filter parent table with structured filters.
      virtual void Filter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Filter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Filter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Filter parent table with unstructured filters.
      virtual void UnstructuredFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void UnstructuredFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void UnstructuredFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Sort parent table via the provide sort descriptors.
      virtual void Sort(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Sort(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Sort(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Extract rows from the head of the parent table.
      virtual void Head(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Head(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Head(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Extract rows from the tail of the parent table.
      virtual void Tail(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Tail(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Tail(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Run the headBy table operation for the given group by columns on the given table.
      virtual void HeadBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void HeadBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void HeadBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Run the tailBy operation for the given group by columns on the given table.
      virtual void TailBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void TailBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void TailBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Ungroup the given columns (all columns will be ungrouped if columnsToUngroup is empty or unspecified).
      virtual void Ungroup(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Ungroup(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Ungroup(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Create a merged table from the given input tables. If a key column is provided (not null), a sorted
      // merged will be performed using that column.
      virtual void MergeTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void MergeTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void MergeTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Returns the result of a cross join operation. Also known as the cartesian product.
      virtual void CrossJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CrossJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CrossJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Returns the result of a natural join operation.
      virtual void NaturalJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NaturalJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NaturalJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Returns the result of an exact join operation.
      virtual void ExactJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ExactJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ExactJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Returns the result of a left join operation.
      virtual void LeftJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LeftJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LeftJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Returns the result of an as of join operation.
      virtual void AsOfJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void AsOfJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void AsOfJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Returns the result of an aggregate table operation.
      virtual void ComboAggregate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ComboAggregate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ComboAggregate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Snapshot rightId, triggered by leftId, and export the resulting new Table.
      // The left table's change events cause a new snapshot to be taken. The result table includes a
      // "snapshot key" which is a subset (possibly all) of the left table's columns. The
      // remaining columns in the result table come from right table, the table being snapshotted.
      virtual void Snapshot(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Snapshot(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Snapshot(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Returns a new table with a flattened index.
      virtual void Flatten(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Flatten(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Flatten(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      // *
      // Downsamples a table assume its contents will be rendered in a run chart, with each subsequent row holding a later
      // X value (i.e., sorted on that column). Multiple Y columns can be specified, as can a range of values for the X
      // column to support zooming in.
      virtual void RunChartDownsample(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void RunChartDownsample(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void RunChartDownsample(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      //
      // Batch a series of requests and send them all at once. This enables the user to create intermediate tables without
      // requiring them to be exported and managed by the client. The server will automatically release any tables when they
      // are no longer depended upon.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Batch(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* request, ::grpc::ClientReadReactor< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* reactor) = 0;
      #else
      virtual void Batch(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* request, ::grpc::experimental::ClientReadReactor< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* reactor) = 0;
      #endif
      //
      // Establish a stream of table updates for cheap notifications of table size updates.
      //
      // New streams will flush updates for all existing table exports. An export id of zero will be sent to indicate all
      // exports have sent their refresh update. Table updates may be intermingled with initial refresh updates after their
      // initial update had been sent.
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ExportedTableUpdates(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* request, ::grpc::ClientReadReactor< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* reactor) = 0;
      #else
      virtual void ExportedTableUpdates(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* request, ::grpc::experimental::ClientReadReactor< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncGetExportedTableCreationResponseRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncGetExportedTableCreationResponseRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncFetchTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncFetchTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncFetchPandasTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncFetchPandasTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>* AsyncFetchTableMapRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>* PrepareAsyncFetchTableMapRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncEmptyTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncEmptyTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncTimeTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncTimeTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncDropColumnsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncDropColumnsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncUpdateRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncUpdateRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncLazyUpdateRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncLazyUpdateRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncViewRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncViewRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncUpdateViewRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncUpdateViewRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncSelectRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncSelectRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncSelectDistinctRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncSelectDistinctRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncFilterRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncFilterRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncUnstructuredFilterRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncUnstructuredFilterRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncSortRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncSortRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncHeadRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncHeadRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncTailRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncTailRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncHeadByRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncHeadByRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncTailByRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncTailByRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncUngroupRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncUngroupRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncMergeTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncMergeTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncCrossJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncCrossJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncNaturalJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncNaturalJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncExactJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncExactJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncLeftJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncLeftJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncAsOfJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncAsOfJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncComboAggregateRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncComboAggregateRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncSnapshotRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncSnapshotRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncFlattenRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncFlattenRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncRunChartDownsampleRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncRunChartDownsampleRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* BatchRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncBatchRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncBatchRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* ExportedTableUpdatesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* AsyncExportedTableUpdatesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* PrepareAsyncExportedTableUpdatesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status GetExportedTableCreationResponse(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncGetExportedTableCreationResponse(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncGetExportedTableCreationResponseRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncGetExportedTableCreationResponse(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncGetExportedTableCreationResponseRaw(context, request, cq));
    }
    ::grpc::Status FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncFetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncFetchTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncFetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncFetchTableRaw(context, request, cq));
    }
    ::grpc::Status FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncFetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncFetchPandasTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncFetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncFetchPandasTableRaw(context, request, cq));
    }
    ::grpc::Status FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest& request, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>> AsyncFetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>>(AsyncFetchTableMapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>> PrepareAsyncFetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>>(PrepareAsyncFetchTableMapRaw(context, request, cq));
    }
    ::grpc::Status EmptyTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncEmptyTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncEmptyTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncEmptyTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncEmptyTableRaw(context, request, cq));
    }
    ::grpc::Status TimeTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncTimeTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncTimeTableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncTimeTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncTimeTableRaw(context, request, cq));
    }
    ::grpc::Status DropColumns(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncDropColumns(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncDropColumnsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncDropColumns(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncDropColumnsRaw(context, request, cq));
    }
    ::grpc::Status Update(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncUpdateRaw(context, request, cq));
    }
    ::grpc::Status LazyUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncLazyUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncLazyUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncLazyUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncLazyUpdateRaw(context, request, cq));
    }
    ::grpc::Status View(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncViewRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncViewRaw(context, request, cq));
    }
    ::grpc::Status UpdateView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncUpdateView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncUpdateViewRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncUpdateView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncUpdateViewRaw(context, request, cq));
    }
    ::grpc::Status Select(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncSelect(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncSelectRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncSelect(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncSelectRaw(context, request, cq));
    }
    ::grpc::Status SelectDistinct(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncSelectDistinct(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncSelectDistinctRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncSelectDistinct(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncSelectDistinctRaw(context, request, cq));
    }
    ::grpc::Status Filter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncFilterRaw(context, request, cq));
    }
    ::grpc::Status UnstructuredFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncUnstructuredFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncUnstructuredFilterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncUnstructuredFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncUnstructuredFilterRaw(context, request, cq));
    }
    ::grpc::Status Sort(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncSort(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncSortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncSort(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncSortRaw(context, request, cq));
    }
    ::grpc::Status Head(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncHead(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncHeadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncHead(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncHeadRaw(context, request, cq));
    }
    ::grpc::Status Tail(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncTail(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncTailRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncTail(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncTailRaw(context, request, cq));
    }
    ::grpc::Status HeadBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncHeadBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncHeadByRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncHeadBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncHeadByRaw(context, request, cq));
    }
    ::grpc::Status TailBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncTailBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncTailByRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncTailBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncTailByRaw(context, request, cq));
    }
    ::grpc::Status Ungroup(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncUngroup(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncUngroupRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncUngroup(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncUngroupRaw(context, request, cq));
    }
    ::grpc::Status MergeTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncMergeTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncMergeTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncMergeTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncMergeTablesRaw(context, request, cq));
    }
    ::grpc::Status CrossJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncCrossJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncCrossJoinTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncCrossJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncCrossJoinTablesRaw(context, request, cq));
    }
    ::grpc::Status NaturalJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncNaturalJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncNaturalJoinTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncNaturalJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncNaturalJoinTablesRaw(context, request, cq));
    }
    ::grpc::Status ExactJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncExactJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncExactJoinTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncExactJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncExactJoinTablesRaw(context, request, cq));
    }
    ::grpc::Status LeftJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncLeftJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncLeftJoinTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncLeftJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncLeftJoinTablesRaw(context, request, cq));
    }
    ::grpc::Status AsOfJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncAsOfJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncAsOfJoinTablesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncAsOfJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncAsOfJoinTablesRaw(context, request, cq));
    }
    ::grpc::Status ComboAggregate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncComboAggregate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncComboAggregateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncComboAggregate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncComboAggregateRaw(context, request, cq));
    }
    ::grpc::Status Snapshot(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncSnapshot(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncSnapshot(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncSnapshotRaw(context, request, cq));
    }
    ::grpc::Status Flatten(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncFlatten(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncFlattenRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncFlatten(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncFlattenRaw(context, request, cq));
    }
    ::grpc::Status RunChartDownsample(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncRunChartDownsample(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncRunChartDownsampleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncRunChartDownsample(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncRunChartDownsampleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> Batch(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(BatchRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> AsyncBatch(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(AsyncBatchRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>> PrepareAsyncBatch(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>>(PrepareAsyncBatchRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>> ExportedTableUpdates(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>>(ExportedTableUpdatesRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>> AsyncExportedTableUpdates(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>>(AsyncExportedTableUpdatesRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>> PrepareAsyncExportedTableUpdates(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>>(PrepareAsyncExportedTableUpdatesRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetExportedTableCreationResponse(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetExportedTableCreationResponse(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetExportedTableCreationResponse(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FetchTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FetchPandasTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void FetchTableMap(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void EmptyTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void EmptyTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void EmptyTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TimeTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TimeTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TimeTable(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DropColumns(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DropColumns(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DropColumns(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Update(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Update(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Update(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LazyUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LazyUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LazyUpdate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void View(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void View(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void View(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UpdateView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UpdateView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UpdateView(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Select(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Select(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Select(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SelectDistinct(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SelectDistinct(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SelectDistinct(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Filter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Filter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Filter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void UnstructuredFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void UnstructuredFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void UnstructuredFilter(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Sort(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Sort(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Sort(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Head(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Head(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Head(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Tail(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Tail(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Tail(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void HeadBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void HeadBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void HeadBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void TailBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void TailBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void TailBy(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Ungroup(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Ungroup(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Ungroup(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void MergeTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void MergeTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void MergeTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CrossJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CrossJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CrossJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void NaturalJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NaturalJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NaturalJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ExactJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ExactJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ExactJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LeftJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LeftJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LeftJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void AsOfJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void AsOfJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void AsOfJoinTables(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ComboAggregate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ComboAggregate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ComboAggregate(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Snapshot(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Snapshot(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Snapshot(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Flatten(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Flatten(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Flatten(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void RunChartDownsample(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void RunChartDownsample(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void RunChartDownsample(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Batch(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* request, ::grpc::ClientReadReactor< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* reactor) override;
      #else
      void Batch(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* request, ::grpc::experimental::ClientReadReactor< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ExportedTableUpdates(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* request, ::grpc::ClientReadReactor< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* reactor) override;
      #else
      void ExportedTableUpdates(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* request, ::grpc::experimental::ClientReadReactor< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncGetExportedTableCreationResponseRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncGetExportedTableCreationResponseRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncFetchTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncFetchTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncFetchPandasTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncFetchPandasTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>* AsyncFetchTableMapRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>* PrepareAsyncFetchTableMapRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncEmptyTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncEmptyTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncTimeTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncTimeTableRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncDropColumnsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncDropColumnsRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncUpdateRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncUpdateRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncLazyUpdateRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncLazyUpdateRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncViewRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncViewRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncUpdateViewRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncUpdateViewRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncSelectRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncSelectRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncSelectDistinctRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncSelectDistinctRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncFilterRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncFilterRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncUnstructuredFilterRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncUnstructuredFilterRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncSortRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncSortRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncHeadRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncHeadRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncTailRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncTailRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncHeadByRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncHeadByRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncTailByRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncTailByRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncUngroupRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncUngroupRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncMergeTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncMergeTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncCrossJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncCrossJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncNaturalJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncNaturalJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncExactJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncExactJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncLeftJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncLeftJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncAsOfJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncAsOfJoinTablesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncComboAggregateRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncComboAggregateRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncSnapshotRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncSnapshotRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncFlattenRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncFlattenRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncRunChartDownsampleRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncRunChartDownsampleRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* BatchRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest& request) override;
    ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* AsyncBatchRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* PrepareAsyncBatchRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* ExportedTableUpdatesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest& request) override;
    ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* AsyncExportedTableUpdatesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* PrepareAsyncExportedTableUpdatesRaw(::grpc::ClientContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetExportedTableCreationResponse_;
    const ::grpc::internal::RpcMethod rpcmethod_FetchTable_;
    const ::grpc::internal::RpcMethod rpcmethod_FetchPandasTable_;
    const ::grpc::internal::RpcMethod rpcmethod_FetchTableMap_;
    const ::grpc::internal::RpcMethod rpcmethod_EmptyTable_;
    const ::grpc::internal::RpcMethod rpcmethod_TimeTable_;
    const ::grpc::internal::RpcMethod rpcmethod_DropColumns_;
    const ::grpc::internal::RpcMethod rpcmethod_Update_;
    const ::grpc::internal::RpcMethod rpcmethod_LazyUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_View_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateView_;
    const ::grpc::internal::RpcMethod rpcmethod_Select_;
    const ::grpc::internal::RpcMethod rpcmethod_SelectDistinct_;
    const ::grpc::internal::RpcMethod rpcmethod_Filter_;
    const ::grpc::internal::RpcMethod rpcmethod_UnstructuredFilter_;
    const ::grpc::internal::RpcMethod rpcmethod_Sort_;
    const ::grpc::internal::RpcMethod rpcmethod_Head_;
    const ::grpc::internal::RpcMethod rpcmethod_Tail_;
    const ::grpc::internal::RpcMethod rpcmethod_HeadBy_;
    const ::grpc::internal::RpcMethod rpcmethod_TailBy_;
    const ::grpc::internal::RpcMethod rpcmethod_Ungroup_;
    const ::grpc::internal::RpcMethod rpcmethod_MergeTables_;
    const ::grpc::internal::RpcMethod rpcmethod_CrossJoinTables_;
    const ::grpc::internal::RpcMethod rpcmethod_NaturalJoinTables_;
    const ::grpc::internal::RpcMethod rpcmethod_ExactJoinTables_;
    const ::grpc::internal::RpcMethod rpcmethod_LeftJoinTables_;
    const ::grpc::internal::RpcMethod rpcmethod_AsOfJoinTables_;
    const ::grpc::internal::RpcMethod rpcmethod_ComboAggregate_;
    const ::grpc::internal::RpcMethod rpcmethod_Snapshot_;
    const ::grpc::internal::RpcMethod rpcmethod_Flatten_;
    const ::grpc::internal::RpcMethod rpcmethod_RunChartDownsample_;
    const ::grpc::internal::RpcMethod rpcmethod_Batch_;
    const ::grpc::internal::RpcMethod rpcmethod_ExportedTableUpdates_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    //
    // Request an ETCR for this ticket. Ticket must reference a Table.
    virtual ::grpc::Status GetExportedTableCreationResponse(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::Ticket* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Fetches a Table from an existing source ticket and exports it to the local session result ticket.
    virtual ::grpc::Status FetchTable(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Fetches a pandas table from an existing source ticket and exports it to the local session result ticket.
    virtual ::grpc::Status FetchPandasTable(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Fetches a TableMap from an existing source ticket and exports it to the local session result ticket.
    virtual ::grpc::Status FetchTableMap(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* response);
    //
    // Create an empty table with the given column names and types.
    virtual ::grpc::Status EmptyTable(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Create a time table with the given start time and period.
    virtual ::grpc::Status TimeTable(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Drop columns from the parent table.
    virtual ::grpc::Status DropColumns(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Add columns to the given table using the given column specifications and the update table operation.
    virtual ::grpc::Status Update(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Add columns to the given table using the given column specifications and the lazyUpdate table operation.
    virtual ::grpc::Status LazyUpdate(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Add columns to the given table using the given column specifications and the view table operation.
    virtual ::grpc::Status View(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Add columns to the given table using the given column specifications and the updateView table operation.
    virtual ::grpc::Status UpdateView(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Select the given columns from the given table.
    virtual ::grpc::Status Select(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Returns a new table definition with the unique tuples of the specified columns
    virtual ::grpc::Status SelectDistinct(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Filter parent table with structured filters.
    virtual ::grpc::Status Filter(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Filter parent table with unstructured filters.
    virtual ::grpc::Status UnstructuredFilter(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Sort parent table via the provide sort descriptors.
    virtual ::grpc::Status Sort(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Extract rows from the head of the parent table.
    virtual ::grpc::Status Head(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Extract rows from the tail of the parent table.
    virtual ::grpc::Status Tail(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Run the headBy table operation for the given group by columns on the given table.
    virtual ::grpc::Status HeadBy(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Run the tailBy operation for the given group by columns on the given table.
    virtual ::grpc::Status TailBy(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Ungroup the given columns (all columns will be ungrouped if columnsToUngroup is empty or unspecified).
    virtual ::grpc::Status Ungroup(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Create a merged table from the given input tables. If a key column is provided (not null), a sorted
    // merged will be performed using that column.
    virtual ::grpc::Status MergeTables(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Returns the result of a cross join operation. Also known as the cartesian product.
    virtual ::grpc::Status CrossJoinTables(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Returns the result of a natural join operation.
    virtual ::grpc::Status NaturalJoinTables(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Returns the result of an exact join operation.
    virtual ::grpc::Status ExactJoinTables(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Returns the result of a left join operation.
    virtual ::grpc::Status LeftJoinTables(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Returns the result of an as of join operation.
    virtual ::grpc::Status AsOfJoinTables(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Returns the result of an aggregate table operation.
    virtual ::grpc::Status ComboAggregate(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Snapshot rightId, triggered by leftId, and export the resulting new Table.
    // The left table's change events cause a new snapshot to be taken. The result table includes a
    // "snapshot key" which is a subset (possibly all) of the left table's columns. The
    // remaining columns in the result table come from right table, the table being snapshotted.
    virtual ::grpc::Status Snapshot(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Returns a new table with a flattened index.
    virtual ::grpc::Status Flatten(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    // *
    // Downsamples a table assume its contents will be rendered in a run chart, with each subsequent row holding a later
    // X value (i.e., sorted on that column). Multiple Y columns can be specified, as can a range of values for the X
    // column to support zooming in.
    virtual ::grpc::Status RunChartDownsample(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response);
    //
    // Batch a series of requests and send them all at once. This enables the user to create intermediate tables without
    // requiring them to be exported and managed by the client. The server will automatically release any tables when they
    // are no longer depended upon.
    virtual ::grpc::Status Batch(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* request, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* writer);
    //
    // Establish a stream of table updates for cheap notifications of table size updates.
    //
    // New streams will flush updates for all existing table exports. An export id of zero will be sent to indicate all
    // exports have sent their refresh update. Table updates may be intermingled with initial refresh updates after their
    // initial update had been sent.
    virtual ::grpc::Status ExportedTableUpdates(::grpc::ServerContext* context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* request, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetExportedTableCreationResponse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetExportedTableCreationResponse() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetExportedTableCreationResponse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExportedTableCreationResponse(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::Ticket* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExportedTableCreationResponse(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::Ticket* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FetchTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FetchTable() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_FetchTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchTable(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::FetchTableRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FetchPandasTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FetchPandasTable() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_FetchPandasTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchPandasTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchPandasTable(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FetchTableMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FetchTableMap() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_FetchTableMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTableMap(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchTableMap(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EmptyTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EmptyTable() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_EmptyTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmptyTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEmptyTable(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TimeTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TimeTable() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_TimeTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimeTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTimeTable(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::TimeTableRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DropColumns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DropColumns() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_DropColumns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropColumns(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDropColumns(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Update() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdate(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LazyUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LazyUpdate() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_LazyUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LazyUpdate(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLazyUpdate(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_View : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_View() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_View() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status View(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestView(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateView : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateView() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_UpdateView() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateView(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateView(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Select : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Select() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_Select() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Select(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSelect(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SelectDistinct : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SelectDistinct() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_SelectDistinct() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectDistinct(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSelectDistinct(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Filter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Filter() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_Filter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Filter(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFilter(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::FilterTableRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnstructuredFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnstructuredFilter() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_UnstructuredFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnstructuredFilter(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnstructuredFilter(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Sort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Sort() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_Sort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sort(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSort(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::SortTableRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Head : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Head() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_Head() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Head(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHead(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Tail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Tail() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_Tail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tail(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTail(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_HeadBy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_HeadBy() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_HeadBy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HeadBy(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHeadBy(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TailBy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TailBy() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_TailBy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TailBy(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTailBy(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Ungroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Ungroup() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_Ungroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ungroup(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUngroup(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::UngroupRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MergeTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_MergeTables() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_MergeTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MergeTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMergeTables(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CrossJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CrossJoinTables() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_CrossJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CrossJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCrossJoinTables(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NaturalJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NaturalJoinTables() {
      ::grpc::Service::MarkMethodAsync(23);
    }
    ~WithAsyncMethod_NaturalJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NaturalJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNaturalJoinTables(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExactJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExactJoinTables() {
      ::grpc::Service::MarkMethodAsync(24);
    }
    ~WithAsyncMethod_ExactJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExactJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExactJoinTables(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LeftJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LeftJoinTables() {
      ::grpc::Service::MarkMethodAsync(25);
    }
    ~WithAsyncMethod_LeftJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeftJoinTables(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AsOfJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AsOfJoinTables() {
      ::grpc::Service::MarkMethodAsync(26);
    }
    ~WithAsyncMethod_AsOfJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AsOfJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAsOfJoinTables(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ComboAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ComboAggregate() {
      ::grpc::Service::MarkMethodAsync(27);
    }
    ~WithAsyncMethod_ComboAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ComboAggregate(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestComboAggregate(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Snapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Snapshot() {
      ::grpc::Service::MarkMethodAsync(28);
    }
    ~WithAsyncMethod_Snapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Snapshot(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSnapshot(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Flatten : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Flatten() {
      ::grpc::Service::MarkMethodAsync(29);
    }
    ~WithAsyncMethod_Flatten() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Flatten(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFlatten(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::FlattenRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RunChartDownsample : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RunChartDownsample() {
      ::grpc::Service::MarkMethodAsync(30);
    }
    ~WithAsyncMethod_RunChartDownsample() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunChartDownsample(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunChartDownsample(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* request, ::grpc::ServerAsyncResponseWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Batch() {
      ::grpc::Service::MarkMethodAsync(31);
    }
    ~WithAsyncMethod_Batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Batch(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatch(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::BatchTableRequest* request, ::grpc::ServerAsyncWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(31, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExportedTableUpdates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExportedTableUpdates() {
      ::grpc::Service::MarkMethodAsync(32);
    }
    ~WithAsyncMethod_ExportedTableUpdates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportedTableUpdates(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExportedTableUpdates(::grpc::ServerContext* context, ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* request, ::grpc::ServerAsyncWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(32, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetExportedTableCreationResponse<WithAsyncMethod_FetchTable<WithAsyncMethod_FetchPandasTable<WithAsyncMethod_FetchTableMap<WithAsyncMethod_EmptyTable<WithAsyncMethod_TimeTable<WithAsyncMethod_DropColumns<WithAsyncMethod_Update<WithAsyncMethod_LazyUpdate<WithAsyncMethod_View<WithAsyncMethod_UpdateView<WithAsyncMethod_Select<WithAsyncMethod_SelectDistinct<WithAsyncMethod_Filter<WithAsyncMethod_UnstructuredFilter<WithAsyncMethod_Sort<WithAsyncMethod_Head<WithAsyncMethod_Tail<WithAsyncMethod_HeadBy<WithAsyncMethod_TailBy<WithAsyncMethod_Ungroup<WithAsyncMethod_MergeTables<WithAsyncMethod_CrossJoinTables<WithAsyncMethod_NaturalJoinTables<WithAsyncMethod_ExactJoinTables<WithAsyncMethod_LeftJoinTables<WithAsyncMethod_AsOfJoinTables<WithAsyncMethod_ComboAggregate<WithAsyncMethod_Snapshot<WithAsyncMethod_Flatten<WithAsyncMethod_RunChartDownsample<WithAsyncMethod_Batch<WithAsyncMethod_ExportedTableUpdates<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetExportedTableCreationResponse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetExportedTableCreationResponse() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::Ticket, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::Ticket* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->GetExportedTableCreationResponse(context, request, response); }));}
    void SetMessageAllocatorFor_GetExportedTableCreationResponse(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::Ticket, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::Ticket, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetExportedTableCreationResponse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExportedTableCreationResponse(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::Ticket* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetExportedTableCreationResponse(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::Ticket* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetExportedTableCreationResponse(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::Ticket* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FetchTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FetchTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::FetchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->FetchTable(context, request, response); }));}
    void SetMessageAllocatorFor_FetchTable(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::FetchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::FetchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FetchTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchTable(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FetchPandasTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FetchPandasTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->FetchPandasTable(context, request, response); }));}
    void SetMessageAllocatorFor_FetchPandasTable(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FetchPandasTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchPandasTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchPandasTable(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchPandasTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_FetchTableMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_FetchTableMap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* request, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* response) { return this->FetchTableMap(context, request, response); }));}
    void SetMessageAllocatorFor_FetchTableMap(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_FetchTableMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTableMap(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchTableMap(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchTableMap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_EmptyTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_EmptyTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::EmptyTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->EmptyTable(context, request, response); }));}
    void SetMessageAllocatorFor_EmptyTable(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::EmptyTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::EmptyTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_EmptyTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmptyTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EmptyTable(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EmptyTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TimeTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TimeTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::TimeTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->TimeTable(context, request, response); }));}
    void SetMessageAllocatorFor_TimeTable(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::TimeTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::TimeTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TimeTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimeTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TimeTable(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TimeTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DropColumns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DropColumns() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::DropColumnsRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->DropColumns(context, request, response); }));}
    void SetMessageAllocatorFor_DropColumns(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::DropColumnsRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::DropColumnsRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DropColumns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropColumns(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DropColumns(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DropColumns(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Update() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->Update(context, request, response); }));}
    void SetMessageAllocatorFor_Update(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Update(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Update(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LazyUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LazyUpdate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->LazyUpdate(context, request, response); }));}
    void SetMessageAllocatorFor_LazyUpdate(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LazyUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LazyUpdate(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LazyUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LazyUpdate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_View : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_View() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->View(context, request, response); }));}
    void SetMessageAllocatorFor_View(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_View() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status View(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* View(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* View(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateView : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateView() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->UpdateView(context, request, response); }));}
    void SetMessageAllocatorFor_UpdateView(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateView() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateView(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateView(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateView(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Select : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Select() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->Select(context, request, response); }));}
    void SetMessageAllocatorFor_Select(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Select() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Select(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Select(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Select(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SelectDistinct : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SelectDistinct() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->SelectDistinct(context, request, response); }));}
    void SetMessageAllocatorFor_SelectDistinct(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SelectDistinct() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectDistinct(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SelectDistinct(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SelectDistinct(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Filter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Filter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::FilterTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->Filter(context, request, response); }));}
    void SetMessageAllocatorFor_Filter(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::FilterTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::FilterTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Filter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Filter(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Filter(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Filter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UnstructuredFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UnstructuredFilter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->UnstructuredFilter(context, request, response); }));}
    void SetMessageAllocatorFor_UnstructuredFilter(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UnstructuredFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnstructuredFilter(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnstructuredFilter(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnstructuredFilter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Sort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Sort() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SortTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->Sort(context, request, response); }));}
    void SetMessageAllocatorFor_Sort(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::SortTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SortTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Sort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sort(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Sort(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Sort(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Head : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Head() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->Head(context, request, response); }));}
    void SetMessageAllocatorFor_Head(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Head() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Head(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Head(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Head(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Tail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Tail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->Tail(context, request, response); }));}
    void SetMessageAllocatorFor_Tail(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Tail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tail(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Tail(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Tail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_HeadBy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_HeadBy() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->HeadBy(context, request, response); }));}
    void SetMessageAllocatorFor_HeadBy(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_HeadBy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HeadBy(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* HeadBy(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* HeadBy(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_TailBy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_TailBy() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->TailBy(context, request, response); }));}
    void SetMessageAllocatorFor_TailBy(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_TailBy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TailBy(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TailBy(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TailBy(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Ungroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Ungroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::UngroupRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->Ungroup(context, request, response); }));}
    void SetMessageAllocatorFor_Ungroup(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::UngroupRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::UngroupRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Ungroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ungroup(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Ungroup(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Ungroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_MergeTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_MergeTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::MergeTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->MergeTables(context, request, response); }));}
    void SetMessageAllocatorFor_MergeTables(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::MergeTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(21);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::MergeTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_MergeTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MergeTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MergeTables(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MergeTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CrossJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CrossJoinTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->CrossJoinTables(context, request, response); }));}
    void SetMessageAllocatorFor_CrossJoinTables(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(22);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CrossJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CrossJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CrossJoinTables(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CrossJoinTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NaturalJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_NaturalJoinTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->NaturalJoinTables(context, request, response); }));}
    void SetMessageAllocatorFor_NaturalJoinTables(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(23);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(23);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NaturalJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NaturalJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NaturalJoinTables(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NaturalJoinTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ExactJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ExactJoinTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->ExactJoinTables(context, request, response); }));}
    void SetMessageAllocatorFor_ExactJoinTables(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(24);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(24);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ExactJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExactJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExactJoinTables(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExactJoinTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LeftJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LeftJoinTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->LeftJoinTables(context, request, response); }));}
    void SetMessageAllocatorFor_LeftJoinTables(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(25);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(25);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LeftJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeftJoinTables(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeftJoinTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AsOfJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AsOfJoinTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->AsOfJoinTables(context, request, response); }));}
    void SetMessageAllocatorFor_AsOfJoinTables(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(26);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(26);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AsOfJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AsOfJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AsOfJoinTables(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AsOfJoinTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ComboAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ComboAggregate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->ComboAggregate(context, request, response); }));}
    void SetMessageAllocatorFor_ComboAggregate(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(27);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(27);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ComboAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ComboAggregate(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ComboAggregate(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ComboAggregate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Snapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Snapshot() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->Snapshot(context, request, response); }));}
    void SetMessageAllocatorFor_Snapshot(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(28);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(28);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Snapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Snapshot(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Snapshot(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Snapshot(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Flatten : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Flatten() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::FlattenRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->Flatten(context, request, response); }));}
    void SetMessageAllocatorFor_Flatten(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::FlattenRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(29);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(29);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::FlattenRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Flatten() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Flatten(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Flatten(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Flatten(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RunChartDownsample : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RunChartDownsample() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* request, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* response) { return this->RunChartDownsample(context, request, response); }));}
    void SetMessageAllocatorFor_RunChartDownsample(
        ::grpc::experimental::MessageAllocator< ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(30);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(30);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_RunChartDownsample() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunChartDownsample(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RunChartDownsample(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RunChartDownsample(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Batch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(31,
          new ::grpc::internal::CallbackServerStreamingHandler< ::io::deephaven::proto::backplane::grpc::BatchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* request) { return this->Batch(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_Batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Batch(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* Batch(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* Batch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ExportedTableUpdates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ExportedTableUpdates() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(32,
          new ::grpc::internal::CallbackServerStreamingHandler< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* request) { return this->ExportedTableUpdates(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_ExportedTableUpdates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportedTableUpdates(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* ExportedTableUpdates(
      ::grpc::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* ExportedTableUpdates(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* /*request*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GetExportedTableCreationResponse<ExperimentalWithCallbackMethod_FetchTable<ExperimentalWithCallbackMethod_FetchPandasTable<ExperimentalWithCallbackMethod_FetchTableMap<ExperimentalWithCallbackMethod_EmptyTable<ExperimentalWithCallbackMethod_TimeTable<ExperimentalWithCallbackMethod_DropColumns<ExperimentalWithCallbackMethod_Update<ExperimentalWithCallbackMethod_LazyUpdate<ExperimentalWithCallbackMethod_View<ExperimentalWithCallbackMethod_UpdateView<ExperimentalWithCallbackMethod_Select<ExperimentalWithCallbackMethod_SelectDistinct<ExperimentalWithCallbackMethod_Filter<ExperimentalWithCallbackMethod_UnstructuredFilter<ExperimentalWithCallbackMethod_Sort<ExperimentalWithCallbackMethod_Head<ExperimentalWithCallbackMethod_Tail<ExperimentalWithCallbackMethod_HeadBy<ExperimentalWithCallbackMethod_TailBy<ExperimentalWithCallbackMethod_Ungroup<ExperimentalWithCallbackMethod_MergeTables<ExperimentalWithCallbackMethod_CrossJoinTables<ExperimentalWithCallbackMethod_NaturalJoinTables<ExperimentalWithCallbackMethod_ExactJoinTables<ExperimentalWithCallbackMethod_LeftJoinTables<ExperimentalWithCallbackMethod_AsOfJoinTables<ExperimentalWithCallbackMethod_ComboAggregate<ExperimentalWithCallbackMethod_Snapshot<ExperimentalWithCallbackMethod_Flatten<ExperimentalWithCallbackMethod_RunChartDownsample<ExperimentalWithCallbackMethod_Batch<ExperimentalWithCallbackMethod_ExportedTableUpdates<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GetExportedTableCreationResponse<ExperimentalWithCallbackMethod_FetchTable<ExperimentalWithCallbackMethod_FetchPandasTable<ExperimentalWithCallbackMethod_FetchTableMap<ExperimentalWithCallbackMethod_EmptyTable<ExperimentalWithCallbackMethod_TimeTable<ExperimentalWithCallbackMethod_DropColumns<ExperimentalWithCallbackMethod_Update<ExperimentalWithCallbackMethod_LazyUpdate<ExperimentalWithCallbackMethod_View<ExperimentalWithCallbackMethod_UpdateView<ExperimentalWithCallbackMethod_Select<ExperimentalWithCallbackMethod_SelectDistinct<ExperimentalWithCallbackMethod_Filter<ExperimentalWithCallbackMethod_UnstructuredFilter<ExperimentalWithCallbackMethod_Sort<ExperimentalWithCallbackMethod_Head<ExperimentalWithCallbackMethod_Tail<ExperimentalWithCallbackMethod_HeadBy<ExperimentalWithCallbackMethod_TailBy<ExperimentalWithCallbackMethod_Ungroup<ExperimentalWithCallbackMethod_MergeTables<ExperimentalWithCallbackMethod_CrossJoinTables<ExperimentalWithCallbackMethod_NaturalJoinTables<ExperimentalWithCallbackMethod_ExactJoinTables<ExperimentalWithCallbackMethod_LeftJoinTables<ExperimentalWithCallbackMethod_AsOfJoinTables<ExperimentalWithCallbackMethod_ComboAggregate<ExperimentalWithCallbackMethod_Snapshot<ExperimentalWithCallbackMethod_Flatten<ExperimentalWithCallbackMethod_RunChartDownsample<ExperimentalWithCallbackMethod_Batch<ExperimentalWithCallbackMethod_ExportedTableUpdates<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetExportedTableCreationResponse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetExportedTableCreationResponse() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetExportedTableCreationResponse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExportedTableCreationResponse(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::Ticket* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FetchTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FetchTable() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_FetchTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FetchPandasTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FetchPandasTable() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_FetchPandasTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchPandasTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FetchTableMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FetchTableMap() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_FetchTableMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTableMap(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EmptyTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EmptyTable() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_EmptyTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmptyTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TimeTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TimeTable() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_TimeTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimeTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DropColumns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DropColumns() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_DropColumns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropColumns(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Update() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LazyUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LazyUpdate() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_LazyUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LazyUpdate(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_View : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_View() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_View() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status View(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateView : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateView() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_UpdateView() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateView(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Select : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Select() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_Select() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Select(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SelectDistinct : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SelectDistinct() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_SelectDistinct() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectDistinct(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Filter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Filter() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_Filter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Filter(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnstructuredFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnstructuredFilter() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_UnstructuredFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnstructuredFilter(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Sort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Sort() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_Sort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sort(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Head : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Head() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_Head() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Head(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Tail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Tail() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_Tail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tail(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_HeadBy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_HeadBy() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_HeadBy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HeadBy(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TailBy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TailBy() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_TailBy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TailBy(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Ungroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Ungroup() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_Ungroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ungroup(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MergeTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_MergeTables() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_MergeTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MergeTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CrossJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CrossJoinTables() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_CrossJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CrossJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NaturalJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NaturalJoinTables() {
      ::grpc::Service::MarkMethodGeneric(23);
    }
    ~WithGenericMethod_NaturalJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NaturalJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExactJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExactJoinTables() {
      ::grpc::Service::MarkMethodGeneric(24);
    }
    ~WithGenericMethod_ExactJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExactJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LeftJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LeftJoinTables() {
      ::grpc::Service::MarkMethodGeneric(25);
    }
    ~WithGenericMethod_LeftJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AsOfJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AsOfJoinTables() {
      ::grpc::Service::MarkMethodGeneric(26);
    }
    ~WithGenericMethod_AsOfJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AsOfJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ComboAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ComboAggregate() {
      ::grpc::Service::MarkMethodGeneric(27);
    }
    ~WithGenericMethod_ComboAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ComboAggregate(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Snapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Snapshot() {
      ::grpc::Service::MarkMethodGeneric(28);
    }
    ~WithGenericMethod_Snapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Snapshot(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Flatten : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Flatten() {
      ::grpc::Service::MarkMethodGeneric(29);
    }
    ~WithGenericMethod_Flatten() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Flatten(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RunChartDownsample : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RunChartDownsample() {
      ::grpc::Service::MarkMethodGeneric(30);
    }
    ~WithGenericMethod_RunChartDownsample() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunChartDownsample(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Batch() {
      ::grpc::Service::MarkMethodGeneric(31);
    }
    ~WithGenericMethod_Batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Batch(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExportedTableUpdates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExportedTableUpdates() {
      ::grpc::Service::MarkMethodGeneric(32);
    }
    ~WithGenericMethod_ExportedTableUpdates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportedTableUpdates(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetExportedTableCreationResponse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetExportedTableCreationResponse() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetExportedTableCreationResponse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExportedTableCreationResponse(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::Ticket* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExportedTableCreationResponse(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FetchTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FetchTable() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_FetchTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchTable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FetchPandasTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FetchPandasTable() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_FetchPandasTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchPandasTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchPandasTable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FetchTableMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FetchTableMap() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_FetchTableMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTableMap(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFetchTableMap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EmptyTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EmptyTable() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_EmptyTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmptyTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEmptyTable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TimeTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TimeTable() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_TimeTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimeTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTimeTable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DropColumns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DropColumns() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_DropColumns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropColumns(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDropColumns(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Update() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LazyUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LazyUpdate() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_LazyUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LazyUpdate(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLazyUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_View : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_View() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_View() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status View(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestView(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateView : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateView() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_UpdateView() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateView(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateView(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Select : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Select() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_Select() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Select(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSelect(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SelectDistinct : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SelectDistinct() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_SelectDistinct() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectDistinct(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSelectDistinct(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Filter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Filter() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_Filter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Filter(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFilter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnstructuredFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnstructuredFilter() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_UnstructuredFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnstructuredFilter(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnstructuredFilter(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Sort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Sort() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_Sort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sort(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSort(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Head : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Head() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_Head() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Head(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHead(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Tail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Tail() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_Tail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tail(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTail(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_HeadBy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_HeadBy() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_HeadBy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HeadBy(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestHeadBy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TailBy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TailBy() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_TailBy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TailBy(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTailBy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Ungroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Ungroup() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_Ungroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ungroup(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUngroup(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MergeTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_MergeTables() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_MergeTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MergeTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMergeTables(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CrossJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CrossJoinTables() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_CrossJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CrossJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCrossJoinTables(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NaturalJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NaturalJoinTables() {
      ::grpc::Service::MarkMethodRaw(23);
    }
    ~WithRawMethod_NaturalJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NaturalJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNaturalJoinTables(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(23, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExactJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExactJoinTables() {
      ::grpc::Service::MarkMethodRaw(24);
    }
    ~WithRawMethod_ExactJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExactJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExactJoinTables(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(24, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LeftJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LeftJoinTables() {
      ::grpc::Service::MarkMethodRaw(25);
    }
    ~WithRawMethod_LeftJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeftJoinTables(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(25, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AsOfJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AsOfJoinTables() {
      ::grpc::Service::MarkMethodRaw(26);
    }
    ~WithRawMethod_AsOfJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AsOfJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAsOfJoinTables(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(26, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ComboAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ComboAggregate() {
      ::grpc::Service::MarkMethodRaw(27);
    }
    ~WithRawMethod_ComboAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ComboAggregate(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestComboAggregate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(27, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Snapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Snapshot() {
      ::grpc::Service::MarkMethodRaw(28);
    }
    ~WithRawMethod_Snapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Snapshot(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSnapshot(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(28, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Flatten : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Flatten() {
      ::grpc::Service::MarkMethodRaw(29);
    }
    ~WithRawMethod_Flatten() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Flatten(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFlatten(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(29, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RunChartDownsample : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RunChartDownsample() {
      ::grpc::Service::MarkMethodRaw(30);
    }
    ~WithRawMethod_RunChartDownsample() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunChartDownsample(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRunChartDownsample(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(30, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Batch() {
      ::grpc::Service::MarkMethodRaw(31);
    }
    ~WithRawMethod_Batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Batch(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBatch(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(31, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExportedTableUpdates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExportedTableUpdates() {
      ::grpc::Service::MarkMethodRaw(32);
    }
    ~WithRawMethod_ExportedTableUpdates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportedTableUpdates(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExportedTableUpdates(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(32, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetExportedTableCreationResponse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetExportedTableCreationResponse() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetExportedTableCreationResponse(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetExportedTableCreationResponse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExportedTableCreationResponse(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::Ticket* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetExportedTableCreationResponse(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetExportedTableCreationResponse(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FetchTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FetchTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FetchTable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FetchTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchTable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FetchPandasTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FetchPandasTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FetchPandasTable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FetchPandasTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchPandasTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchPandasTable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchPandasTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_FetchTableMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_FetchTableMap() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FetchTableMap(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_FetchTableMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FetchTableMap(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* FetchTableMap(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* FetchTableMap(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_EmptyTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_EmptyTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EmptyTable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_EmptyTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EmptyTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* EmptyTable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* EmptyTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TimeTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TimeTable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TimeTable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TimeTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TimeTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TimeTable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TimeTable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DropColumns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DropColumns() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DropColumns(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DropColumns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DropColumns(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DropColumns(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DropColumns(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Update() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Update(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Update(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Update(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LazyUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LazyUpdate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LazyUpdate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LazyUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LazyUpdate(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LazyUpdate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LazyUpdate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_View : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_View() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->View(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_View() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status View(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* View(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* View(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateView : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateView() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UpdateView(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateView() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateView(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UpdateView(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UpdateView(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Select : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Select() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Select(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Select() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Select(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Select(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Select(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SelectDistinct : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SelectDistinct() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SelectDistinct(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SelectDistinct() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SelectDistinct(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SelectDistinct(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SelectDistinct(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Filter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Filter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Filter(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Filter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Filter(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Filter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Filter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UnstructuredFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UnstructuredFilter() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnstructuredFilter(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_UnstructuredFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnstructuredFilter(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* UnstructuredFilter(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* UnstructuredFilter(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Sort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Sort() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Sort(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Sort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Sort(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Sort(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Sort(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Head : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Head() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Head(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Head() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Head(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Head(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Head(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Tail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Tail() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Tail(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Tail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tail(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Tail(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Tail(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_HeadBy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_HeadBy() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->HeadBy(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_HeadBy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status HeadBy(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* HeadBy(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* HeadBy(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_TailBy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_TailBy() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TailBy(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_TailBy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TailBy(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* TailBy(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* TailBy(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Ungroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Ungroup() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Ungroup(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Ungroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ungroup(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Ungroup(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Ungroup(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_MergeTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_MergeTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->MergeTables(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_MergeTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MergeTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* MergeTables(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* MergeTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CrossJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CrossJoinTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CrossJoinTables(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CrossJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CrossJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CrossJoinTables(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CrossJoinTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NaturalJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_NaturalJoinTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(23,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NaturalJoinTables(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_NaturalJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NaturalJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NaturalJoinTables(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NaturalJoinTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ExactJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ExactJoinTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(24,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExactJoinTables(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ExactJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExactJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExactJoinTables(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExactJoinTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LeftJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LeftJoinTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(25,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LeftJoinTables(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LeftJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeftJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeftJoinTables(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeftJoinTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AsOfJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AsOfJoinTables() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(26,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AsOfJoinTables(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_AsOfJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AsOfJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* AsOfJoinTables(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* AsOfJoinTables(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ComboAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ComboAggregate() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(27,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ComboAggregate(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ComboAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ComboAggregate(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ComboAggregate(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ComboAggregate(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Snapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Snapshot() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(28,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Snapshot(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Snapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Snapshot(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Snapshot(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Snapshot(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Flatten : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Flatten() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(29,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Flatten(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Flatten() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Flatten(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Flatten(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Flatten(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RunChartDownsample : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RunChartDownsample() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(30,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RunChartDownsample(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_RunChartDownsample() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RunChartDownsample(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* RunChartDownsample(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* RunChartDownsample(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Batch() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(31,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->Batch(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_Batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Batch(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* Batch(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* Batch(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ExportedTableUpdates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ExportedTableUpdates() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(32,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->ExportedTableUpdates(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_ExportedTableUpdates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExportedTableUpdates(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* ExportedTableUpdates(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* ExportedTableUpdates(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetExportedTableCreationResponse : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetExportedTableCreationResponse() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::Ticket, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::Ticket, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedGetExportedTableCreationResponse(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetExportedTableCreationResponse() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetExportedTableCreationResponse(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::Ticket* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetExportedTableCreationResponse(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::Ticket,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FetchTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FetchTable() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::FetchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::FetchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedFetchTable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FetchTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FetchTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFetchTable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::FetchTableRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FetchPandasTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FetchPandasTable() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedFetchPandasTable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FetchPandasTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FetchPandasTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFetchPandasTable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::FetchPandasTableRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FetchTableMap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FetchTableMap() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>* streamer) {
                       return this->StreamedFetchTableMap(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FetchTableMap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FetchTableMap(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::FetchTableMapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFetchTableMap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::FetchTableMapRequest,::io::deephaven::proto::backplane::grpc::FetchTableMapResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EmptyTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EmptyTable() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::EmptyTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::EmptyTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedEmptyTable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EmptyTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EmptyTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEmptyTable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::EmptyTableRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TimeTable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TimeTable() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::TimeTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::TimeTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedTimeTable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TimeTable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TimeTable(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::TimeTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTimeTable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::TimeTableRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DropColumns : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DropColumns() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::DropColumnsRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::DropColumnsRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedDropColumns(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DropColumns() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DropColumns(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDropColumns(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::DropColumnsRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Update() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LazyUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LazyUpdate() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedLazyUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LazyUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LazyUpdate(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLazyUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_View : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_View() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedView(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_View() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status View(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedView(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateView : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateView() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedUpdateView(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UpdateView() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateView(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateView(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Select : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Select() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedSelect(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Select() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Select(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSelect(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SelectDistinct : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SelectDistinct() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedSelectDistinct(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SelectDistinct() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SelectDistinct(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSelectDistinct(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Filter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Filter() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::FilterTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::FilterTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedFilter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Filter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Filter(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFilter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::FilterTableRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnstructuredFilter : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnstructuredFilter() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedUnstructuredFilter(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnstructuredFilter() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnstructuredFilter(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnstructuredFilter(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Sort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Sort() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::SortTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::SortTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedSort(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Sort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Sort(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SortTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSort(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::SortTableRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Head : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Head() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedHead(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Head() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Head(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHead(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Tail : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Tail() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedTail(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Tail() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Tail(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTail(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_HeadBy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_HeadBy() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedHeadBy(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_HeadBy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status HeadBy(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedHeadBy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TailBy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TailBy() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedTailBy(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TailBy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TailBy(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTailBy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Ungroup : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Ungroup() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::UngroupRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::UngroupRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedUngroup(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Ungroup() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Ungroup(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::UngroupRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUngroup(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::UngroupRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MergeTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_MergeTables() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::MergeTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::MergeTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedMergeTables(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_MergeTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MergeTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMergeTables(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::MergeTablesRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CrossJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CrossJoinTables() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedCrossJoinTables(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CrossJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CrossJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCrossJoinTables(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NaturalJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NaturalJoinTables() {
      ::grpc::Service::MarkMethodStreamed(23,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedNaturalJoinTables(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NaturalJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NaturalJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNaturalJoinTables(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExactJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExactJoinTables() {
      ::grpc::Service::MarkMethodStreamed(24,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedExactJoinTables(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExactJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExactJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExactJoinTables(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LeftJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LeftJoinTables() {
      ::grpc::Service::MarkMethodStreamed(25,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedLeftJoinTables(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LeftJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LeftJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLeftJoinTables(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AsOfJoinTables : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AsOfJoinTables() {
      ::grpc::Service::MarkMethodStreamed(26,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedAsOfJoinTables(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AsOfJoinTables() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AsOfJoinTables(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAsOfJoinTables(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ComboAggregate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ComboAggregate() {
      ::grpc::Service::MarkMethodStreamed(27,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedComboAggregate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ComboAggregate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ComboAggregate(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedComboAggregate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Snapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Snapshot() {
      ::grpc::Service::MarkMethodStreamed(28,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedSnapshot(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Snapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Snapshot(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSnapshot(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Flatten : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Flatten() {
      ::grpc::Service::MarkMethodStreamed(29,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::FlattenRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::FlattenRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedFlatten(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Flatten() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Flatten(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::FlattenRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFlatten(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::FlattenRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RunChartDownsample : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RunChartDownsample() {
      ::grpc::Service::MarkMethodStreamed(30,
        new ::grpc::internal::StreamedUnaryHandler<
          ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedRunChartDownsample(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RunChartDownsample() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RunChartDownsample(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* /*request*/, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRunChartDownsample(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetExportedTableCreationResponse<WithStreamedUnaryMethod_FetchTable<WithStreamedUnaryMethod_FetchPandasTable<WithStreamedUnaryMethod_FetchTableMap<WithStreamedUnaryMethod_EmptyTable<WithStreamedUnaryMethod_TimeTable<WithStreamedUnaryMethod_DropColumns<WithStreamedUnaryMethod_Update<WithStreamedUnaryMethod_LazyUpdate<WithStreamedUnaryMethod_View<WithStreamedUnaryMethod_UpdateView<WithStreamedUnaryMethod_Select<WithStreamedUnaryMethod_SelectDistinct<WithStreamedUnaryMethod_Filter<WithStreamedUnaryMethod_UnstructuredFilter<WithStreamedUnaryMethod_Sort<WithStreamedUnaryMethod_Head<WithStreamedUnaryMethod_Tail<WithStreamedUnaryMethod_HeadBy<WithStreamedUnaryMethod_TailBy<WithStreamedUnaryMethod_Ungroup<WithStreamedUnaryMethod_MergeTables<WithStreamedUnaryMethod_CrossJoinTables<WithStreamedUnaryMethod_NaturalJoinTables<WithStreamedUnaryMethod_ExactJoinTables<WithStreamedUnaryMethod_LeftJoinTables<WithStreamedUnaryMethod_AsOfJoinTables<WithStreamedUnaryMethod_ComboAggregate<WithStreamedUnaryMethod_Snapshot<WithStreamedUnaryMethod_Flatten<WithStreamedUnaryMethod_RunChartDownsample<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Batch : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_Batch() {
      ::grpc::Service::MarkMethodStreamed(31,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::io::deephaven::proto::backplane::grpc::BatchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::io::deephaven::proto::backplane::grpc::BatchTableRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* streamer) {
                       return this->StreamedBatch(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_Batch() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Batch(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::BatchTableRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedBatch(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::io::deephaven::proto::backplane::grpc::BatchTableRequest,::io::deephaven::proto::backplane::grpc::ExportedTableCreationResponse>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_ExportedTableUpdates : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_ExportedTableUpdates() {
      ::grpc::Service::MarkMethodStreamed(32,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest, ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* streamer) {
                       return this->StreamedExportedTableUpdates(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_ExportedTableUpdates() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExportedTableUpdates(::grpc::ServerContext* /*context*/, const ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest* /*request*/, ::grpc::ServerWriter< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedExportedTableUpdates(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::io::deephaven::proto::backplane::grpc::ExportedTableUpdatesRequest,::io::deephaven::proto::backplane::grpc::ExportedTableUpdateMessage>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Batch<WithSplitStreamingMethod_ExportedTableUpdates<Service > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetExportedTableCreationResponse<WithStreamedUnaryMethod_FetchTable<WithStreamedUnaryMethod_FetchPandasTable<WithStreamedUnaryMethod_FetchTableMap<WithStreamedUnaryMethod_EmptyTable<WithStreamedUnaryMethod_TimeTable<WithStreamedUnaryMethod_DropColumns<WithStreamedUnaryMethod_Update<WithStreamedUnaryMethod_LazyUpdate<WithStreamedUnaryMethod_View<WithStreamedUnaryMethod_UpdateView<WithStreamedUnaryMethod_Select<WithStreamedUnaryMethod_SelectDistinct<WithStreamedUnaryMethod_Filter<WithStreamedUnaryMethod_UnstructuredFilter<WithStreamedUnaryMethod_Sort<WithStreamedUnaryMethod_Head<WithStreamedUnaryMethod_Tail<WithStreamedUnaryMethod_HeadBy<WithStreamedUnaryMethod_TailBy<WithStreamedUnaryMethod_Ungroup<WithStreamedUnaryMethod_MergeTables<WithStreamedUnaryMethod_CrossJoinTables<WithStreamedUnaryMethod_NaturalJoinTables<WithStreamedUnaryMethod_ExactJoinTables<WithStreamedUnaryMethod_LeftJoinTables<WithStreamedUnaryMethod_AsOfJoinTables<WithStreamedUnaryMethod_ComboAggregate<WithStreamedUnaryMethod_Snapshot<WithStreamedUnaryMethod_Flatten<WithStreamedUnaryMethod_RunChartDownsample<WithSplitStreamingMethod_Batch<WithSplitStreamingMethod_ExportedTableUpdates<Service > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace grpc
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io


#endif  // GRPC_deephaven_2fproto_2ftable_2eproto__INCLUDED
