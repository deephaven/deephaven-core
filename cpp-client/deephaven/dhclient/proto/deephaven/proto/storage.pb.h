// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: deephaven/proto/storage.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2fstorage_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2fstorage_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_deephaven_2fproto_2fstorage_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_deephaven_2fproto_2fstorage_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_deephaven_2fproto_2fstorage_2eproto;
namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace grpc {
class CreateDirectoryRequest;
struct CreateDirectoryRequestDefaultTypeInternal;
extern CreateDirectoryRequestDefaultTypeInternal _CreateDirectoryRequest_default_instance_;
class CreateDirectoryResponse;
struct CreateDirectoryResponseDefaultTypeInternal;
extern CreateDirectoryResponseDefaultTypeInternal _CreateDirectoryResponse_default_instance_;
class DeleteItemRequest;
struct DeleteItemRequestDefaultTypeInternal;
extern DeleteItemRequestDefaultTypeInternal _DeleteItemRequest_default_instance_;
class DeleteItemResponse;
struct DeleteItemResponseDefaultTypeInternal;
extern DeleteItemResponseDefaultTypeInternal _DeleteItemResponse_default_instance_;
class FetchFileRequest;
struct FetchFileRequestDefaultTypeInternal;
extern FetchFileRequestDefaultTypeInternal _FetchFileRequest_default_instance_;
class FetchFileResponse;
struct FetchFileResponseDefaultTypeInternal;
extern FetchFileResponseDefaultTypeInternal _FetchFileResponse_default_instance_;
class ItemInfo;
struct ItemInfoDefaultTypeInternal;
extern ItemInfoDefaultTypeInternal _ItemInfo_default_instance_;
class ListItemsRequest;
struct ListItemsRequestDefaultTypeInternal;
extern ListItemsRequestDefaultTypeInternal _ListItemsRequest_default_instance_;
class ListItemsResponse;
struct ListItemsResponseDefaultTypeInternal;
extern ListItemsResponseDefaultTypeInternal _ListItemsResponse_default_instance_;
class MoveItemRequest;
struct MoveItemRequestDefaultTypeInternal;
extern MoveItemRequestDefaultTypeInternal _MoveItemRequest_default_instance_;
class MoveItemResponse;
struct MoveItemResponseDefaultTypeInternal;
extern MoveItemResponseDefaultTypeInternal _MoveItemResponse_default_instance_;
class SaveFileRequest;
struct SaveFileRequestDefaultTypeInternal;
extern SaveFileRequestDefaultTypeInternal _SaveFileRequest_default_instance_;
class SaveFileResponse;
struct SaveFileResponseDefaultTypeInternal;
extern SaveFileResponseDefaultTypeInternal _SaveFileResponse_default_instance_;
}  // namespace grpc
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace grpc {
enum ItemType : int {
  UNKNOWN = 0,
  DIRECTORY = 1,
  FILE = 2,
  ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ItemType_IsValid(int value);
extern const uint32_t ItemType_internal_data_[];
constexpr ItemType ItemType_MIN = static_cast<ItemType>(0);
constexpr ItemType ItemType_MAX = static_cast<ItemType>(2);
constexpr int ItemType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
ItemType_descriptor();
template <typename T>
const std::string& ItemType_Name(T value) {
  static_assert(std::is_same<T, ItemType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ItemType_Name().");
  return ItemType_Name(static_cast<ItemType>(value));
}
template <>
inline const std::string& ItemType_Name(ItemType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ItemType_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool ItemType_Parse(absl::string_view name, ItemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ItemType>(
      ItemType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SaveFileResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SaveFileResponse) */ {
 public:
  inline SaveFileResponse() : SaveFileResponse(nullptr) {}
  ~SaveFileResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SaveFileResponse(::google::protobuf::internal::ConstantInitialized);

  inline SaveFileResponse(const SaveFileResponse& from)
      : SaveFileResponse(nullptr, from) {}
  SaveFileResponse(SaveFileResponse&& from) noexcept
    : SaveFileResponse() {
    *this = ::std::move(from);
  }

  inline SaveFileResponse& operator=(const SaveFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveFileResponse& operator=(SaveFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveFileResponse* internal_default_instance() {
    return reinterpret_cast<const SaveFileResponse*>(
               &_SaveFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SaveFileResponse& a, SaveFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveFileResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveFileResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveFileResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SaveFileResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SaveFileResponse& from) {
    SaveFileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SaveFileResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SaveFileResponse";
  }
  protected:
  explicit SaveFileResponse(::google::protobuf::Arena* arena);
  SaveFileResponse(::google::protobuf::Arena* arena, const SaveFileResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEtagFieldNumber = 1,
  };
  // optional string etag = 1;
  bool has_etag() const;
  void clear_etag() ;
  const std::string& etag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_etag(Arg_&& arg, Args_... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* value);

  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(
      const std::string& value);
  std::string* _internal_mutable_etag();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SaveFileResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      63, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr etag_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};// -------------------------------------------------------------------

class SaveFileRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SaveFileRequest) */ {
 public:
  inline SaveFileRequest() : SaveFileRequest(nullptr) {}
  ~SaveFileRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SaveFileRequest(::google::protobuf::internal::ConstantInitialized);

  inline SaveFileRequest(const SaveFileRequest& from)
      : SaveFileRequest(nullptr, from) {}
  SaveFileRequest(SaveFileRequest&& from) noexcept
    : SaveFileRequest() {
    *this = ::std::move(from);
  }

  inline SaveFileRequest& operator=(const SaveFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveFileRequest& operator=(SaveFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveFileRequest* internal_default_instance() {
    return reinterpret_cast<const SaveFileRequest*>(
               &_SaveFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SaveFileRequest& a, SaveFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveFileRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveFileRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveFileRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SaveFileRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SaveFileRequest& from) {
    SaveFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SaveFileRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SaveFileRequest";
  }
  protected:
  explicit SaveFileRequest(::google::protobuf::Arena* arena);
  SaveFileRequest(::google::protobuf::Arena* arena, const SaveFileRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kContentsFieldNumber = 3,
    kAllowOverwriteFieldNumber = 1,
  };
  // string path = 2;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // bytes contents = 3;
  void clear_contents() ;
  const std::string& contents() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contents(Arg_&& arg, Args_... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* value);

  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(
      const std::string& value);
  std::string* _internal_mutable_contents();

  public:
  // bool allow_overwrite = 1;
  void clear_allow_overwrite() ;
  bool allow_overwrite() const;
  void set_allow_overwrite(bool value);

  private:
  bool _internal_allow_overwrite() const;
  void _internal_set_allow_overwrite(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SaveFileRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr contents_;
    bool allow_overwrite_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};// -------------------------------------------------------------------

class MoveItemResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MoveItemResponse) */ {
 public:
  inline MoveItemResponse() : MoveItemResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveItemResponse(::google::protobuf::internal::ConstantInitialized);

  inline MoveItemResponse(const MoveItemResponse& from)
      : MoveItemResponse(nullptr, from) {}
  MoveItemResponse(MoveItemResponse&& from) noexcept
    : MoveItemResponse() {
    *this = ::std::move(from);
  }

  inline MoveItemResponse& operator=(const MoveItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveItemResponse& operator=(MoveItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveItemResponse* internal_default_instance() {
    return reinterpret_cast<const MoveItemResponse*>(
               &_MoveItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MoveItemResponse& a, MoveItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveItemResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveItemResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveItemResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MoveItemResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MoveItemResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MoveItemResponse";
  }
  protected:
  explicit MoveItemResponse(::google::protobuf::Arena* arena);
  MoveItemResponse(::google::protobuf::Arena* arena, const MoveItemResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MoveItemResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};// -------------------------------------------------------------------

class MoveItemRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MoveItemRequest) */ {
 public:
  inline MoveItemRequest() : MoveItemRequest(nullptr) {}
  ~MoveItemRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MoveItemRequest(::google::protobuf::internal::ConstantInitialized);

  inline MoveItemRequest(const MoveItemRequest& from)
      : MoveItemRequest(nullptr, from) {}
  MoveItemRequest(MoveItemRequest&& from) noexcept
    : MoveItemRequest() {
    *this = ::std::move(from);
  }

  inline MoveItemRequest& operator=(const MoveItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveItemRequest& operator=(MoveItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveItemRequest* internal_default_instance() {
    return reinterpret_cast<const MoveItemRequest*>(
               &_MoveItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MoveItemRequest& a, MoveItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveItemRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveItemRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveItemRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MoveItemRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MoveItemRequest& from) {
    MoveItemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MoveItemRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MoveItemRequest";
  }
  protected:
  explicit MoveItemRequest(::google::protobuf::Arena* arena);
  MoveItemRequest(::google::protobuf::Arena* arena, const MoveItemRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldPathFieldNumber = 1,
    kNewPathFieldNumber = 2,
    kAllowOverwriteFieldNumber = 3,
  };
  // string old_path = 1;
  void clear_old_path() ;
  const std::string& old_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_old_path(Arg_&& arg, Args_... args);
  std::string* mutable_old_path();
  PROTOBUF_NODISCARD std::string* release_old_path();
  void set_allocated_old_path(std::string* value);

  private:
  const std::string& _internal_old_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_path(
      const std::string& value);
  std::string* _internal_mutable_old_path();

  public:
  // string new_path = 2;
  void clear_new_path() ;
  const std::string& new_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_path(Arg_&& arg, Args_... args);
  std::string* mutable_new_path();
  PROTOBUF_NODISCARD std::string* release_new_path();
  void set_allocated_new_path(std::string* value);

  private:
  const std::string& _internal_new_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_path(
      const std::string& value);
  std::string* _internal_mutable_new_path();

  public:
  // bool allow_overwrite = 3;
  void clear_allow_overwrite() ;
  bool allow_overwrite() const;
  void set_allow_overwrite(bool value);

  private:
  bool _internal_allow_overwrite() const;
  void _internal_set_allow_overwrite(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MoveItemRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      74, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr old_path_;
    ::google::protobuf::internal::ArenaStringPtr new_path_;
    bool allow_overwrite_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};// -------------------------------------------------------------------

class ListItemsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ListItemsRequest) */ {
 public:
  inline ListItemsRequest() : ListItemsRequest(nullptr) {}
  ~ListItemsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListItemsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ListItemsRequest(const ListItemsRequest& from)
      : ListItemsRequest(nullptr, from) {}
  ListItemsRequest(ListItemsRequest&& from) noexcept
    : ListItemsRequest() {
    *this = ::std::move(from);
  }

  inline ListItemsRequest& operator=(const ListItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListItemsRequest& operator=(ListItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListItemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListItemsRequest* internal_default_instance() {
    return reinterpret_cast<const ListItemsRequest*>(
               &_ListItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ListItemsRequest& a, ListItemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListItemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListItemsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListItemsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListItemsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListItemsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListItemsRequest& from) {
    ListItemsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListItemsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ListItemsRequest";
  }
  protected:
  explicit ListItemsRequest(::google::protobuf::Arena* arena);
  ListItemsRequest(::google::protobuf::Arena* arena, const ListItemsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kFilterGlobFieldNumber = 4,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // optional string filter_glob = 4;
  bool has_filter_glob() const;
  void clear_filter_glob() ;
  const std::string& filter_glob() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_filter_glob(Arg_&& arg, Args_... args);
  std::string* mutable_filter_glob();
  PROTOBUF_NODISCARD std::string* release_filter_glob();
  void set_allocated_filter_glob(std::string* value);

  private:
  const std::string& _internal_filter_glob() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_glob(
      const std::string& value);
  std::string* _internal_mutable_filter_glob();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ListItemsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      74, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr filter_glob_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};// -------------------------------------------------------------------

class ItemInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ItemInfo) */ {
 public:
  inline ItemInfo() : ItemInfo(nullptr) {}
  ~ItemInfo() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ItemInfo(::google::protobuf::internal::ConstantInitialized);

  inline ItemInfo(const ItemInfo& from)
      : ItemInfo(nullptr, from) {}
  ItemInfo(ItemInfo&& from) noexcept
    : ItemInfo() {
    *this = ::std::move(from);
  }

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemInfo& operator=(ItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemInfo* internal_default_instance() {
    return reinterpret_cast<const ItemInfo*>(
               &_ItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ItemInfo& a, ItemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemInfo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemInfo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemInfo>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ItemInfo& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ItemInfo& from) {
    ItemInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ItemInfo* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ItemInfo";
  }
  protected:
  explicit ItemInfo(::google::protobuf::Arena* arena);
  ItemInfo(::google::protobuf::Arena* arena, const ItemInfo& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kEtagFieldNumber = 4,
    kSizeFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // optional string etag = 4;
  bool has_etag() const;
  void clear_etag() ;
  const std::string& etag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_etag(Arg_&& arg, Args_... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* value);

  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(
      const std::string& value);
  std::string* _internal_mutable_etag();

  public:
  // sint64 size = 3 [jstype = JS_STRING];
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // .io.deephaven.proto.backplane.grpc.ItemType type = 2;
  void clear_type() ;
  ::io::deephaven::proto::backplane::grpc::ItemType type() const;
  void set_type(::io::deephaven::proto::backplane::grpc::ItemType value);

  private:
  ::io::deephaven::proto::backplane::grpc::ItemType _internal_type() const;
  void _internal_set_type(::io::deephaven::proto::backplane::grpc::ItemType value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ItemInfo)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      59, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr etag_;
    ::int64_t size_;
    int type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};// -------------------------------------------------------------------

class FetchFileResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FetchFileResponse) */ {
 public:
  inline FetchFileResponse() : FetchFileResponse(nullptr) {}
  ~FetchFileResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FetchFileResponse(::google::protobuf::internal::ConstantInitialized);

  inline FetchFileResponse(const FetchFileResponse& from)
      : FetchFileResponse(nullptr, from) {}
  FetchFileResponse(FetchFileResponse&& from) noexcept
    : FetchFileResponse() {
    *this = ::std::move(from);
  }

  inline FetchFileResponse& operator=(const FetchFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchFileResponse& operator=(FetchFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchFileResponse* internal_default_instance() {
    return reinterpret_cast<const FetchFileResponse*>(
               &_FetchFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FetchFileResponse& a, FetchFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchFileResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchFileResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchFileResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FetchFileResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FetchFileResponse& from) {
    FetchFileResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FetchFileResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FetchFileResponse";
  }
  protected:
  explicit FetchFileResponse(::google::protobuf::Arena* arena);
  FetchFileResponse(::google::protobuf::Arena* arena, const FetchFileResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentsFieldNumber = 1,
    kEtagFieldNumber = 2,
  };
  // bytes contents = 1;
  void clear_contents() ;
  const std::string& contents() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_contents(Arg_&& arg, Args_... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* value);

  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(
      const std::string& value);
  std::string* _internal_mutable_contents();

  public:
  // optional string etag = 2;
  bool has_etag() const;
  void clear_etag() ;
  const std::string& etag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_etag(Arg_&& arg, Args_... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* value);

  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(
      const std::string& value);
  std::string* _internal_mutable_etag();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FetchFileResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr contents_;
    ::google::protobuf::internal::ArenaStringPtr etag_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};// -------------------------------------------------------------------

class FetchFileRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FetchFileRequest) */ {
 public:
  inline FetchFileRequest() : FetchFileRequest(nullptr) {}
  ~FetchFileRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FetchFileRequest(::google::protobuf::internal::ConstantInitialized);

  inline FetchFileRequest(const FetchFileRequest& from)
      : FetchFileRequest(nullptr, from) {}
  FetchFileRequest(FetchFileRequest&& from) noexcept
    : FetchFileRequest() {
    *this = ::std::move(from);
  }

  inline FetchFileRequest& operator=(const FetchFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchFileRequest& operator=(FetchFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchFileRequest* internal_default_instance() {
    return reinterpret_cast<const FetchFileRequest*>(
               &_FetchFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FetchFileRequest& a, FetchFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchFileRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchFileRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchFileRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FetchFileRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FetchFileRequest& from) {
    FetchFileRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FetchFileRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FetchFileRequest";
  }
  protected:
  explicit FetchFileRequest(::google::protobuf::Arena* arena);
  FetchFileRequest(::google::protobuf::Arena* arena, const FetchFileRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kEtagFieldNumber = 2,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // optional string etag = 2;
  bool has_etag() const;
  void clear_etag() ;
  const std::string& etag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_etag(Arg_&& arg, Args_... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* value);

  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(
      const std::string& value);
  std::string* _internal_mutable_etag();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FetchFileRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      67, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr path_;
    ::google::protobuf::internal::ArenaStringPtr etag_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};// -------------------------------------------------------------------

class DeleteItemResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.DeleteItemResponse) */ {
 public:
  inline DeleteItemResponse() : DeleteItemResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteItemResponse(::google::protobuf::internal::ConstantInitialized);

  inline DeleteItemResponse(const DeleteItemResponse& from)
      : DeleteItemResponse(nullptr, from) {}
  DeleteItemResponse(DeleteItemResponse&& from) noexcept
    : DeleteItemResponse() {
    *this = ::std::move(from);
  }

  inline DeleteItemResponse& operator=(const DeleteItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteItemResponse& operator=(DeleteItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteItemResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteItemResponse*>(
               &_DeleteItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeleteItemResponse& a, DeleteItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteItemResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteItemResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteItemResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteItemResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteItemResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.DeleteItemResponse";
  }
  protected:
  explicit DeleteItemResponse(::google::protobuf::Arena* arena);
  DeleteItemResponse(::google::protobuf::Arena* arena, const DeleteItemResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.DeleteItemResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};// -------------------------------------------------------------------

class DeleteItemRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.DeleteItemRequest) */ {
 public:
  inline DeleteItemRequest() : DeleteItemRequest(nullptr) {}
  ~DeleteItemRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DeleteItemRequest(::google::protobuf::internal::ConstantInitialized);

  inline DeleteItemRequest(const DeleteItemRequest& from)
      : DeleteItemRequest(nullptr, from) {}
  DeleteItemRequest(DeleteItemRequest&& from) noexcept
    : DeleteItemRequest() {
    *this = ::std::move(from);
  }

  inline DeleteItemRequest& operator=(const DeleteItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteItemRequest& operator=(DeleteItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteItemRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteItemRequest*>(
               &_DeleteItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeleteItemRequest& a, DeleteItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteItemRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteItemRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteItemRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DeleteItemRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DeleteItemRequest& from) {
    DeleteItemRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DeleteItemRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.DeleteItemRequest";
  }
  protected:
  explicit DeleteItemRequest(::google::protobuf::Arena* arena);
  DeleteItemRequest(::google::protobuf::Arena* arena, const DeleteItemRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.DeleteItemRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};// -------------------------------------------------------------------

class CreateDirectoryResponse final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateDirectoryResponse) */ {
 public:
  inline CreateDirectoryResponse() : CreateDirectoryResponse(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateDirectoryResponse(::google::protobuf::internal::ConstantInitialized);

  inline CreateDirectoryResponse(const CreateDirectoryResponse& from)
      : CreateDirectoryResponse(nullptr, from) {}
  CreateDirectoryResponse(CreateDirectoryResponse&& from) noexcept
    : CreateDirectoryResponse() {
    *this = ::std::move(from);
  }

  inline CreateDirectoryResponse& operator=(const CreateDirectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDirectoryResponse& operator=(CreateDirectoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDirectoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDirectoryResponse* internal_default_instance() {
    return reinterpret_cast<const CreateDirectoryResponse*>(
               &_CreateDirectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateDirectoryResponse& a, CreateDirectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDirectoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDirectoryResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDirectoryResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDirectoryResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateDirectoryResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateDirectoryResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateDirectoryResponse";
  }
  protected:
  explicit CreateDirectoryResponse(::google::protobuf::Arena* arena);
  CreateDirectoryResponse(::google::protobuf::Arena* arena, const CreateDirectoryResponse& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateDirectoryResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};// -------------------------------------------------------------------

class CreateDirectoryRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest) */ {
 public:
  inline CreateDirectoryRequest() : CreateDirectoryRequest(nullptr) {}
  ~CreateDirectoryRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateDirectoryRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateDirectoryRequest(const CreateDirectoryRequest& from)
      : CreateDirectoryRequest(nullptr, from) {}
  CreateDirectoryRequest(CreateDirectoryRequest&& from) noexcept
    : CreateDirectoryRequest() {
    *this = ::std::move(from);
  }

  inline CreateDirectoryRequest& operator=(const CreateDirectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDirectoryRequest& operator=(CreateDirectoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDirectoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDirectoryRequest* internal_default_instance() {
    return reinterpret_cast<const CreateDirectoryRequest*>(
               &_CreateDirectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateDirectoryRequest& a, CreateDirectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDirectoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDirectoryRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDirectoryRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDirectoryRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateDirectoryRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateDirectoryRequest& from) {
    CreateDirectoryRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateDirectoryRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateDirectoryRequest";
  }
  protected:
  explicit CreateDirectoryRequest(::google::protobuf::Arena* arena);
  CreateDirectoryRequest(::google::protobuf::Arena* arena, const CreateDirectoryRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path() ;
  const std::string& path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_path(Arg_&& arg, Args_... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* value);

  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(
      const std::string& value);
  std::string* _internal_mutable_path();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      69, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};// -------------------------------------------------------------------

class ListItemsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ListItemsResponse) */ {
 public:
  inline ListItemsResponse() : ListItemsResponse(nullptr) {}
  ~ListItemsResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ListItemsResponse(::google::protobuf::internal::ConstantInitialized);

  inline ListItemsResponse(const ListItemsResponse& from)
      : ListItemsResponse(nullptr, from) {}
  ListItemsResponse(ListItemsResponse&& from) noexcept
    : ListItemsResponse() {
    *this = ::std::move(from);
  }

  inline ListItemsResponse& operator=(const ListItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListItemsResponse& operator=(ListItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListItemsResponse* internal_default_instance() {
    return reinterpret_cast<const ListItemsResponse*>(
               &_ListItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ListItemsResponse& a, ListItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListItemsResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListItemsResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListItemsResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ListItemsResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ListItemsResponse& from) {
    ListItemsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ListItemsResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ListItemsResponse";
  }
  protected:
  explicit ListItemsResponse(::google::protobuf::Arena* arena);
  ListItemsResponse(::google::protobuf::Arena* arena, const ListItemsResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
    kCanonicalPathFieldNumber = 2,
  };
  // repeated .io.deephaven.proto.backplane.grpc.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;

  public:
  void clear_items() ;
  ::io::deephaven::proto::backplane::grpc::ItemInfo* mutable_items(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ItemInfo >*
      mutable_items();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::ItemInfo>& _internal_items() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::ItemInfo>* _internal_mutable_items();
  public:
  const ::io::deephaven::proto::backplane::grpc::ItemInfo& items(int index) const;
  ::io::deephaven::proto::backplane::grpc::ItemInfo* add_items();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ItemInfo >&
      items() const;
  // string canonical_path = 2;
  void clear_canonical_path() ;
  const std::string& canonical_path() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_canonical_path(Arg_&& arg, Args_... args);
  std::string* mutable_canonical_path();
  PROTOBUF_NODISCARD std::string* release_canonical_path();
  void set_allocated_canonical_path(std::string* value);

  private:
  const std::string& _internal_canonical_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_canonical_path(
      const std::string& value);
  std::string* _internal_mutable_canonical_path();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ListItemsResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      74, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ItemInfo > items_;
    ::google::protobuf::internal::ArenaStringPtr canonical_path_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// ListItemsRequest

// string path = 1;
inline void ListItemsRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& ListItemsRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ListItemsRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListItemsRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ListItemsRequest.path)
}
inline std::string* ListItemsRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ListItemsRequest.path)
  return _s;
}
inline const std::string& ListItemsRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void ListItemsRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* ListItemsRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* ListItemsRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ListItemsRequest.path)
  return _impl_.path_.Release();
}
inline void ListItemsRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ListItemsRequest.path)
}

// optional string filter_glob = 4;
inline bool ListItemsRequest::has_filter_glob() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ListItemsRequest::clear_filter_glob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filter_glob_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListItemsRequest::filter_glob() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ListItemsRequest.filter_glob)
  return _internal_filter_glob();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListItemsRequest::set_filter_glob(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filter_glob_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ListItemsRequest.filter_glob)
}
inline std::string* ListItemsRequest::mutable_filter_glob() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_filter_glob();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ListItemsRequest.filter_glob)
  return _s;
}
inline const std::string& ListItemsRequest::_internal_filter_glob() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filter_glob_.Get();
}
inline void ListItemsRequest::_internal_set_filter_glob(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.filter_glob_.Set(value, GetArena());
}
inline std::string* ListItemsRequest::_internal_mutable_filter_glob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.filter_glob_.Mutable( GetArena());
}
inline std::string* ListItemsRequest::release_filter_glob() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ListItemsRequest.filter_glob)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.filter_glob_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filter_glob_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ListItemsRequest::set_allocated_filter_glob(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.filter_glob_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.filter_glob_.IsDefault()) {
          _impl_.filter_glob_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ListItemsRequest.filter_glob)
}

// -------------------------------------------------------------------

// ItemInfo

// string path = 1;
inline void ItemInfo::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& ItemInfo::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ItemInfo.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ItemInfo::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ItemInfo.path)
}
inline std::string* ItemInfo::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ItemInfo.path)
  return _s;
}
inline const std::string& ItemInfo::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void ItemInfo::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* ItemInfo::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* ItemInfo::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ItemInfo.path)
  return _impl_.path_.Release();
}
inline void ItemInfo::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ItemInfo.path)
}

// .io.deephaven.proto.backplane.grpc.ItemType type = 2;
inline void ItemInfo::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::ItemType ItemInfo::type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ItemInfo.type)
  return _internal_type();
}
inline void ItemInfo::set_type(::io::deephaven::proto::backplane::grpc::ItemType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ItemInfo.type)
}
inline ::io::deephaven::proto::backplane::grpc::ItemType ItemInfo::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::ItemType>(_impl_.type_);
}
inline void ItemInfo::_internal_set_type(::io::deephaven::proto::backplane::grpc::ItemType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// sint64 size = 3 [jstype = JS_STRING];
inline void ItemInfo::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = ::int64_t{0};
}
inline ::int64_t ItemInfo::size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ItemInfo.size)
  return _internal_size();
}
inline void ItemInfo::set_size(::int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ItemInfo.size)
}
inline ::int64_t ItemInfo::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void ItemInfo::_internal_set_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_ = value;
}

// optional string etag = 4;
inline bool ItemInfo::has_etag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void ItemInfo::clear_etag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.etag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ItemInfo::etag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ItemInfo.etag)
  return _internal_etag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ItemInfo::set_etag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.etag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ItemInfo.etag)
}
inline std::string* ItemInfo::mutable_etag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ItemInfo.etag)
  return _s;
}
inline const std::string& ItemInfo::_internal_etag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.etag_.Get();
}
inline void ItemInfo::_internal_set_etag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.etag_.Set(value, GetArena());
}
inline std::string* ItemInfo::_internal_mutable_etag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.etag_.Mutable( GetArena());
}
inline std::string* ItemInfo::release_etag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ItemInfo.etag)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.etag_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.etag_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void ItemInfo::set_allocated_etag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.etag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.etag_.IsDefault()) {
          _impl_.etag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ItemInfo.etag)
}

// -------------------------------------------------------------------

// ListItemsResponse

// repeated .io.deephaven.proto.backplane.grpc.ItemInfo items = 1;
inline int ListItemsResponse::_internal_items_size() const {
  return _internal_items().size();
}
inline int ListItemsResponse::items_size() const {
  return _internal_items_size();
}
inline void ListItemsResponse::clear_items() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.items_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::ItemInfo* ListItemsResponse::mutable_items(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ListItemsResponse.items)
  return _internal_mutable_items()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::ItemInfo>* ListItemsResponse::mutable_items()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ListItemsResponse.items)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_items();
}
inline const ::io::deephaven::proto::backplane::grpc::ItemInfo& ListItemsResponse::items(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ListItemsResponse.items)
  return _internal_items().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::ItemInfo* ListItemsResponse::add_items() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::ItemInfo* _add = _internal_mutable_items()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ListItemsResponse.items)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::ItemInfo>& ListItemsResponse::items() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ListItemsResponse.items)
  return _internal_items();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::ItemInfo>&
ListItemsResponse::_internal_items() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.items_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::ItemInfo>*
ListItemsResponse::_internal_mutable_items() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.items_;
}

// string canonical_path = 2;
inline void ListItemsResponse::clear_canonical_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.canonical_path_.ClearToEmpty();
}
inline const std::string& ListItemsResponse::canonical_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ListItemsResponse.canonical_path)
  return _internal_canonical_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ListItemsResponse::set_canonical_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.canonical_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ListItemsResponse.canonical_path)
}
inline std::string* ListItemsResponse::mutable_canonical_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_canonical_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ListItemsResponse.canonical_path)
  return _s;
}
inline const std::string& ListItemsResponse::_internal_canonical_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.canonical_path_.Get();
}
inline void ListItemsResponse::_internal_set_canonical_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.canonical_path_.Set(value, GetArena());
}
inline std::string* ListItemsResponse::_internal_mutable_canonical_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.canonical_path_.Mutable( GetArena());
}
inline std::string* ListItemsResponse::release_canonical_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ListItemsResponse.canonical_path)
  return _impl_.canonical_path_.Release();
}
inline void ListItemsResponse::set_allocated_canonical_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.canonical_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.canonical_path_.IsDefault()) {
          _impl_.canonical_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ListItemsResponse.canonical_path)
}

// -------------------------------------------------------------------

// FetchFileRequest

// string path = 1;
inline void FetchFileRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& FetchFileRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchFileRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FetchFileRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.FetchFileRequest.path)
}
inline std::string* FetchFileRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchFileRequest.path)
  return _s;
}
inline const std::string& FetchFileRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void FetchFileRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* FetchFileRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* FetchFileRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchFileRequest.path)
  return _impl_.path_.Release();
}
inline void FetchFileRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchFileRequest.path)
}

// optional string etag = 2;
inline bool FetchFileRequest::has_etag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FetchFileRequest::clear_etag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.etag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FetchFileRequest::etag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchFileRequest.etag)
  return _internal_etag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FetchFileRequest::set_etag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.etag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.FetchFileRequest.etag)
}
inline std::string* FetchFileRequest::mutable_etag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchFileRequest.etag)
  return _s;
}
inline const std::string& FetchFileRequest::_internal_etag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.etag_.Get();
}
inline void FetchFileRequest::_internal_set_etag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.etag_.Set(value, GetArena());
}
inline std::string* FetchFileRequest::_internal_mutable_etag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.etag_.Mutable( GetArena());
}
inline std::string* FetchFileRequest::release_etag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchFileRequest.etag)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.etag_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.etag_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FetchFileRequest::set_allocated_etag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.etag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.etag_.IsDefault()) {
          _impl_.etag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchFileRequest.etag)
}

// -------------------------------------------------------------------

// FetchFileResponse

// bytes contents = 1;
inline void FetchFileResponse::clear_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contents_.ClearToEmpty();
}
inline const std::string& FetchFileResponse::contents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchFileResponse.contents)
  return _internal_contents();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FetchFileResponse::set_contents(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.contents_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.FetchFileResponse.contents)
}
inline std::string* FetchFileResponse::mutable_contents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchFileResponse.contents)
  return _s;
}
inline const std::string& FetchFileResponse::_internal_contents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contents_.Get();
}
inline void FetchFileResponse::_internal_set_contents(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.contents_.Set(value, GetArena());
}
inline std::string* FetchFileResponse::_internal_mutable_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.contents_.Mutable( GetArena());
}
inline std::string* FetchFileResponse::release_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchFileResponse.contents)
  return _impl_.contents_.Release();
}
inline void FetchFileResponse::set_allocated_contents(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contents_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contents_.IsDefault()) {
          _impl_.contents_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchFileResponse.contents)
}

// optional string etag = 2;
inline bool FetchFileResponse::has_etag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void FetchFileResponse::clear_etag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.etag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FetchFileResponse::etag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchFileResponse.etag)
  return _internal_etag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void FetchFileResponse::set_etag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.etag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.FetchFileResponse.etag)
}
inline std::string* FetchFileResponse::mutable_etag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchFileResponse.etag)
  return _s;
}
inline const std::string& FetchFileResponse::_internal_etag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.etag_.Get();
}
inline void FetchFileResponse::_internal_set_etag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.etag_.Set(value, GetArena());
}
inline std::string* FetchFileResponse::_internal_mutable_etag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.etag_.Mutable( GetArena());
}
inline std::string* FetchFileResponse::release_etag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchFileResponse.etag)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.etag_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.etag_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void FetchFileResponse::set_allocated_etag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.etag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.etag_.IsDefault()) {
          _impl_.etag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchFileResponse.etag)
}

// -------------------------------------------------------------------

// SaveFileRequest

// bool allow_overwrite = 1;
inline void SaveFileRequest::clear_allow_overwrite() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allow_overwrite_ = false;
}
inline bool SaveFileRequest::allow_overwrite() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SaveFileRequest.allow_overwrite)
  return _internal_allow_overwrite();
}
inline void SaveFileRequest::set_allow_overwrite(bool value) {
  _internal_set_allow_overwrite(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SaveFileRequest.allow_overwrite)
}
inline bool SaveFileRequest::_internal_allow_overwrite() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allow_overwrite_;
}
inline void SaveFileRequest::_internal_set_allow_overwrite(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.allow_overwrite_ = value;
}

// string path = 2;
inline void SaveFileRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& SaveFileRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SaveFileRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SaveFileRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SaveFileRequest.path)
}
inline std::string* SaveFileRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SaveFileRequest.path)
  return _s;
}
inline const std::string& SaveFileRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void SaveFileRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* SaveFileRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* SaveFileRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SaveFileRequest.path)
  return _impl_.path_.Release();
}
inline void SaveFileRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SaveFileRequest.path)
}

// bytes contents = 3;
inline void SaveFileRequest::clear_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contents_.ClearToEmpty();
}
inline const std::string& SaveFileRequest::contents() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SaveFileRequest.contents)
  return _internal_contents();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SaveFileRequest::set_contents(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.contents_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SaveFileRequest.contents)
}
inline std::string* SaveFileRequest::mutable_contents() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SaveFileRequest.contents)
  return _s;
}
inline const std::string& SaveFileRequest::_internal_contents() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contents_.Get();
}
inline void SaveFileRequest::_internal_set_contents(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.contents_.Set(value, GetArena());
}
inline std::string* SaveFileRequest::_internal_mutable_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.contents_.Mutable( GetArena());
}
inline std::string* SaveFileRequest::release_contents() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SaveFileRequest.contents)
  return _impl_.contents_.Release();
}
inline void SaveFileRequest::set_allocated_contents(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contents_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.contents_.IsDefault()) {
          _impl_.contents_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SaveFileRequest.contents)
}

// -------------------------------------------------------------------

// SaveFileResponse

// optional string etag = 1;
inline bool SaveFileResponse::has_etag() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void SaveFileResponse::clear_etag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.etag_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SaveFileResponse::etag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SaveFileResponse.etag)
  return _internal_etag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SaveFileResponse::set_etag(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.etag_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SaveFileResponse.etag)
}
inline std::string* SaveFileResponse::mutable_etag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SaveFileResponse.etag)
  return _s;
}
inline const std::string& SaveFileResponse::_internal_etag() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.etag_.Get();
}
inline void SaveFileResponse::_internal_set_etag(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.etag_.Set(value, GetArena());
}
inline std::string* SaveFileResponse::_internal_mutable_etag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.etag_.Mutable( GetArena());
}
inline std::string* SaveFileResponse::release_etag() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SaveFileResponse.etag)
  if ((_impl_._has_bits_[0] & 0x00000001u) == 0) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* released = _impl_.etag_.Release();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.etag_.Set("", GetArena());
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return released;
}
inline void SaveFileResponse::set_allocated_etag(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.etag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.etag_.IsDefault()) {
          _impl_.etag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SaveFileResponse.etag)
}

// -------------------------------------------------------------------

// MoveItemRequest

// string old_path = 1;
inline void MoveItemRequest::clear_old_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.old_path_.ClearToEmpty();
}
inline const std::string& MoveItemRequest::old_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MoveItemRequest.old_path)
  return _internal_old_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MoveItemRequest::set_old_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.old_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MoveItemRequest.old_path)
}
inline std::string* MoveItemRequest::mutable_old_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_old_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MoveItemRequest.old_path)
  return _s;
}
inline const std::string& MoveItemRequest::_internal_old_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.old_path_.Get();
}
inline void MoveItemRequest::_internal_set_old_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.old_path_.Set(value, GetArena());
}
inline std::string* MoveItemRequest::_internal_mutable_old_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.old_path_.Mutable( GetArena());
}
inline std::string* MoveItemRequest::release_old_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MoveItemRequest.old_path)
  return _impl_.old_path_.Release();
}
inline void MoveItemRequest::set_allocated_old_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.old_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.old_path_.IsDefault()) {
          _impl_.old_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MoveItemRequest.old_path)
}

// string new_path = 2;
inline void MoveItemRequest::clear_new_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_path_.ClearToEmpty();
}
inline const std::string& MoveItemRequest::new_path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MoveItemRequest.new_path)
  return _internal_new_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MoveItemRequest::set_new_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MoveItemRequest.new_path)
}
inline std::string* MoveItemRequest::mutable_new_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MoveItemRequest.new_path)
  return _s;
}
inline const std::string& MoveItemRequest::_internal_new_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.new_path_.Get();
}
inline void MoveItemRequest::_internal_set_new_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.new_path_.Set(value, GetArena());
}
inline std::string* MoveItemRequest::_internal_mutable_new_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.new_path_.Mutable( GetArena());
}
inline std::string* MoveItemRequest::release_new_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MoveItemRequest.new_path)
  return _impl_.new_path_.Release();
}
inline void MoveItemRequest::set_allocated_new_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.new_path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_path_.IsDefault()) {
          _impl_.new_path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MoveItemRequest.new_path)
}

// bool allow_overwrite = 3;
inline void MoveItemRequest::clear_allow_overwrite() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.allow_overwrite_ = false;
}
inline bool MoveItemRequest::allow_overwrite() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MoveItemRequest.allow_overwrite)
  return _internal_allow_overwrite();
}
inline void MoveItemRequest::set_allow_overwrite(bool value) {
  _internal_set_allow_overwrite(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MoveItemRequest.allow_overwrite)
}
inline bool MoveItemRequest::_internal_allow_overwrite() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.allow_overwrite_;
}
inline void MoveItemRequest::_internal_set_allow_overwrite(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.allow_overwrite_ = value;
}

// -------------------------------------------------------------------

// MoveItemResponse

// -------------------------------------------------------------------

// CreateDirectoryRequest

// string path = 1;
inline void CreateDirectoryRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& CreateDirectoryRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateDirectoryRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest.path)
}
inline std::string* CreateDirectoryRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest.path)
  return _s;
}
inline const std::string& CreateDirectoryRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void CreateDirectoryRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* CreateDirectoryRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* CreateDirectoryRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest.path)
  return _impl_.path_.Release();
}
inline void CreateDirectoryRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest.path)
}

// -------------------------------------------------------------------

// CreateDirectoryResponse

// -------------------------------------------------------------------

// DeleteItemRequest

// string path = 1;
inline void DeleteItemRequest::clear_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.ClearToEmpty();
}
inline const std::string& DeleteItemRequest::path() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.DeleteItemRequest.path)
  return _internal_path();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteItemRequest::set_path(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.DeleteItemRequest.path)
}
inline std::string* DeleteItemRequest::mutable_path() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.DeleteItemRequest.path)
  return _s;
}
inline const std::string& DeleteItemRequest::_internal_path() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.path_.Get();
}
inline void DeleteItemRequest::_internal_set_path(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.path_.Set(value, GetArena());
}
inline std::string* DeleteItemRequest::_internal_mutable_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.path_.Mutable( GetArena());
}
inline std::string* DeleteItemRequest::release_path() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.DeleteItemRequest.path)
  return _impl_.path_.Release();
}
inline void DeleteItemRequest::set_allocated_path(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.path_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.path_.IsDefault()) {
          _impl_.path_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.DeleteItemRequest.path)
}

// -------------------------------------------------------------------

// DeleteItemResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace grpc
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::ItemType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::ItemType>() {
  return ::io::deephaven::proto::backplane::grpc::ItemType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2fstorage_2eproto_2epb_2eh
