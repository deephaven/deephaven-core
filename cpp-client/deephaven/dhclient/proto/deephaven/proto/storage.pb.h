// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: deephaven/proto/storage.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2fstorage_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2fstorage_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_deephaven_2fproto_2fstorage_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_deephaven_2fproto_2fstorage_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_deephaven_2fproto_2fstorage_2eproto;
namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace grpc {
class CreateDirectoryRequest;
struct CreateDirectoryRequestDefaultTypeInternal;
extern CreateDirectoryRequestDefaultTypeInternal _CreateDirectoryRequest_default_instance_;
class CreateDirectoryResponse;
struct CreateDirectoryResponseDefaultTypeInternal;
extern CreateDirectoryResponseDefaultTypeInternal _CreateDirectoryResponse_default_instance_;
class DeleteItemRequest;
struct DeleteItemRequestDefaultTypeInternal;
extern DeleteItemRequestDefaultTypeInternal _DeleteItemRequest_default_instance_;
class DeleteItemResponse;
struct DeleteItemResponseDefaultTypeInternal;
extern DeleteItemResponseDefaultTypeInternal _DeleteItemResponse_default_instance_;
class FetchFileRequest;
struct FetchFileRequestDefaultTypeInternal;
extern FetchFileRequestDefaultTypeInternal _FetchFileRequest_default_instance_;
class FetchFileResponse;
struct FetchFileResponseDefaultTypeInternal;
extern FetchFileResponseDefaultTypeInternal _FetchFileResponse_default_instance_;
class ItemInfo;
struct ItemInfoDefaultTypeInternal;
extern ItemInfoDefaultTypeInternal _ItemInfo_default_instance_;
class ListItemsRequest;
struct ListItemsRequestDefaultTypeInternal;
extern ListItemsRequestDefaultTypeInternal _ListItemsRequest_default_instance_;
class ListItemsResponse;
struct ListItemsResponseDefaultTypeInternal;
extern ListItemsResponseDefaultTypeInternal _ListItemsResponse_default_instance_;
class MoveItemRequest;
struct MoveItemRequestDefaultTypeInternal;
extern MoveItemRequestDefaultTypeInternal _MoveItemRequest_default_instance_;
class MoveItemResponse;
struct MoveItemResponseDefaultTypeInternal;
extern MoveItemResponseDefaultTypeInternal _MoveItemResponse_default_instance_;
class SaveFileRequest;
struct SaveFileRequestDefaultTypeInternal;
extern SaveFileRequestDefaultTypeInternal _SaveFileRequest_default_instance_;
class SaveFileResponse;
struct SaveFileResponseDefaultTypeInternal;
extern SaveFileResponseDefaultTypeInternal _SaveFileResponse_default_instance_;
}  // namespace grpc
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io
PROTOBUF_NAMESPACE_OPEN
template<> ::io::deephaven::proto::backplane::grpc::CreateDirectoryRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CreateDirectoryRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::CreateDirectoryResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CreateDirectoryResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::DeleteItemRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::DeleteItemRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::DeleteItemResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::DeleteItemResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::FetchFileRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FetchFileRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::FetchFileResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FetchFileResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ItemInfo* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ItemInfo>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ListItemsRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ListItemsRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::ListItemsResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ListItemsResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::MoveItemRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MoveItemRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::MoveItemResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MoveItemResponse>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SaveFileRequest* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SaveFileRequest>(Arena*);
template<> ::io::deephaven::proto::backplane::grpc::SaveFileResponse* Arena::CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SaveFileResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace grpc {

enum ItemType : int {
  UNKNOWN = 0,
  DIRECTORY = 1,
  FILE = 2,
  ItemType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ItemType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ItemType_IsValid(int value);
constexpr ItemType ItemType_MIN = UNKNOWN;
constexpr ItemType ItemType_MAX = FILE;
constexpr int ItemType_ARRAYSIZE = ItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ItemType_descriptor();
template<typename T>
inline const std::string& ItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ItemType_descriptor(), enum_t_value);
}
inline bool ItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ItemType>(
    ItemType_descriptor(), name, value);
}
// ===================================================================

class ListItemsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ListItemsRequest) */ {
 public:
  inline ListItemsRequest() : ListItemsRequest(nullptr) {}
  ~ListItemsRequest() override;
  explicit PROTOBUF_CONSTEXPR ListItemsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListItemsRequest(const ListItemsRequest& from);
  ListItemsRequest(ListItemsRequest&& from) noexcept
    : ListItemsRequest() {
    *this = ::std::move(from);
  }

  inline ListItemsRequest& operator=(const ListItemsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListItemsRequest& operator=(ListItemsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListItemsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListItemsRequest* internal_default_instance() {
    return reinterpret_cast<const ListItemsRequest*>(
               &_ListItemsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ListItemsRequest& a, ListItemsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListItemsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListItemsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListItemsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListItemsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListItemsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListItemsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListItemsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ListItemsRequest";
  }
  protected:
  explicit ListItemsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kFilterGlobFieldNumber = 4,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // optional string filter_glob = 4;
  bool has_filter_glob() const;
  private:
  bool _internal_has_filter_glob() const;
  public:
  void clear_filter_glob();
  const std::string& filter_glob() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter_glob(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter_glob();
  PROTOBUF_NODISCARD std::string* release_filter_glob();
  void set_allocated_filter_glob(std::string* filter_glob);
  private:
  const std::string& _internal_filter_glob() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_glob(const std::string& value);
  std::string* _internal_mutable_filter_glob();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ListItemsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_glob_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class ItemInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ItemInfo) */ {
 public:
  inline ItemInfo() : ItemInfo(nullptr) {}
  ~ItemInfo() override;
  explicit PROTOBUF_CONSTEXPR ItemInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ItemInfo(const ItemInfo& from);
  ItemInfo(ItemInfo&& from) noexcept
    : ItemInfo() {
    *this = ::std::move(from);
  }

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ItemInfo& operator=(ItemInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ItemInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ItemInfo* internal_default_instance() {
    return reinterpret_cast<const ItemInfo*>(
               &_ItemInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ItemInfo& a, ItemInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(ItemInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ItemInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ItemInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ItemInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ItemInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ItemInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ItemInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ItemInfo";
  }
  protected:
  explicit ItemInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kEtagFieldNumber = 4,
    kSizeFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // optional string etag = 4;
  bool has_etag() const;
  private:
  bool _internal_has_etag() const;
  public:
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // sint64 size = 3 [jstype = JS_STRING];
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // .io.deephaven.proto.backplane.grpc.ItemType type = 2;
  void clear_type();
  ::io::deephaven::proto::backplane::grpc::ItemType type() const;
  void set_type(::io::deephaven::proto::backplane::grpc::ItemType value);
  private:
  ::io::deephaven::proto::backplane::grpc::ItemType _internal_type() const;
  void _internal_set_type(::io::deephaven::proto::backplane::grpc::ItemType value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ItemInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
  int64_t size_;
  int type_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class ListItemsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ListItemsResponse) */ {
 public:
  inline ListItemsResponse() : ListItemsResponse(nullptr) {}
  ~ListItemsResponse() override;
  explicit PROTOBUF_CONSTEXPR ListItemsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ListItemsResponse(const ListItemsResponse& from);
  ListItemsResponse(ListItemsResponse&& from) noexcept
    : ListItemsResponse() {
    *this = ::std::move(from);
  }

  inline ListItemsResponse& operator=(const ListItemsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListItemsResponse& operator=(ListItemsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ListItemsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ListItemsResponse* internal_default_instance() {
    return reinterpret_cast<const ListItemsResponse*>(
               &_ListItemsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ListItemsResponse& a, ListItemsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListItemsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListItemsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ListItemsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ListItemsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ListItemsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ListItemsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListItemsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ListItemsResponse";
  }
  protected:
  explicit ListItemsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kItemsFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.ItemInfo items = 1;
  int items_size() const;
  private:
  int _internal_items_size() const;
  public:
  void clear_items();
  ::io::deephaven::proto::backplane::grpc::ItemInfo* mutable_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ItemInfo >*
      mutable_items();
  private:
  const ::io::deephaven::proto::backplane::grpc::ItemInfo& _internal_items(int index) const;
  ::io::deephaven::proto::backplane::grpc::ItemInfo* _internal_add_items();
  public:
  const ::io::deephaven::proto::backplane::grpc::ItemInfo& items(int index) const;
  ::io::deephaven::proto::backplane::grpc::ItemInfo* add_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ItemInfo >&
      items() const;

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ListItemsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ItemInfo > items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class FetchFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FetchFileRequest) */ {
 public:
  inline FetchFileRequest() : FetchFileRequest(nullptr) {}
  ~FetchFileRequest() override;
  explicit PROTOBUF_CONSTEXPR FetchFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchFileRequest(const FetchFileRequest& from);
  FetchFileRequest(FetchFileRequest&& from) noexcept
    : FetchFileRequest() {
    *this = ::std::move(from);
  }

  inline FetchFileRequest& operator=(const FetchFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchFileRequest& operator=(FetchFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchFileRequest* internal_default_instance() {
    return reinterpret_cast<const FetchFileRequest*>(
               &_FetchFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FetchFileRequest& a, FetchFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FetchFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FetchFileRequest";
  }
  protected:
  explicit FetchFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
    kEtagFieldNumber = 2,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // optional string etag = 2;
  bool has_etag() const;
  private:
  bool _internal_has_etag() const;
  public:
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FetchFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class FetchFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FetchFileResponse) */ {
 public:
  inline FetchFileResponse() : FetchFileResponse(nullptr) {}
  ~FetchFileResponse() override;
  explicit PROTOBUF_CONSTEXPR FetchFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FetchFileResponse(const FetchFileResponse& from);
  FetchFileResponse(FetchFileResponse&& from) noexcept
    : FetchFileResponse() {
    *this = ::std::move(from);
  }

  inline FetchFileResponse& operator=(const FetchFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchFileResponse& operator=(FetchFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchFileResponse* internal_default_instance() {
    return reinterpret_cast<const FetchFileResponse*>(
               &_FetchFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FetchFileResponse& a, FetchFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FetchFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FetchFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FetchFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FetchFileResponse";
  }
  protected:
  explicit FetchFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentsFieldNumber = 1,
    kEtagFieldNumber = 2,
  };
  // bytes contents = 1;
  void clear_contents();
  const std::string& contents() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contents(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* contents);
  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(const std::string& value);
  std::string* _internal_mutable_contents();
  public:

  // optional string etag = 2;
  bool has_etag() const;
  private:
  bool _internal_has_etag() const;
  public:
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FetchFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contents_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class SaveFileRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SaveFileRequest) */ {
 public:
  inline SaveFileRequest() : SaveFileRequest(nullptr) {}
  ~SaveFileRequest() override;
  explicit PROTOBUF_CONSTEXPR SaveFileRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveFileRequest(const SaveFileRequest& from);
  SaveFileRequest(SaveFileRequest&& from) noexcept
    : SaveFileRequest() {
    *this = ::std::move(from);
  }

  inline SaveFileRequest& operator=(const SaveFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveFileRequest& operator=(SaveFileRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveFileRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveFileRequest* internal_default_instance() {
    return reinterpret_cast<const SaveFileRequest*>(
               &_SaveFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SaveFileRequest& a, SaveFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveFileRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveFileRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveFileRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveFileRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SaveFileRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveFileRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SaveFileRequest";
  }
  protected:
  explicit SaveFileRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 2,
    kContentsFieldNumber = 3,
    kAllowOverwriteFieldNumber = 1,
  };
  // string path = 2;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // bytes contents = 3;
  void clear_contents();
  const std::string& contents() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_contents(ArgT0&& arg0, ArgT... args);
  std::string* mutable_contents();
  PROTOBUF_NODISCARD std::string* release_contents();
  void set_allocated_contents(std::string* contents);
  private:
  const std::string& _internal_contents() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_contents(const std::string& value);
  std::string* _internal_mutable_contents();
  public:

  // bool allow_overwrite = 1;
  void clear_allow_overwrite();
  bool allow_overwrite() const;
  void set_allow_overwrite(bool value);
  private:
  bool _internal_allow_overwrite() const;
  void _internal_set_allow_overwrite(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SaveFileRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr contents_;
  bool allow_overwrite_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class SaveFileResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SaveFileResponse) */ {
 public:
  inline SaveFileResponse() : SaveFileResponse(nullptr) {}
  ~SaveFileResponse() override;
  explicit PROTOBUF_CONSTEXPR SaveFileResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SaveFileResponse(const SaveFileResponse& from);
  SaveFileResponse(SaveFileResponse&& from) noexcept
    : SaveFileResponse() {
    *this = ::std::move(from);
  }

  inline SaveFileResponse& operator=(const SaveFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveFileResponse& operator=(SaveFileResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveFileResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveFileResponse* internal_default_instance() {
    return reinterpret_cast<const SaveFileResponse*>(
               &_SaveFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SaveFileResponse& a, SaveFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveFileResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveFileResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveFileResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SaveFileResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SaveFileResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaveFileResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SaveFileResponse";
  }
  protected:
  explicit SaveFileResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEtagFieldNumber = 1,
  };
  // optional string etag = 1;
  bool has_etag() const;
  private:
  bool _internal_has_etag() const;
  public:
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SaveFileResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class MoveItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MoveItemRequest) */ {
 public:
  inline MoveItemRequest() : MoveItemRequest(nullptr) {}
  ~MoveItemRequest() override;
  explicit PROTOBUF_CONSTEXPR MoveItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveItemRequest(const MoveItemRequest& from);
  MoveItemRequest(MoveItemRequest&& from) noexcept
    : MoveItemRequest() {
    *this = ::std::move(from);
  }

  inline MoveItemRequest& operator=(const MoveItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveItemRequest& operator=(MoveItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveItemRequest* internal_default_instance() {
    return reinterpret_cast<const MoveItemRequest*>(
               &_MoveItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(MoveItemRequest& a, MoveItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MoveItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MoveItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MoveItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MoveItemRequest";
  }
  protected:
  explicit MoveItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOldPathFieldNumber = 1,
    kNewPathFieldNumber = 2,
    kAllowOverwriteFieldNumber = 3,
  };
  // string old_path = 1;
  void clear_old_path();
  const std::string& old_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_old_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_old_path();
  PROTOBUF_NODISCARD std::string* release_old_path();
  void set_allocated_old_path(std::string* old_path);
  private:
  const std::string& _internal_old_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_old_path(const std::string& value);
  std::string* _internal_mutable_old_path();
  public:

  // string new_path = 2;
  void clear_new_path();
  const std::string& new_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_path();
  PROTOBUF_NODISCARD std::string* release_new_path();
  void set_allocated_new_path(std::string* new_path);
  private:
  const std::string& _internal_new_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_path(const std::string& value);
  std::string* _internal_mutable_new_path();
  public:

  // bool allow_overwrite = 3;
  void clear_allow_overwrite();
  bool allow_overwrite() const;
  void set_allow_overwrite(bool value);
  private:
  bool _internal_allow_overwrite() const;
  void _internal_set_allow_overwrite(bool value);
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MoveItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr old_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_path_;
  bool allow_overwrite_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class MoveItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MoveItemResponse) */ {
 public:
  inline MoveItemResponse() : MoveItemResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MoveItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MoveItemResponse(const MoveItemResponse& from);
  MoveItemResponse(MoveItemResponse&& from) noexcept
    : MoveItemResponse() {
    *this = ::std::move(from);
  }

  inline MoveItemResponse& operator=(const MoveItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MoveItemResponse& operator=(MoveItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MoveItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MoveItemResponse* internal_default_instance() {
    return reinterpret_cast<const MoveItemResponse*>(
               &_MoveItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MoveItemResponse& a, MoveItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MoveItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MoveItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MoveItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MoveItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MoveItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MoveItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MoveItemResponse";
  }
  protected:
  explicit MoveItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MoveItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CreateDirectoryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest) */ {
 public:
  inline CreateDirectoryRequest() : CreateDirectoryRequest(nullptr) {}
  ~CreateDirectoryRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateDirectoryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDirectoryRequest(const CreateDirectoryRequest& from);
  CreateDirectoryRequest(CreateDirectoryRequest&& from) noexcept
    : CreateDirectoryRequest() {
    *this = ::std::move(from);
  }

  inline CreateDirectoryRequest& operator=(const CreateDirectoryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDirectoryRequest& operator=(CreateDirectoryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDirectoryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDirectoryRequest* internal_default_instance() {
    return reinterpret_cast<const CreateDirectoryRequest*>(
               &_CreateDirectoryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CreateDirectoryRequest& a, CreateDirectoryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDirectoryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDirectoryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDirectoryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDirectoryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateDirectoryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreateDirectoryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateDirectoryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateDirectoryRequest";
  }
  protected:
  explicit CreateDirectoryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class CreateDirectoryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateDirectoryResponse) */ {
 public:
  inline CreateDirectoryResponse() : CreateDirectoryResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CreateDirectoryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateDirectoryResponse(const CreateDirectoryResponse& from);
  CreateDirectoryResponse(CreateDirectoryResponse&& from) noexcept
    : CreateDirectoryResponse() {
    *this = ::std::move(from);
  }

  inline CreateDirectoryResponse& operator=(const CreateDirectoryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateDirectoryResponse& operator=(CreateDirectoryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateDirectoryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateDirectoryResponse* internal_default_instance() {
    return reinterpret_cast<const CreateDirectoryResponse*>(
               &_CreateDirectoryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CreateDirectoryResponse& a, CreateDirectoryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateDirectoryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateDirectoryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateDirectoryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateDirectoryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateDirectoryResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateDirectoryResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateDirectoryResponse";
  }
  protected:
  explicit CreateDirectoryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateDirectoryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class DeleteItemRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.DeleteItemRequest) */ {
 public:
  inline DeleteItemRequest() : DeleteItemRequest(nullptr) {}
  ~DeleteItemRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteItemRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteItemRequest(const DeleteItemRequest& from);
  DeleteItemRequest(DeleteItemRequest&& from) noexcept
    : DeleteItemRequest() {
    *this = ::std::move(from);
  }

  inline DeleteItemRequest& operator=(const DeleteItemRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteItemRequest& operator=(DeleteItemRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteItemRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteItemRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteItemRequest*>(
               &_DeleteItemRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DeleteItemRequest& a, DeleteItemRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteItemRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteItemRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteItemRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteItemRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteItemRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteItemRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteItemRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.DeleteItemRequest";
  }
  protected:
  explicit DeleteItemRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathFieldNumber = 1,
  };
  // string path = 1;
  void clear_path();
  const std::string& path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_path();
  PROTOBUF_NODISCARD std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.DeleteItemRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// -------------------------------------------------------------------

class DeleteItemResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.DeleteItemResponse) */ {
 public:
  inline DeleteItemResponse() : DeleteItemResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteItemResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteItemResponse(const DeleteItemResponse& from);
  DeleteItemResponse(DeleteItemResponse&& from) noexcept
    : DeleteItemResponse() {
    *this = ::std::move(from);
  }

  inline DeleteItemResponse& operator=(const DeleteItemResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteItemResponse& operator=(DeleteItemResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteItemResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteItemResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteItemResponse*>(
               &_DeleteItemResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeleteItemResponse& a, DeleteItemResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteItemResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteItemResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteItemResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteItemResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteItemResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.DeleteItemResponse";
  }
  protected:
  explicit DeleteItemResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.DeleteItemResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_deephaven_2fproto_2fstorage_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ListItemsRequest

// string path = 1;
inline void ListItemsRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& ListItemsRequest::path() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ListItemsRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListItemsRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ListItemsRequest.path)
}
inline std::string* ListItemsRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ListItemsRequest.path)
  return _s;
}
inline const std::string& ListItemsRequest::_internal_path() const {
  return path_.Get();
}
inline void ListItemsRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(value, GetArenaForAllocation());
}
inline std::string* ListItemsRequest::_internal_mutable_path() {
  
  return path_.Mutable(GetArenaForAllocation());
}
inline std::string* ListItemsRequest::release_path() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ListItemsRequest.path)
  return path_.Release();
}
inline void ListItemsRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault()) {
    path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ListItemsRequest.path)
}

// optional string filter_glob = 4;
inline bool ListItemsRequest::_internal_has_filter_glob() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ListItemsRequest::has_filter_glob() const {
  return _internal_has_filter_glob();
}
inline void ListItemsRequest::clear_filter_glob() {
  filter_glob_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ListItemsRequest::filter_glob() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ListItemsRequest.filter_glob)
  return _internal_filter_glob();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ListItemsRequest::set_filter_glob(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 filter_glob_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ListItemsRequest.filter_glob)
}
inline std::string* ListItemsRequest::mutable_filter_glob() {
  std::string* _s = _internal_mutable_filter_glob();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ListItemsRequest.filter_glob)
  return _s;
}
inline const std::string& ListItemsRequest::_internal_filter_glob() const {
  return filter_glob_.Get();
}
inline void ListItemsRequest::_internal_set_filter_glob(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filter_glob_.Set(value, GetArenaForAllocation());
}
inline std::string* ListItemsRequest::_internal_mutable_filter_glob() {
  _has_bits_[0] |= 0x00000001u;
  return filter_glob_.Mutable(GetArenaForAllocation());
}
inline std::string* ListItemsRequest::release_filter_glob() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ListItemsRequest.filter_glob)
  if (!_internal_has_filter_glob()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = filter_glob_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_glob_.IsDefault()) {
    filter_glob_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ListItemsRequest::set_allocated_filter_glob(std::string* filter_glob) {
  if (filter_glob != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_glob_.SetAllocated(filter_glob, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_glob_.IsDefault()) {
    filter_glob_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ListItemsRequest.filter_glob)
}

// -------------------------------------------------------------------

// ItemInfo

// string path = 1;
inline void ItemInfo::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& ItemInfo::path() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ItemInfo.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemInfo::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ItemInfo.path)
}
inline std::string* ItemInfo::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ItemInfo.path)
  return _s;
}
inline const std::string& ItemInfo::_internal_path() const {
  return path_.Get();
}
inline void ItemInfo::_internal_set_path(const std::string& value) {
  
  path_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemInfo::_internal_mutable_path() {
  
  return path_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemInfo::release_path() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ItemInfo.path)
  return path_.Release();
}
inline void ItemInfo::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault()) {
    path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ItemInfo.path)
}

// .io.deephaven.proto.backplane.grpc.ItemType type = 2;
inline void ItemInfo::clear_type() {
  type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::ItemType ItemInfo::_internal_type() const {
  return static_cast< ::io::deephaven::proto::backplane::grpc::ItemType >(type_);
}
inline ::io::deephaven::proto::backplane::grpc::ItemType ItemInfo::type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ItemInfo.type)
  return _internal_type();
}
inline void ItemInfo::_internal_set_type(::io::deephaven::proto::backplane::grpc::ItemType value) {
  
  type_ = value;
}
inline void ItemInfo::set_type(::io::deephaven::proto::backplane::grpc::ItemType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ItemInfo.type)
}

// sint64 size = 3 [jstype = JS_STRING];
inline void ItemInfo::clear_size() {
  size_ = int64_t{0};
}
inline int64_t ItemInfo::_internal_size() const {
  return size_;
}
inline int64_t ItemInfo::size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ItemInfo.size)
  return _internal_size();
}
inline void ItemInfo::_internal_set_size(int64_t value) {
  
  size_ = value;
}
inline void ItemInfo::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ItemInfo.size)
}

// optional string etag = 4;
inline bool ItemInfo::_internal_has_etag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ItemInfo::has_etag() const {
  return _internal_has_etag();
}
inline void ItemInfo::clear_etag() {
  etag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ItemInfo::etag() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ItemInfo.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ItemInfo::set_etag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ItemInfo.etag)
}
inline std::string* ItemInfo::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ItemInfo.etag)
  return _s;
}
inline const std::string& ItemInfo::_internal_etag() const {
  return etag_.Get();
}
inline void ItemInfo::_internal_set_etag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  etag_.Set(value, GetArenaForAllocation());
}
inline std::string* ItemInfo::_internal_mutable_etag() {
  _has_bits_[0] |= 0x00000001u;
  return etag_.Mutable(GetArenaForAllocation());
}
inline std::string* ItemInfo::release_etag() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ItemInfo.etag)
  if (!_internal_has_etag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = etag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault()) {
    etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ItemInfo::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault()) {
    etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ItemInfo.etag)
}

// -------------------------------------------------------------------

// ListItemsResponse

// repeated .io.deephaven.proto.backplane.grpc.ItemInfo items = 1;
inline int ListItemsResponse::_internal_items_size() const {
  return items_.size();
}
inline int ListItemsResponse::items_size() const {
  return _internal_items_size();
}
inline void ListItemsResponse::clear_items() {
  items_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::ItemInfo* ListItemsResponse::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ListItemsResponse.items)
  return items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ItemInfo >*
ListItemsResponse::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ListItemsResponse.items)
  return &items_;
}
inline const ::io::deephaven::proto::backplane::grpc::ItemInfo& ListItemsResponse::_internal_items(int index) const {
  return items_.Get(index);
}
inline const ::io::deephaven::proto::backplane::grpc::ItemInfo& ListItemsResponse::items(int index) const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ListItemsResponse.items)
  return _internal_items(index);
}
inline ::io::deephaven::proto::backplane::grpc::ItemInfo* ListItemsResponse::_internal_add_items() {
  return items_.Add();
}
inline ::io::deephaven::proto::backplane::grpc::ItemInfo* ListItemsResponse::add_items() {
  ::io::deephaven::proto::backplane::grpc::ItemInfo* _add = _internal_add_items();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ListItemsResponse.items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ItemInfo >&
ListItemsResponse::items() const {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ListItemsResponse.items)
  return items_;
}

// -------------------------------------------------------------------

// FetchFileRequest

// string path = 1;
inline void FetchFileRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& FetchFileRequest::path() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchFileRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.FetchFileRequest.path)
}
inline std::string* FetchFileRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchFileRequest.path)
  return _s;
}
inline const std::string& FetchFileRequest::_internal_path() const {
  return path_.Get();
}
inline void FetchFileRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileRequest::_internal_mutable_path() {
  
  return path_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileRequest::release_path() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchFileRequest.path)
  return path_.Release();
}
inline void FetchFileRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault()) {
    path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchFileRequest.path)
}

// optional string etag = 2;
inline bool FetchFileRequest::_internal_has_etag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FetchFileRequest::has_etag() const {
  return _internal_has_etag();
}
inline void FetchFileRequest::clear_etag() {
  etag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FetchFileRequest::etag() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchFileRequest.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileRequest::set_etag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.FetchFileRequest.etag)
}
inline std::string* FetchFileRequest::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchFileRequest.etag)
  return _s;
}
inline const std::string& FetchFileRequest::_internal_etag() const {
  return etag_.Get();
}
inline void FetchFileRequest::_internal_set_etag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  etag_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileRequest::_internal_mutable_etag() {
  _has_bits_[0] |= 0x00000001u;
  return etag_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileRequest::release_etag() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchFileRequest.etag)
  if (!_internal_has_etag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = etag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault()) {
    etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FetchFileRequest::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault()) {
    etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchFileRequest.etag)
}

// -------------------------------------------------------------------

// FetchFileResponse

// bytes contents = 1;
inline void FetchFileResponse::clear_contents() {
  contents_.ClearToEmpty();
}
inline const std::string& FetchFileResponse::contents() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchFileResponse.contents)
  return _internal_contents();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileResponse::set_contents(ArgT0&& arg0, ArgT... args) {
 
 contents_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.FetchFileResponse.contents)
}
inline std::string* FetchFileResponse::mutable_contents() {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchFileResponse.contents)
  return _s;
}
inline const std::string& FetchFileResponse::_internal_contents() const {
  return contents_.Get();
}
inline void FetchFileResponse::_internal_set_contents(const std::string& value) {
  
  contents_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileResponse::_internal_mutable_contents() {
  
  return contents_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileResponse::release_contents() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchFileResponse.contents)
  return contents_.Release();
}
inline void FetchFileResponse::set_allocated_contents(std::string* contents) {
  if (contents != nullptr) {
    
  } else {
    
  }
  contents_.SetAllocated(contents, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contents_.IsDefault()) {
    contents_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchFileResponse.contents)
}

// optional string etag = 2;
inline bool FetchFileResponse::_internal_has_etag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FetchFileResponse::has_etag() const {
  return _internal_has_etag();
}
inline void FetchFileResponse::clear_etag() {
  etag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FetchFileResponse::etag() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchFileResponse.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FetchFileResponse::set_etag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.FetchFileResponse.etag)
}
inline std::string* FetchFileResponse::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchFileResponse.etag)
  return _s;
}
inline const std::string& FetchFileResponse::_internal_etag() const {
  return etag_.Get();
}
inline void FetchFileResponse::_internal_set_etag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  etag_.Set(value, GetArenaForAllocation());
}
inline std::string* FetchFileResponse::_internal_mutable_etag() {
  _has_bits_[0] |= 0x00000001u;
  return etag_.Mutable(GetArenaForAllocation());
}
inline std::string* FetchFileResponse::release_etag() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchFileResponse.etag)
  if (!_internal_has_etag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = etag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault()) {
    etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void FetchFileResponse::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault()) {
    etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchFileResponse.etag)
}

// -------------------------------------------------------------------

// SaveFileRequest

// bool allow_overwrite = 1;
inline void SaveFileRequest::clear_allow_overwrite() {
  allow_overwrite_ = false;
}
inline bool SaveFileRequest::_internal_allow_overwrite() const {
  return allow_overwrite_;
}
inline bool SaveFileRequest::allow_overwrite() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SaveFileRequest.allow_overwrite)
  return _internal_allow_overwrite();
}
inline void SaveFileRequest::_internal_set_allow_overwrite(bool value) {
  
  allow_overwrite_ = value;
}
inline void SaveFileRequest::set_allow_overwrite(bool value) {
  _internal_set_allow_overwrite(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SaveFileRequest.allow_overwrite)
}

// string path = 2;
inline void SaveFileRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& SaveFileRequest::path() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SaveFileRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveFileRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SaveFileRequest.path)
}
inline std::string* SaveFileRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SaveFileRequest.path)
  return _s;
}
inline const std::string& SaveFileRequest::_internal_path() const {
  return path_.Get();
}
inline void SaveFileRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveFileRequest::_internal_mutable_path() {
  
  return path_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveFileRequest::release_path() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SaveFileRequest.path)
  return path_.Release();
}
inline void SaveFileRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault()) {
    path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SaveFileRequest.path)
}

// bytes contents = 3;
inline void SaveFileRequest::clear_contents() {
  contents_.ClearToEmpty();
}
inline const std::string& SaveFileRequest::contents() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SaveFileRequest.contents)
  return _internal_contents();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveFileRequest::set_contents(ArgT0&& arg0, ArgT... args) {
 
 contents_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SaveFileRequest.contents)
}
inline std::string* SaveFileRequest::mutable_contents() {
  std::string* _s = _internal_mutable_contents();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SaveFileRequest.contents)
  return _s;
}
inline const std::string& SaveFileRequest::_internal_contents() const {
  return contents_.Get();
}
inline void SaveFileRequest::_internal_set_contents(const std::string& value) {
  
  contents_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveFileRequest::_internal_mutable_contents() {
  
  return contents_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveFileRequest::release_contents() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SaveFileRequest.contents)
  return contents_.Release();
}
inline void SaveFileRequest::set_allocated_contents(std::string* contents) {
  if (contents != nullptr) {
    
  } else {
    
  }
  contents_.SetAllocated(contents, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (contents_.IsDefault()) {
    contents_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SaveFileRequest.contents)
}

// -------------------------------------------------------------------

// SaveFileResponse

// optional string etag = 1;
inline bool SaveFileResponse::_internal_has_etag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SaveFileResponse::has_etag() const {
  return _internal_has_etag();
}
inline void SaveFileResponse::clear_etag() {
  etag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SaveFileResponse::etag() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SaveFileResponse.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SaveFileResponse::set_etag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SaveFileResponse.etag)
}
inline std::string* SaveFileResponse::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SaveFileResponse.etag)
  return _s;
}
inline const std::string& SaveFileResponse::_internal_etag() const {
  return etag_.Get();
}
inline void SaveFileResponse::_internal_set_etag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  etag_.Set(value, GetArenaForAllocation());
}
inline std::string* SaveFileResponse::_internal_mutable_etag() {
  _has_bits_[0] |= 0x00000001u;
  return etag_.Mutable(GetArenaForAllocation());
}
inline std::string* SaveFileResponse::release_etag() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SaveFileResponse.etag)
  if (!_internal_has_etag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = etag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault()) {
    etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SaveFileResponse::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault()) {
    etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SaveFileResponse.etag)
}

// -------------------------------------------------------------------

// MoveItemRequest

// string old_path = 1;
inline void MoveItemRequest::clear_old_path() {
  old_path_.ClearToEmpty();
}
inline const std::string& MoveItemRequest::old_path() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MoveItemRequest.old_path)
  return _internal_old_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveItemRequest::set_old_path(ArgT0&& arg0, ArgT... args) {
 
 old_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MoveItemRequest.old_path)
}
inline std::string* MoveItemRequest::mutable_old_path() {
  std::string* _s = _internal_mutable_old_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MoveItemRequest.old_path)
  return _s;
}
inline const std::string& MoveItemRequest::_internal_old_path() const {
  return old_path_.Get();
}
inline void MoveItemRequest::_internal_set_old_path(const std::string& value) {
  
  old_path_.Set(value, GetArenaForAllocation());
}
inline std::string* MoveItemRequest::_internal_mutable_old_path() {
  
  return old_path_.Mutable(GetArenaForAllocation());
}
inline std::string* MoveItemRequest::release_old_path() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MoveItemRequest.old_path)
  return old_path_.Release();
}
inline void MoveItemRequest::set_allocated_old_path(std::string* old_path) {
  if (old_path != nullptr) {
    
  } else {
    
  }
  old_path_.SetAllocated(old_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (old_path_.IsDefault()) {
    old_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MoveItemRequest.old_path)
}

// string new_path = 2;
inline void MoveItemRequest::clear_new_path() {
  new_path_.ClearToEmpty();
}
inline const std::string& MoveItemRequest::new_path() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MoveItemRequest.new_path)
  return _internal_new_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MoveItemRequest::set_new_path(ArgT0&& arg0, ArgT... args) {
 
 new_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MoveItemRequest.new_path)
}
inline std::string* MoveItemRequest::mutable_new_path() {
  std::string* _s = _internal_mutable_new_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MoveItemRequest.new_path)
  return _s;
}
inline const std::string& MoveItemRequest::_internal_new_path() const {
  return new_path_.Get();
}
inline void MoveItemRequest::_internal_set_new_path(const std::string& value) {
  
  new_path_.Set(value, GetArenaForAllocation());
}
inline std::string* MoveItemRequest::_internal_mutable_new_path() {
  
  return new_path_.Mutable(GetArenaForAllocation());
}
inline std::string* MoveItemRequest::release_new_path() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MoveItemRequest.new_path)
  return new_path_.Release();
}
inline void MoveItemRequest::set_allocated_new_path(std::string* new_path) {
  if (new_path != nullptr) {
    
  } else {
    
  }
  new_path_.SetAllocated(new_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_path_.IsDefault()) {
    new_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MoveItemRequest.new_path)
}

// bool allow_overwrite = 3;
inline void MoveItemRequest::clear_allow_overwrite() {
  allow_overwrite_ = false;
}
inline bool MoveItemRequest::_internal_allow_overwrite() const {
  return allow_overwrite_;
}
inline bool MoveItemRequest::allow_overwrite() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MoveItemRequest.allow_overwrite)
  return _internal_allow_overwrite();
}
inline void MoveItemRequest::_internal_set_allow_overwrite(bool value) {
  
  allow_overwrite_ = value;
}
inline void MoveItemRequest::set_allow_overwrite(bool value) {
  _internal_set_allow_overwrite(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MoveItemRequest.allow_overwrite)
}

// -------------------------------------------------------------------

// MoveItemResponse

// -------------------------------------------------------------------

// CreateDirectoryRequest

// string path = 1;
inline void CreateDirectoryRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& CreateDirectoryRequest::path() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateDirectoryRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest.path)
}
inline std::string* CreateDirectoryRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest.path)
  return _s;
}
inline const std::string& CreateDirectoryRequest::_internal_path() const {
  return path_.Get();
}
inline void CreateDirectoryRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateDirectoryRequest::_internal_mutable_path() {
  
  return path_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateDirectoryRequest::release_path() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest.path)
  return path_.Release();
}
inline void CreateDirectoryRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault()) {
    path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CreateDirectoryRequest.path)
}

// -------------------------------------------------------------------

// CreateDirectoryResponse

// -------------------------------------------------------------------

// DeleteItemRequest

// string path = 1;
inline void DeleteItemRequest::clear_path() {
  path_.ClearToEmpty();
}
inline const std::string& DeleteItemRequest::path() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.DeleteItemRequest.path)
  return _internal_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteItemRequest::set_path(ArgT0&& arg0, ArgT... args) {
 
 path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.DeleteItemRequest.path)
}
inline std::string* DeleteItemRequest::mutable_path() {
  std::string* _s = _internal_mutable_path();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.DeleteItemRequest.path)
  return _s;
}
inline const std::string& DeleteItemRequest::_internal_path() const {
  return path_.Get();
}
inline void DeleteItemRequest::_internal_set_path(const std::string& value) {
  
  path_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteItemRequest::_internal_mutable_path() {
  
  return path_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteItemRequest::release_path() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.DeleteItemRequest.path)
  return path_.Release();
}
inline void DeleteItemRequest::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    
  } else {
    
  }
  path_.SetAllocated(path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (path_.IsDefault()) {
    path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.DeleteItemRequest.path)
}

// -------------------------------------------------------------------

// DeleteItemResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace grpc
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::io::deephaven::proto::backplane::grpc::ItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::io::deephaven::proto::backplane::grpc::ItemType>() {
  return ::io::deephaven::proto::backplane::grpc::ItemType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2fstorage_2eproto
