// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: deephaven/proto/table.proto
// Protobuf C++ Version: 4.25.3

#ifndef GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2ftable_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2ftable_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "deephaven/proto/ticket.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_deephaven_2fproto_2ftable_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_deephaven_2fproto_2ftable_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_deephaven_2fproto_2ftable_2eproto;
namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace grpc {
class AggSpec;
struct AggSpecDefaultTypeInternal;
extern AggSpecDefaultTypeInternal _AggSpec_default_instance_;
class AggSpec_AggSpecAbsSum;
struct AggSpec_AggSpecAbsSumDefaultTypeInternal;
extern AggSpec_AggSpecAbsSumDefaultTypeInternal _AggSpec_AggSpecAbsSum_default_instance_;
class AggSpec_AggSpecApproximatePercentile;
struct AggSpec_AggSpecApproximatePercentileDefaultTypeInternal;
extern AggSpec_AggSpecApproximatePercentileDefaultTypeInternal _AggSpec_AggSpecApproximatePercentile_default_instance_;
class AggSpec_AggSpecAvg;
struct AggSpec_AggSpecAvgDefaultTypeInternal;
extern AggSpec_AggSpecAvgDefaultTypeInternal _AggSpec_AggSpecAvg_default_instance_;
class AggSpec_AggSpecCountDistinct;
struct AggSpec_AggSpecCountDistinctDefaultTypeInternal;
extern AggSpec_AggSpecCountDistinctDefaultTypeInternal _AggSpec_AggSpecCountDistinct_default_instance_;
class AggSpec_AggSpecDistinct;
struct AggSpec_AggSpecDistinctDefaultTypeInternal;
extern AggSpec_AggSpecDistinctDefaultTypeInternal _AggSpec_AggSpecDistinct_default_instance_;
class AggSpec_AggSpecFirst;
struct AggSpec_AggSpecFirstDefaultTypeInternal;
extern AggSpec_AggSpecFirstDefaultTypeInternal _AggSpec_AggSpecFirst_default_instance_;
class AggSpec_AggSpecFormula;
struct AggSpec_AggSpecFormulaDefaultTypeInternal;
extern AggSpec_AggSpecFormulaDefaultTypeInternal _AggSpec_AggSpecFormula_default_instance_;
class AggSpec_AggSpecFreeze;
struct AggSpec_AggSpecFreezeDefaultTypeInternal;
extern AggSpec_AggSpecFreezeDefaultTypeInternal _AggSpec_AggSpecFreeze_default_instance_;
class AggSpec_AggSpecGroup;
struct AggSpec_AggSpecGroupDefaultTypeInternal;
extern AggSpec_AggSpecGroupDefaultTypeInternal _AggSpec_AggSpecGroup_default_instance_;
class AggSpec_AggSpecLast;
struct AggSpec_AggSpecLastDefaultTypeInternal;
extern AggSpec_AggSpecLastDefaultTypeInternal _AggSpec_AggSpecLast_default_instance_;
class AggSpec_AggSpecMax;
struct AggSpec_AggSpecMaxDefaultTypeInternal;
extern AggSpec_AggSpecMaxDefaultTypeInternal _AggSpec_AggSpecMax_default_instance_;
class AggSpec_AggSpecMedian;
struct AggSpec_AggSpecMedianDefaultTypeInternal;
extern AggSpec_AggSpecMedianDefaultTypeInternal _AggSpec_AggSpecMedian_default_instance_;
class AggSpec_AggSpecMin;
struct AggSpec_AggSpecMinDefaultTypeInternal;
extern AggSpec_AggSpecMinDefaultTypeInternal _AggSpec_AggSpecMin_default_instance_;
class AggSpec_AggSpecNonUniqueSentinel;
struct AggSpec_AggSpecNonUniqueSentinelDefaultTypeInternal;
extern AggSpec_AggSpecNonUniqueSentinelDefaultTypeInternal _AggSpec_AggSpecNonUniqueSentinel_default_instance_;
class AggSpec_AggSpecPercentile;
struct AggSpec_AggSpecPercentileDefaultTypeInternal;
extern AggSpec_AggSpecPercentileDefaultTypeInternal _AggSpec_AggSpecPercentile_default_instance_;
class AggSpec_AggSpecSorted;
struct AggSpec_AggSpecSortedDefaultTypeInternal;
extern AggSpec_AggSpecSortedDefaultTypeInternal _AggSpec_AggSpecSorted_default_instance_;
class AggSpec_AggSpecSortedColumn;
struct AggSpec_AggSpecSortedColumnDefaultTypeInternal;
extern AggSpec_AggSpecSortedColumnDefaultTypeInternal _AggSpec_AggSpecSortedColumn_default_instance_;
class AggSpec_AggSpecStd;
struct AggSpec_AggSpecStdDefaultTypeInternal;
extern AggSpec_AggSpecStdDefaultTypeInternal _AggSpec_AggSpecStd_default_instance_;
class AggSpec_AggSpecSum;
struct AggSpec_AggSpecSumDefaultTypeInternal;
extern AggSpec_AggSpecSumDefaultTypeInternal _AggSpec_AggSpecSum_default_instance_;
class AggSpec_AggSpecTDigest;
struct AggSpec_AggSpecTDigestDefaultTypeInternal;
extern AggSpec_AggSpecTDigestDefaultTypeInternal _AggSpec_AggSpecTDigest_default_instance_;
class AggSpec_AggSpecUnique;
struct AggSpec_AggSpecUniqueDefaultTypeInternal;
extern AggSpec_AggSpecUniqueDefaultTypeInternal _AggSpec_AggSpecUnique_default_instance_;
class AggSpec_AggSpecVar;
struct AggSpec_AggSpecVarDefaultTypeInternal;
extern AggSpec_AggSpecVarDefaultTypeInternal _AggSpec_AggSpecVar_default_instance_;
class AggSpec_AggSpecWeighted;
struct AggSpec_AggSpecWeightedDefaultTypeInternal;
extern AggSpec_AggSpecWeightedDefaultTypeInternal _AggSpec_AggSpecWeighted_default_instance_;
class AggregateAllRequest;
struct AggregateAllRequestDefaultTypeInternal;
extern AggregateAllRequestDefaultTypeInternal _AggregateAllRequest_default_instance_;
class AggregateRequest;
struct AggregateRequestDefaultTypeInternal;
extern AggregateRequestDefaultTypeInternal _AggregateRequest_default_instance_;
class Aggregation;
struct AggregationDefaultTypeInternal;
extern AggregationDefaultTypeInternal _Aggregation_default_instance_;
class Aggregation_AggregationColumns;
struct Aggregation_AggregationColumnsDefaultTypeInternal;
extern Aggregation_AggregationColumnsDefaultTypeInternal _Aggregation_AggregationColumns_default_instance_;
class Aggregation_AggregationCount;
struct Aggregation_AggregationCountDefaultTypeInternal;
extern Aggregation_AggregationCountDefaultTypeInternal _Aggregation_AggregationCount_default_instance_;
class Aggregation_AggregationPartition;
struct Aggregation_AggregationPartitionDefaultTypeInternal;
extern Aggregation_AggregationPartitionDefaultTypeInternal _Aggregation_AggregationPartition_default_instance_;
class Aggregation_AggregationRowKey;
struct Aggregation_AggregationRowKeyDefaultTypeInternal;
extern Aggregation_AggregationRowKeyDefaultTypeInternal _Aggregation_AggregationRowKey_default_instance_;
class AjRajTablesRequest;
struct AjRajTablesRequestDefaultTypeInternal;
extern AjRajTablesRequestDefaultTypeInternal _AjRajTablesRequest_default_instance_;
class AndCondition;
struct AndConditionDefaultTypeInternal;
extern AndConditionDefaultTypeInternal _AndCondition_default_instance_;
class ApplyPreviewColumnsRequest;
struct ApplyPreviewColumnsRequestDefaultTypeInternal;
extern ApplyPreviewColumnsRequestDefaultTypeInternal _ApplyPreviewColumnsRequest_default_instance_;
class AsOfJoinTablesRequest;
struct AsOfJoinTablesRequestDefaultTypeInternal;
extern AsOfJoinTablesRequestDefaultTypeInternal _AsOfJoinTablesRequest_default_instance_;
class BatchTableRequest;
struct BatchTableRequestDefaultTypeInternal;
extern BatchTableRequestDefaultTypeInternal _BatchTableRequest_default_instance_;
class BatchTableRequest_Operation;
struct BatchTableRequest_OperationDefaultTypeInternal;
extern BatchTableRequest_OperationDefaultTypeInternal _BatchTableRequest_Operation_default_instance_;
class ColumnStatisticsRequest;
struct ColumnStatisticsRequestDefaultTypeInternal;
extern ColumnStatisticsRequestDefaultTypeInternal _ColumnStatisticsRequest_default_instance_;
class ComboAggregateRequest;
struct ComboAggregateRequestDefaultTypeInternal;
extern ComboAggregateRequestDefaultTypeInternal _ComboAggregateRequest_default_instance_;
class ComboAggregateRequest_Aggregate;
struct ComboAggregateRequest_AggregateDefaultTypeInternal;
extern ComboAggregateRequest_AggregateDefaultTypeInternal _ComboAggregateRequest_Aggregate_default_instance_;
class CompareCondition;
struct CompareConditionDefaultTypeInternal;
extern CompareConditionDefaultTypeInternal _CompareCondition_default_instance_;
class Condition;
struct ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class ContainsCondition;
struct ContainsConditionDefaultTypeInternal;
extern ContainsConditionDefaultTypeInternal _ContainsCondition_default_instance_;
class CreateInputTableRequest;
struct CreateInputTableRequestDefaultTypeInternal;
extern CreateInputTableRequestDefaultTypeInternal _CreateInputTableRequest_default_instance_;
class CreateInputTableRequest_InputTableKind;
struct CreateInputTableRequest_InputTableKindDefaultTypeInternal;
extern CreateInputTableRequest_InputTableKindDefaultTypeInternal _CreateInputTableRequest_InputTableKind_default_instance_;
class CreateInputTableRequest_InputTableKind_Blink;
struct CreateInputTableRequest_InputTableKind_BlinkDefaultTypeInternal;
extern CreateInputTableRequest_InputTableKind_BlinkDefaultTypeInternal _CreateInputTableRequest_InputTableKind_Blink_default_instance_;
class CreateInputTableRequest_InputTableKind_InMemoryAppendOnly;
struct CreateInputTableRequest_InputTableKind_InMemoryAppendOnlyDefaultTypeInternal;
extern CreateInputTableRequest_InputTableKind_InMemoryAppendOnlyDefaultTypeInternal _CreateInputTableRequest_InputTableKind_InMemoryAppendOnly_default_instance_;
class CreateInputTableRequest_InputTableKind_InMemoryKeyBacked;
struct CreateInputTableRequest_InputTableKind_InMemoryKeyBackedDefaultTypeInternal;
extern CreateInputTableRequest_InputTableKind_InMemoryKeyBackedDefaultTypeInternal _CreateInputTableRequest_InputTableKind_InMemoryKeyBacked_default_instance_;
class CrossJoinTablesRequest;
struct CrossJoinTablesRequestDefaultTypeInternal;
extern CrossJoinTablesRequestDefaultTypeInternal _CrossJoinTablesRequest_default_instance_;
class DropColumnsRequest;
struct DropColumnsRequestDefaultTypeInternal;
extern DropColumnsRequestDefaultTypeInternal _DropColumnsRequest_default_instance_;
class EmptyTableRequest;
struct EmptyTableRequestDefaultTypeInternal;
extern EmptyTableRequestDefaultTypeInternal _EmptyTableRequest_default_instance_;
class ExactJoinTablesRequest;
struct ExactJoinTablesRequestDefaultTypeInternal;
extern ExactJoinTablesRequestDefaultTypeInternal _ExactJoinTablesRequest_default_instance_;
class ExportedTableCreationResponse;
struct ExportedTableCreationResponseDefaultTypeInternal;
extern ExportedTableCreationResponseDefaultTypeInternal _ExportedTableCreationResponse_default_instance_;
class ExportedTableUpdateMessage;
struct ExportedTableUpdateMessageDefaultTypeInternal;
extern ExportedTableUpdateMessageDefaultTypeInternal _ExportedTableUpdateMessage_default_instance_;
class ExportedTableUpdatesRequest;
struct ExportedTableUpdatesRequestDefaultTypeInternal;
extern ExportedTableUpdatesRequestDefaultTypeInternal _ExportedTableUpdatesRequest_default_instance_;
class FetchTableRequest;
struct FetchTableRequestDefaultTypeInternal;
extern FetchTableRequestDefaultTypeInternal _FetchTableRequest_default_instance_;
class FilterTableRequest;
struct FilterTableRequestDefaultTypeInternal;
extern FilterTableRequestDefaultTypeInternal _FilterTableRequest_default_instance_;
class FlattenRequest;
struct FlattenRequestDefaultTypeInternal;
extern FlattenRequestDefaultTypeInternal _FlattenRequest_default_instance_;
class HeadOrTailByRequest;
struct HeadOrTailByRequestDefaultTypeInternal;
extern HeadOrTailByRequestDefaultTypeInternal _HeadOrTailByRequest_default_instance_;
class HeadOrTailRequest;
struct HeadOrTailRequestDefaultTypeInternal;
extern HeadOrTailRequestDefaultTypeInternal _HeadOrTailRequest_default_instance_;
class InCondition;
struct InConditionDefaultTypeInternal;
extern InConditionDefaultTypeInternal _InCondition_default_instance_;
class InvokeCondition;
struct InvokeConditionDefaultTypeInternal;
extern InvokeConditionDefaultTypeInternal _InvokeCondition_default_instance_;
class IsNullCondition;
struct IsNullConditionDefaultTypeInternal;
extern IsNullConditionDefaultTypeInternal _IsNullCondition_default_instance_;
class LeftJoinTablesRequest;
struct LeftJoinTablesRequestDefaultTypeInternal;
extern LeftJoinTablesRequestDefaultTypeInternal _LeftJoinTablesRequest_default_instance_;
class Literal;
struct LiteralDefaultTypeInternal;
extern LiteralDefaultTypeInternal _Literal_default_instance_;
class MatchesCondition;
struct MatchesConditionDefaultTypeInternal;
extern MatchesConditionDefaultTypeInternal _MatchesCondition_default_instance_;
class MathContext;
struct MathContextDefaultTypeInternal;
extern MathContextDefaultTypeInternal _MathContext_default_instance_;
class MergeTablesRequest;
struct MergeTablesRequestDefaultTypeInternal;
extern MergeTablesRequestDefaultTypeInternal _MergeTablesRequest_default_instance_;
class MetaTableRequest;
struct MetaTableRequestDefaultTypeInternal;
extern MetaTableRequestDefaultTypeInternal _MetaTableRequest_default_instance_;
class MultiJoinInput;
struct MultiJoinInputDefaultTypeInternal;
extern MultiJoinInputDefaultTypeInternal _MultiJoinInput_default_instance_;
class MultiJoinTablesRequest;
struct MultiJoinTablesRequestDefaultTypeInternal;
extern MultiJoinTablesRequestDefaultTypeInternal _MultiJoinTablesRequest_default_instance_;
class NaturalJoinTablesRequest;
struct NaturalJoinTablesRequestDefaultTypeInternal;
extern NaturalJoinTablesRequestDefaultTypeInternal _NaturalJoinTablesRequest_default_instance_;
class NotCondition;
struct NotConditionDefaultTypeInternal;
extern NotConditionDefaultTypeInternal _NotCondition_default_instance_;
class OrCondition;
struct OrConditionDefaultTypeInternal;
extern OrConditionDefaultTypeInternal _OrCondition_default_instance_;
class RangeJoinTablesRequest;
struct RangeJoinTablesRequestDefaultTypeInternal;
extern RangeJoinTablesRequestDefaultTypeInternal _RangeJoinTablesRequest_default_instance_;
class Reference;
struct ReferenceDefaultTypeInternal;
extern ReferenceDefaultTypeInternal _Reference_default_instance_;
class RunChartDownsampleRequest;
struct RunChartDownsampleRequestDefaultTypeInternal;
extern RunChartDownsampleRequestDefaultTypeInternal _RunChartDownsampleRequest_default_instance_;
class RunChartDownsampleRequest_ZoomRange;
struct RunChartDownsampleRequest_ZoomRangeDefaultTypeInternal;
extern RunChartDownsampleRequest_ZoomRangeDefaultTypeInternal _RunChartDownsampleRequest_ZoomRange_default_instance_;
class SearchCondition;
struct SearchConditionDefaultTypeInternal;
extern SearchConditionDefaultTypeInternal _SearchCondition_default_instance_;
class SeekRowRequest;
struct SeekRowRequestDefaultTypeInternal;
extern SeekRowRequestDefaultTypeInternal _SeekRowRequest_default_instance_;
class SeekRowResponse;
struct SeekRowResponseDefaultTypeInternal;
extern SeekRowResponseDefaultTypeInternal _SeekRowResponse_default_instance_;
class SelectDistinctRequest;
struct SelectDistinctRequestDefaultTypeInternal;
extern SelectDistinctRequestDefaultTypeInternal _SelectDistinctRequest_default_instance_;
class SelectOrUpdateRequest;
struct SelectOrUpdateRequestDefaultTypeInternal;
extern SelectOrUpdateRequestDefaultTypeInternal _SelectOrUpdateRequest_default_instance_;
class SnapshotTableRequest;
struct SnapshotTableRequestDefaultTypeInternal;
extern SnapshotTableRequestDefaultTypeInternal _SnapshotTableRequest_default_instance_;
class SnapshotWhenTableRequest;
struct SnapshotWhenTableRequestDefaultTypeInternal;
extern SnapshotWhenTableRequestDefaultTypeInternal _SnapshotWhenTableRequest_default_instance_;
class SortDescriptor;
struct SortDescriptorDefaultTypeInternal;
extern SortDescriptorDefaultTypeInternal _SortDescriptor_default_instance_;
class SortTableRequest;
struct SortTableRequestDefaultTypeInternal;
extern SortTableRequestDefaultTypeInternal _SortTableRequest_default_instance_;
class TableReference;
struct TableReferenceDefaultTypeInternal;
extern TableReferenceDefaultTypeInternal _TableReference_default_instance_;
class TimeTableRequest;
struct TimeTableRequestDefaultTypeInternal;
extern TimeTableRequestDefaultTypeInternal _TimeTableRequest_default_instance_;
class UngroupRequest;
struct UngroupRequestDefaultTypeInternal;
extern UngroupRequestDefaultTypeInternal _UngroupRequest_default_instance_;
class UnstructuredFilterTableRequest;
struct UnstructuredFilterTableRequestDefaultTypeInternal;
extern UnstructuredFilterTableRequestDefaultTypeInternal _UnstructuredFilterTableRequest_default_instance_;
class UpdateByDeltaOptions;
struct UpdateByDeltaOptionsDefaultTypeInternal;
extern UpdateByDeltaOptionsDefaultTypeInternal _UpdateByDeltaOptions_default_instance_;
class UpdateByEmOptions;
struct UpdateByEmOptionsDefaultTypeInternal;
extern UpdateByEmOptionsDefaultTypeInternal _UpdateByEmOptions_default_instance_;
class UpdateByRequest;
struct UpdateByRequestDefaultTypeInternal;
extern UpdateByRequestDefaultTypeInternal _UpdateByRequest_default_instance_;
class UpdateByRequest_UpdateByOperation;
struct UpdateByRequest_UpdateByOperationDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperationDefaultTypeInternal _UpdateByRequest_UpdateByOperation_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn;
struct UpdateByRequest_UpdateByOperation_UpdateByColumnDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumnDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpecDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpecDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMaxDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMaxDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMinDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMinDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProductDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProductDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSumDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSumDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDeltaDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDeltaDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMaxDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMaxDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMinDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMinDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStdDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStdDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmaDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmaDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmsDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmsDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFillDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFillDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvgDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvgDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCountDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCountDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormulaDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormulaDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroupDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroupDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMaxDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMaxDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMinDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMinDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProductDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProductDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStdDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStdDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSumDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSumDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum_default_instance_;
class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg;
struct UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvgDefaultTypeInternal;
extern UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvgDefaultTypeInternal _UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg_default_instance_;
class UpdateByRequest_UpdateByOptions;
struct UpdateByRequest_UpdateByOptionsDefaultTypeInternal;
extern UpdateByRequest_UpdateByOptionsDefaultTypeInternal _UpdateByRequest_UpdateByOptions_default_instance_;
class UpdateByWindowScale;
struct UpdateByWindowScaleDefaultTypeInternal;
extern UpdateByWindowScaleDefaultTypeInternal _UpdateByWindowScale_default_instance_;
class UpdateByWindowScale_UpdateByWindowTicks;
struct UpdateByWindowScale_UpdateByWindowTicksDefaultTypeInternal;
extern UpdateByWindowScale_UpdateByWindowTicksDefaultTypeInternal _UpdateByWindowScale_UpdateByWindowTicks_default_instance_;
class UpdateByWindowScale_UpdateByWindowTime;
struct UpdateByWindowScale_UpdateByWindowTimeDefaultTypeInternal;
extern UpdateByWindowScale_UpdateByWindowTimeDefaultTypeInternal _UpdateByWindowScale_UpdateByWindowTime_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class WhereInRequest;
struct WhereInRequestDefaultTypeInternal;
extern WhereInRequestDefaultTypeInternal _WhereInRequest_default_instance_;
}  // namespace grpc
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace io {
namespace deephaven {
namespace proto {
namespace backplane {
namespace grpc {
enum MathContext_RoundingMode : int {
  MathContext_RoundingMode_ROUNDING_MODE_NOT_SPECIFIED = 0,
  MathContext_RoundingMode_UP = 1,
  MathContext_RoundingMode_DOWN = 2,
  MathContext_RoundingMode_CEILING = 3,
  MathContext_RoundingMode_FLOOR = 4,
  MathContext_RoundingMode_HALF_UP = 5,
  MathContext_RoundingMode_HALF_DOWN = 6,
  MathContext_RoundingMode_HALF_EVEN = 7,
  MathContext_RoundingMode_UNNECESSARY = 8,
  MathContext_RoundingMode_MathContext_RoundingMode_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MathContext_RoundingMode_MathContext_RoundingMode_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MathContext_RoundingMode_IsValid(int value);
extern const uint32_t MathContext_RoundingMode_internal_data_[];
constexpr MathContext_RoundingMode MathContext_RoundingMode_RoundingMode_MIN = static_cast<MathContext_RoundingMode>(0);
constexpr MathContext_RoundingMode MathContext_RoundingMode_RoundingMode_MAX = static_cast<MathContext_RoundingMode>(8);
constexpr int MathContext_RoundingMode_RoundingMode_ARRAYSIZE = 8 + 1;
const ::google::protobuf::EnumDescriptor*
MathContext_RoundingMode_descriptor();
template <typename T>
const std::string& MathContext_RoundingMode_Name(T value) {
  static_assert(std::is_same<T, MathContext_RoundingMode>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RoundingMode_Name().");
  return MathContext_RoundingMode_Name(static_cast<MathContext_RoundingMode>(value));
}
template <>
inline const std::string& MathContext_RoundingMode_Name(MathContext_RoundingMode value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MathContext_RoundingMode_descriptor,
                                                 0, 8>(
      static_cast<int>(value));
}
inline bool MathContext_RoundingMode_Parse(absl::string_view name, MathContext_RoundingMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MathContext_RoundingMode>(
      MathContext_RoundingMode_descriptor(), name, value);
}
enum AsOfJoinTablesRequest_MatchRule : int {
  AsOfJoinTablesRequest_MatchRule_LESS_THAN_EQUAL = 0,
  AsOfJoinTablesRequest_MatchRule_LESS_THAN = 1,
  AsOfJoinTablesRequest_MatchRule_GREATER_THAN_EQUAL = 2,
  AsOfJoinTablesRequest_MatchRule_GREATER_THAN = 3,
  AsOfJoinTablesRequest_MatchRule_AsOfJoinTablesRequest_MatchRule_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  AsOfJoinTablesRequest_MatchRule_AsOfJoinTablesRequest_MatchRule_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool AsOfJoinTablesRequest_MatchRule_IsValid(int value);
extern const uint32_t AsOfJoinTablesRequest_MatchRule_internal_data_[];
constexpr AsOfJoinTablesRequest_MatchRule AsOfJoinTablesRequest_MatchRule_MatchRule_MIN = static_cast<AsOfJoinTablesRequest_MatchRule>(0);
constexpr AsOfJoinTablesRequest_MatchRule AsOfJoinTablesRequest_MatchRule_MatchRule_MAX = static_cast<AsOfJoinTablesRequest_MatchRule>(3);
constexpr int AsOfJoinTablesRequest_MatchRule_MatchRule_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
AsOfJoinTablesRequest_MatchRule_descriptor();
template <typename T>
const std::string& AsOfJoinTablesRequest_MatchRule_Name(T value) {
  static_assert(std::is_same<T, AsOfJoinTablesRequest_MatchRule>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MatchRule_Name().");
  return AsOfJoinTablesRequest_MatchRule_Name(static_cast<AsOfJoinTablesRequest_MatchRule>(value));
}
template <>
inline const std::string& AsOfJoinTablesRequest_MatchRule_Name(AsOfJoinTablesRequest_MatchRule value) {
  return ::google::protobuf::internal::NameOfDenseEnum<AsOfJoinTablesRequest_MatchRule_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool AsOfJoinTablesRequest_MatchRule_Parse(absl::string_view name, AsOfJoinTablesRequest_MatchRule* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AsOfJoinTablesRequest_MatchRule>(
      AsOfJoinTablesRequest_MatchRule_descriptor(), name, value);
}
enum RangeJoinTablesRequest_RangeStartRule : int {
  RangeJoinTablesRequest_RangeStartRule_START_UNSPECIFIED = 0,
  RangeJoinTablesRequest_RangeStartRule_LESS_THAN = 1,
  RangeJoinTablesRequest_RangeStartRule_LESS_THAN_OR_EQUAL = 2,
  RangeJoinTablesRequest_RangeStartRule_LESS_THAN_OR_EQUAL_ALLOW_PRECEDING = 3,
  RangeJoinTablesRequest_RangeStartRule_RangeJoinTablesRequest_RangeStartRule_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RangeJoinTablesRequest_RangeStartRule_RangeJoinTablesRequest_RangeStartRule_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RangeJoinTablesRequest_RangeStartRule_IsValid(int value);
extern const uint32_t RangeJoinTablesRequest_RangeStartRule_internal_data_[];
constexpr RangeJoinTablesRequest_RangeStartRule RangeJoinTablesRequest_RangeStartRule_RangeStartRule_MIN = static_cast<RangeJoinTablesRequest_RangeStartRule>(0);
constexpr RangeJoinTablesRequest_RangeStartRule RangeJoinTablesRequest_RangeStartRule_RangeStartRule_MAX = static_cast<RangeJoinTablesRequest_RangeStartRule>(3);
constexpr int RangeJoinTablesRequest_RangeStartRule_RangeStartRule_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
RangeJoinTablesRequest_RangeStartRule_descriptor();
template <typename T>
const std::string& RangeJoinTablesRequest_RangeStartRule_Name(T value) {
  static_assert(std::is_same<T, RangeJoinTablesRequest_RangeStartRule>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RangeStartRule_Name().");
  return RangeJoinTablesRequest_RangeStartRule_Name(static_cast<RangeJoinTablesRequest_RangeStartRule>(value));
}
template <>
inline const std::string& RangeJoinTablesRequest_RangeStartRule_Name(RangeJoinTablesRequest_RangeStartRule value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RangeJoinTablesRequest_RangeStartRule_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool RangeJoinTablesRequest_RangeStartRule_Parse(absl::string_view name, RangeJoinTablesRequest_RangeStartRule* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RangeJoinTablesRequest_RangeStartRule>(
      RangeJoinTablesRequest_RangeStartRule_descriptor(), name, value);
}
enum RangeJoinTablesRequest_RangeEndRule : int {
  RangeJoinTablesRequest_RangeEndRule_END_UNSPECIFIED = 0,
  RangeJoinTablesRequest_RangeEndRule_GREATER_THAN = 1,
  RangeJoinTablesRequest_RangeEndRule_GREATER_THAN_OR_EQUAL = 2,
  RangeJoinTablesRequest_RangeEndRule_GREATER_THAN_OR_EQUAL_ALLOW_FOLLOWING = 3,
  RangeJoinTablesRequest_RangeEndRule_RangeJoinTablesRequest_RangeEndRule_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  RangeJoinTablesRequest_RangeEndRule_RangeJoinTablesRequest_RangeEndRule_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool RangeJoinTablesRequest_RangeEndRule_IsValid(int value);
extern const uint32_t RangeJoinTablesRequest_RangeEndRule_internal_data_[];
constexpr RangeJoinTablesRequest_RangeEndRule RangeJoinTablesRequest_RangeEndRule_RangeEndRule_MIN = static_cast<RangeJoinTablesRequest_RangeEndRule>(0);
constexpr RangeJoinTablesRequest_RangeEndRule RangeJoinTablesRequest_RangeEndRule_RangeEndRule_MAX = static_cast<RangeJoinTablesRequest_RangeEndRule>(3);
constexpr int RangeJoinTablesRequest_RangeEndRule_RangeEndRule_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
RangeJoinTablesRequest_RangeEndRule_descriptor();
template <typename T>
const std::string& RangeJoinTablesRequest_RangeEndRule_Name(T value) {
  static_assert(std::is_same<T, RangeJoinTablesRequest_RangeEndRule>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RangeEndRule_Name().");
  return RangeJoinTablesRequest_RangeEndRule_Name(static_cast<RangeJoinTablesRequest_RangeEndRule>(value));
}
template <>
inline const std::string& RangeJoinTablesRequest_RangeEndRule_Name(RangeJoinTablesRequest_RangeEndRule value) {
  return ::google::protobuf::internal::NameOfDenseEnum<RangeJoinTablesRequest_RangeEndRule_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool RangeJoinTablesRequest_RangeEndRule_Parse(absl::string_view name, RangeJoinTablesRequest_RangeEndRule* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RangeJoinTablesRequest_RangeEndRule>(
      RangeJoinTablesRequest_RangeEndRule_descriptor(), name, value);
}
enum ComboAggregateRequest_AggType : int {
  ComboAggregateRequest_AggType_SUM = 0,
  ComboAggregateRequest_AggType_ABS_SUM = 1,
  ComboAggregateRequest_AggType_GROUP = 2,
  ComboAggregateRequest_AggType_AVG = 3,
  ComboAggregateRequest_AggType_COUNT = 4,
  ComboAggregateRequest_AggType_FIRST = 5,
  ComboAggregateRequest_AggType_LAST = 6,
  ComboAggregateRequest_AggType_MIN = 7,
  ComboAggregateRequest_AggType_MAX = 8,
  ComboAggregateRequest_AggType_MEDIAN = 9,
  ComboAggregateRequest_AggType_PERCENTILE = 10,
  ComboAggregateRequest_AggType_STD = 11,
  ComboAggregateRequest_AggType_VAR = 12,
  ComboAggregateRequest_AggType_WEIGHTED_AVG = 13,
  ComboAggregateRequest_AggType_ComboAggregateRequest_AggType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  ComboAggregateRequest_AggType_ComboAggregateRequest_AggType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool ComboAggregateRequest_AggType_IsValid(int value);
extern const uint32_t ComboAggregateRequest_AggType_internal_data_[];
constexpr ComboAggregateRequest_AggType ComboAggregateRequest_AggType_AggType_MIN = static_cast<ComboAggregateRequest_AggType>(0);
constexpr ComboAggregateRequest_AggType ComboAggregateRequest_AggType_AggType_MAX = static_cast<ComboAggregateRequest_AggType>(13);
constexpr int ComboAggregateRequest_AggType_AggType_ARRAYSIZE = 13 + 1;
const ::google::protobuf::EnumDescriptor*
ComboAggregateRequest_AggType_descriptor();
template <typename T>
const std::string& ComboAggregateRequest_AggType_Name(T value) {
  static_assert(std::is_same<T, ComboAggregateRequest_AggType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to AggType_Name().");
  return ComboAggregateRequest_AggType_Name(static_cast<ComboAggregateRequest_AggType>(value));
}
template <>
inline const std::string& ComboAggregateRequest_AggType_Name(ComboAggregateRequest_AggType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<ComboAggregateRequest_AggType_descriptor,
                                                 0, 13>(
      static_cast<int>(value));
}
inline bool ComboAggregateRequest_AggType_Parse(absl::string_view name, ComboAggregateRequest_AggType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComboAggregateRequest_AggType>(
      ComboAggregateRequest_AggType_descriptor(), name, value);
}
enum SortDescriptor_SortDirection : int {
  SortDescriptor_SortDirection_UNKNOWN = 0,
  SortDescriptor_SortDirection_DESCENDING = -1,
  SortDescriptor_SortDirection_ASCENDING = 1,
  SortDescriptor_SortDirection_REVERSE = 2,
  SortDescriptor_SortDirection_SortDescriptor_SortDirection_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SortDescriptor_SortDirection_SortDescriptor_SortDirection_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SortDescriptor_SortDirection_IsValid(int value);
extern const uint32_t SortDescriptor_SortDirection_internal_data_[];
constexpr SortDescriptor_SortDirection SortDescriptor_SortDirection_SortDirection_MIN = static_cast<SortDescriptor_SortDirection>(-1);
constexpr SortDescriptor_SortDirection SortDescriptor_SortDirection_SortDirection_MAX = static_cast<SortDescriptor_SortDirection>(2);
constexpr int SortDescriptor_SortDirection_SortDirection_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SortDescriptor_SortDirection_descriptor();
template <typename T>
const std::string& SortDescriptor_SortDirection_Name(T value) {
  static_assert(std::is_same<T, SortDescriptor_SortDirection>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SortDirection_Name().");
  return SortDescriptor_SortDirection_Name(static_cast<SortDescriptor_SortDirection>(value));
}
template <>
inline const std::string& SortDescriptor_SortDirection_Name(SortDescriptor_SortDirection value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SortDescriptor_SortDirection_descriptor,
                                                 -1, 2>(
      static_cast<int>(value));
}
inline bool SortDescriptor_SortDirection_Parse(absl::string_view name, SortDescriptor_SortDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SortDescriptor_SortDirection>(
      SortDescriptor_SortDirection_descriptor(), name, value);
}
enum CompareCondition_CompareOperation : int {
  CompareCondition_CompareOperation_LESS_THAN = 0,
  CompareCondition_CompareOperation_LESS_THAN_OR_EQUAL = 1,
  CompareCondition_CompareOperation_GREATER_THAN = 2,
  CompareCondition_CompareOperation_GREATER_THAN_OR_EQUAL = 3,
  CompareCondition_CompareOperation_EQUALS = 4,
  CompareCondition_CompareOperation_NOT_EQUALS = 5,
  CompareCondition_CompareOperation_CompareCondition_CompareOperation_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CompareCondition_CompareOperation_CompareCondition_CompareOperation_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CompareCondition_CompareOperation_IsValid(int value);
extern const uint32_t CompareCondition_CompareOperation_internal_data_[];
constexpr CompareCondition_CompareOperation CompareCondition_CompareOperation_CompareOperation_MIN = static_cast<CompareCondition_CompareOperation>(0);
constexpr CompareCondition_CompareOperation CompareCondition_CompareOperation_CompareOperation_MAX = static_cast<CompareCondition_CompareOperation>(5);
constexpr int CompareCondition_CompareOperation_CompareOperation_ARRAYSIZE = 5 + 1;
const ::google::protobuf::EnumDescriptor*
CompareCondition_CompareOperation_descriptor();
template <typename T>
const std::string& CompareCondition_CompareOperation_Name(T value) {
  static_assert(std::is_same<T, CompareCondition_CompareOperation>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CompareOperation_Name().");
  return CompareCondition_CompareOperation_Name(static_cast<CompareCondition_CompareOperation>(value));
}
template <>
inline const std::string& CompareCondition_CompareOperation_Name(CompareCondition_CompareOperation value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CompareCondition_CompareOperation_descriptor,
                                                 0, 5>(
      static_cast<int>(value));
}
inline bool CompareCondition_CompareOperation_Parse(absl::string_view name, CompareCondition_CompareOperation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CompareCondition_CompareOperation>(
      CompareCondition_CompareOperation_descriptor(), name, value);
}
enum BadDataBehavior : int {
  BAD_DATA_BEHAVIOR_NOT_SPECIFIED = 0,
  THROW = 1,
  RESET = 2,
  SKIP = 3,
  POISON = 4,
  BadDataBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  BadDataBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool BadDataBehavior_IsValid(int value);
extern const uint32_t BadDataBehavior_internal_data_[];
constexpr BadDataBehavior BadDataBehavior_MIN = static_cast<BadDataBehavior>(0);
constexpr BadDataBehavior BadDataBehavior_MAX = static_cast<BadDataBehavior>(4);
constexpr int BadDataBehavior_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
BadDataBehavior_descriptor();
template <typename T>
const std::string& BadDataBehavior_Name(T value) {
  static_assert(std::is_same<T, BadDataBehavior>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BadDataBehavior_Name().");
  return BadDataBehavior_Name(static_cast<BadDataBehavior>(value));
}
template <>
inline const std::string& BadDataBehavior_Name(BadDataBehavior value) {
  return ::google::protobuf::internal::NameOfDenseEnum<BadDataBehavior_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool BadDataBehavior_Parse(absl::string_view name, BadDataBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BadDataBehavior>(
      BadDataBehavior_descriptor(), name, value);
}
enum UpdateByNullBehavior : int {
  NULL_BEHAVIOR_NOT_SPECIFIED = 0,
  NULL_DOMINATES = 1,
  VALUE_DOMINATES = 2,
  ZERO_DOMINATES = 3,
  UpdateByNullBehavior_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  UpdateByNullBehavior_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool UpdateByNullBehavior_IsValid(int value);
extern const uint32_t UpdateByNullBehavior_internal_data_[];
constexpr UpdateByNullBehavior UpdateByNullBehavior_MIN = static_cast<UpdateByNullBehavior>(0);
constexpr UpdateByNullBehavior UpdateByNullBehavior_MAX = static_cast<UpdateByNullBehavior>(3);
constexpr int UpdateByNullBehavior_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
UpdateByNullBehavior_descriptor();
template <typename T>
const std::string& UpdateByNullBehavior_Name(T value) {
  static_assert(std::is_same<T, UpdateByNullBehavior>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UpdateByNullBehavior_Name().");
  return UpdateByNullBehavior_Name(static_cast<UpdateByNullBehavior>(value));
}
template <>
inline const std::string& UpdateByNullBehavior_Name(UpdateByNullBehavior value) {
  return ::google::protobuf::internal::NameOfDenseEnum<UpdateByNullBehavior_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool UpdateByNullBehavior_Parse(absl::string_view name, UpdateByNullBehavior* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdateByNullBehavior>(
      UpdateByNullBehavior_descriptor(), name, value);
}
enum NullValue : int {
  NULL_VALUE = 0,
  NullValue_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NullValue_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NullValue_IsValid(int value);
extern const uint32_t NullValue_internal_data_[];
constexpr NullValue NullValue_MIN = static_cast<NullValue>(0);
constexpr NullValue NullValue_MAX = static_cast<NullValue>(0);
constexpr int NullValue_ARRAYSIZE = 0 + 1;
const ::google::protobuf::EnumDescriptor*
NullValue_descriptor();
template <typename T>
const std::string& NullValue_Name(T value) {
  static_assert(std::is_same<T, NullValue>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to NullValue_Name().");
  return NullValue_Name(static_cast<NullValue>(value));
}
template <>
inline const std::string& NullValue_Name(NullValue value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NullValue_descriptor,
                                                 0, 0>(
      static_cast<int>(value));
}
inline bool NullValue_Parse(absl::string_view name, NullValue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NullValue>(
      NullValue_descriptor(), name, value);
}
enum CaseSensitivity : int {
  MATCH_CASE = 0,
  IGNORE_CASE = 1,
  CaseSensitivity_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  CaseSensitivity_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool CaseSensitivity_IsValid(int value);
extern const uint32_t CaseSensitivity_internal_data_[];
constexpr CaseSensitivity CaseSensitivity_MIN = static_cast<CaseSensitivity>(0);
constexpr CaseSensitivity CaseSensitivity_MAX = static_cast<CaseSensitivity>(1);
constexpr int CaseSensitivity_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
CaseSensitivity_descriptor();
template <typename T>
const std::string& CaseSensitivity_Name(T value) {
  static_assert(std::is_same<T, CaseSensitivity>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to CaseSensitivity_Name().");
  return CaseSensitivity_Name(static_cast<CaseSensitivity>(value));
}
template <>
inline const std::string& CaseSensitivity_Name(CaseSensitivity value) {
  return ::google::protobuf::internal::NameOfDenseEnum<CaseSensitivity_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool CaseSensitivity_Parse(absl::string_view name, CaseSensitivity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CaseSensitivity>(
      CaseSensitivity_descriptor(), name, value);
}
enum MatchType : int {
  REGULAR = 0,
  INVERTED = 1,
  MatchType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MatchType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MatchType_IsValid(int value);
extern const uint32_t MatchType_internal_data_[];
constexpr MatchType MatchType_MIN = static_cast<MatchType>(0);
constexpr MatchType MatchType_MAX = static_cast<MatchType>(1);
constexpr int MatchType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
MatchType_descriptor();
template <typename T>
const std::string& MatchType_Name(T value) {
  static_assert(std::is_same<T, MatchType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MatchType_Name().");
  return MatchType_Name(static_cast<MatchType>(value));
}
template <>
inline const std::string& MatchType_Name(MatchType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MatchType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool MatchType_Parse(absl::string_view name, MatchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MatchType>(
      MatchType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class UpdateByWindowScale_UpdateByWindowTime final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime) */ {
 public:
  inline UpdateByWindowScale_UpdateByWindowTime() : UpdateByWindowScale_UpdateByWindowTime(nullptr) {}
  ~UpdateByWindowScale_UpdateByWindowTime() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByWindowScale_UpdateByWindowTime(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByWindowScale_UpdateByWindowTime(const UpdateByWindowScale_UpdateByWindowTime& from)
      : UpdateByWindowScale_UpdateByWindowTime(nullptr, from) {}
  UpdateByWindowScale_UpdateByWindowTime(UpdateByWindowScale_UpdateByWindowTime&& from) noexcept
    : UpdateByWindowScale_UpdateByWindowTime() {
    *this = ::std::move(from);
  }

  inline UpdateByWindowScale_UpdateByWindowTime& operator=(const UpdateByWindowScale_UpdateByWindowTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByWindowScale_UpdateByWindowTime& operator=(UpdateByWindowScale_UpdateByWindowTime&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByWindowScale_UpdateByWindowTime& default_instance() {
    return *internal_default_instance();
  }
  enum WindowCase {
    kNanos = 2,
    kDurationString = 3,
    WINDOW_NOT_SET = 0,
  };

  static inline const UpdateByWindowScale_UpdateByWindowTime* internal_default_instance() {
    return reinterpret_cast<const UpdateByWindowScale_UpdateByWindowTime*>(
               &_UpdateByWindowScale_UpdateByWindowTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(UpdateByWindowScale_UpdateByWindowTime& a, UpdateByWindowScale_UpdateByWindowTime& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByWindowScale_UpdateByWindowTime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByWindowScale_UpdateByWindowTime* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByWindowScale_UpdateByWindowTime* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByWindowScale_UpdateByWindowTime>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByWindowScale_UpdateByWindowTime& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByWindowScale_UpdateByWindowTime& from) {
    UpdateByWindowScale_UpdateByWindowTime::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByWindowScale_UpdateByWindowTime* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime";
  }
  protected:
  explicit UpdateByWindowScale_UpdateByWindowTime(::google::protobuf::Arena* arena);
  UpdateByWindowScale_UpdateByWindowTime(::google::protobuf::Arena* arena, const UpdateByWindowScale_UpdateByWindowTime& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFieldNumber = 1,
    kNanosFieldNumber = 2,
    kDurationStringFieldNumber = 3,
  };
  // string column = 1;
  void clear_column() ;
  const std::string& column() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column(Arg_&& arg, Args_... args);
  std::string* mutable_column();
  PROTOBUF_NODISCARD std::string* release_column();
  void set_allocated_column(std::string* value);

  private:
  const std::string& _internal_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column(
      const std::string& value);
  std::string* _internal_mutable_column();

  public:
  // sint64 nanos = 2 [jstype = JS_STRING];
  bool has_nanos() const;
  void clear_nanos() ;
  ::int64_t nanos() const;
  void set_nanos(::int64_t value);

  private:
  ::int64_t _internal_nanos() const;
  void _internal_set_nanos(::int64_t value);

  public:
  // string duration_string = 3;
  bool has_duration_string() const;
  void clear_duration_string() ;
  const std::string& duration_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_duration_string(Arg_&& arg, Args_... args);
  std::string* mutable_duration_string();
  PROTOBUF_NODISCARD std::string* release_duration_string();
  void set_allocated_duration_string(std::string* value);

  private:
  const std::string& _internal_duration_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_duration_string(
      const std::string& value);
  std::string* _internal_mutable_duration_string();

  public:
  void clear_window();
  WindowCase window_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime)
 private:
  class _Internal;
  void set_has_nanos();
  void set_has_duration_string();

  inline bool has_window() const;
  inline void clear_has_window();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 0,
      102, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr column_;
    union WindowUnion {
      constexpr WindowUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t nanos_;
      ::google::protobuf::internal::ArenaStringPtr duration_string_;
    } window_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByWindowScale_UpdateByWindowTicks final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks) */ {
 public:
  inline UpdateByWindowScale_UpdateByWindowTicks() : UpdateByWindowScale_UpdateByWindowTicks(nullptr) {}
  ~UpdateByWindowScale_UpdateByWindowTicks() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByWindowScale_UpdateByWindowTicks(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByWindowScale_UpdateByWindowTicks(const UpdateByWindowScale_UpdateByWindowTicks& from)
      : UpdateByWindowScale_UpdateByWindowTicks(nullptr, from) {}
  UpdateByWindowScale_UpdateByWindowTicks(UpdateByWindowScale_UpdateByWindowTicks&& from) noexcept
    : UpdateByWindowScale_UpdateByWindowTicks() {
    *this = ::std::move(from);
  }

  inline UpdateByWindowScale_UpdateByWindowTicks& operator=(const UpdateByWindowScale_UpdateByWindowTicks& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByWindowScale_UpdateByWindowTicks& operator=(UpdateByWindowScale_UpdateByWindowTicks&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByWindowScale_UpdateByWindowTicks& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByWindowScale_UpdateByWindowTicks* internal_default_instance() {
    return reinterpret_cast<const UpdateByWindowScale_UpdateByWindowTicks*>(
               &_UpdateByWindowScale_UpdateByWindowTicks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(UpdateByWindowScale_UpdateByWindowTicks& a, UpdateByWindowScale_UpdateByWindowTicks& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByWindowScale_UpdateByWindowTicks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByWindowScale_UpdateByWindowTicks* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByWindowScale_UpdateByWindowTicks* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByWindowScale_UpdateByWindowTicks>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByWindowScale_UpdateByWindowTicks& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByWindowScale_UpdateByWindowTicks& from) {
    UpdateByWindowScale_UpdateByWindowTicks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByWindowScale_UpdateByWindowTicks* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks";
  }
  protected:
  explicit UpdateByWindowScale_UpdateByWindowTicks(::google::protobuf::Arena* arena);
  UpdateByWindowScale_UpdateByWindowTicks(::google::protobuf::Arena* arena, const UpdateByWindowScale_UpdateByWindowTicks& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicksFieldNumber = 1,
  };
  // double ticks = 1;
  void clear_ticks() ;
  double ticks() const;
  void set_ticks(double value);

  private:
  double _internal_ticks() const;
  void _internal_set_ticks(double value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double ticks_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByFill) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByFill";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByFill)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeSum) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeSum";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeSum)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeProduct) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeProduct";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeProduct)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMin) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMin";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMin)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMax) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMax";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMax)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByDeltaOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions) */ {
 public:
  inline UpdateByDeltaOptions() : UpdateByDeltaOptions(nullptr) {}
  ~UpdateByDeltaOptions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByDeltaOptions(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByDeltaOptions(const UpdateByDeltaOptions& from)
      : UpdateByDeltaOptions(nullptr, from) {}
  UpdateByDeltaOptions(UpdateByDeltaOptions&& from) noexcept
    : UpdateByDeltaOptions() {
    *this = ::std::move(from);
  }

  inline UpdateByDeltaOptions& operator=(const UpdateByDeltaOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByDeltaOptions& operator=(UpdateByDeltaOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByDeltaOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByDeltaOptions* internal_default_instance() {
    return reinterpret_cast<const UpdateByDeltaOptions*>(
               &_UpdateByDeltaOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(UpdateByDeltaOptions& a, UpdateByDeltaOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByDeltaOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByDeltaOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByDeltaOptions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByDeltaOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByDeltaOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByDeltaOptions& from) {
    UpdateByDeltaOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByDeltaOptions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions";
  }
  protected:
  explicit UpdateByDeltaOptions(::google::protobuf::Arena* arena);
  UpdateByDeltaOptions(::google::protobuf::Arena* arena, const UpdateByDeltaOptions& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNullBehaviorFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByNullBehavior null_behavior = 1;
  void clear_null_behavior() ;
  ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior null_behavior() const;
  void set_null_behavior(::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior value);

  private:
  ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior _internal_null_behavior() const;
  void _internal_set_null_behavior(::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int null_behavior_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class SortDescriptor final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SortDescriptor) */ {
 public:
  inline SortDescriptor() : SortDescriptor(nullptr) {}
  ~SortDescriptor() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SortDescriptor(::google::protobuf::internal::ConstantInitialized);

  inline SortDescriptor(const SortDescriptor& from)
      : SortDescriptor(nullptr, from) {}
  SortDescriptor(SortDescriptor&& from) noexcept
    : SortDescriptor() {
    *this = ::std::move(from);
  }

  inline SortDescriptor& operator=(const SortDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortDescriptor& operator=(SortDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const SortDescriptor* internal_default_instance() {
    return reinterpret_cast<const SortDescriptor*>(
               &_SortDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(SortDescriptor& a, SortDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(SortDescriptor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortDescriptor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SortDescriptor* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SortDescriptor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SortDescriptor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SortDescriptor& from) {
    SortDescriptor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SortDescriptor* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SortDescriptor";
  }
  protected:
  explicit SortDescriptor(::google::protobuf::Arena* arena);
  SortDescriptor(::google::protobuf::Arena* arena, const SortDescriptor& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using SortDirection = SortDescriptor_SortDirection;
  static constexpr SortDirection UNKNOWN = SortDescriptor_SortDirection_UNKNOWN;
  static constexpr SortDirection DESCENDING = SortDescriptor_SortDirection_DESCENDING;
  static constexpr SortDirection ASCENDING = SortDescriptor_SortDirection_ASCENDING;
  static constexpr SortDirection REVERSE = SortDescriptor_SortDirection_REVERSE;
  static inline bool SortDirection_IsValid(int value) {
    return SortDescriptor_SortDirection_IsValid(value);
  }
  static constexpr SortDirection SortDirection_MIN = SortDescriptor_SortDirection_SortDirection_MIN;
  static constexpr SortDirection SortDirection_MAX = SortDescriptor_SortDirection_SortDirection_MAX;
  static constexpr int SortDirection_ARRAYSIZE = SortDescriptor_SortDirection_SortDirection_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* SortDirection_descriptor() {
    return SortDescriptor_SortDirection_descriptor();
  }
  template <typename T>
  static inline const std::string& SortDirection_Name(T value) {
    return SortDescriptor_SortDirection_Name(value);
  }
  static inline bool SortDirection_Parse(absl::string_view name, SortDirection* value) {
    return SortDescriptor_SortDirection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
    kIsAbsoluteFieldNumber = 2,
    kDirectionFieldNumber = 3,
  };
  // string column_name = 1;
  void clear_column_name() ;
  const std::string& column_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* value);

  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(
      const std::string& value);
  std::string* _internal_mutable_column_name();

  public:
  // bool is_absolute = 2;
  void clear_is_absolute() ;
  bool is_absolute() const;
  void set_is_absolute(bool value);

  private:
  bool _internal_is_absolute() const;
  void _internal_set_is_absolute(bool value);

  public:
  // .io.deephaven.proto.backplane.grpc.SortDescriptor.SortDirection direction = 3;
  void clear_direction() ;
  ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection direction() const;
  void set_direction(::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection value);

  private:
  ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection _internal_direction() const;
  void _internal_set_direction(::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SortDescriptor)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr column_name_;
    bool is_absolute_;
    int direction_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class SeekRowResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SeekRowResponse) */ {
 public:
  inline SeekRowResponse() : SeekRowResponse(nullptr) {}
  ~SeekRowResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SeekRowResponse(::google::protobuf::internal::ConstantInitialized);

  inline SeekRowResponse(const SeekRowResponse& from)
      : SeekRowResponse(nullptr, from) {}
  SeekRowResponse(SeekRowResponse&& from) noexcept
    : SeekRowResponse() {
    *this = ::std::move(from);
  }

  inline SeekRowResponse& operator=(const SeekRowResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeekRowResponse& operator=(SeekRowResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeekRowResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeekRowResponse* internal_default_instance() {
    return reinterpret_cast<const SeekRowResponse*>(
               &_SeekRowResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(SeekRowResponse& a, SeekRowResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SeekRowResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeekRowResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SeekRowResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SeekRowResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SeekRowResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SeekRowResponse& from) {
    SeekRowResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SeekRowResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SeekRowResponse";
  }
  protected:
  explicit SeekRowResponse(::google::protobuf::Arena* arena);
  SeekRowResponse(::google::protobuf::Arena* arena, const SeekRowResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultRowFieldNumber = 1,
  };
  // sint64 result_row = 1 [jstype = JS_STRING];
  void clear_result_row() ;
  ::int64_t result_row() const;
  void set_result_row(::int64_t value);

  private:
  ::int64_t _internal_result_row() const;
  void _internal_set_result_row(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SeekRowResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int64_t result_row_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class RunChartDownsampleRequest_ZoomRange final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange) */ {
 public:
  inline RunChartDownsampleRequest_ZoomRange() : RunChartDownsampleRequest_ZoomRange(nullptr) {}
  ~RunChartDownsampleRequest_ZoomRange() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RunChartDownsampleRequest_ZoomRange(::google::protobuf::internal::ConstantInitialized);

  inline RunChartDownsampleRequest_ZoomRange(const RunChartDownsampleRequest_ZoomRange& from)
      : RunChartDownsampleRequest_ZoomRange(nullptr, from) {}
  RunChartDownsampleRequest_ZoomRange(RunChartDownsampleRequest_ZoomRange&& from) noexcept
    : RunChartDownsampleRequest_ZoomRange() {
    *this = ::std::move(from);
  }

  inline RunChartDownsampleRequest_ZoomRange& operator=(const RunChartDownsampleRequest_ZoomRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunChartDownsampleRequest_ZoomRange& operator=(RunChartDownsampleRequest_ZoomRange&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunChartDownsampleRequest_ZoomRange& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunChartDownsampleRequest_ZoomRange* internal_default_instance() {
    return reinterpret_cast<const RunChartDownsampleRequest_ZoomRange*>(
               &_RunChartDownsampleRequest_ZoomRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    113;

  friend void swap(RunChartDownsampleRequest_ZoomRange& a, RunChartDownsampleRequest_ZoomRange& b) {
    a.Swap(&b);
  }
  inline void Swap(RunChartDownsampleRequest_ZoomRange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunChartDownsampleRequest_ZoomRange* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunChartDownsampleRequest_ZoomRange* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunChartDownsampleRequest_ZoomRange>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RunChartDownsampleRequest_ZoomRange& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RunChartDownsampleRequest_ZoomRange& from) {
    RunChartDownsampleRequest_ZoomRange::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RunChartDownsampleRequest_ZoomRange* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange";
  }
  protected:
  explicit RunChartDownsampleRequest_ZoomRange(::google::protobuf::Arena* arena);
  RunChartDownsampleRequest_ZoomRange(::google::protobuf::Arena* arena, const RunChartDownsampleRequest_ZoomRange& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinDateNanosFieldNumber = 1,
    kMaxDateNanosFieldNumber = 2,
  };
  // optional int64 min_date_nanos = 1 [jstype = JS_STRING];
  bool has_min_date_nanos() const;
  void clear_min_date_nanos() ;
  ::int64_t min_date_nanos() const;
  void set_min_date_nanos(::int64_t value);

  private:
  ::int64_t _internal_min_date_nanos() const;
  void _internal_set_min_date_nanos(::int64_t value);

  public:
  // optional int64 max_date_nanos = 2 [jstype = JS_STRING];
  bool has_max_date_nanos() const;
  void clear_max_date_nanos() ;
  ::int64_t max_date_nanos() const;
  void set_max_date_nanos(::int64_t value);

  private:
  ::int64_t _internal_max_date_nanos() const;
  void _internal_set_max_date_nanos(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::int64_t min_date_nanos_;
    ::int64_t max_date_nanos_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class Reference final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Reference) */ {
 public:
  inline Reference() : Reference(nullptr) {}
  ~Reference() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Reference(::google::protobuf::internal::ConstantInitialized);

  inline Reference(const Reference& from)
      : Reference(nullptr, from) {}
  Reference(Reference&& from) noexcept
    : Reference() {
    *this = ::std::move(from);
  }

  inline Reference& operator=(const Reference& from) {
    CopyFrom(from);
    return *this;
  }
  inline Reference& operator=(Reference&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Reference& default_instance() {
    return *internal_default_instance();
  }
  static inline const Reference* internal_default_instance() {
    return reinterpret_cast<const Reference*>(
               &_Reference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(Reference& a, Reference& b) {
    a.Swap(&b);
  }
  inline void Swap(Reference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Reference* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Reference* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Reference>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Reference& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Reference& from) {
    Reference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Reference* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Reference";
  }
  protected:
  explicit Reference(::google::protobuf::Arena* arena);
  Reference(::google::protobuf::Arena* arena, const Reference& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name() ;
  const std::string& column_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* value);

  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(
      const std::string& value);
  std::string* _internal_mutable_column_name();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Reference)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      63, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr column_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class MathContext final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MathContext) */ {
 public:
  inline MathContext() : MathContext(nullptr) {}
  ~MathContext() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MathContext(::google::protobuf::internal::ConstantInitialized);

  inline MathContext(const MathContext& from)
      : MathContext(nullptr, from) {}
  MathContext(MathContext&& from) noexcept
    : MathContext() {
    *this = ::std::move(from);
  }

  inline MathContext& operator=(const MathContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline MathContext& operator=(MathContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MathContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const MathContext* internal_default_instance() {
    return reinterpret_cast<const MathContext*>(
               &_MathContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MathContext& a, MathContext& b) {
    a.Swap(&b);
  }
  inline void Swap(MathContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MathContext* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MathContext* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MathContext>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MathContext& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MathContext& from) {
    MathContext::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MathContext* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MathContext";
  }
  protected:
  explicit MathContext(::google::protobuf::Arena* arena);
  MathContext(::google::protobuf::Arena* arena, const MathContext& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using RoundingMode = MathContext_RoundingMode;
  static constexpr RoundingMode ROUNDING_MODE_NOT_SPECIFIED = MathContext_RoundingMode_ROUNDING_MODE_NOT_SPECIFIED;
  static constexpr RoundingMode UP = MathContext_RoundingMode_UP;
  static constexpr RoundingMode DOWN = MathContext_RoundingMode_DOWN;
  static constexpr RoundingMode CEILING = MathContext_RoundingMode_CEILING;
  static constexpr RoundingMode FLOOR = MathContext_RoundingMode_FLOOR;
  static constexpr RoundingMode HALF_UP = MathContext_RoundingMode_HALF_UP;
  static constexpr RoundingMode HALF_DOWN = MathContext_RoundingMode_HALF_DOWN;
  static constexpr RoundingMode HALF_EVEN = MathContext_RoundingMode_HALF_EVEN;
  static constexpr RoundingMode UNNECESSARY = MathContext_RoundingMode_UNNECESSARY;
  static inline bool RoundingMode_IsValid(int value) {
    return MathContext_RoundingMode_IsValid(value);
  }
  static constexpr RoundingMode RoundingMode_MIN = MathContext_RoundingMode_RoundingMode_MIN;
  static constexpr RoundingMode RoundingMode_MAX = MathContext_RoundingMode_RoundingMode_MAX;
  static constexpr int RoundingMode_ARRAYSIZE = MathContext_RoundingMode_RoundingMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RoundingMode_descriptor() {
    return MathContext_RoundingMode_descriptor();
  }
  template <typename T>
  static inline const std::string& RoundingMode_Name(T value) {
    return MathContext_RoundingMode_Name(value);
  }
  static inline bool RoundingMode_Parse(absl::string_view name, RoundingMode* value) {
    return MathContext_RoundingMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPrecisionFieldNumber = 1,
    kRoundingModeFieldNumber = 2,
  };
  // sint32 precision = 1;
  void clear_precision() ;
  ::int32_t precision() const;
  void set_precision(::int32_t value);

  private:
  ::int32_t _internal_precision() const;
  void _internal_set_precision(::int32_t value);

  public:
  // .io.deephaven.proto.backplane.grpc.MathContext.RoundingMode rounding_mode = 2;
  void clear_rounding_mode() ;
  ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode rounding_mode() const;
  void set_rounding_mode(::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode value);

  private:
  ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode _internal_rounding_mode() const;
  void _internal_set_rounding_mode(::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MathContext)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t precision_;
    int rounding_mode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class Literal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Literal) */ {
 public:
  inline Literal() : Literal(nullptr) {}
  ~Literal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Literal(::google::protobuf::internal::ConstantInitialized);

  inline Literal(const Literal& from)
      : Literal(nullptr, from) {}
  Literal(Literal&& from) noexcept
    : Literal() {
    *this = ::std::move(from);
  }

  inline Literal& operator=(const Literal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Literal& operator=(Literal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Literal& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kStringValue = 1,
    kDoubleValue = 2,
    kBoolValue = 3,
    kLongValue = 4,
    kNanoTimeValue = 5,
    VALUE_NOT_SET = 0,
  };

  static inline const Literal* internal_default_instance() {
    return reinterpret_cast<const Literal*>(
               &_Literal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(Literal& a, Literal& b) {
    a.Swap(&b);
  }
  inline void Swap(Literal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Literal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Literal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Literal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Literal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Literal& from) {
    Literal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Literal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Literal";
  }
  protected:
  explicit Literal(::google::protobuf::Arena* arena);
  Literal(::google::protobuf::Arena* arena, const Literal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStringValueFieldNumber = 1,
    kDoubleValueFieldNumber = 2,
    kBoolValueFieldNumber = 3,
    kLongValueFieldNumber = 4,
    kNanoTimeValueFieldNumber = 5,
  };
  // string string_value = 1;
  bool has_string_value() const;
  void clear_string_value() ;
  const std::string& string_value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string_value(Arg_&& arg, Args_... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* value);

  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(
      const std::string& value);
  std::string* _internal_mutable_string_value();

  public:
  // double double_value = 2;
  bool has_double_value() const;
  void clear_double_value() ;
  double double_value() const;
  void set_double_value(double value);

  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);

  public:
  // bool bool_value = 3;
  bool has_bool_value() const;
  void clear_bool_value() ;
  bool bool_value() const;
  void set_bool_value(bool value);

  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);

  public:
  // sint64 long_value = 4 [jstype = JS_STRING];
  bool has_long_value() const;
  void clear_long_value() ;
  ::int64_t long_value() const;
  void set_long_value(::int64_t value);

  private:
  ::int64_t _internal_long_value() const;
  void _internal_set_long_value(::int64_t value);

  public:
  // sint64 nano_time_value = 5 [jstype = JS_STRING];
  bool has_nano_time_value() const;
  void clear_nano_time_value() ;
  ::int64_t nano_time_value() const;
  void set_nano_time_value(::int64_t value);

  private:
  ::int64_t _internal_nano_time_value() const;
  void _internal_set_nano_time_value(::int64_t value);

  public:
  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Literal)
 private:
  class _Internal;
  void set_has_string_value();
  void set_has_double_value();
  void set_has_bool_value();
  void set_has_long_value();
  void set_has_nano_time_value();

  inline bool has_value() const;
  inline void clear_has_value();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 0,
      62, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union ValueUnion {
      constexpr ValueUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::google::protobuf::internal::ArenaStringPtr string_value_;
      double double_value_;
      bool bool_value_;
      ::int64_t long_value_;
      ::int64_t nano_time_value_;
    } value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class ExportedTableUpdatesRequest final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ExportedTableUpdatesRequest) */ {
 public:
  inline ExportedTableUpdatesRequest() : ExportedTableUpdatesRequest(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExportedTableUpdatesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ExportedTableUpdatesRequest(const ExportedTableUpdatesRequest& from)
      : ExportedTableUpdatesRequest(nullptr, from) {}
  ExportedTableUpdatesRequest(ExportedTableUpdatesRequest&& from) noexcept
    : ExportedTableUpdatesRequest() {
    *this = ::std::move(from);
  }

  inline ExportedTableUpdatesRequest& operator=(const ExportedTableUpdatesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportedTableUpdatesRequest& operator=(ExportedTableUpdatesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportedTableUpdatesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportedTableUpdatesRequest* internal_default_instance() {
    return reinterpret_cast<const ExportedTableUpdatesRequest*>(
               &_ExportedTableUpdatesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ExportedTableUpdatesRequest& a, ExportedTableUpdatesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportedTableUpdatesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportedTableUpdatesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExportedTableUpdatesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExportedTableUpdatesRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ExportedTableUpdatesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ExportedTableUpdatesRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ExportedTableUpdatesRequest";
  }
  protected:
  explicit ExportedTableUpdatesRequest(::google::protobuf::Arena* arena);
  ExportedTableUpdatesRequest(::google::protobuf::Arena* arena, const ExportedTableUpdatesRequest& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ExportedTableUpdatesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class CreateInputTableRequest_InputTableKind_InMemoryKeyBacked final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked) */ {
 public:
  inline CreateInputTableRequest_InputTableKind_InMemoryKeyBacked() : CreateInputTableRequest_InputTableKind_InMemoryKeyBacked(nullptr) {}
  ~CreateInputTableRequest_InputTableKind_InMemoryKeyBacked() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateInputTableRequest_InputTableKind_InMemoryKeyBacked(::google::protobuf::internal::ConstantInitialized);

  inline CreateInputTableRequest_InputTableKind_InMemoryKeyBacked(const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& from)
      : CreateInputTableRequest_InputTableKind_InMemoryKeyBacked(nullptr, from) {}
  CreateInputTableRequest_InputTableKind_InMemoryKeyBacked(CreateInputTableRequest_InputTableKind_InMemoryKeyBacked&& from) noexcept
    : CreateInputTableRequest_InputTableKind_InMemoryKeyBacked() {
    *this = ::std::move(from);
  }

  inline CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& operator=(const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& operator=(CreateInputTableRequest_InputTableKind_InMemoryKeyBacked&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* internal_default_instance() {
    return reinterpret_cast<const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked*>(
               &_CreateInputTableRequest_InputTableKind_InMemoryKeyBacked_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    116;

  friend void swap(CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& a, CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInputTableRequest_InputTableKind_InMemoryKeyBacked>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& from) {
    CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked";
  }
  protected:
  explicit CreateInputTableRequest_InputTableKind_InMemoryKeyBacked(::google::protobuf::Arena* arena);
  CreateInputTableRequest_InputTableKind_InMemoryKeyBacked(::google::protobuf::Arena* arena, const CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyColumnsFieldNumber = 1,
  };
  // repeated string key_columns = 1;
  int key_columns_size() const;
  private:
  int _internal_key_columns_size() const;

  public:
  void clear_key_columns() ;
  const std::string& key_columns(int index) const;
  std::string* mutable_key_columns(int index);
  void set_key_columns(int index, const std::string& value);
  void set_key_columns(int index, std::string&& value);
  void set_key_columns(int index, const char* value);
  void set_key_columns(int index, const char* value, std::size_t size);
  void set_key_columns(int index, absl::string_view value);
  std::string* add_key_columns();
  void add_key_columns(const std::string& value);
  void add_key_columns(std::string&& value);
  void add_key_columns(const char* value);
  void add_key_columns(const char* value, std::size_t size);
  void add_key_columns(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& key_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_key_columns();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_key_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_key_columns();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      110, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> key_columns_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class CreateInputTableRequest_InputTableKind_InMemoryAppendOnly final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryAppendOnly) */ {
 public:
  inline CreateInputTableRequest_InputTableKind_InMemoryAppendOnly() : CreateInputTableRequest_InputTableKind_InMemoryAppendOnly(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateInputTableRequest_InputTableKind_InMemoryAppendOnly(::google::protobuf::internal::ConstantInitialized);

  inline CreateInputTableRequest_InputTableKind_InMemoryAppendOnly(const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& from)
      : CreateInputTableRequest_InputTableKind_InMemoryAppendOnly(nullptr, from) {}
  CreateInputTableRequest_InputTableKind_InMemoryAppendOnly(CreateInputTableRequest_InputTableKind_InMemoryAppendOnly&& from) noexcept
    : CreateInputTableRequest_InputTableKind_InMemoryAppendOnly() {
    *this = ::std::move(from);
  }

  inline CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& operator=(const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& operator=(CreateInputTableRequest_InputTableKind_InMemoryAppendOnly&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* internal_default_instance() {
    return reinterpret_cast<const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly*>(
               &_CreateInputTableRequest_InputTableKind_InMemoryAppendOnly_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    115;

  friend void swap(CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& a, CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInputTableRequest_InputTableKind_InMemoryAppendOnly>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryAppendOnly";
  }
  protected:
  explicit CreateInputTableRequest_InputTableKind_InMemoryAppendOnly(::google::protobuf::Arena* arena);
  CreateInputTableRequest_InputTableKind_InMemoryAppendOnly(::google::protobuf::Arena* arena, const CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryAppendOnly)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class CreateInputTableRequest_InputTableKind_Blink final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.Blink) */ {
 public:
  inline CreateInputTableRequest_InputTableKind_Blink() : CreateInputTableRequest_InputTableKind_Blink(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateInputTableRequest_InputTableKind_Blink(::google::protobuf::internal::ConstantInitialized);

  inline CreateInputTableRequest_InputTableKind_Blink(const CreateInputTableRequest_InputTableKind_Blink& from)
      : CreateInputTableRequest_InputTableKind_Blink(nullptr, from) {}
  CreateInputTableRequest_InputTableKind_Blink(CreateInputTableRequest_InputTableKind_Blink&& from) noexcept
    : CreateInputTableRequest_InputTableKind_Blink() {
    *this = ::std::move(from);
  }

  inline CreateInputTableRequest_InputTableKind_Blink& operator=(const CreateInputTableRequest_InputTableKind_Blink& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInputTableRequest_InputTableKind_Blink& operator=(CreateInputTableRequest_InputTableKind_Blink&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInputTableRequest_InputTableKind_Blink& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateInputTableRequest_InputTableKind_Blink* internal_default_instance() {
    return reinterpret_cast<const CreateInputTableRequest_InputTableKind_Blink*>(
               &_CreateInputTableRequest_InputTableKind_Blink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    117;

  friend void swap(CreateInputTableRequest_InputTableKind_Blink& a, CreateInputTableRequest_InputTableKind_Blink& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInputTableRequest_InputTableKind_Blink* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInputTableRequest_InputTableKind_Blink* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInputTableRequest_InputTableKind_Blink* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInputTableRequest_InputTableKind_Blink>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateInputTableRequest_InputTableKind_Blink& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateInputTableRequest_InputTableKind_Blink& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.Blink";
  }
  protected:
  explicit CreateInputTableRequest_InputTableKind_Blink(::google::protobuf::Arena* arena);
  CreateInputTableRequest_InputTableKind_Blink(::google::protobuf::Arena* arena, const CreateInputTableRequest_InputTableKind_Blink& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.Blink)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class ComboAggregateRequest_Aggregate final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate) */ {
 public:
  inline ComboAggregateRequest_Aggregate() : ComboAggregateRequest_Aggregate(nullptr) {}
  ~ComboAggregateRequest_Aggregate() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ComboAggregateRequest_Aggregate(::google::protobuf::internal::ConstantInitialized);

  inline ComboAggregateRequest_Aggregate(const ComboAggregateRequest_Aggregate& from)
      : ComboAggregateRequest_Aggregate(nullptr, from) {}
  ComboAggregateRequest_Aggregate(ComboAggregateRequest_Aggregate&& from) noexcept
    : ComboAggregateRequest_Aggregate() {
    *this = ::std::move(from);
  }

  inline ComboAggregateRequest_Aggregate& operator=(const ComboAggregateRequest_Aggregate& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComboAggregateRequest_Aggregate& operator=(ComboAggregateRequest_Aggregate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComboAggregateRequest_Aggregate& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComboAggregateRequest_Aggregate* internal_default_instance() {
    return reinterpret_cast<const ComboAggregateRequest_Aggregate*>(
               &_ComboAggregateRequest_Aggregate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(ComboAggregateRequest_Aggregate& a, ComboAggregateRequest_Aggregate& b) {
    a.Swap(&b);
  }
  inline void Swap(ComboAggregateRequest_Aggregate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComboAggregateRequest_Aggregate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComboAggregateRequest_Aggregate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComboAggregateRequest_Aggregate>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ComboAggregateRequest_Aggregate& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ComboAggregateRequest_Aggregate& from) {
    ComboAggregateRequest_Aggregate::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ComboAggregateRequest_Aggregate* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate";
  }
  protected:
  explicit ComboAggregateRequest_Aggregate(::google::protobuf::Arena* arena);
  ComboAggregateRequest_Aggregate(::google::protobuf::Arena* arena, const ComboAggregateRequest_Aggregate& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchPairsFieldNumber = 2,
    kColumnNameFieldNumber = 3,
    kTypeFieldNumber = 1,
    kAvgMedianFieldNumber = 5,
    kPercentileFieldNumber = 4,
  };
  // repeated string match_pairs = 2;
  int match_pairs_size() const;
  private:
  int _internal_match_pairs_size() const;

  public:
  void clear_match_pairs() ;
  const std::string& match_pairs(int index) const;
  std::string* mutable_match_pairs(int index);
  void set_match_pairs(int index, const std::string& value);
  void set_match_pairs(int index, std::string&& value);
  void set_match_pairs(int index, const char* value);
  void set_match_pairs(int index, const char* value, std::size_t size);
  void set_match_pairs(int index, absl::string_view value);
  std::string* add_match_pairs();
  void add_match_pairs(const std::string& value);
  void add_match_pairs(std::string&& value);
  void add_match_pairs(const char* value);
  void add_match_pairs(const char* value, std::size_t size);
  void add_match_pairs(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& match_pairs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_match_pairs();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_match_pairs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_match_pairs();

  public:
  // string column_name = 3;
  void clear_column_name() ;
  const std::string& column_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* value);

  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(
      const std::string& value);
  std::string* _internal_mutable_column_name();

  public:
  // .io.deephaven.proto.backplane.grpc.ComboAggregateRequest.AggType type = 1;
  void clear_type() ;
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType type() const;
  void set_type(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType value);

  private:
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType _internal_type() const;
  void _internal_set_type(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType value);

  public:
  // bool avg_median = 5;
  void clear_avg_median() ;
  bool avg_median() const;
  void set_avg_median(bool value);

  private:
  bool _internal_avg_median() const;
  void _internal_set_avg_median(bool value);

  public:
  // double percentile = 4;
  void clear_percentile() ;
  double percentile() const;
  void set_percentile(double value);

  private:
  double _internal_percentile() const;
  void _internal_set_percentile(double value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      96, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField<std::string> match_pairs_;
    ::google::protobuf::internal::ArenaStringPtr column_name_;
    int type_;
    bool avg_median_;
    double percentile_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class Aggregation_AggregationRowKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey) */ {
 public:
  inline Aggregation_AggregationRowKey() : Aggregation_AggregationRowKey(nullptr) {}
  ~Aggregation_AggregationRowKey() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Aggregation_AggregationRowKey(::google::protobuf::internal::ConstantInitialized);

  inline Aggregation_AggregationRowKey(const Aggregation_AggregationRowKey& from)
      : Aggregation_AggregationRowKey(nullptr, from) {}
  Aggregation_AggregationRowKey(Aggregation_AggregationRowKey&& from) noexcept
    : Aggregation_AggregationRowKey() {
    *this = ::std::move(from);
  }

  inline Aggregation_AggregationRowKey& operator=(const Aggregation_AggregationRowKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aggregation_AggregationRowKey& operator=(Aggregation_AggregationRowKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aggregation_AggregationRowKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aggregation_AggregationRowKey* internal_default_instance() {
    return reinterpret_cast<const Aggregation_AggregationRowKey*>(
               &_Aggregation_AggregationRowKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(Aggregation_AggregationRowKey& a, Aggregation_AggregationRowKey& b) {
    a.Swap(&b);
  }
  inline void Swap(Aggregation_AggregationRowKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aggregation_AggregationRowKey* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aggregation_AggregationRowKey* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aggregation_AggregationRowKey>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Aggregation_AggregationRowKey& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Aggregation_AggregationRowKey& from) {
    Aggregation_AggregationRowKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Aggregation_AggregationRowKey* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey";
  }
  protected:
  explicit Aggregation_AggregationRowKey(::google::protobuf::Arena* arena);
  Aggregation_AggregationRowKey(::google::protobuf::Arena* arena, const Aggregation_AggregationRowKey& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name() ;
  const std::string& column_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* value);

  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(
      const std::string& value);
  std::string* _internal_mutable_column_name();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      83, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr column_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class Aggregation_AggregationPartition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition) */ {
 public:
  inline Aggregation_AggregationPartition() : Aggregation_AggregationPartition(nullptr) {}
  ~Aggregation_AggregationPartition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Aggregation_AggregationPartition(::google::protobuf::internal::ConstantInitialized);

  inline Aggregation_AggregationPartition(const Aggregation_AggregationPartition& from)
      : Aggregation_AggregationPartition(nullptr, from) {}
  Aggregation_AggregationPartition(Aggregation_AggregationPartition&& from) noexcept
    : Aggregation_AggregationPartition() {
    *this = ::std::move(from);
  }

  inline Aggregation_AggregationPartition& operator=(const Aggregation_AggregationPartition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aggregation_AggregationPartition& operator=(Aggregation_AggregationPartition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aggregation_AggregationPartition& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aggregation_AggregationPartition* internal_default_instance() {
    return reinterpret_cast<const Aggregation_AggregationPartition*>(
               &_Aggregation_AggregationPartition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(Aggregation_AggregationPartition& a, Aggregation_AggregationPartition& b) {
    a.Swap(&b);
  }
  inline void Swap(Aggregation_AggregationPartition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aggregation_AggregationPartition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aggregation_AggregationPartition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aggregation_AggregationPartition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Aggregation_AggregationPartition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Aggregation_AggregationPartition& from) {
    Aggregation_AggregationPartition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Aggregation_AggregationPartition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition";
  }
  protected:
  explicit Aggregation_AggregationPartition(::google::protobuf::Arena* arena);
  Aggregation_AggregationPartition(::google::protobuf::Arena* arena, const Aggregation_AggregationPartition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
    kIncludeGroupByColumnsFieldNumber = 2,
  };
  // string column_name = 1;
  void clear_column_name() ;
  const std::string& column_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* value);

  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(
      const std::string& value);
  std::string* _internal_mutable_column_name();

  public:
  // bool include_group_by_columns = 2;
  void clear_include_group_by_columns() ;
  bool include_group_by_columns() const;
  void set_include_group_by_columns(bool value);

  private:
  bool _internal_include_group_by_columns() const;
  void _internal_set_include_group_by_columns(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      86, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr column_name_;
    bool include_group_by_columns_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class Aggregation_AggregationCount final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount) */ {
 public:
  inline Aggregation_AggregationCount() : Aggregation_AggregationCount(nullptr) {}
  ~Aggregation_AggregationCount() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Aggregation_AggregationCount(::google::protobuf::internal::ConstantInitialized);

  inline Aggregation_AggregationCount(const Aggregation_AggregationCount& from)
      : Aggregation_AggregationCount(nullptr, from) {}
  Aggregation_AggregationCount(Aggregation_AggregationCount&& from) noexcept
    : Aggregation_AggregationCount() {
    *this = ::std::move(from);
  }

  inline Aggregation_AggregationCount& operator=(const Aggregation_AggregationCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aggregation_AggregationCount& operator=(Aggregation_AggregationCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aggregation_AggregationCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aggregation_AggregationCount* internal_default_instance() {
    return reinterpret_cast<const Aggregation_AggregationCount*>(
               &_Aggregation_AggregationCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(Aggregation_AggregationCount& a, Aggregation_AggregationCount& b) {
    a.Swap(&b);
  }
  inline void Swap(Aggregation_AggregationCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aggregation_AggregationCount* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aggregation_AggregationCount* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aggregation_AggregationCount>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Aggregation_AggregationCount& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Aggregation_AggregationCount& from) {
    Aggregation_AggregationCount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Aggregation_AggregationCount* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount";
  }
  protected:
  explicit Aggregation_AggregationCount(::google::protobuf::Arena* arena);
  Aggregation_AggregationCount(::google::protobuf::Arena* arena, const Aggregation_AggregationCount& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name() ;
  const std::string& column_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* value);

  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(
      const std::string& value);
  std::string* _internal_mutable_column_name();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      82, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr column_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecWeighted final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted) */ {
 public:
  inline AggSpec_AggSpecWeighted() : AggSpec_AggSpecWeighted(nullptr) {}
  ~AggSpec_AggSpecWeighted() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecWeighted(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecWeighted(const AggSpec_AggSpecWeighted& from)
      : AggSpec_AggSpecWeighted(nullptr, from) {}
  AggSpec_AggSpecWeighted(AggSpec_AggSpecWeighted&& from) noexcept
    : AggSpec_AggSpecWeighted() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecWeighted& operator=(const AggSpec_AggSpecWeighted& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecWeighted& operator=(AggSpec_AggSpecWeighted&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecWeighted& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecWeighted* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecWeighted*>(
               &_AggSpec_AggSpecWeighted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(AggSpec_AggSpecWeighted& a, AggSpec_AggSpecWeighted& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecWeighted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecWeighted* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecWeighted* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecWeighted>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecWeighted& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec_AggSpecWeighted& from) {
    AggSpec_AggSpecWeighted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec_AggSpecWeighted* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted";
  }
  protected:
  explicit AggSpec_AggSpecWeighted(::google::protobuf::Arena* arena);
  AggSpec_AggSpecWeighted(::google::protobuf::Arena* arena, const AggSpec_AggSpecWeighted& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeightColumnFieldNumber = 1,
  };
  // string weight_column = 1;
  void clear_weight_column() ;
  const std::string& weight_column() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_weight_column(Arg_&& arg, Args_... args);
  std::string* mutable_weight_column();
  PROTOBUF_NODISCARD std::string* release_weight_column();
  void set_allocated_weight_column(std::string* value);

  private:
  const std::string& _internal_weight_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weight_column(
      const std::string& value);
  std::string* _internal_mutable_weight_column();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      79, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr weight_column_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecVar final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecVar) */ {
 public:
  inline AggSpec_AggSpecVar() : AggSpec_AggSpecVar(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecVar(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecVar(const AggSpec_AggSpecVar& from)
      : AggSpec_AggSpecVar(nullptr, from) {}
  AggSpec_AggSpecVar(AggSpec_AggSpecVar&& from) noexcept
    : AggSpec_AggSpecVar() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecVar& operator=(const AggSpec_AggSpecVar& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecVar& operator=(AggSpec_AggSpecVar&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecVar& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecVar* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecVar*>(
               &_AggSpec_AggSpecVar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(AggSpec_AggSpecVar& a, AggSpec_AggSpecVar& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecVar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecVar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecVar* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecVar>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecVar& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecVar& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecVar";
  }
  protected:
  explicit AggSpec_AggSpecVar(::google::protobuf::Arena* arena);
  AggSpec_AggSpecVar(::google::protobuf::Arena* arena, const AggSpec_AggSpecVar& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecVar)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecTDigest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest) */ {
 public:
  inline AggSpec_AggSpecTDigest() : AggSpec_AggSpecTDigest(nullptr) {}
  ~AggSpec_AggSpecTDigest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecTDigest(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecTDigest(const AggSpec_AggSpecTDigest& from)
      : AggSpec_AggSpecTDigest(nullptr, from) {}
  AggSpec_AggSpecTDigest(AggSpec_AggSpecTDigest&& from) noexcept
    : AggSpec_AggSpecTDigest() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecTDigest& operator=(const AggSpec_AggSpecTDigest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecTDigest& operator=(AggSpec_AggSpecTDigest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecTDigest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecTDigest* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecTDigest*>(
               &_AggSpec_AggSpecTDigest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(AggSpec_AggSpecTDigest& a, AggSpec_AggSpecTDigest& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecTDigest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecTDigest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecTDigest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecTDigest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecTDigest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec_AggSpecTDigest& from) {
    AggSpec_AggSpecTDigest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec_AggSpecTDigest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest";
  }
  protected:
  explicit AggSpec_AggSpecTDigest(::google::protobuf::Arena* arena);
  AggSpec_AggSpecTDigest(::google::protobuf::Arena* arena, const AggSpec_AggSpecTDigest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompressionFieldNumber = 1,
  };
  // optional double compression = 1;
  bool has_compression() const;
  void clear_compression() ;
  double compression() const;
  void set_compression(double value);

  private:
  double _internal_compression() const;
  void _internal_set_compression(double value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double compression_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecSum final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSum) */ {
 public:
  inline AggSpec_AggSpecSum() : AggSpec_AggSpecSum(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecSum(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecSum(const AggSpec_AggSpecSum& from)
      : AggSpec_AggSpecSum(nullptr, from) {}
  AggSpec_AggSpecSum(AggSpec_AggSpecSum&& from) noexcept
    : AggSpec_AggSpecSum() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecSum& operator=(const AggSpec_AggSpecSum& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecSum& operator=(AggSpec_AggSpecSum&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecSum& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecSum* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecSum*>(
               &_AggSpec_AggSpecSum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(AggSpec_AggSpecSum& a, AggSpec_AggSpecSum& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecSum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecSum* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecSum* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecSum>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecSum& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecSum& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSum";
  }
  protected:
  explicit AggSpec_AggSpecSum(::google::protobuf::Arena* arena);
  AggSpec_AggSpecSum(::google::protobuf::Arena* arena, const AggSpec_AggSpecSum& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSum)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecStd final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecStd) */ {
 public:
  inline AggSpec_AggSpecStd() : AggSpec_AggSpecStd(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecStd(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecStd(const AggSpec_AggSpecStd& from)
      : AggSpec_AggSpecStd(nullptr, from) {}
  AggSpec_AggSpecStd(AggSpec_AggSpecStd&& from) noexcept
    : AggSpec_AggSpecStd() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecStd& operator=(const AggSpec_AggSpecStd& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecStd& operator=(AggSpec_AggSpecStd&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecStd& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecStd* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecStd*>(
               &_AggSpec_AggSpecStd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(AggSpec_AggSpecStd& a, AggSpec_AggSpecStd& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecStd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecStd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecStd* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecStd>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecStd& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecStd& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecStd";
  }
  protected:
  explicit AggSpec_AggSpecStd(::google::protobuf::Arena* arena);
  AggSpec_AggSpecStd(::google::protobuf::Arena* arena, const AggSpec_AggSpecStd& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecStd)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecSortedColumn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn) */ {
 public:
  inline AggSpec_AggSpecSortedColumn() : AggSpec_AggSpecSortedColumn(nullptr) {}
  ~AggSpec_AggSpecSortedColumn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecSortedColumn(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecSortedColumn(const AggSpec_AggSpecSortedColumn& from)
      : AggSpec_AggSpecSortedColumn(nullptr, from) {}
  AggSpec_AggSpecSortedColumn(AggSpec_AggSpecSortedColumn&& from) noexcept
    : AggSpec_AggSpecSortedColumn() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecSortedColumn& operator=(const AggSpec_AggSpecSortedColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecSortedColumn& operator=(AggSpec_AggSpecSortedColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecSortedColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecSortedColumn* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecSortedColumn*>(
               &_AggSpec_AggSpecSortedColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(AggSpec_AggSpecSortedColumn& a, AggSpec_AggSpecSortedColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecSortedColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecSortedColumn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecSortedColumn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecSortedColumn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecSortedColumn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec_AggSpecSortedColumn& from) {
    AggSpec_AggSpecSortedColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec_AggSpecSortedColumn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn";
  }
  protected:
  explicit AggSpec_AggSpecSortedColumn(::google::protobuf::Arena* arena);
  AggSpec_AggSpecSortedColumn(::google::protobuf::Arena* arena, const AggSpec_AggSpecSortedColumn& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 1,
  };
  // string column_name = 1;
  void clear_column_name() ;
  const std::string& column_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* value);

  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(
      const std::string& value);
  std::string* _internal_mutable_column_name();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      81, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr column_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecPercentile final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile) */ {
 public:
  inline AggSpec_AggSpecPercentile() : AggSpec_AggSpecPercentile(nullptr) {}
  ~AggSpec_AggSpecPercentile() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecPercentile(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecPercentile(const AggSpec_AggSpecPercentile& from)
      : AggSpec_AggSpecPercentile(nullptr, from) {}
  AggSpec_AggSpecPercentile(AggSpec_AggSpecPercentile&& from) noexcept
    : AggSpec_AggSpecPercentile() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecPercentile& operator=(const AggSpec_AggSpecPercentile& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecPercentile& operator=(AggSpec_AggSpecPercentile&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecPercentile& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecPercentile* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecPercentile*>(
               &_AggSpec_AggSpecPercentile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(AggSpec_AggSpecPercentile& a, AggSpec_AggSpecPercentile& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecPercentile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecPercentile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecPercentile* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecPercentile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecPercentile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec_AggSpecPercentile& from) {
    AggSpec_AggSpecPercentile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec_AggSpecPercentile* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile";
  }
  protected:
  explicit AggSpec_AggSpecPercentile(::google::protobuf::Arena* arena);
  AggSpec_AggSpecPercentile(::google::protobuf::Arena* arena, const AggSpec_AggSpecPercentile& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPercentileFieldNumber = 1,
    kAverageEvenlyDividedFieldNumber = 2,
  };
  // double percentile = 1;
  void clear_percentile() ;
  double percentile() const;
  void set_percentile(double value);

  private:
  double _internal_percentile() const;
  void _internal_set_percentile(double value);

  public:
  // bool average_evenly_divided = 2;
  void clear_average_evenly_divided() ;
  bool average_evenly_divided() const;
  void set_average_evenly_divided(bool value);

  private:
  bool _internal_average_evenly_divided() const;
  void _internal_set_average_evenly_divided(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    double percentile_;
    bool average_evenly_divided_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecNonUniqueSentinel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel) */ {
 public:
  inline AggSpec_AggSpecNonUniqueSentinel() : AggSpec_AggSpecNonUniqueSentinel(nullptr) {}
  ~AggSpec_AggSpecNonUniqueSentinel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecNonUniqueSentinel(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecNonUniqueSentinel(const AggSpec_AggSpecNonUniqueSentinel& from)
      : AggSpec_AggSpecNonUniqueSentinel(nullptr, from) {}
  AggSpec_AggSpecNonUniqueSentinel(AggSpec_AggSpecNonUniqueSentinel&& from) noexcept
    : AggSpec_AggSpecNonUniqueSentinel() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecNonUniqueSentinel& operator=(const AggSpec_AggSpecNonUniqueSentinel& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecNonUniqueSentinel& operator=(AggSpec_AggSpecNonUniqueSentinel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecNonUniqueSentinel& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kNullValue = 1,
    kStringValue = 2,
    kIntValue = 3,
    kLongValue = 4,
    kFloatValue = 5,
    kDoubleValue = 6,
    kBoolValue = 7,
    kByteValue = 8,
    kShortValue = 9,
    kCharValue = 10,
    TYPE_NOT_SET = 0,
  };

  static inline const AggSpec_AggSpecNonUniqueSentinel* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecNonUniqueSentinel*>(
               &_AggSpec_AggSpecNonUniqueSentinel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(AggSpec_AggSpecNonUniqueSentinel& a, AggSpec_AggSpecNonUniqueSentinel& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecNonUniqueSentinel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecNonUniqueSentinel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecNonUniqueSentinel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecNonUniqueSentinel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecNonUniqueSentinel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec_AggSpecNonUniqueSentinel& from) {
    AggSpec_AggSpecNonUniqueSentinel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec_AggSpecNonUniqueSentinel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel";
  }
  protected:
  explicit AggSpec_AggSpecNonUniqueSentinel(::google::protobuf::Arena* arena);
  AggSpec_AggSpecNonUniqueSentinel(::google::protobuf::Arena* arena, const AggSpec_AggSpecNonUniqueSentinel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNullValueFieldNumber = 1,
    kStringValueFieldNumber = 2,
    kIntValueFieldNumber = 3,
    kLongValueFieldNumber = 4,
    kFloatValueFieldNumber = 5,
    kDoubleValueFieldNumber = 6,
    kBoolValueFieldNumber = 7,
    kByteValueFieldNumber = 8,
    kShortValueFieldNumber = 9,
    kCharValueFieldNumber = 10,
  };
  // .io.deephaven.proto.backplane.grpc.NullValue null_value = 1;
  bool has_null_value() const;
  void clear_null_value() ;
  ::io::deephaven::proto::backplane::grpc::NullValue null_value() const;
  void set_null_value(::io::deephaven::proto::backplane::grpc::NullValue value);

  private:
  ::io::deephaven::proto::backplane::grpc::NullValue _internal_null_value() const;
  void _internal_set_null_value(::io::deephaven::proto::backplane::grpc::NullValue value);

  public:
  // string string_value = 2;
  bool has_string_value() const;
  void clear_string_value() ;
  const std::string& string_value() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_string_value(Arg_&& arg, Args_... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* value);

  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(
      const std::string& value);
  std::string* _internal_mutable_string_value();

  public:
  // sint32 int_value = 3;
  bool has_int_value() const;
  void clear_int_value() ;
  ::int32_t int_value() const;
  void set_int_value(::int32_t value);

  private:
  ::int32_t _internal_int_value() const;
  void _internal_set_int_value(::int32_t value);

  public:
  // sint64 long_value = 4 [jstype = JS_STRING];
  bool has_long_value() const;
  void clear_long_value() ;
  ::int64_t long_value() const;
  void set_long_value(::int64_t value);

  private:
  ::int64_t _internal_long_value() const;
  void _internal_set_long_value(::int64_t value);

  public:
  // float float_value = 5;
  bool has_float_value() const;
  void clear_float_value() ;
  float float_value() const;
  void set_float_value(float value);

  private:
  float _internal_float_value() const;
  void _internal_set_float_value(float value);

  public:
  // double double_value = 6;
  bool has_double_value() const;
  void clear_double_value() ;
  double double_value() const;
  void set_double_value(double value);

  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);

  public:
  // bool bool_value = 7;
  bool has_bool_value() const;
  void clear_bool_value() ;
  bool bool_value() const;
  void set_bool_value(bool value);

  private:
  bool _internal_bool_value() const;
  void _internal_set_bool_value(bool value);

  public:
  // sint32 byte_value = 8;
  bool has_byte_value() const;
  void clear_byte_value() ;
  ::int32_t byte_value() const;
  void set_byte_value(::int32_t value);

  private:
  ::int32_t _internal_byte_value() const;
  void _internal_set_byte_value(::int32_t value);

  public:
  // sint32 short_value = 9;
  bool has_short_value() const;
  void clear_short_value() ;
  ::int32_t short_value() const;
  void set_short_value(::int32_t value);

  private:
  ::int32_t _internal_short_value() const;
  void _internal_set_short_value(::int32_t value);

  public:
  // sint32 char_value = 10;
  bool has_char_value() const;
  void clear_char_value() ;
  ::int32_t char_value() const;
  void set_char_value(::int32_t value);

  private:
  ::int32_t _internal_char_value() const;
  void _internal_set_char_value(::int32_t value);

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel)
 private:
  class _Internal;
  void set_has_null_value();
  void set_has_string_value();
  void set_has_int_value();
  void set_has_long_value();
  void set_has_float_value();
  void set_has_double_value();
  void set_has_bool_value();
  void set_has_byte_value();
  void set_has_short_value();
  void set_has_char_value();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 10, 0,
      95, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      int null_value_;
      ::google::protobuf::internal::ArenaStringPtr string_value_;
      ::int32_t int_value_;
      ::int64_t long_value_;
      float float_value_;
      double double_value_;
      bool bool_value_;
      ::int32_t byte_value_;
      ::int32_t short_value_;
      ::int32_t char_value_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecMin final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMin) */ {
 public:
  inline AggSpec_AggSpecMin() : AggSpec_AggSpecMin(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecMin(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecMin(const AggSpec_AggSpecMin& from)
      : AggSpec_AggSpecMin(nullptr, from) {}
  AggSpec_AggSpecMin(AggSpec_AggSpecMin&& from) noexcept
    : AggSpec_AggSpecMin() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecMin& operator=(const AggSpec_AggSpecMin& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecMin& operator=(AggSpec_AggSpecMin&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecMin& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecMin* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecMin*>(
               &_AggSpec_AggSpecMin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(AggSpec_AggSpecMin& a, AggSpec_AggSpecMin& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecMin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecMin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecMin* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecMin>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecMin& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecMin& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMin";
  }
  protected:
  explicit AggSpec_AggSpecMin(::google::protobuf::Arena* arena);
  AggSpec_AggSpecMin(::google::protobuf::Arena* arena, const AggSpec_AggSpecMin& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMin)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecMedian final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian) */ {
 public:
  inline AggSpec_AggSpecMedian() : AggSpec_AggSpecMedian(nullptr) {}
  ~AggSpec_AggSpecMedian() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecMedian(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecMedian(const AggSpec_AggSpecMedian& from)
      : AggSpec_AggSpecMedian(nullptr, from) {}
  AggSpec_AggSpecMedian(AggSpec_AggSpecMedian&& from) noexcept
    : AggSpec_AggSpecMedian() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecMedian& operator=(const AggSpec_AggSpecMedian& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecMedian& operator=(AggSpec_AggSpecMedian&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecMedian& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecMedian* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecMedian*>(
               &_AggSpec_AggSpecMedian_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(AggSpec_AggSpecMedian& a, AggSpec_AggSpecMedian& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecMedian* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecMedian* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecMedian* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecMedian>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecMedian& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec_AggSpecMedian& from) {
    AggSpec_AggSpecMedian::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec_AggSpecMedian* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian";
  }
  protected:
  explicit AggSpec_AggSpecMedian(::google::protobuf::Arena* arena);
  AggSpec_AggSpecMedian(::google::protobuf::Arena* arena, const AggSpec_AggSpecMedian& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAverageEvenlyDividedFieldNumber = 1,
  };
  // bool average_evenly_divided = 1;
  void clear_average_evenly_divided() ;
  bool average_evenly_divided() const;
  void set_average_evenly_divided(bool value);

  private:
  bool _internal_average_evenly_divided() const;
  void _internal_set_average_evenly_divided(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool average_evenly_divided_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecMax final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMax) */ {
 public:
  inline AggSpec_AggSpecMax() : AggSpec_AggSpecMax(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecMax(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecMax(const AggSpec_AggSpecMax& from)
      : AggSpec_AggSpecMax(nullptr, from) {}
  AggSpec_AggSpecMax(AggSpec_AggSpecMax&& from) noexcept
    : AggSpec_AggSpecMax() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecMax& operator=(const AggSpec_AggSpecMax& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecMax& operator=(AggSpec_AggSpecMax&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecMax& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecMax* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecMax*>(
               &_AggSpec_AggSpecMax_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(AggSpec_AggSpecMax& a, AggSpec_AggSpecMax& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecMax* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecMax* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecMax* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecMax>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecMax& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecMax& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMax";
  }
  protected:
  explicit AggSpec_AggSpecMax(::google::protobuf::Arena* arena);
  AggSpec_AggSpecMax(::google::protobuf::Arena* arena, const AggSpec_AggSpecMax& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMax)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecLast final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecLast) */ {
 public:
  inline AggSpec_AggSpecLast() : AggSpec_AggSpecLast(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecLast(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecLast(const AggSpec_AggSpecLast& from)
      : AggSpec_AggSpecLast(nullptr, from) {}
  AggSpec_AggSpecLast(AggSpec_AggSpecLast&& from) noexcept
    : AggSpec_AggSpecLast() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecLast& operator=(const AggSpec_AggSpecLast& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecLast& operator=(AggSpec_AggSpecLast&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecLast& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecLast* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecLast*>(
               &_AggSpec_AggSpecLast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(AggSpec_AggSpecLast& a, AggSpec_AggSpecLast& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecLast* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecLast* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecLast* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecLast>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecLast& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecLast& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecLast";
  }
  protected:
  explicit AggSpec_AggSpecLast(::google::protobuf::Arena* arena);
  AggSpec_AggSpecLast(::google::protobuf::Arena* arena, const AggSpec_AggSpecLast& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecLast)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecGroup final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecGroup) */ {
 public:
  inline AggSpec_AggSpecGroup() : AggSpec_AggSpecGroup(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecGroup(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecGroup(const AggSpec_AggSpecGroup& from)
      : AggSpec_AggSpecGroup(nullptr, from) {}
  AggSpec_AggSpecGroup(AggSpec_AggSpecGroup&& from) noexcept
    : AggSpec_AggSpecGroup() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecGroup& operator=(const AggSpec_AggSpecGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecGroup& operator=(AggSpec_AggSpecGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecGroup* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecGroup*>(
               &_AggSpec_AggSpecGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(AggSpec_AggSpecGroup& a, AggSpec_AggSpecGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecGroup* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecGroup>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecGroup& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecGroup& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecGroup";
  }
  protected:
  explicit AggSpec_AggSpecGroup(::google::protobuf::Arena* arena);
  AggSpec_AggSpecGroup(::google::protobuf::Arena* arena, const AggSpec_AggSpecGroup& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecGroup)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecFreeze final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFreeze) */ {
 public:
  inline AggSpec_AggSpecFreeze() : AggSpec_AggSpecFreeze(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecFreeze(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecFreeze(const AggSpec_AggSpecFreeze& from)
      : AggSpec_AggSpecFreeze(nullptr, from) {}
  AggSpec_AggSpecFreeze(AggSpec_AggSpecFreeze&& from) noexcept
    : AggSpec_AggSpecFreeze() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecFreeze& operator=(const AggSpec_AggSpecFreeze& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecFreeze& operator=(AggSpec_AggSpecFreeze&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecFreeze& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecFreeze* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecFreeze*>(
               &_AggSpec_AggSpecFreeze_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(AggSpec_AggSpecFreeze& a, AggSpec_AggSpecFreeze& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecFreeze* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecFreeze* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecFreeze* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecFreeze>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecFreeze& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecFreeze& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFreeze";
  }
  protected:
  explicit AggSpec_AggSpecFreeze(::google::protobuf::Arena* arena);
  AggSpec_AggSpecFreeze(::google::protobuf::Arena* arena, const AggSpec_AggSpecFreeze& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFreeze)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecFormula final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula) */ {
 public:
  inline AggSpec_AggSpecFormula() : AggSpec_AggSpecFormula(nullptr) {}
  ~AggSpec_AggSpecFormula() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecFormula(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecFormula(const AggSpec_AggSpecFormula& from)
      : AggSpec_AggSpecFormula(nullptr, from) {}
  AggSpec_AggSpecFormula(AggSpec_AggSpecFormula&& from) noexcept
    : AggSpec_AggSpecFormula() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecFormula& operator=(const AggSpec_AggSpecFormula& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecFormula& operator=(AggSpec_AggSpecFormula&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecFormula& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecFormula* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecFormula*>(
               &_AggSpec_AggSpecFormula_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(AggSpec_AggSpecFormula& a, AggSpec_AggSpecFormula& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecFormula* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecFormula* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecFormula* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecFormula>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecFormula& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec_AggSpecFormula& from) {
    AggSpec_AggSpecFormula::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec_AggSpecFormula* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula";
  }
  protected:
  explicit AggSpec_AggSpecFormula(::google::protobuf::Arena* arena);
  AggSpec_AggSpecFormula(::google::protobuf::Arena* arena, const AggSpec_AggSpecFormula& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormulaFieldNumber = 1,
    kParamTokenFieldNumber = 2,
  };
  // string formula = 1;
  void clear_formula() ;
  const std::string& formula() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_formula(Arg_&& arg, Args_... args);
  std::string* mutable_formula();
  PROTOBUF_NODISCARD std::string* release_formula();
  void set_allocated_formula(std::string* value);

  private:
  const std::string& _internal_formula() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formula(
      const std::string& value);
  std::string* _internal_mutable_formula();

  public:
  // string param_token = 2;
  void clear_param_token() ;
  const std::string& param_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_param_token(Arg_&& arg, Args_... args);
  std::string* mutable_param_token();
  PROTOBUF_NODISCARD std::string* release_param_token();
  void set_allocated_param_token(std::string* value);

  private:
  const std::string& _internal_param_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_param_token(
      const std::string& value);
  std::string* _internal_mutable_param_token();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      83, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr formula_;
    ::google::protobuf::internal::ArenaStringPtr param_token_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecFirst final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFirst) */ {
 public:
  inline AggSpec_AggSpecFirst() : AggSpec_AggSpecFirst(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecFirst(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecFirst(const AggSpec_AggSpecFirst& from)
      : AggSpec_AggSpecFirst(nullptr, from) {}
  AggSpec_AggSpecFirst(AggSpec_AggSpecFirst&& from) noexcept
    : AggSpec_AggSpecFirst() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecFirst& operator=(const AggSpec_AggSpecFirst& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecFirst& operator=(AggSpec_AggSpecFirst&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecFirst& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecFirst* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecFirst*>(
               &_AggSpec_AggSpecFirst_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(AggSpec_AggSpecFirst& a, AggSpec_AggSpecFirst& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecFirst* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecFirst* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecFirst* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecFirst>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecFirst& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecFirst& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFirst";
  }
  protected:
  explicit AggSpec_AggSpecFirst(::google::protobuf::Arena* arena);
  AggSpec_AggSpecFirst(::google::protobuf::Arena* arena, const AggSpec_AggSpecFirst& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFirst)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecDistinct final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct) */ {
 public:
  inline AggSpec_AggSpecDistinct() : AggSpec_AggSpecDistinct(nullptr) {}
  ~AggSpec_AggSpecDistinct() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecDistinct(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecDistinct(const AggSpec_AggSpecDistinct& from)
      : AggSpec_AggSpecDistinct(nullptr, from) {}
  AggSpec_AggSpecDistinct(AggSpec_AggSpecDistinct&& from) noexcept
    : AggSpec_AggSpecDistinct() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecDistinct& operator=(const AggSpec_AggSpecDistinct& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecDistinct& operator=(AggSpec_AggSpecDistinct&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecDistinct& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecDistinct* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecDistinct*>(
               &_AggSpec_AggSpecDistinct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(AggSpec_AggSpecDistinct& a, AggSpec_AggSpecDistinct& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecDistinct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecDistinct* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecDistinct* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecDistinct>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecDistinct& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec_AggSpecDistinct& from) {
    AggSpec_AggSpecDistinct::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec_AggSpecDistinct* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct";
  }
  protected:
  explicit AggSpec_AggSpecDistinct(::google::protobuf::Arena* arena);
  AggSpec_AggSpecDistinct(::google::protobuf::Arena* arena, const AggSpec_AggSpecDistinct& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludeNullsFieldNumber = 1,
  };
  // bool include_nulls = 1;
  void clear_include_nulls() ;
  bool include_nulls() const;
  void set_include_nulls(bool value);

  private:
  bool _internal_include_nulls() const;
  void _internal_set_include_nulls(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool include_nulls_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecCountDistinct final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct) */ {
 public:
  inline AggSpec_AggSpecCountDistinct() : AggSpec_AggSpecCountDistinct(nullptr) {}
  ~AggSpec_AggSpecCountDistinct() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecCountDistinct(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecCountDistinct(const AggSpec_AggSpecCountDistinct& from)
      : AggSpec_AggSpecCountDistinct(nullptr, from) {}
  AggSpec_AggSpecCountDistinct(AggSpec_AggSpecCountDistinct&& from) noexcept
    : AggSpec_AggSpecCountDistinct() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecCountDistinct& operator=(const AggSpec_AggSpecCountDistinct& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecCountDistinct& operator=(AggSpec_AggSpecCountDistinct&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecCountDistinct& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecCountDistinct* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecCountDistinct*>(
               &_AggSpec_AggSpecCountDistinct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(AggSpec_AggSpecCountDistinct& a, AggSpec_AggSpecCountDistinct& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecCountDistinct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecCountDistinct* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecCountDistinct* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecCountDistinct>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecCountDistinct& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec_AggSpecCountDistinct& from) {
    AggSpec_AggSpecCountDistinct::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec_AggSpecCountDistinct* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct";
  }
  protected:
  explicit AggSpec_AggSpecCountDistinct(::google::protobuf::Arena* arena);
  AggSpec_AggSpecCountDistinct(::google::protobuf::Arena* arena, const AggSpec_AggSpecCountDistinct& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountNullsFieldNumber = 1,
  };
  // bool count_nulls = 1;
  void clear_count_nulls() ;
  bool count_nulls() const;
  void set_count_nulls(bool value);

  private:
  bool _internal_count_nulls() const;
  void _internal_set_count_nulls(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool count_nulls_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecAvg final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAvg) */ {
 public:
  inline AggSpec_AggSpecAvg() : AggSpec_AggSpecAvg(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecAvg(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecAvg(const AggSpec_AggSpecAvg& from)
      : AggSpec_AggSpecAvg(nullptr, from) {}
  AggSpec_AggSpecAvg(AggSpec_AggSpecAvg&& from) noexcept
    : AggSpec_AggSpecAvg() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecAvg& operator=(const AggSpec_AggSpecAvg& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecAvg& operator=(AggSpec_AggSpecAvg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecAvg& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecAvg* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecAvg*>(
               &_AggSpec_AggSpecAvg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(AggSpec_AggSpecAvg& a, AggSpec_AggSpecAvg& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecAvg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecAvg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecAvg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecAvg>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecAvg& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecAvg& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAvg";
  }
  protected:
  explicit AggSpec_AggSpecAvg(::google::protobuf::Arena* arena);
  AggSpec_AggSpecAvg(::google::protobuf::Arena* arena, const AggSpec_AggSpecAvg& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAvg)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecApproximatePercentile final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile) */ {
 public:
  inline AggSpec_AggSpecApproximatePercentile() : AggSpec_AggSpecApproximatePercentile(nullptr) {}
  ~AggSpec_AggSpecApproximatePercentile() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecApproximatePercentile(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecApproximatePercentile(const AggSpec_AggSpecApproximatePercentile& from)
      : AggSpec_AggSpecApproximatePercentile(nullptr, from) {}
  AggSpec_AggSpecApproximatePercentile(AggSpec_AggSpecApproximatePercentile&& from) noexcept
    : AggSpec_AggSpecApproximatePercentile() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecApproximatePercentile& operator=(const AggSpec_AggSpecApproximatePercentile& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecApproximatePercentile& operator=(AggSpec_AggSpecApproximatePercentile&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecApproximatePercentile& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecApproximatePercentile* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecApproximatePercentile*>(
               &_AggSpec_AggSpecApproximatePercentile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(AggSpec_AggSpecApproximatePercentile& a, AggSpec_AggSpecApproximatePercentile& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecApproximatePercentile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecApproximatePercentile* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecApproximatePercentile* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecApproximatePercentile>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecApproximatePercentile& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec_AggSpecApproximatePercentile& from) {
    AggSpec_AggSpecApproximatePercentile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec_AggSpecApproximatePercentile* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile";
  }
  protected:
  explicit AggSpec_AggSpecApproximatePercentile(::google::protobuf::Arena* arena);
  AggSpec_AggSpecApproximatePercentile(::google::protobuf::Arena* arena, const AggSpec_AggSpecApproximatePercentile& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPercentileFieldNumber = 1,
    kCompressionFieldNumber = 2,
  };
  // double percentile = 1;
  void clear_percentile() ;
  double percentile() const;
  void set_percentile(double value);

  private:
  double _internal_percentile() const;
  void _internal_set_percentile(double value);

  public:
  // optional double compression = 2;
  bool has_compression() const;
  void clear_compression() ;
  double compression() const;
  void set_compression(double value);

  private:
  double _internal_compression() const;
  void _internal_set_compression(double value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    double percentile_;
    double compression_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecAbsSum final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAbsSum) */ {
 public:
  inline AggSpec_AggSpecAbsSum() : AggSpec_AggSpecAbsSum(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecAbsSum(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecAbsSum(const AggSpec_AggSpecAbsSum& from)
      : AggSpec_AggSpecAbsSum(nullptr, from) {}
  AggSpec_AggSpecAbsSum(AggSpec_AggSpecAbsSum&& from) noexcept
    : AggSpec_AggSpecAbsSum() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecAbsSum& operator=(const AggSpec_AggSpecAbsSum& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecAbsSum& operator=(AggSpec_AggSpecAbsSum&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecAbsSum& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecAbsSum* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecAbsSum*>(
               &_AggSpec_AggSpecAbsSum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(AggSpec_AggSpecAbsSum& a, AggSpec_AggSpecAbsSum& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecAbsSum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecAbsSum* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecAbsSum* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecAbsSum>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const AggSpec_AggSpecAbsSum& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const AggSpec_AggSpecAbsSum& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAbsSum";
  }
  protected:
  explicit AggSpec_AggSpecAbsSum(::google::protobuf::Arena* arena);
  AggSpec_AggSpecAbsSum(::google::protobuf::Arena* arena, const AggSpec_AggSpecAbsSum& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAbsSum)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class Value final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Value(::google::protobuf::internal::ConstantInitialized);

  inline Value(const Value& from)
      : Value(nullptr, from) {}
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kReference = 1,
    kLiteral = 2,
    DATA_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  inline void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Value& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Value& from) {
    Value::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Value* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Value";
  }
  protected:
  explicit Value(::google::protobuf::Arena* arena);
  Value(::google::protobuf::Arena* arena, const Value& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferenceFieldNumber = 1,
    kLiteralFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Reference reference = 1;
  bool has_reference() const;
  private:
  bool _internal_has_reference() const;

  public:
  void clear_reference() ;
  const ::io::deephaven::proto::backplane::grpc::Reference& reference() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Reference* release_reference();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_reference();
  void set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value);
  void unsafe_arena_set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value);
  ::io::deephaven::proto::backplane::grpc::Reference* unsafe_arena_release_reference();

  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_reference() const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_mutable_reference();

  public:
  // .io.deephaven.proto.backplane.grpc.Literal literal = 2;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;

  public:
  void clear_literal() ;
  const ::io::deephaven::proto::backplane::grpc::Literal& literal() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Literal* release_literal();
  ::io::deephaven::proto::backplane::grpc::Literal* mutable_literal();
  void set_allocated_literal(::io::deephaven::proto::backplane::grpc::Literal* value);
  void unsafe_arena_set_allocated_literal(::io::deephaven::proto::backplane::grpc::Literal* value);
  ::io::deephaven::proto::backplane::grpc::Literal* unsafe_arena_release_literal();

  private:
  const ::io::deephaven::proto::backplane::grpc::Literal& _internal_literal() const;
  ::io::deephaven::proto::backplane::grpc::Literal* _internal_mutable_literal();

  public:
  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Value)
 private:
  class _Internal;
  void set_has_reference();
  void set_has_literal();

  inline bool has_data() const;
  inline void clear_has_data();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::io::deephaven::proto::backplane::grpc::Reference* reference_;
      ::io::deephaven::proto::backplane::grpc::Literal* literal_;
    } data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByWindowScale final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByWindowScale) */ {
 public:
  inline UpdateByWindowScale() : UpdateByWindowScale(nullptr) {}
  ~UpdateByWindowScale() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByWindowScale(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByWindowScale(const UpdateByWindowScale& from)
      : UpdateByWindowScale(nullptr, from) {}
  UpdateByWindowScale(UpdateByWindowScale&& from) noexcept
    : UpdateByWindowScale() {
    *this = ::std::move(from);
  }

  inline UpdateByWindowScale& operator=(const UpdateByWindowScale& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByWindowScale& operator=(UpdateByWindowScale&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByWindowScale& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kTicks = 1,
    kTime = 2,
    TYPE_NOT_SET = 0,
  };

  static inline const UpdateByWindowScale* internal_default_instance() {
    return reinterpret_cast<const UpdateByWindowScale*>(
               &_UpdateByWindowScale_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(UpdateByWindowScale& a, UpdateByWindowScale& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByWindowScale* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByWindowScale* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByWindowScale* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByWindowScale>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByWindowScale& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByWindowScale& from) {
    UpdateByWindowScale::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByWindowScale* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByWindowScale";
  }
  protected:
  explicit UpdateByWindowScale(::google::protobuf::Arena* arena);
  UpdateByWindowScale(::google::protobuf::Arena* arena, const UpdateByWindowScale& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using UpdateByWindowTicks = UpdateByWindowScale_UpdateByWindowTicks;
  using UpdateByWindowTime = UpdateByWindowScale_UpdateByWindowTime;

  // accessors -------------------------------------------------------

  enum : int {
    kTicksFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks ticks = 1;
  bool has_ticks() const;
  private:
  bool _internal_has_ticks() const;

  public:
  void clear_ticks() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks& ticks() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* release_ticks();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* mutable_ticks();
  void set_allocated_ticks(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* value);
  void unsafe_arena_set_allocated_ticks(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* unsafe_arena_release_ticks();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks& _internal_ticks() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* _internal_mutable_ticks();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime time = 2;
  bool has_time() const;
  private:
  bool _internal_has_time() const;

  public:
  void clear_time() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime& time() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* release_time();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* mutable_time();
  void set_allocated_time(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* value);
  void unsafe_arena_set_allocated_time(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* unsafe_arena_release_time();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime& _internal_time() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* _internal_mutable_time();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByWindowScale)
 private:
  class _Internal;
  void set_has_ticks();
  void set_has_time();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* ticks_;
      ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* time_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions) */ {
 public:
  inline UpdateByRequest_UpdateByOptions() : UpdateByRequest_UpdateByOptions(nullptr) {}
  ~UpdateByRequest_UpdateByOptions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOptions(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOptions(const UpdateByRequest_UpdateByOptions& from)
      : UpdateByRequest_UpdateByOptions(nullptr, from) {}
  UpdateByRequest_UpdateByOptions(UpdateByRequest_UpdateByOptions&& from) noexcept
    : UpdateByRequest_UpdateByOptions() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOptions& operator=(const UpdateByRequest_UpdateByOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOptions& operator=(UpdateByRequest_UpdateByOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOptions* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOptions*>(
               &_UpdateByRequest_UpdateByOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UpdateByRequest_UpdateByOptions& a, UpdateByRequest_UpdateByOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOptions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOptions& from) {
    UpdateByRequest_UpdateByOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOptions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions";
  }
  protected:
  explicit UpdateByRequest_UpdateByOptions(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOptions(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOptions& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMathContextFieldNumber = 7,
    kUseRedirectionFieldNumber = 1,
    kChunkCapacityFieldNumber = 2,
    kMaxStaticSparseMemoryOverheadFieldNumber = 3,
    kMaximumLoadFactorFieldNumber = 5,
    kTargetLoadFactorFieldNumber = 6,
    kInitialHashTableSizeFieldNumber = 4,
  };
  // .io.deephaven.proto.backplane.grpc.MathContext math_context = 7;
  bool has_math_context() const;
  void clear_math_context() ;
  const ::io::deephaven::proto::backplane::grpc::MathContext& math_context() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::MathContext* release_math_context();
  ::io::deephaven::proto::backplane::grpc::MathContext* mutable_math_context();
  void set_allocated_math_context(::io::deephaven::proto::backplane::grpc::MathContext* value);
  void unsafe_arena_set_allocated_math_context(::io::deephaven::proto::backplane::grpc::MathContext* value);
  ::io::deephaven::proto::backplane::grpc::MathContext* unsafe_arena_release_math_context();

  private:
  const ::io::deephaven::proto::backplane::grpc::MathContext& _internal_math_context() const;
  ::io::deephaven::proto::backplane::grpc::MathContext* _internal_mutable_math_context();

  public:
  // optional bool use_redirection = 1;
  bool has_use_redirection() const;
  void clear_use_redirection() ;
  bool use_redirection() const;
  void set_use_redirection(bool value);

  private:
  bool _internal_use_redirection() const;
  void _internal_set_use_redirection(bool value);

  public:
  // optional int32 chunk_capacity = 2;
  bool has_chunk_capacity() const;
  void clear_chunk_capacity() ;
  ::int32_t chunk_capacity() const;
  void set_chunk_capacity(::int32_t value);

  private:
  ::int32_t _internal_chunk_capacity() const;
  void _internal_set_chunk_capacity(::int32_t value);

  public:
  // optional double max_static_sparse_memory_overhead = 3;
  bool has_max_static_sparse_memory_overhead() const;
  void clear_max_static_sparse_memory_overhead() ;
  double max_static_sparse_memory_overhead() const;
  void set_max_static_sparse_memory_overhead(double value);

  private:
  double _internal_max_static_sparse_memory_overhead() const;
  void _internal_set_max_static_sparse_memory_overhead(double value);

  public:
  // optional double maximum_load_factor = 5;
  bool has_maximum_load_factor() const;
  void clear_maximum_load_factor() ;
  double maximum_load_factor() const;
  void set_maximum_load_factor(double value);

  private:
  double _internal_maximum_load_factor() const;
  void _internal_set_maximum_load_factor(double value);

  public:
  // optional double target_load_factor = 6;
  bool has_target_load_factor() const;
  void clear_target_load_factor() ;
  double target_load_factor() const;
  void set_target_load_factor(double value);

  private:
  double _internal_target_load_factor() const;
  void _internal_set_target_load_factor(double value);

  public:
  // optional int32 initial_hash_table_size = 4;
  bool has_initial_hash_table_size() const;
  void clear_initial_hash_table_size() ;
  ::int32_t initial_hash_table_size() const;
  void set_initial_hash_table_size(::int32_t value);

  private:
  ::int32_t _internal_initial_hash_table_size() const;
  void _internal_set_initial_hash_table_size(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::MathContext* math_context_;
    bool use_redirection_;
    ::int32_t chunk_capacity_;
    double max_static_sparse_memory_overhead_;
    double maximum_load_factor_;
    double target_load_factor_;
    ::int32_t initial_hash_table_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions options = 1;
  bool has_options() const;
  void clear_options() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* value);
  void unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* unsafe_arena_release_options();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* _internal_mutable_options();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* options_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByEmOptions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByEmOptions) */ {
 public:
  inline UpdateByEmOptions() : UpdateByEmOptions(nullptr) {}
  ~UpdateByEmOptions() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByEmOptions(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByEmOptions(const UpdateByEmOptions& from)
      : UpdateByEmOptions(nullptr, from) {}
  UpdateByEmOptions(UpdateByEmOptions&& from) noexcept
    : UpdateByEmOptions() {
    *this = ::std::move(from);
  }

  inline UpdateByEmOptions& operator=(const UpdateByEmOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByEmOptions& operator=(UpdateByEmOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByEmOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByEmOptions* internal_default_instance() {
    return reinterpret_cast<const UpdateByEmOptions*>(
               &_UpdateByEmOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(UpdateByEmOptions& a, UpdateByEmOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByEmOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByEmOptions* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByEmOptions* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByEmOptions>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByEmOptions& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByEmOptions& from) {
    UpdateByEmOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByEmOptions* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByEmOptions";
  }
  protected:
  explicit UpdateByEmOptions(::google::protobuf::Arena* arena);
  UpdateByEmOptions(::google::protobuf::Arena* arena, const UpdateByEmOptions& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBigValueContextFieldNumber = 6,
    kOnNullValueFieldNumber = 1,
    kOnNanValueFieldNumber = 2,
    kOnNullTimeFieldNumber = 3,
    kOnNegativeDeltaTimeFieldNumber = 4,
    kOnZeroDeltaTimeFieldNumber = 5,
  };
  // .io.deephaven.proto.backplane.grpc.MathContext big_value_context = 6;
  bool has_big_value_context() const;
  void clear_big_value_context() ;
  const ::io::deephaven::proto::backplane::grpc::MathContext& big_value_context() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::MathContext* release_big_value_context();
  ::io::deephaven::proto::backplane::grpc::MathContext* mutable_big_value_context();
  void set_allocated_big_value_context(::io::deephaven::proto::backplane::grpc::MathContext* value);
  void unsafe_arena_set_allocated_big_value_context(::io::deephaven::proto::backplane::grpc::MathContext* value);
  ::io::deephaven::proto::backplane::grpc::MathContext* unsafe_arena_release_big_value_context();

  private:
  const ::io::deephaven::proto::backplane::grpc::MathContext& _internal_big_value_context() const;
  ::io::deephaven::proto::backplane::grpc::MathContext* _internal_mutable_big_value_context();

  public:
  // .io.deephaven.proto.backplane.grpc.BadDataBehavior on_null_value = 1;
  void clear_on_null_value() ;
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior on_null_value() const;
  void set_on_null_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);

  private:
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior _internal_on_null_value() const;
  void _internal_set_on_null_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);

  public:
  // .io.deephaven.proto.backplane.grpc.BadDataBehavior on_nan_value = 2;
  void clear_on_nan_value() ;
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior on_nan_value() const;
  void set_on_nan_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);

  private:
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior _internal_on_nan_value() const;
  void _internal_set_on_nan_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);

  public:
  // .io.deephaven.proto.backplane.grpc.BadDataBehavior on_null_time = 3;
  void clear_on_null_time() ;
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior on_null_time() const;
  void set_on_null_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);

  private:
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior _internal_on_null_time() const;
  void _internal_set_on_null_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);

  public:
  // .io.deephaven.proto.backplane.grpc.BadDataBehavior on_negative_delta_time = 4;
  void clear_on_negative_delta_time() ;
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior on_negative_delta_time() const;
  void set_on_negative_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);

  private:
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior _internal_on_negative_delta_time() const;
  void _internal_set_on_negative_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);

  public:
  // .io.deephaven.proto.backplane.grpc.BadDataBehavior on_zero_delta_time = 5;
  void clear_on_zero_delta_time() ;
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior on_zero_delta_time() const;
  void set_on_zero_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);

  private:
  ::io::deephaven::proto::backplane::grpc::BadDataBehavior _internal_on_zero_delta_time() const;
  void _internal_set_on_zero_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByEmOptions)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::MathContext* big_value_context_;
    int on_null_value_;
    int on_nan_value_;
    int on_null_time_;
    int on_negative_delta_time_;
    int on_zero_delta_time_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class TimeTableRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.TimeTableRequest) */ {
 public:
  inline TimeTableRequest() : TimeTableRequest(nullptr) {}
  ~TimeTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TimeTableRequest(::google::protobuf::internal::ConstantInitialized);

  inline TimeTableRequest(const TimeTableRequest& from)
      : TimeTableRequest(nullptr, from) {}
  TimeTableRequest(TimeTableRequest&& from) noexcept
    : TimeTableRequest() {
    *this = ::std::move(from);
  }

  inline TimeTableRequest& operator=(const TimeTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeTableRequest& operator=(TimeTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TimeTableRequest& default_instance() {
    return *internal_default_instance();
  }
  enum StartTimeCase {
    kStartTimeNanos = 2,
    kStartTimeString = 5,
    START_TIME_NOT_SET = 0,
  };

  enum PeriodCase {
    kPeriodNanos = 3,
    kPeriodString = 6,
    PERIOD_NOT_SET = 0,
  };

  static inline const TimeTableRequest* internal_default_instance() {
    return reinterpret_cast<const TimeTableRequest*>(
               &_TimeTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TimeTableRequest& a, TimeTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimeTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimeTableRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimeTableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TimeTableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TimeTableRequest& from) {
    TimeTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TimeTableRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.TimeTableRequest";
  }
  protected:
  explicit TimeTableRequest(::google::protobuf::Arena* arena);
  TimeTableRequest(::google::protobuf::Arena* arena, const TimeTableRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kBlinkTableFieldNumber = 4,
    kStartTimeNanosFieldNumber = 2,
    kStartTimeStringFieldNumber = 5,
    kPeriodNanosFieldNumber = 3,
    kPeriodStringFieldNumber = 6,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // bool blink_table = 4;
  void clear_blink_table() ;
  bool blink_table() const;
  void set_blink_table(bool value);

  private:
  bool _internal_blink_table() const;
  void _internal_set_blink_table(bool value);

  public:
  // sint64 start_time_nanos = 2 [jstype = JS_STRING];
  bool has_start_time_nanos() const;
  void clear_start_time_nanos() ;
  ::int64_t start_time_nanos() const;
  void set_start_time_nanos(::int64_t value);

  private:
  ::int64_t _internal_start_time_nanos() const;
  void _internal_set_start_time_nanos(::int64_t value);

  public:
  // string start_time_string = 5;
  bool has_start_time_string() const;
  void clear_start_time_string() ;
  const std::string& start_time_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_start_time_string(Arg_&& arg, Args_... args);
  std::string* mutable_start_time_string();
  PROTOBUF_NODISCARD std::string* release_start_time_string();
  void set_allocated_start_time_string(std::string* value);

  private:
  const std::string& _internal_start_time_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_time_string(
      const std::string& value);
  std::string* _internal_mutable_start_time_string();

  public:
  // sint64 period_nanos = 3 [jstype = JS_STRING];
  bool has_period_nanos() const;
  void clear_period_nanos() ;
  ::int64_t period_nanos() const;
  void set_period_nanos(::int64_t value);

  private:
  ::int64_t _internal_period_nanos() const;
  void _internal_set_period_nanos(::int64_t value);

  public:
  // string period_string = 6;
  bool has_period_string() const;
  void clear_period_string() ;
  const std::string& period_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_period_string(Arg_&& arg, Args_... args);
  std::string* mutable_period_string();
  PROTOBUF_NODISCARD std::string* release_period_string();
  void set_allocated_period_string(std::string* value);

  private:
  const std::string& _internal_period_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_period_string(
      const std::string& value);
  std::string* _internal_mutable_period_string();

  public:
  void clear_start_time();
  StartTimeCase start_time_case() const;
  void clear_period();
  PeriodCase period_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.TimeTableRequest)
 private:
  class _Internal;
  void set_has_start_time_nanos();
  void set_has_start_time_string();
  void set_has_period_nanos();
  void set_has_period_string();

  inline bool has_start_time() const;
  inline void clear_has_start_time();

  inline bool has_period() const;
  inline void clear_has_period();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 6, 1,
      89, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    bool blink_table_;
    union StartTimeUnion {
      constexpr StartTimeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t start_time_nanos_;
      ::google::protobuf::internal::ArenaStringPtr start_time_string_;
    } start_time_;
    union PeriodUnion {
      constexpr PeriodUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::int64_t period_nanos_;
      ::google::protobuf::internal::ArenaStringPtr period_string_;
    } period_;
    ::uint32_t _oneof_case_[2];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class TableReference final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.TableReference) */ {
 public:
  inline TableReference() : TableReference(nullptr) {}
  ~TableReference() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR TableReference(::google::protobuf::internal::ConstantInitialized);

  inline TableReference(const TableReference& from)
      : TableReference(nullptr, from) {}
  TableReference(TableReference&& from) noexcept
    : TableReference() {
    *this = ::std::move(from);
  }

  inline TableReference& operator=(const TableReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableReference& operator=(TableReference&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableReference& default_instance() {
    return *internal_default_instance();
  }
  enum RefCase {
    kTicket = 1,
    kBatchOffset = 2,
    REF_NOT_SET = 0,
  };

  static inline const TableReference* internal_default_instance() {
    return reinterpret_cast<const TableReference*>(
               &_TableReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TableReference& a, TableReference& b) {
    a.Swap(&b);
  }
  inline void Swap(TableReference* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableReference* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableReference* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableReference>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TableReference& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const TableReference& from) {
    TableReference::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TableReference* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.TableReference";
  }
  protected:
  explicit TableReference(::google::protobuf::Arena* arena);
  TableReference(::google::protobuf::Arena* arena, const TableReference& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTicketFieldNumber = 1,
    kBatchOffsetFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket ticket = 1;
  bool has_ticket() const;
  private:
  bool _internal_has_ticket() const;

  public:
  void clear_ticket() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& ticket() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_ticket();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_ticket();
  void set_allocated_ticket(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_ticket(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_ticket();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_ticket() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_ticket();

  public:
  // sint32 batch_offset = 2;
  bool has_batch_offset() const;
  void clear_batch_offset() ;
  ::int32_t batch_offset() const;
  void set_batch_offset(::int32_t value);

  private:
  ::int32_t _internal_batch_offset() const;
  void _internal_set_batch_offset(::int32_t value);

  public:
  void clear_ref();
  RefCase ref_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.TableReference)
 private:
  class _Internal;
  void set_has_ticket();
  void set_has_batch_offset();

  inline bool has_ref() const;
  inline void clear_has_ref();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union RefUnion {
      constexpr RefUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::io::deephaven::proto::backplane::grpc::Ticket* ticket_;
      ::int32_t batch_offset_;
    } ref_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class SeekRowRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SeekRowRequest) */ {
 public:
  inline SeekRowRequest() : SeekRowRequest(nullptr) {}
  ~SeekRowRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SeekRowRequest(::google::protobuf::internal::ConstantInitialized);

  inline SeekRowRequest(const SeekRowRequest& from)
      : SeekRowRequest(nullptr, from) {}
  SeekRowRequest(SeekRowRequest&& from) noexcept
    : SeekRowRequest() {
    *this = ::std::move(from);
  }

  inline SeekRowRequest& operator=(const SeekRowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeekRowRequest& operator=(SeekRowRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeekRowRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeekRowRequest* internal_default_instance() {
    return reinterpret_cast<const SeekRowRequest*>(
               &_SeekRowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(SeekRowRequest& a, SeekRowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SeekRowRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeekRowRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SeekRowRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SeekRowRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SeekRowRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SeekRowRequest& from) {
    SeekRowRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SeekRowRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SeekRowRequest";
  }
  protected:
  explicit SeekRowRequest(::google::protobuf::Arena* arena);
  SeekRowRequest(::google::protobuf::Arena* arena, const SeekRowRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 3,
    kSourceIdFieldNumber = 1,
    kSeekValueFieldNumber = 4,
    kStartingRowFieldNumber = 2,
    kInsensitiveFieldNumber = 5,
    kContainsFieldNumber = 6,
    kIsBackwardFieldNumber = 7,
  };
  // string column_name = 3;
  void clear_column_name() ;
  const std::string& column_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* value);

  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(
      const std::string& value);
  std::string* _internal_mutable_column_name();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket source_id = 1;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_source_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_source_id();

  public:
  // .io.deephaven.proto.backplane.grpc.Literal seek_value = 4;
  bool has_seek_value() const;
  void clear_seek_value() ;
  const ::io::deephaven::proto::backplane::grpc::Literal& seek_value() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Literal* release_seek_value();
  ::io::deephaven::proto::backplane::grpc::Literal* mutable_seek_value();
  void set_allocated_seek_value(::io::deephaven::proto::backplane::grpc::Literal* value);
  void unsafe_arena_set_allocated_seek_value(::io::deephaven::proto::backplane::grpc::Literal* value);
  ::io::deephaven::proto::backplane::grpc::Literal* unsafe_arena_release_seek_value();

  private:
  const ::io::deephaven::proto::backplane::grpc::Literal& _internal_seek_value() const;
  ::io::deephaven::proto::backplane::grpc::Literal* _internal_mutable_seek_value();

  public:
  // sint64 starting_row = 2 [jstype = JS_STRING];
  void clear_starting_row() ;
  ::int64_t starting_row() const;
  void set_starting_row(::int64_t value);

  private:
  ::int64_t _internal_starting_row() const;
  void _internal_set_starting_row(::int64_t value);

  public:
  // bool insensitive = 5;
  void clear_insensitive() ;
  bool insensitive() const;
  void set_insensitive(bool value);

  private:
  bool _internal_insensitive() const;
  void _internal_set_insensitive(bool value);

  public:
  // bool contains = 6;
  void clear_contains() ;
  bool contains() const;
  void set_contains(bool value);

  private:
  bool _internal_contains() const;
  void _internal_set_contains(bool value);

  public:
  // bool is_backward = 7;
  void clear_is_backward() ;
  bool is_backward() const;
  void set_is_backward(bool value);

  private:
  bool _internal_is_backward() const;
  void _internal_set_is_backward(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SeekRowRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 2,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr column_name_;
    ::io::deephaven::proto::backplane::grpc::Ticket* source_id_;
    ::io::deephaven::proto::backplane::grpc::Literal* seek_value_;
    ::int64_t starting_row_;
    bool insensitive_;
    bool contains_;
    bool is_backward_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class SearchCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SearchCondition) */ {
 public:
  inline SearchCondition() : SearchCondition(nullptr) {}
  ~SearchCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SearchCondition(::google::protobuf::internal::ConstantInitialized);

  inline SearchCondition(const SearchCondition& from)
      : SearchCondition(nullptr, from) {}
  SearchCondition(SearchCondition&& from) noexcept
    : SearchCondition() {
    *this = ::std::move(from);
  }

  inline SearchCondition& operator=(const SearchCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline SearchCondition& operator=(SearchCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SearchCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const SearchCondition* internal_default_instance() {
    return reinterpret_cast<const SearchCondition*>(
               &_SearchCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(SearchCondition& a, SearchCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(SearchCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SearchCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SearchCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SearchCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SearchCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SearchCondition& from) {
    SearchCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SearchCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SearchCondition";
  }
  protected:
  explicit SearchCondition(::google::protobuf::Arena* arena);
  SearchCondition(::google::protobuf::Arena* arena, const SearchCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionalReferencesFieldNumber = 2,
    kSearchStringFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Reference optional_references = 2;
  int optional_references_size() const;
  private:
  int _internal_optional_references_size() const;

  public:
  void clear_optional_references() ;
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_optional_references(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference >*
      mutable_optional_references();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Reference>& _internal_optional_references() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Reference>* _internal_mutable_optional_references();
  public:
  const ::io::deephaven::proto::backplane::grpc::Reference& optional_references(int index) const;
  ::io::deephaven::proto::backplane::grpc::Reference* add_optional_references();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference >&
      optional_references() const;
  // string search_string = 1;
  void clear_search_string() ;
  const std::string& search_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_search_string(Arg_&& arg, Args_... args);
  std::string* mutable_search_string();
  PROTOBUF_NODISCARD std::string* release_search_string();
  void set_allocated_search_string(std::string* value);

  private:
  const std::string& _internal_search_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_string(
      const std::string& value);
  std::string* _internal_mutable_search_string();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SearchCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Reference > optional_references_;
    ::google::protobuf::internal::ArenaStringPtr search_string_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class MatchesCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MatchesCondition) */ {
 public:
  inline MatchesCondition() : MatchesCondition(nullptr) {}
  ~MatchesCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MatchesCondition(::google::protobuf::internal::ConstantInitialized);

  inline MatchesCondition(const MatchesCondition& from)
      : MatchesCondition(nullptr, from) {}
  MatchesCondition(MatchesCondition&& from) noexcept
    : MatchesCondition() {
    *this = ::std::move(from);
  }

  inline MatchesCondition& operator=(const MatchesCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchesCondition& operator=(MatchesCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchesCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchesCondition* internal_default_instance() {
    return reinterpret_cast<const MatchesCondition*>(
               &_MatchesCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(MatchesCondition& a, MatchesCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchesCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchesCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchesCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchesCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MatchesCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MatchesCondition& from) {
    MatchesCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MatchesCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MatchesCondition";
  }
  protected:
  explicit MatchesCondition(::google::protobuf::Arena* arena);
  MatchesCondition(::google::protobuf::Arena* arena, const MatchesCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegexFieldNumber = 2,
    kReferenceFieldNumber = 1,
    kCaseSensitivityFieldNumber = 3,
    kMatchTypeFieldNumber = 4,
  };
  // string regex = 2;
  void clear_regex() ;
  const std::string& regex() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_regex(Arg_&& arg, Args_... args);
  std::string* mutable_regex();
  PROTOBUF_NODISCARD std::string* release_regex();
  void set_allocated_regex(std::string* value);

  private:
  const std::string& _internal_regex() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_regex(
      const std::string& value);
  std::string* _internal_mutable_regex();

  public:
  // .io.deephaven.proto.backplane.grpc.Reference reference = 1;
  bool has_reference() const;
  void clear_reference() ;
  const ::io::deephaven::proto::backplane::grpc::Reference& reference() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Reference* release_reference();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_reference();
  void set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value);
  void unsafe_arena_set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value);
  ::io::deephaven::proto::backplane::grpc::Reference* unsafe_arena_release_reference();

  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_reference() const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_mutable_reference();

  public:
  // .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
  void clear_case_sensitivity() ;
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity case_sensitivity() const;
  void set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);

  private:
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);

  public:
  // .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
  void clear_match_type() ;
  ::io::deephaven::proto::backplane::grpc::MatchType match_type() const;
  void set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);

  private:
  ::io::deephaven::proto::backplane::grpc::MatchType _internal_match_type() const;
  void _internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MatchesCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr regex_;
    ::io::deephaven::proto::backplane::grpc::Reference* reference_;
    int case_sensitivity_;
    int match_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class IsNullCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.IsNullCondition) */ {
 public:
  inline IsNullCondition() : IsNullCondition(nullptr) {}
  ~IsNullCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR IsNullCondition(::google::protobuf::internal::ConstantInitialized);

  inline IsNullCondition(const IsNullCondition& from)
      : IsNullCondition(nullptr, from) {}
  IsNullCondition(IsNullCondition&& from) noexcept
    : IsNullCondition() {
    *this = ::std::move(from);
  }

  inline IsNullCondition& operator=(const IsNullCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline IsNullCondition& operator=(IsNullCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IsNullCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const IsNullCondition* internal_default_instance() {
    return reinterpret_cast<const IsNullCondition*>(
               &_IsNullCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(IsNullCondition& a, IsNullCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(IsNullCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IsNullCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IsNullCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IsNullCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const IsNullCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const IsNullCondition& from) {
    IsNullCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(IsNullCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.IsNullCondition";
  }
  protected:
  explicit IsNullCondition(::google::protobuf::Arena* arena);
  IsNullCondition(::google::protobuf::Arena* arena, const IsNullCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReferenceFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.Reference reference = 1;
  bool has_reference() const;
  void clear_reference() ;
  const ::io::deephaven::proto::backplane::grpc::Reference& reference() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Reference* release_reference();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_reference();
  void set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value);
  void unsafe_arena_set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value);
  ::io::deephaven::proto::backplane::grpc::Reference* unsafe_arena_release_reference();

  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_reference() const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_mutable_reference();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.IsNullCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::Reference* reference_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class ExportedTableUpdateMessage final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage) */ {
 public:
  inline ExportedTableUpdateMessage() : ExportedTableUpdateMessage(nullptr) {}
  ~ExportedTableUpdateMessage() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExportedTableUpdateMessage(::google::protobuf::internal::ConstantInitialized);

  inline ExportedTableUpdateMessage(const ExportedTableUpdateMessage& from)
      : ExportedTableUpdateMessage(nullptr, from) {}
  ExportedTableUpdateMessage(ExportedTableUpdateMessage&& from) noexcept
    : ExportedTableUpdateMessage() {
    *this = ::std::move(from);
  }

  inline ExportedTableUpdateMessage& operator=(const ExportedTableUpdateMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportedTableUpdateMessage& operator=(ExportedTableUpdateMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportedTableUpdateMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportedTableUpdateMessage* internal_default_instance() {
    return reinterpret_cast<const ExportedTableUpdateMessage*>(
               &_ExportedTableUpdateMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ExportedTableUpdateMessage& a, ExportedTableUpdateMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportedTableUpdateMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportedTableUpdateMessage* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExportedTableUpdateMessage* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExportedTableUpdateMessage>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExportedTableUpdateMessage& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ExportedTableUpdateMessage& from) {
    ExportedTableUpdateMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExportedTableUpdateMessage* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage";
  }
  protected:
  explicit ExportedTableUpdateMessage(::google::protobuf::Arena* arena);
  ExportedTableUpdateMessage(::google::protobuf::Arena* arena, const ExportedTableUpdateMessage& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateFailureMessageFieldNumber = 3,
    kExportIdFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // string update_failure_message = 3;
  void clear_update_failure_message() ;
  const std::string& update_failure_message() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_update_failure_message(Arg_&& arg, Args_... args);
  std::string* mutable_update_failure_message();
  PROTOBUF_NODISCARD std::string* release_update_failure_message();
  void set_allocated_update_failure_message(std::string* value);

  private:
  const std::string& _internal_update_failure_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_update_failure_message(
      const std::string& value);
  std::string* _internal_mutable_update_failure_message();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket export_id = 1;
  bool has_export_id() const;
  void clear_export_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& export_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_export_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_export_id();
  void set_allocated_export_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_export_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_export_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_export_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_export_id();

  public:
  // sint64 size = 2 [jstype = JS_STRING];
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      91, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr update_failure_message_;
    ::io::deephaven::proto::backplane::grpc::Ticket* export_id_;
    ::int64_t size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class EmptyTableRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.EmptyTableRequest) */ {
 public:
  inline EmptyTableRequest() : EmptyTableRequest(nullptr) {}
  ~EmptyTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EmptyTableRequest(::google::protobuf::internal::ConstantInitialized);

  inline EmptyTableRequest(const EmptyTableRequest& from)
      : EmptyTableRequest(nullptr, from) {}
  EmptyTableRequest(EmptyTableRequest&& from) noexcept
    : EmptyTableRequest() {
    *this = ::std::move(from);
  }

  inline EmptyTableRequest& operator=(const EmptyTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyTableRequest& operator=(EmptyTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EmptyTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EmptyTableRequest* internal_default_instance() {
    return reinterpret_cast<const EmptyTableRequest*>(
               &_EmptyTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EmptyTableRequest& a, EmptyTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EmptyTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EmptyTableRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EmptyTableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EmptyTableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const EmptyTableRequest& from) {
    EmptyTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(EmptyTableRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.EmptyTableRequest";
  }
  protected:
  explicit EmptyTableRequest(::google::protobuf::Arena* arena);
  EmptyTableRequest(::google::protobuf::Arena* arena, const EmptyTableRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // sint64 size = 2 [jstype = JS_STRING];
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.EmptyTableRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::int64_t size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class CreateInputTableRequest_InputTableKind final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind) */ {
 public:
  inline CreateInputTableRequest_InputTableKind() : CreateInputTableRequest_InputTableKind(nullptr) {}
  ~CreateInputTableRequest_InputTableKind() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateInputTableRequest_InputTableKind(::google::protobuf::internal::ConstantInitialized);

  inline CreateInputTableRequest_InputTableKind(const CreateInputTableRequest_InputTableKind& from)
      : CreateInputTableRequest_InputTableKind(nullptr, from) {}
  CreateInputTableRequest_InputTableKind(CreateInputTableRequest_InputTableKind&& from) noexcept
    : CreateInputTableRequest_InputTableKind() {
    *this = ::std::move(from);
  }

  inline CreateInputTableRequest_InputTableKind& operator=(const CreateInputTableRequest_InputTableKind& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInputTableRequest_InputTableKind& operator=(CreateInputTableRequest_InputTableKind&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInputTableRequest_InputTableKind& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kInMemoryAppendOnly = 1,
    kInMemoryKeyBacked = 2,
    kBlink = 3,
    KIND_NOT_SET = 0,
  };

  static inline const CreateInputTableRequest_InputTableKind* internal_default_instance() {
    return reinterpret_cast<const CreateInputTableRequest_InputTableKind*>(
               &_CreateInputTableRequest_InputTableKind_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    118;

  friend void swap(CreateInputTableRequest_InputTableKind& a, CreateInputTableRequest_InputTableKind& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInputTableRequest_InputTableKind* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInputTableRequest_InputTableKind* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInputTableRequest_InputTableKind* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInputTableRequest_InputTableKind>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateInputTableRequest_InputTableKind& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateInputTableRequest_InputTableKind& from) {
    CreateInputTableRequest_InputTableKind::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateInputTableRequest_InputTableKind* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind";
  }
  protected:
  explicit CreateInputTableRequest_InputTableKind(::google::protobuf::Arena* arena);
  CreateInputTableRequest_InputTableKind(::google::protobuf::Arena* arena, const CreateInputTableRequest_InputTableKind& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using InMemoryAppendOnly = CreateInputTableRequest_InputTableKind_InMemoryAppendOnly;
  using InMemoryKeyBacked = CreateInputTableRequest_InputTableKind_InMemoryKeyBacked;
  using Blink = CreateInputTableRequest_InputTableKind_Blink;

  // accessors -------------------------------------------------------

  enum : int {
    kInMemoryAppendOnlyFieldNumber = 1,
    kInMemoryKeyBackedFieldNumber = 2,
    kBlinkFieldNumber = 3,
  };
  // .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryAppendOnly in_memory_append_only = 1;
  bool has_in_memory_append_only() const;
  private:
  bool _internal_has_in_memory_append_only() const;

  public:
  void clear_in_memory_append_only() ;
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& in_memory_append_only() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* release_in_memory_append_only();
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* mutable_in_memory_append_only();
  void set_allocated_in_memory_append_only(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* value);
  void unsafe_arena_set_allocated_in_memory_append_only(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* value);
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* unsafe_arena_release_in_memory_append_only();

  private:
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& _internal_in_memory_append_only() const;
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* _internal_mutable_in_memory_append_only();

  public:
  // .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked in_memory_key_backed = 2;
  bool has_in_memory_key_backed() const;
  private:
  bool _internal_has_in_memory_key_backed() const;

  public:
  void clear_in_memory_key_backed() ;
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& in_memory_key_backed() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* release_in_memory_key_backed();
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* mutable_in_memory_key_backed();
  void set_allocated_in_memory_key_backed(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* value);
  void unsafe_arena_set_allocated_in_memory_key_backed(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* value);
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* unsafe_arena_release_in_memory_key_backed();

  private:
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& _internal_in_memory_key_backed() const;
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* _internal_mutable_in_memory_key_backed();

  public:
  // .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.Blink blink = 3;
  bool has_blink() const;
  private:
  bool _internal_has_blink() const;

  public:
  void clear_blink() ;
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink& blink() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* release_blink();
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* mutable_blink();
  void set_allocated_blink(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* value);
  void unsafe_arena_set_allocated_blink(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* value);
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* unsafe_arena_release_blink();

  private:
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink& _internal_blink() const;
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* _internal_mutable_blink();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind)
 private:
  class _Internal;
  void set_has_in_memory_append_only();
  void set_has_in_memory_key_backed();
  void set_has_blink();

  inline bool has_kind() const;
  inline void clear_has_kind();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* in_memory_append_only_;
      ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* in_memory_key_backed_;
      ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* blink_;
    } kind_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class ContainsCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ContainsCondition) */ {
 public:
  inline ContainsCondition() : ContainsCondition(nullptr) {}
  ~ContainsCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ContainsCondition(::google::protobuf::internal::ConstantInitialized);

  inline ContainsCondition(const ContainsCondition& from)
      : ContainsCondition(nullptr, from) {}
  ContainsCondition(ContainsCondition&& from) noexcept
    : ContainsCondition() {
    *this = ::std::move(from);
  }

  inline ContainsCondition& operator=(const ContainsCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContainsCondition& operator=(ContainsCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ContainsCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContainsCondition* internal_default_instance() {
    return reinterpret_cast<const ContainsCondition*>(
               &_ContainsCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(ContainsCondition& a, ContainsCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(ContainsCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContainsCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContainsCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContainsCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ContainsCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ContainsCondition& from) {
    ContainsCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ContainsCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ContainsCondition";
  }
  protected:
  explicit ContainsCondition(::google::protobuf::Arena* arena);
  ContainsCondition(::google::protobuf::Arena* arena, const ContainsCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSearchStringFieldNumber = 2,
    kReferenceFieldNumber = 1,
    kCaseSensitivityFieldNumber = 3,
    kMatchTypeFieldNumber = 4,
  };
  // string search_string = 2;
  void clear_search_string() ;
  const std::string& search_string() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_search_string(Arg_&& arg, Args_... args);
  std::string* mutable_search_string();
  PROTOBUF_NODISCARD std::string* release_search_string();
  void set_allocated_search_string(std::string* value);

  private:
  const std::string& _internal_search_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_string(
      const std::string& value);
  std::string* _internal_mutable_search_string();

  public:
  // .io.deephaven.proto.backplane.grpc.Reference reference = 1;
  bool has_reference() const;
  void clear_reference() ;
  const ::io::deephaven::proto::backplane::grpc::Reference& reference() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Reference* release_reference();
  ::io::deephaven::proto::backplane::grpc::Reference* mutable_reference();
  void set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value);
  void unsafe_arena_set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value);
  ::io::deephaven::proto::backplane::grpc::Reference* unsafe_arena_release_reference();

  private:
  const ::io::deephaven::proto::backplane::grpc::Reference& _internal_reference() const;
  ::io::deephaven::proto::backplane::grpc::Reference* _internal_mutable_reference();

  public:
  // .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
  void clear_case_sensitivity() ;
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity case_sensitivity() const;
  void set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);

  private:
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);

  public:
  // .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
  void clear_match_type() ;
  ::io::deephaven::proto::backplane::grpc::MatchType match_type() const;
  void set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);

  private:
  ::io::deephaven::proto::backplane::grpc::MatchType _internal_match_type() const;
  void _internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ContainsCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      73, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr search_string_;
    ::io::deephaven::proto::backplane::grpc::Reference* reference_;
    int case_sensitivity_;
    int match_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecUnique final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique) */ {
 public:
  inline AggSpec_AggSpecUnique() : AggSpec_AggSpecUnique(nullptr) {}
  ~AggSpec_AggSpecUnique() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecUnique(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecUnique(const AggSpec_AggSpecUnique& from)
      : AggSpec_AggSpecUnique(nullptr, from) {}
  AggSpec_AggSpecUnique(AggSpec_AggSpecUnique&& from) noexcept
    : AggSpec_AggSpecUnique() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecUnique& operator=(const AggSpec_AggSpecUnique& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecUnique& operator=(AggSpec_AggSpecUnique&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecUnique& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecUnique* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecUnique*>(
               &_AggSpec_AggSpecUnique_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(AggSpec_AggSpecUnique& a, AggSpec_AggSpecUnique& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecUnique* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecUnique* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecUnique* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecUnique>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecUnique& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec_AggSpecUnique& from) {
    AggSpec_AggSpecUnique::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec_AggSpecUnique* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique";
  }
  protected:
  explicit AggSpec_AggSpecUnique(::google::protobuf::Arena* arena);
  AggSpec_AggSpecUnique(::google::protobuf::Arena* arena, const AggSpec_AggSpecUnique& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonUniqueSentinelFieldNumber = 2,
    kIncludeNullsFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel non_unique_sentinel = 2;
  bool has_non_unique_sentinel() const;
  void clear_non_unique_sentinel() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel& non_unique_sentinel() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* release_non_unique_sentinel();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* mutable_non_unique_sentinel();
  void set_allocated_non_unique_sentinel(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* value);
  void unsafe_arena_set_allocated_non_unique_sentinel(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* unsafe_arena_release_non_unique_sentinel();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel& _internal_non_unique_sentinel() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* _internal_mutable_non_unique_sentinel();

  public:
  // bool include_nulls = 1;
  void clear_include_nulls() ;
  bool include_nulls() const;
  void set_include_nulls(bool value);

  private:
  bool _internal_include_nulls() const;
  void _internal_set_include_nulls(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* non_unique_sentinel_;
    bool include_nulls_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec_AggSpecSorted final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted) */ {
 public:
  inline AggSpec_AggSpecSorted() : AggSpec_AggSpecSorted(nullptr) {}
  ~AggSpec_AggSpecSorted() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec_AggSpecSorted(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec_AggSpecSorted(const AggSpec_AggSpecSorted& from)
      : AggSpec_AggSpecSorted(nullptr, from) {}
  AggSpec_AggSpecSorted(AggSpec_AggSpecSorted&& from) noexcept
    : AggSpec_AggSpecSorted() {
    *this = ::std::move(from);
  }

  inline AggSpec_AggSpecSorted& operator=(const AggSpec_AggSpecSorted& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec_AggSpecSorted& operator=(AggSpec_AggSpecSorted&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec_AggSpecSorted& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggSpec_AggSpecSorted* internal_default_instance() {
    return reinterpret_cast<const AggSpec_AggSpecSorted*>(
               &_AggSpec_AggSpecSorted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(AggSpec_AggSpecSorted& a, AggSpec_AggSpecSorted& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec_AggSpecSorted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec_AggSpecSorted* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec_AggSpecSorted* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec_AggSpecSorted>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec_AggSpecSorted& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec_AggSpecSorted& from) {
    AggSpec_AggSpecSorted::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec_AggSpecSorted* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted";
  }
  protected:
  explicit AggSpec_AggSpecSorted(::google::protobuf::Arena* arena);
  AggSpec_AggSpecSorted(::google::protobuf::Arena* arena, const AggSpec_AggSpecSorted& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn columns = 1;
  int columns_size() const;
  private:
  int _internal_columns_size() const;

  public:
  void clear_columns() ;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* mutable_columns(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn >*
      mutable_columns();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn>& _internal_columns() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn>* _internal_mutable_columns();
  public:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn& columns(int index) const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* add_columns();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn >&
      columns() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn > columns_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class WhereInRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.WhereInRequest) */ {
 public:
  inline WhereInRequest() : WhereInRequest(nullptr) {}
  ~WhereInRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR WhereInRequest(::google::protobuf::internal::ConstantInitialized);

  inline WhereInRequest(const WhereInRequest& from)
      : WhereInRequest(nullptr, from) {}
  WhereInRequest(WhereInRequest&& from) noexcept
    : WhereInRequest() {
    *this = ::std::move(from);
  }

  inline WhereInRequest& operator=(const WhereInRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WhereInRequest& operator=(WhereInRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WhereInRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WhereInRequest* internal_default_instance() {
    return reinterpret_cast<const WhereInRequest*>(
               &_WhereInRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    120;

  friend void swap(WhereInRequest& a, WhereInRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WhereInRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WhereInRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WhereInRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WhereInRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WhereInRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const WhereInRequest& from) {
    WhereInRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WhereInRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.WhereInRequest";
  }
  protected:
  explicit WhereInRequest(::google::protobuf::Arena* arena);
  WhereInRequest(::google::protobuf::Arena* arena, const WhereInRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
    kInvertedFieldNumber = 4,
  };
  // repeated string columns_to_match = 5;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;

  public:
  void clear_columns_to_match() ;
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, std::size_t size);
  void set_columns_to_match(int index, absl::string_view value);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, std::size_t size);
  void add_columns_to_match(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_match();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_match();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  void clear_left_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  void clear_right_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();

  public:
  // bool inverted = 4;
  void clear_inverted() ;
  bool inverted() const;
  void set_inverted(bool value);

  private:
  bool _internal_inverted() const;
  void _internal_set_inverted(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.WhereInRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      73, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_match_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
    bool inverted_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWeightColumnFieldNumber = 3,
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // string weight_column = 3;
  void clear_weight_column() ;
  const std::string& weight_column() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_weight_column(Arg_&& arg, Args_... args);
  std::string* mutable_weight_column();
  PROTOBUF_NODISCARD std::string* release_weight_column();
  void set_allocated_weight_column(std::string* value);

  private:
  const std::string& _internal_weight_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weight_column(
      const std::string& value);
  std::string* _internal_mutable_weight_column();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  void clear_reverse_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  void clear_forward_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      137, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr weight_column_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  void clear_reverse_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  void clear_forward_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  void clear_reverse_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  void clear_forward_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  void clear_reverse_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  void clear_forward_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  void clear_reverse_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  void clear_forward_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  void clear_reverse_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  void clear_forward_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  void clear_reverse_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  void clear_forward_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormulaFieldNumber = 3,
    kParamTokenFieldNumber = 4,
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // string formula = 3;
  void clear_formula() ;
  const std::string& formula() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_formula(Arg_&& arg, Args_... args);
  std::string* mutable_formula();
  PROTOBUF_NODISCARD std::string* release_formula();
  void set_allocated_formula(std::string* value);

  private:
  const std::string& _internal_formula() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formula(
      const std::string& value);
  std::string* _internal_mutable_formula();

  public:
  // string param_token = 4;
  void clear_param_token() ;
  const std::string& param_token() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_param_token(Arg_&& arg, Args_... args);
  std::string* mutable_param_token();
  PROTOBUF_NODISCARD std::string* release_param_token();
  void set_allocated_param_token(std::string* value);

  private:
  const std::string& _internal_param_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_param_token(
      const std::string& value);
  std::string* _internal_mutable_param_token();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  void clear_reverse_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  void clear_forward_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      145, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr formula_;
    ::google::protobuf::internal::ArenaStringPtr param_token_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  void clear_reverse_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  void clear_forward_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReverseWindowScaleFieldNumber = 1,
    kForwardWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
  bool has_reverse_window_scale() const;
  void clear_reverse_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& reverse_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_reverse_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_reverse_window_scale();
  void set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_reverse_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_reverse_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_reverse_window_scale();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
  bool has_forward_window_scale() const;
  void clear_forward_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& forward_window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_forward_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_forward_window_scale();
  void set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_forward_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_forward_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_forward_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* reverse_window_scale_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* forward_window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
  bool has_options() const;
  void clear_options() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value);
  void unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* unsafe_arena_release_options();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _internal_mutable_options();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
  bool has_window_scale() const;
  void clear_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_window_scale();
  void set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
  bool has_options() const;
  void clear_options() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value);
  void unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* unsafe_arena_release_options();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _internal_mutable_options();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
  bool has_window_scale() const;
  void clear_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_window_scale();
  void set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
  bool has_options() const;
  void clear_options() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value);
  void unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* unsafe_arena_release_options();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _internal_mutable_options();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
  bool has_window_scale() const;
  void clear_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_window_scale();
  void set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
  bool has_options() const;
  void clear_options() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value);
  void unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* unsafe_arena_release_options();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _internal_mutable_options();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
  bool has_window_scale() const;
  void clear_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_window_scale();
  void set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOptionsFieldNumber = 1,
    kWindowScaleFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
  bool has_options() const;
  void clear_options() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value);
  void unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* unsafe_arena_release_options();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _internal_mutable_options();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
  bool has_window_scale() const;
  void clear_window_scale() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& window_scale() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* release_window_scale();
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* mutable_window_scale();
  void set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  void unsafe_arena_set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* unsafe_arena_release_window_scale();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& _internal_window_scale() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _internal_mutable_window_scale();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* options_;
    ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* window_scale_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UnstructuredFilterTableRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest) */ {
 public:
  inline UnstructuredFilterTableRequest() : UnstructuredFilterTableRequest(nullptr) {}
  ~UnstructuredFilterTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UnstructuredFilterTableRequest(::google::protobuf::internal::ConstantInitialized);

  inline UnstructuredFilterTableRequest(const UnstructuredFilterTableRequest& from)
      : UnstructuredFilterTableRequest(nullptr, from) {}
  UnstructuredFilterTableRequest(UnstructuredFilterTableRequest&& from) noexcept
    : UnstructuredFilterTableRequest() {
    *this = ::std::move(from);
  }

  inline UnstructuredFilterTableRequest& operator=(const UnstructuredFilterTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnstructuredFilterTableRequest& operator=(UnstructuredFilterTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnstructuredFilterTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnstructuredFilterTableRequest* internal_default_instance() {
    return reinterpret_cast<const UnstructuredFilterTableRequest*>(
               &_UnstructuredFilterTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(UnstructuredFilterTableRequest& a, UnstructuredFilterTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UnstructuredFilterTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnstructuredFilterTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnstructuredFilterTableRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UnstructuredFilterTableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnstructuredFilterTableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UnstructuredFilterTableRequest& from) {
    UnstructuredFilterTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnstructuredFilterTableRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest";
  }
  protected:
  explicit UnstructuredFilterTableRequest(::google::protobuf::Arena* arena);
  UnstructuredFilterTableRequest(::google::protobuf::Arena* arena, const UnstructuredFilterTableRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated string filters = 3;
  int filters_size() const;
  private:
  int _internal_filters_size() const;

  public:
  void clear_filters() ;
  const std::string& filters(int index) const;
  std::string* mutable_filters(int index);
  void set_filters(int index, const std::string& value);
  void set_filters(int index, std::string&& value);
  void set_filters(int index, const char* value);
  void set_filters(int index, const char* value, std::size_t size);
  void set_filters(int index, absl::string_view value);
  std::string* add_filters();
  void add_filters(const std::string& value);
  void add_filters(std::string&& value);
  void add_filters(const char* value);
  void add_filters(const char* value, std::size_t size);
  void add_filters(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& filters() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_filters();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_filters() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_filters();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      80, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> filters_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UngroupRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UngroupRequest) */ {
 public:
  inline UngroupRequest() : UngroupRequest(nullptr) {}
  ~UngroupRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UngroupRequest(::google::protobuf::internal::ConstantInitialized);

  inline UngroupRequest(const UngroupRequest& from)
      : UngroupRequest(nullptr, from) {}
  UngroupRequest(UngroupRequest&& from) noexcept
    : UngroupRequest() {
    *this = ::std::move(from);
  }

  inline UngroupRequest& operator=(const UngroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UngroupRequest& operator=(UngroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UngroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UngroupRequest* internal_default_instance() {
    return reinterpret_cast<const UngroupRequest*>(
               &_UngroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(UngroupRequest& a, UngroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UngroupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UngroupRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UngroupRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UngroupRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UngroupRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UngroupRequest& from) {
    UngroupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UngroupRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UngroupRequest";
  }
  protected:
  explicit UngroupRequest(::google::protobuf::Arena* arena);
  UngroupRequest(::google::protobuf::Arena* arena, const UngroupRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToUngroupFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kNullFillFieldNumber = 3,
  };
  // repeated string columns_to_ungroup = 4;
  int columns_to_ungroup_size() const;
  private:
  int _internal_columns_to_ungroup_size() const;

  public:
  void clear_columns_to_ungroup() ;
  const std::string& columns_to_ungroup(int index) const;
  std::string* mutable_columns_to_ungroup(int index);
  void set_columns_to_ungroup(int index, const std::string& value);
  void set_columns_to_ungroup(int index, std::string&& value);
  void set_columns_to_ungroup(int index, const char* value);
  void set_columns_to_ungroup(int index, const char* value, std::size_t size);
  void set_columns_to_ungroup(int index, absl::string_view value);
  std::string* add_columns_to_ungroup();
  void add_columns_to_ungroup(const std::string& value);
  void add_columns_to_ungroup(std::string&& value);
  void add_columns_to_ungroup(const char* value);
  void add_columns_to_ungroup(const char* value, std::size_t size);
  void add_columns_to_ungroup(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_ungroup() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_ungroup();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_ungroup() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_ungroup();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // bool null_fill = 3;
  void clear_null_fill() ;
  bool null_fill() const;
  void set_null_fill(bool value);

  private:
  bool _internal_null_fill() const;
  void _internal_set_null_fill(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UngroupRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      75, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_ungroup_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    bool null_fill_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class SortTableRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SortTableRequest) */ {
 public:
  inline SortTableRequest() : SortTableRequest(nullptr) {}
  ~SortTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SortTableRequest(::google::protobuf::internal::ConstantInitialized);

  inline SortTableRequest(const SortTableRequest& from)
      : SortTableRequest(nullptr, from) {}
  SortTableRequest(SortTableRequest&& from) noexcept
    : SortTableRequest() {
    *this = ::std::move(from);
  }

  inline SortTableRequest& operator=(const SortTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SortTableRequest& operator=(SortTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SortTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SortTableRequest* internal_default_instance() {
    return reinterpret_cast<const SortTableRequest*>(
               &_SortTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(SortTableRequest& a, SortTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SortTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SortTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SortTableRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SortTableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SortTableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SortTableRequest& from) {
    SortTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SortTableRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SortTableRequest";
  }
  protected:
  explicit SortTableRequest(::google::protobuf::Arena* arena);
  SortTableRequest(::google::protobuf::Arena* arena, const SortTableRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSortsFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated .io.deephaven.proto.backplane.grpc.SortDescriptor sorts = 3;
  int sorts_size() const;
  private:
  int _internal_sorts_size() const;

  public:
  void clear_sorts() ;
  ::io::deephaven::proto::backplane::grpc::SortDescriptor* mutable_sorts(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor >*
      mutable_sorts();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::SortDescriptor>& _internal_sorts() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::SortDescriptor>* _internal_mutable_sorts();
  public:
  const ::io::deephaven::proto::backplane::grpc::SortDescriptor& sorts(int index) const;
  ::io::deephaven::proto::backplane::grpc::SortDescriptor* add_sorts();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor >&
      sorts() const;
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SortTableRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::SortDescriptor > sorts_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class SnapshotWhenTableRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest) */ {
 public:
  inline SnapshotWhenTableRequest() : SnapshotWhenTableRequest(nullptr) {}
  ~SnapshotWhenTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotWhenTableRequest(::google::protobuf::internal::ConstantInitialized);

  inline SnapshotWhenTableRequest(const SnapshotWhenTableRequest& from)
      : SnapshotWhenTableRequest(nullptr, from) {}
  SnapshotWhenTableRequest(SnapshotWhenTableRequest&& from) noexcept
    : SnapshotWhenTableRequest() {
    *this = ::std::move(from);
  }

  inline SnapshotWhenTableRequest& operator=(const SnapshotWhenTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotWhenTableRequest& operator=(SnapshotWhenTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotWhenTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotWhenTableRequest* internal_default_instance() {
    return reinterpret_cast<const SnapshotWhenTableRequest*>(
               &_SnapshotWhenTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(SnapshotWhenTableRequest& a, SnapshotWhenTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotWhenTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotWhenTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotWhenTableRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotWhenTableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SnapshotWhenTableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SnapshotWhenTableRequest& from) {
    SnapshotWhenTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SnapshotWhenTableRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest";
  }
  protected:
  explicit SnapshotWhenTableRequest(::google::protobuf::Arena* arena);
  SnapshotWhenTableRequest(::google::protobuf::Arena* arena, const SnapshotWhenTableRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStampColumnsFieldNumber = 7,
    kResultIdFieldNumber = 1,
    kBaseIdFieldNumber = 2,
    kTriggerIdFieldNumber = 3,
    kInitialFieldNumber = 4,
    kIncrementalFieldNumber = 5,
    kHistoryFieldNumber = 6,
  };
  // repeated string stamp_columns = 7;
  int stamp_columns_size() const;
  private:
  int _internal_stamp_columns_size() const;

  public:
  void clear_stamp_columns() ;
  const std::string& stamp_columns(int index) const;
  std::string* mutable_stamp_columns(int index);
  void set_stamp_columns(int index, const std::string& value);
  void set_stamp_columns(int index, std::string&& value);
  void set_stamp_columns(int index, const char* value);
  void set_stamp_columns(int index, const char* value, std::size_t size);
  void set_stamp_columns(int index, absl::string_view value);
  std::string* add_stamp_columns();
  void add_stamp_columns(const std::string& value);
  void add_stamp_columns(std::string&& value);
  void add_stamp_columns(const char* value);
  void add_stamp_columns(const char* value, std::size_t size);
  void add_stamp_columns(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& stamp_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_stamp_columns();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_stamp_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_stamp_columns();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference base_id = 2;
  bool has_base_id() const;
  void clear_base_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& base_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_base_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_base_id();
  void set_allocated_base_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_base_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_base_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_base_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_base_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference trigger_id = 3;
  bool has_trigger_id() const;
  void clear_trigger_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& trigger_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_trigger_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_trigger_id();
  void set_allocated_trigger_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_trigger_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_trigger_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_trigger_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_trigger_id();

  public:
  // bool initial = 4;
  void clear_initial() ;
  bool initial() const;
  void set_initial(bool value);

  private:
  bool _internal_initial() const;
  void _internal_set_initial(bool value);

  public:
  // bool incremental = 5;
  void clear_incremental() ;
  bool incremental() const;
  void set_incremental(bool value);

  private:
  bool _internal_incremental() const;
  void _internal_set_incremental(bool value);

  public:
  // bool history = 6;
  void clear_history() ;
  bool history() const;
  void set_history(bool value);

  private:
  bool _internal_history() const;
  void _internal_set_history(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      80, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> stamp_columns_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* base_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* trigger_id_;
    bool initial_;
    bool incremental_;
    bool history_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class SnapshotTableRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SnapshotTableRequest) */ {
 public:
  inline SnapshotTableRequest() : SnapshotTableRequest(nullptr) {}
  ~SnapshotTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotTableRequest(::google::protobuf::internal::ConstantInitialized);

  inline SnapshotTableRequest(const SnapshotTableRequest& from)
      : SnapshotTableRequest(nullptr, from) {}
  SnapshotTableRequest(SnapshotTableRequest&& from) noexcept
    : SnapshotTableRequest() {
    *this = ::std::move(from);
  }

  inline SnapshotTableRequest& operator=(const SnapshotTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotTableRequest& operator=(SnapshotTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotTableRequest* internal_default_instance() {
    return reinterpret_cast<const SnapshotTableRequest*>(
               &_SnapshotTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(SnapshotTableRequest& a, SnapshotTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotTableRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotTableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SnapshotTableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SnapshotTableRequest& from) {
    SnapshotTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SnapshotTableRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SnapshotTableRequest";
  }
  protected:
  explicit SnapshotTableRequest(::google::protobuf::Arena* arena);
  SnapshotTableRequest(::google::protobuf::Arena* arena, const SnapshotTableRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SnapshotTableRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class SelectOrUpdateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest) */ {
 public:
  inline SelectOrUpdateRequest() : SelectOrUpdateRequest(nullptr) {}
  ~SelectOrUpdateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SelectOrUpdateRequest(::google::protobuf::internal::ConstantInitialized);

  inline SelectOrUpdateRequest(const SelectOrUpdateRequest& from)
      : SelectOrUpdateRequest(nullptr, from) {}
  SelectOrUpdateRequest(SelectOrUpdateRequest&& from) noexcept
    : SelectOrUpdateRequest() {
    *this = ::std::move(from);
  }

  inline SelectOrUpdateRequest& operator=(const SelectOrUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectOrUpdateRequest& operator=(SelectOrUpdateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectOrUpdateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectOrUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const SelectOrUpdateRequest*>(
               &_SelectOrUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SelectOrUpdateRequest& a, SelectOrUpdateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectOrUpdateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectOrUpdateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectOrUpdateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectOrUpdateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SelectOrUpdateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SelectOrUpdateRequest& from) {
    SelectOrUpdateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SelectOrUpdateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest";
  }
  protected:
  explicit SelectOrUpdateRequest(::google::protobuf::Arena* arena);
  SelectOrUpdateRequest(::google::protobuf::Arena* arena, const SelectOrUpdateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnSpecsFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated string column_specs = 3;
  int column_specs_size() const;
  private:
  int _internal_column_specs_size() const;

  public:
  void clear_column_specs() ;
  const std::string& column_specs(int index) const;
  std::string* mutable_column_specs(int index);
  void set_column_specs(int index, const std::string& value);
  void set_column_specs(int index, std::string&& value);
  void set_column_specs(int index, const char* value);
  void set_column_specs(int index, const char* value, std::size_t size);
  void set_column_specs(int index, absl::string_view value);
  std::string* add_column_specs();
  void add_column_specs(const std::string& value);
  void add_column_specs(std::string&& value);
  void add_column_specs(const char* value);
  void add_column_specs(const char* value, std::size_t size);
  void add_column_specs(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& column_specs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_column_specs();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_column_specs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_column_specs();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      76, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> column_specs_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class SelectDistinctRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.SelectDistinctRequest) */ {
 public:
  inline SelectDistinctRequest() : SelectDistinctRequest(nullptr) {}
  ~SelectDistinctRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SelectDistinctRequest(::google::protobuf::internal::ConstantInitialized);

  inline SelectDistinctRequest(const SelectDistinctRequest& from)
      : SelectDistinctRequest(nullptr, from) {}
  SelectDistinctRequest(SelectDistinctRequest&& from) noexcept
    : SelectDistinctRequest() {
    *this = ::std::move(from);
  }

  inline SelectDistinctRequest& operator=(const SelectDistinctRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SelectDistinctRequest& operator=(SelectDistinctRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SelectDistinctRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SelectDistinctRequest* internal_default_instance() {
    return reinterpret_cast<const SelectDistinctRequest*>(
               &_SelectDistinctRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(SelectDistinctRequest& a, SelectDistinctRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SelectDistinctRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SelectDistinctRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SelectDistinctRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SelectDistinctRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SelectDistinctRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SelectDistinctRequest& from) {
    SelectDistinctRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SelectDistinctRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.SelectDistinctRequest";
  }
  protected:
  explicit SelectDistinctRequest(::google::protobuf::Arena* arena);
  SelectDistinctRequest(::google::protobuf::Arena* arena, const SelectDistinctRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNamesFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated string column_names = 3;
  int column_names_size() const;
  private:
  int _internal_column_names_size() const;

  public:
  void clear_column_names() ;
  const std::string& column_names(int index) const;
  std::string* mutable_column_names(int index);
  void set_column_names(int index, const std::string& value);
  void set_column_names(int index, std::string&& value);
  void set_column_names(int index, const char* value);
  void set_column_names(int index, const char* value, std::size_t size);
  void set_column_names(int index, absl::string_view value);
  std::string* add_column_names();
  void add_column_names(const std::string& value);
  void add_column_names(std::string&& value);
  void add_column_names(const char* value);
  void add_column_names(const char* value, std::size_t size);
  void add_column_names(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& column_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_column_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_column_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_column_names();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.SelectDistinctRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      76, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> column_names_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class RunChartDownsampleRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest) */ {
 public:
  inline RunChartDownsampleRequest() : RunChartDownsampleRequest(nullptr) {}
  ~RunChartDownsampleRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RunChartDownsampleRequest(::google::protobuf::internal::ConstantInitialized);

  inline RunChartDownsampleRequest(const RunChartDownsampleRequest& from)
      : RunChartDownsampleRequest(nullptr, from) {}
  RunChartDownsampleRequest(RunChartDownsampleRequest&& from) noexcept
    : RunChartDownsampleRequest() {
    *this = ::std::move(from);
  }

  inline RunChartDownsampleRequest& operator=(const RunChartDownsampleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RunChartDownsampleRequest& operator=(RunChartDownsampleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RunChartDownsampleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RunChartDownsampleRequest* internal_default_instance() {
    return reinterpret_cast<const RunChartDownsampleRequest*>(
               &_RunChartDownsampleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    114;

  friend void swap(RunChartDownsampleRequest& a, RunChartDownsampleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RunChartDownsampleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RunChartDownsampleRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RunChartDownsampleRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RunChartDownsampleRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RunChartDownsampleRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RunChartDownsampleRequest& from) {
    RunChartDownsampleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RunChartDownsampleRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest";
  }
  protected:
  explicit RunChartDownsampleRequest(::google::protobuf::Arena* arena);
  RunChartDownsampleRequest(::google::protobuf::Arena* arena, const RunChartDownsampleRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ZoomRange = RunChartDownsampleRequest_ZoomRange;

  // accessors -------------------------------------------------------

  enum : int {
    kYColumnNamesFieldNumber = 6,
    kXColumnNameFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kZoomRangeFieldNumber = 4,
    kPixelCountFieldNumber = 3,
  };
  // repeated string y_column_names = 6;
  int y_column_names_size() const;
  private:
  int _internal_y_column_names_size() const;

  public:
  void clear_y_column_names() ;
  const std::string& y_column_names(int index) const;
  std::string* mutable_y_column_names(int index);
  void set_y_column_names(int index, const std::string& value);
  void set_y_column_names(int index, std::string&& value);
  void set_y_column_names(int index, const char* value);
  void set_y_column_names(int index, const char* value, std::size_t size);
  void set_y_column_names(int index, absl::string_view value);
  std::string* add_y_column_names();
  void add_y_column_names(const std::string& value);
  void add_y_column_names(std::string&& value);
  void add_y_column_names(const char* value);
  void add_y_column_names(const char* value, std::size_t size);
  void add_y_column_names(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& y_column_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_y_column_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_y_column_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_y_column_names();

  public:
  // string x_column_name = 5;
  void clear_x_column_name() ;
  const std::string& x_column_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_x_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_x_column_name();
  PROTOBUF_NODISCARD std::string* release_x_column_name();
  void set_allocated_x_column_name(std::string* value);

  private:
  const std::string& _internal_x_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_x_column_name(
      const std::string& value);
  std::string* _internal_mutable_x_column_name();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // .io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange zoom_range = 4;
  bool has_zoom_range() const;
  void clear_zoom_range() ;
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange& zoom_range() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* release_zoom_range();
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* mutable_zoom_range();
  void set_allocated_zoom_range(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* value);
  void unsafe_arena_set_allocated_zoom_range(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* value);
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* unsafe_arena_release_zoom_range();

  private:
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange& _internal_zoom_range() const;
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* _internal_mutable_zoom_range();

  public:
  // int32 pixel_count = 3;
  void clear_pixel_count() ;
  ::int32_t pixel_count() const;
  void set_pixel_count(::int32_t value);

  private:
  ::int32_t _internal_pixel_count() const;
  void _internal_set_pixel_count(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      95, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> y_column_names_;
    ::google::protobuf::internal::ArenaStringPtr x_column_name_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* zoom_range_;
    ::int32_t pixel_count_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class NaturalJoinTablesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest) */ {
 public:
  inline NaturalJoinTablesRequest() : NaturalJoinTablesRequest(nullptr) {}
  ~NaturalJoinTablesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NaturalJoinTablesRequest(::google::protobuf::internal::ConstantInitialized);

  inline NaturalJoinTablesRequest(const NaturalJoinTablesRequest& from)
      : NaturalJoinTablesRequest(nullptr, from) {}
  NaturalJoinTablesRequest(NaturalJoinTablesRequest&& from) noexcept
    : NaturalJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline NaturalJoinTablesRequest& operator=(const NaturalJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NaturalJoinTablesRequest& operator=(NaturalJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NaturalJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const NaturalJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const NaturalJoinTablesRequest*>(
               &_NaturalJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(NaturalJoinTablesRequest& a, NaturalJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NaturalJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NaturalJoinTablesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NaturalJoinTablesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NaturalJoinTablesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NaturalJoinTablesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NaturalJoinTablesRequest& from) {
    NaturalJoinTablesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NaturalJoinTablesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest";
  }
  protected:
  explicit NaturalJoinTablesRequest(::google::protobuf::Arena* arena);
  NaturalJoinTablesRequest(::google::protobuf::Arena* arena, const NaturalJoinTablesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;

  public:
  void clear_columns_to_match() ;
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, std::size_t size);
  void set_columns_to_match(int index, absl::string_view value);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, std::size_t size);
  void add_columns_to_match(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_match();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_match();

  public:
  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;

  public:
  void clear_columns_to_add() ;
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, std::size_t size);
  void set_columns_to_add(int index, absl::string_view value);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, std::size_t size);
  void add_columns_to_add(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_add();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_add();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  void clear_left_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  void clear_right_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      97, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_match_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_add_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class MultiJoinInput final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MultiJoinInput) */ {
 public:
  inline MultiJoinInput() : MultiJoinInput(nullptr) {}
  ~MultiJoinInput() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MultiJoinInput(::google::protobuf::internal::ConstantInitialized);

  inline MultiJoinInput(const MultiJoinInput& from)
      : MultiJoinInput(nullptr, from) {}
  MultiJoinInput(MultiJoinInput&& from) noexcept
    : MultiJoinInput() {
    *this = ::std::move(from);
  }

  inline MultiJoinInput& operator=(const MultiJoinInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiJoinInput& operator=(MultiJoinInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiJoinInput& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiJoinInput* internal_default_instance() {
    return reinterpret_cast<const MultiJoinInput*>(
               &_MultiJoinInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(MultiJoinInput& a, MultiJoinInput& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiJoinInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiJoinInput* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiJoinInput* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiJoinInput>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MultiJoinInput& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MultiJoinInput& from) {
    MultiJoinInput::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MultiJoinInput* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MultiJoinInput";
  }
  protected:
  explicit MultiJoinInput(::google::protobuf::Arena* arena);
  MultiJoinInput(::google::protobuf::Arena* arena, const MultiJoinInput& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 2,
    kColumnsToAddFieldNumber = 3,
    kSourceIdFieldNumber = 1,
  };
  // repeated string columns_to_match = 2;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;

  public:
  void clear_columns_to_match() ;
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, std::size_t size);
  void set_columns_to_match(int index, absl::string_view value);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, std::size_t size);
  void add_columns_to_match(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_match();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_match();

  public:
  // repeated string columns_to_add = 3;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;

  public:
  void clear_columns_to_add() ;
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, std::size_t size);
  void set_columns_to_add(int index, absl::string_view value);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, std::size_t size);
  void add_columns_to_add(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_add();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_add();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MultiJoinInput)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      87, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_match_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_add_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class MetaTableRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MetaTableRequest) */ {
 public:
  inline MetaTableRequest() : MetaTableRequest(nullptr) {}
  ~MetaTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MetaTableRequest(::google::protobuf::internal::ConstantInitialized);

  inline MetaTableRequest(const MetaTableRequest& from)
      : MetaTableRequest(nullptr, from) {}
  MetaTableRequest(MetaTableRequest&& from) noexcept
    : MetaTableRequest() {
    *this = ::std::move(from);
  }

  inline MetaTableRequest& operator=(const MetaTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaTableRequest& operator=(MetaTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetaTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetaTableRequest* internal_default_instance() {
    return reinterpret_cast<const MetaTableRequest*>(
               &_MetaTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    112;

  friend void swap(MetaTableRequest& a, MetaTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetaTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetaTableRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetaTableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MetaTableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MetaTableRequest& from) {
    MetaTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MetaTableRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MetaTableRequest";
  }
  protected:
  explicit MetaTableRequest(::google::protobuf::Arena* arena);
  MetaTableRequest(::google::protobuf::Arena* arena, const MetaTableRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MetaTableRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class MergeTablesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MergeTablesRequest) */ {
 public:
  inline MergeTablesRequest() : MergeTablesRequest(nullptr) {}
  ~MergeTablesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MergeTablesRequest(::google::protobuf::internal::ConstantInitialized);

  inline MergeTablesRequest(const MergeTablesRequest& from)
      : MergeTablesRequest(nullptr, from) {}
  MergeTablesRequest(MergeTablesRequest&& from) noexcept
    : MergeTablesRequest() {
    *this = ::std::move(from);
  }

  inline MergeTablesRequest& operator=(const MergeTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MergeTablesRequest& operator=(MergeTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MergeTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MergeTablesRequest* internal_default_instance() {
    return reinterpret_cast<const MergeTablesRequest*>(
               &_MergeTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(MergeTablesRequest& a, MergeTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MergeTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MergeTablesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MergeTablesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MergeTablesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MergeTablesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MergeTablesRequest& from) {
    MergeTablesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MergeTablesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MergeTablesRequest";
  }
  protected:
  explicit MergeTablesRequest(::google::protobuf::Arena* arena);
  MergeTablesRequest(::google::protobuf::Arena* arena, const MergeTablesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdsFieldNumber = 2,
    kKeyColumnFieldNumber = 3,
    kResultIdFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.TableReference source_ids = 2;
  int source_ids_size() const;
  private:
  int _internal_source_ids_size() const;

  public:
  void clear_source_ids() ;
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_ids(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference >*
      mutable_source_ids();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::TableReference>& _internal_source_ids() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::TableReference>* _internal_mutable_source_ids();
  public:
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_ids(int index) const;
  ::io::deephaven::proto::backplane::grpc::TableReference* add_source_ids();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference >&
      source_ids() const;
  // string key_column = 3;
  void clear_key_column() ;
  const std::string& key_column() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_key_column(Arg_&& arg, Args_... args);
  std::string* mutable_key_column();
  PROTOBUF_NODISCARD std::string* release_key_column();
  void set_allocated_key_column(std::string* value);

  private:
  const std::string& _internal_key_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key_column(
      const std::string& value);
  std::string* _internal_mutable_key_column();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MergeTablesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      71, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::TableReference > source_ids_;
    ::google::protobuf::internal::ArenaStringPtr key_column_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class LeftJoinTablesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest) */ {
 public:
  inline LeftJoinTablesRequest() : LeftJoinTablesRequest(nullptr) {}
  ~LeftJoinTablesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR LeftJoinTablesRequest(::google::protobuf::internal::ConstantInitialized);

  inline LeftJoinTablesRequest(const LeftJoinTablesRequest& from)
      : LeftJoinTablesRequest(nullptr, from) {}
  LeftJoinTablesRequest(LeftJoinTablesRequest&& from) noexcept
    : LeftJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline LeftJoinTablesRequest& operator=(const LeftJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeftJoinTablesRequest& operator=(LeftJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LeftJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LeftJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const LeftJoinTablesRequest*>(
               &_LeftJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(LeftJoinTablesRequest& a, LeftJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LeftJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LeftJoinTablesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LeftJoinTablesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LeftJoinTablesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const LeftJoinTablesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const LeftJoinTablesRequest& from) {
    LeftJoinTablesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(LeftJoinTablesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest";
  }
  protected:
  explicit LeftJoinTablesRequest(::google::protobuf::Arena* arena);
  LeftJoinTablesRequest(::google::protobuf::Arena* arena, const LeftJoinTablesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;

  public:
  void clear_columns_to_match() ;
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, std::size_t size);
  void set_columns_to_match(int index, absl::string_view value);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, std::size_t size);
  void add_columns_to_match(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_match();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_match();

  public:
  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;

  public:
  void clear_columns_to_add() ;
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, std::size_t size);
  void set_columns_to_add(int index, absl::string_view value);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, std::size_t size);
  void add_columns_to_add(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_add();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_add();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  void clear_left_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  void clear_right_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      94, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_match_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_add_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class InvokeCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.InvokeCondition) */ {
 public:
  inline InvokeCondition() : InvokeCondition(nullptr) {}
  ~InvokeCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InvokeCondition(::google::protobuf::internal::ConstantInitialized);

  inline InvokeCondition(const InvokeCondition& from)
      : InvokeCondition(nullptr, from) {}
  InvokeCondition(InvokeCondition&& from) noexcept
    : InvokeCondition() {
    *this = ::std::move(from);
  }

  inline InvokeCondition& operator=(const InvokeCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline InvokeCondition& operator=(InvokeCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InvokeCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const InvokeCondition* internal_default_instance() {
    return reinterpret_cast<const InvokeCondition*>(
               &_InvokeCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(InvokeCondition& a, InvokeCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(InvokeCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InvokeCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InvokeCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InvokeCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InvokeCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InvokeCondition& from) {
    InvokeCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InvokeCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.InvokeCondition";
  }
  protected:
  explicit InvokeCondition(::google::protobuf::Arena* arena);
  InvokeCondition(::google::protobuf::Arena* arena, const InvokeCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 3,
    kMethodFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Value arguments = 3;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;

  public:
  void clear_arguments() ;
  ::io::deephaven::proto::backplane::grpc::Value* mutable_arguments(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >*
      mutable_arguments();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Value>& _internal_arguments() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Value>* _internal_mutable_arguments();
  public:
  const ::io::deephaven::proto::backplane::grpc::Value& arguments(int index) const;
  ::io::deephaven::proto::backplane::grpc::Value* add_arguments();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >&
      arguments() const;
  // string method = 1;
  void clear_method() ;
  const std::string& method() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_method(Arg_&& arg, Args_... args);
  std::string* mutable_method();
  PROTOBUF_NODISCARD std::string* release_method();
  void set_allocated_method(std::string* value);

  private:
  const std::string& _internal_method() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_method(
      const std::string& value);
  std::string* _internal_mutable_method();

  public:
  // .io.deephaven.proto.backplane.grpc.Value target = 2;
  bool has_target() const;
  void clear_target() ;
  const ::io::deephaven::proto::backplane::grpc::Value& target() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Value* release_target();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_target();
  void set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* value);
  void unsafe_arena_set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* value);
  ::io::deephaven::proto::backplane::grpc::Value* unsafe_arena_release_target();

  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_target() const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_mutable_target();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.InvokeCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      64, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value > arguments_;
    ::google::protobuf::internal::ArenaStringPtr method_;
    ::io::deephaven::proto::backplane::grpc::Value* target_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class InCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.InCondition) */ {
 public:
  inline InCondition() : InCondition(nullptr) {}
  ~InCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR InCondition(::google::protobuf::internal::ConstantInitialized);

  inline InCondition(const InCondition& from)
      : InCondition(nullptr, from) {}
  InCondition(InCondition&& from) noexcept
    : InCondition() {
    *this = ::std::move(from);
  }

  inline InCondition& operator=(const InCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline InCondition& operator=(InCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const InCondition* internal_default_instance() {
    return reinterpret_cast<const InCondition*>(
               &_InCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(InCondition& a, InCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(InCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const InCondition& from) {
    InCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.InCondition";
  }
  protected:
  explicit InCondition(::google::protobuf::Arena* arena);
  InCondition(::google::protobuf::Arena* arena, const InCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCandidatesFieldNumber = 2,
    kTargetFieldNumber = 1,
    kCaseSensitivityFieldNumber = 3,
    kMatchTypeFieldNumber = 4,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Value candidates = 2;
  int candidates_size() const;
  private:
  int _internal_candidates_size() const;

  public:
  void clear_candidates() ;
  ::io::deephaven::proto::backplane::grpc::Value* mutable_candidates(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >*
      mutable_candidates();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Value>& _internal_candidates() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Value>* _internal_mutable_candidates();
  public:
  const ::io::deephaven::proto::backplane::grpc::Value& candidates(int index) const;
  ::io::deephaven::proto::backplane::grpc::Value* add_candidates();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value >&
      candidates() const;
  // .io.deephaven.proto.backplane.grpc.Value target = 1;
  bool has_target() const;
  void clear_target() ;
  const ::io::deephaven::proto::backplane::grpc::Value& target() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Value* release_target();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_target();
  void set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* value);
  void unsafe_arena_set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* value);
  ::io::deephaven::proto::backplane::grpc::Value* unsafe_arena_release_target();

  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_target() const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_mutable_target();

  public:
  // .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
  void clear_case_sensitivity() ;
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity case_sensitivity() const;
  void set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);

  private:
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);

  public:
  // .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
  void clear_match_type() ;
  ::io::deephaven::proto::backplane::grpc::MatchType match_type() const;
  void set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);

  private:
  ::io::deephaven::proto::backplane::grpc::MatchType _internal_match_type() const;
  void _internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.InCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Value > candidates_;
    ::io::deephaven::proto::backplane::grpc::Value* target_;
    int case_sensitivity_;
    int match_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class HeadOrTailRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.HeadOrTailRequest) */ {
 public:
  inline HeadOrTailRequest() : HeadOrTailRequest(nullptr) {}
  ~HeadOrTailRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeadOrTailRequest(::google::protobuf::internal::ConstantInitialized);

  inline HeadOrTailRequest(const HeadOrTailRequest& from)
      : HeadOrTailRequest(nullptr, from) {}
  HeadOrTailRequest(HeadOrTailRequest&& from) noexcept
    : HeadOrTailRequest() {
    *this = ::std::move(from);
  }

  inline HeadOrTailRequest& operator=(const HeadOrTailRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadOrTailRequest& operator=(HeadOrTailRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeadOrTailRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeadOrTailRequest* internal_default_instance() {
    return reinterpret_cast<const HeadOrTailRequest*>(
               &_HeadOrTailRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(HeadOrTailRequest& a, HeadOrTailRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeadOrTailRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeadOrTailRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeadOrTailRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeadOrTailRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeadOrTailRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HeadOrTailRequest& from) {
    HeadOrTailRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeadOrTailRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.HeadOrTailRequest";
  }
  protected:
  explicit HeadOrTailRequest(::google::protobuf::Arena* arena);
  HeadOrTailRequest(::google::protobuf::Arena* arena, const HeadOrTailRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kNumRowsFieldNumber = 3,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // sint64 num_rows = 3 [jstype = JS_STRING];
  void clear_num_rows() ;
  ::int64_t num_rows() const;
  void set_num_rows(::int64_t value);

  private:
  ::int64_t _internal_num_rows() const;
  void _internal_set_num_rows(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.HeadOrTailRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    ::int64_t num_rows_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class HeadOrTailByRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest) */ {
 public:
  inline HeadOrTailByRequest() : HeadOrTailByRequest(nullptr) {}
  ~HeadOrTailByRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR HeadOrTailByRequest(::google::protobuf::internal::ConstantInitialized);

  inline HeadOrTailByRequest(const HeadOrTailByRequest& from)
      : HeadOrTailByRequest(nullptr, from) {}
  HeadOrTailByRequest(HeadOrTailByRequest&& from) noexcept
    : HeadOrTailByRequest() {
    *this = ::std::move(from);
  }

  inline HeadOrTailByRequest& operator=(const HeadOrTailByRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeadOrTailByRequest& operator=(HeadOrTailByRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeadOrTailByRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeadOrTailByRequest* internal_default_instance() {
    return reinterpret_cast<const HeadOrTailByRequest*>(
               &_HeadOrTailByRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(HeadOrTailByRequest& a, HeadOrTailByRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeadOrTailByRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeadOrTailByRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeadOrTailByRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeadOrTailByRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeadOrTailByRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const HeadOrTailByRequest& from) {
    HeadOrTailByRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(HeadOrTailByRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.HeadOrTailByRequest";
  }
  protected:
  explicit HeadOrTailByRequest(::google::protobuf::Arena* arena);
  HeadOrTailByRequest(::google::protobuf::Arena* arena, const HeadOrTailByRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupByColumnSpecsFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kNumRowsFieldNumber = 3,
  };
  // repeated string group_by_column_specs = 4;
  int group_by_column_specs_size() const;
  private:
  int _internal_group_by_column_specs_size() const;

  public:
  void clear_group_by_column_specs() ;
  const std::string& group_by_column_specs(int index) const;
  std::string* mutable_group_by_column_specs(int index);
  void set_group_by_column_specs(int index, const std::string& value);
  void set_group_by_column_specs(int index, std::string&& value);
  void set_group_by_column_specs(int index, const char* value);
  void set_group_by_column_specs(int index, const char* value, std::size_t size);
  void set_group_by_column_specs(int index, absl::string_view value);
  std::string* add_group_by_column_specs();
  void add_group_by_column_specs(const std::string& value);
  void add_group_by_column_specs(std::string&& value);
  void add_group_by_column_specs(const char* value);
  void add_group_by_column_specs(const char* value, std::size_t size);
  void add_group_by_column_specs(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& group_by_column_specs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_group_by_column_specs();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_group_by_column_specs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_group_by_column_specs();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // sint64 num_rows = 3 [jstype = JS_STRING];
  void clear_num_rows() ;
  ::int64_t num_rows() const;
  void set_num_rows(::int64_t value);

  private:
  ::int64_t _internal_num_rows() const;
  void _internal_set_num_rows(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      83, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> group_by_column_specs_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    ::int64_t num_rows_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class FlattenRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FlattenRequest) */ {
 public:
  inline FlattenRequest() : FlattenRequest(nullptr) {}
  ~FlattenRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FlattenRequest(::google::protobuf::internal::ConstantInitialized);

  inline FlattenRequest(const FlattenRequest& from)
      : FlattenRequest(nullptr, from) {}
  FlattenRequest(FlattenRequest&& from) noexcept
    : FlattenRequest() {
    *this = ::std::move(from);
  }

  inline FlattenRequest& operator=(const FlattenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlattenRequest& operator=(FlattenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlattenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlattenRequest* internal_default_instance() {
    return reinterpret_cast<const FlattenRequest*>(
               &_FlattenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(FlattenRequest& a, FlattenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FlattenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlattenRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlattenRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlattenRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FlattenRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FlattenRequest& from) {
    FlattenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FlattenRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FlattenRequest";
  }
  protected:
  explicit FlattenRequest(::google::protobuf::Arena* arena);
  FlattenRequest(::google::protobuf::Arena* arena, const FlattenRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FlattenRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class FetchTableRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FetchTableRequest) */ {
 public:
  inline FetchTableRequest() : FetchTableRequest(nullptr) {}
  ~FetchTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FetchTableRequest(::google::protobuf::internal::ConstantInitialized);

  inline FetchTableRequest(const FetchTableRequest& from)
      : FetchTableRequest(nullptr, from) {}
  FetchTableRequest(FetchTableRequest&& from) noexcept
    : FetchTableRequest() {
    *this = ::std::move(from);
  }

  inline FetchTableRequest& operator=(const FetchTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FetchTableRequest& operator=(FetchTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FetchTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FetchTableRequest* internal_default_instance() {
    return reinterpret_cast<const FetchTableRequest*>(
               &_FetchTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FetchTableRequest& a, FetchTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FetchTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FetchTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FetchTableRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FetchTableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FetchTableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FetchTableRequest& from) {
    FetchTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FetchTableRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FetchTableRequest";
  }
  protected:
  explicit FetchTableRequest(::google::protobuf::Arena* arena);
  FetchTableRequest(::google::protobuf::Arena* arena, const FetchTableRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 1,
    kResultIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FetchTableRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class ExportedTableCreationResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse) */ {
 public:
  inline ExportedTableCreationResponse() : ExportedTableCreationResponse(nullptr) {}
  ~ExportedTableCreationResponse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExportedTableCreationResponse(::google::protobuf::internal::ConstantInitialized);

  inline ExportedTableCreationResponse(const ExportedTableCreationResponse& from)
      : ExportedTableCreationResponse(nullptr, from) {}
  ExportedTableCreationResponse(ExportedTableCreationResponse&& from) noexcept
    : ExportedTableCreationResponse() {
    *this = ::std::move(from);
  }

  inline ExportedTableCreationResponse& operator=(const ExportedTableCreationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExportedTableCreationResponse& operator=(ExportedTableCreationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExportedTableCreationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExportedTableCreationResponse* internal_default_instance() {
    return reinterpret_cast<const ExportedTableCreationResponse*>(
               &_ExportedTableCreationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ExportedTableCreationResponse& a, ExportedTableCreationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExportedTableCreationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExportedTableCreationResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExportedTableCreationResponse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExportedTableCreationResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExportedTableCreationResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ExportedTableCreationResponse& from) {
    ExportedTableCreationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExportedTableCreationResponse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse";
  }
  protected:
  explicit ExportedTableCreationResponse(::google::protobuf::Arena* arena);
  ExportedTableCreationResponse(::google::protobuf::Arena* arena, const ExportedTableCreationResponse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorInfoFieldNumber = 3,
    kSchemaHeaderFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSizeFieldNumber = 6,
    kSuccessFieldNumber = 2,
    kIsStaticFieldNumber = 5,
  };
  // string error_info = 3;
  void clear_error_info() ;
  const std::string& error_info() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_error_info(Arg_&& arg, Args_... args);
  std::string* mutable_error_info();
  PROTOBUF_NODISCARD std::string* release_error_info();
  void set_allocated_error_info(std::string* value);

  private:
  const std::string& _internal_error_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_info(
      const std::string& value);
  std::string* _internal_mutable_error_info();

  public:
  // bytes schema_header = 4;
  void clear_schema_header() ;
  const std::string& schema_header() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema_header(Arg_&& arg, Args_... args);
  std::string* mutable_schema_header();
  PROTOBUF_NODISCARD std::string* release_schema_header();
  void set_allocated_schema_header(std::string* value);

  private:
  const std::string& _internal_schema_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema_header(
      const std::string& value);
  std::string* _internal_mutable_schema_header();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_result_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_result_id();

  public:
  // sint64 size = 6 [jstype = JS_STRING];
  void clear_size() ;
  ::int64_t size() const;
  void set_size(::int64_t value);

  private:
  ::int64_t _internal_size() const;
  void _internal_set_size(::int64_t value);

  public:
  // bool success = 2;
  void clear_success() ;
  bool success() const;
  void set_success(bool value);

  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);

  public:
  // bool is_static = 5;
  void clear_is_static() ;
  bool is_static() const;
  void set_is_static(bool value);

  private:
  bool _internal_is_static() const;
  void _internal_set_is_static(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 1,
      82, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr error_info_;
    ::google::protobuf::internal::ArenaStringPtr schema_header_;
    ::io::deephaven::proto::backplane::grpc::TableReference* result_id_;
    ::int64_t size_;
    bool success_;
    bool is_static_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class ExactJoinTablesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest) */ {
 public:
  inline ExactJoinTablesRequest() : ExactJoinTablesRequest(nullptr) {}
  ~ExactJoinTablesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ExactJoinTablesRequest(::google::protobuf::internal::ConstantInitialized);

  inline ExactJoinTablesRequest(const ExactJoinTablesRequest& from)
      : ExactJoinTablesRequest(nullptr, from) {}
  ExactJoinTablesRequest(ExactJoinTablesRequest&& from) noexcept
    : ExactJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline ExactJoinTablesRequest& operator=(const ExactJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExactJoinTablesRequest& operator=(ExactJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExactJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExactJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const ExactJoinTablesRequest*>(
               &_ExactJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ExactJoinTablesRequest& a, ExactJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExactJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExactJoinTablesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExactJoinTablesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExactJoinTablesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ExactJoinTablesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ExactJoinTablesRequest& from) {
    ExactJoinTablesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ExactJoinTablesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest";
  }
  protected:
  explicit ExactJoinTablesRequest(::google::protobuf::Arena* arena);
  ExactJoinTablesRequest(::google::protobuf::Arena* arena, const ExactJoinTablesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;

  public:
  void clear_columns_to_match() ;
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, std::size_t size);
  void set_columns_to_match(int index, absl::string_view value);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, std::size_t size);
  void add_columns_to_match(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_match();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_match();

  public:
  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;

  public:
  void clear_columns_to_add() ;
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, std::size_t size);
  void set_columns_to_add(int index, absl::string_view value);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, std::size_t size);
  void add_columns_to_add(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_add();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_add();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  void clear_left_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  void clear_right_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      95, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_match_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_add_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class DropColumnsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.DropColumnsRequest) */ {
 public:
  inline DropColumnsRequest() : DropColumnsRequest(nullptr) {}
  ~DropColumnsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DropColumnsRequest(::google::protobuf::internal::ConstantInitialized);

  inline DropColumnsRequest(const DropColumnsRequest& from)
      : DropColumnsRequest(nullptr, from) {}
  DropColumnsRequest(DropColumnsRequest&& from) noexcept
    : DropColumnsRequest() {
    *this = ::std::move(from);
  }

  inline DropColumnsRequest& operator=(const DropColumnsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DropColumnsRequest& operator=(DropColumnsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DropColumnsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DropColumnsRequest* internal_default_instance() {
    return reinterpret_cast<const DropColumnsRequest*>(
               &_DropColumnsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(DropColumnsRequest& a, DropColumnsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DropColumnsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DropColumnsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DropColumnsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DropColumnsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DropColumnsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DropColumnsRequest& from) {
    DropColumnsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DropColumnsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.DropColumnsRequest";
  }
  protected:
  explicit DropColumnsRequest(::google::protobuf::Arena* arena);
  DropColumnsRequest(::google::protobuf::Arena* arena, const DropColumnsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNamesFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated string column_names = 3;
  int column_names_size() const;
  private:
  int _internal_column_names_size() const;

  public:
  void clear_column_names() ;
  const std::string& column_names(int index) const;
  std::string* mutable_column_names(int index);
  void set_column_names(int index, const std::string& value);
  void set_column_names(int index, std::string&& value);
  void set_column_names(int index, const char* value);
  void set_column_names(int index, const char* value, std::size_t size);
  void set_column_names(int index, absl::string_view value);
  std::string* add_column_names();
  void add_column_names(const std::string& value);
  void add_column_names(std::string&& value);
  void add_column_names(const char* value);
  void add_column_names(const char* value, std::size_t size);
  void add_column_names(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& column_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_column_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_column_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_column_names();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.DropColumnsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      73, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> column_names_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class CrossJoinTablesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest) */ {
 public:
  inline CrossJoinTablesRequest() : CrossJoinTablesRequest(nullptr) {}
  ~CrossJoinTablesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CrossJoinTablesRequest(::google::protobuf::internal::ConstantInitialized);

  inline CrossJoinTablesRequest(const CrossJoinTablesRequest& from)
      : CrossJoinTablesRequest(nullptr, from) {}
  CrossJoinTablesRequest(CrossJoinTablesRequest&& from) noexcept
    : CrossJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline CrossJoinTablesRequest& operator=(const CrossJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CrossJoinTablesRequest& operator=(CrossJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CrossJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CrossJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const CrossJoinTablesRequest*>(
               &_CrossJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(CrossJoinTablesRequest& a, CrossJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CrossJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CrossJoinTablesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CrossJoinTablesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CrossJoinTablesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CrossJoinTablesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CrossJoinTablesRequest& from) {
    CrossJoinTablesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CrossJoinTablesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest";
  }
  protected:
  explicit CrossJoinTablesRequest(::google::protobuf::Arena* arena);
  CrossJoinTablesRequest(::google::protobuf::Arena* arena, const CrossJoinTablesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
    kReserveBitsFieldNumber = 6,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;

  public:
  void clear_columns_to_match() ;
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, std::size_t size);
  void set_columns_to_match(int index, absl::string_view value);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, std::size_t size);
  void add_columns_to_match(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_match();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_match();

  public:
  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;

  public:
  void clear_columns_to_add() ;
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, std::size_t size);
  void set_columns_to_add(int index, absl::string_view value);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, std::size_t size);
  void add_columns_to_add(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_add();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_add();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  void clear_left_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  void clear_right_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();

  public:
  // int32 reserve_bits = 6;
  void clear_reserve_bits() ;
  ::int32_t reserve_bits() const;
  void set_reserve_bits(::int32_t value);

  private:
  ::int32_t _internal_reserve_bits() const;
  void _internal_set_reserve_bits(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      95, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_match_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_add_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
    ::int32_t reserve_bits_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class CreateInputTableRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CreateInputTableRequest) */ {
 public:
  inline CreateInputTableRequest() : CreateInputTableRequest(nullptr) {}
  ~CreateInputTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateInputTableRequest(::google::protobuf::internal::ConstantInitialized);

  inline CreateInputTableRequest(const CreateInputTableRequest& from)
      : CreateInputTableRequest(nullptr, from) {}
  CreateInputTableRequest(CreateInputTableRequest&& from) noexcept
    : CreateInputTableRequest() {
    *this = ::std::move(from);
  }

  inline CreateInputTableRequest& operator=(const CreateInputTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateInputTableRequest& operator=(CreateInputTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateInputTableRequest& default_instance() {
    return *internal_default_instance();
  }
  enum DefinitionCase {
    kSourceTableId = 2,
    kSchema = 3,
    DEFINITION_NOT_SET = 0,
  };

  static inline const CreateInputTableRequest* internal_default_instance() {
    return reinterpret_cast<const CreateInputTableRequest*>(
               &_CreateInputTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    119;

  friend void swap(CreateInputTableRequest& a, CreateInputTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateInputTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateInputTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateInputTableRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateInputTableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CreateInputTableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CreateInputTableRequest& from) {
    CreateInputTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CreateInputTableRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CreateInputTableRequest";
  }
  protected:
  explicit CreateInputTableRequest(::google::protobuf::Arena* arena);
  CreateInputTableRequest(::google::protobuf::Arena* arena, const CreateInputTableRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using InputTableKind = CreateInputTableRequest_InputTableKind;

  // accessors -------------------------------------------------------

  enum : int {
    kResultIdFieldNumber = 1,
    kKindFieldNumber = 4,
    kSourceTableIdFieldNumber = 2,
    kSchemaFieldNumber = 3,
  };
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind kind = 4;
  bool has_kind() const;
  void clear_kind() ;
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind& kind() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* release_kind();
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* mutable_kind();
  void set_allocated_kind(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* value);
  void unsafe_arena_set_allocated_kind(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* value);
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* unsafe_arena_release_kind();

  private:
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind& _internal_kind() const;
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* _internal_mutable_kind();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_table_id = 2;
  bool has_source_table_id() const;
  private:
  bool _internal_has_source_table_id() const;

  public:
  void clear_source_table_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_table_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_table_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_table_id();
  void set_allocated_source_table_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_table_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_table_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_table_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_table_id();

  public:
  // bytes schema = 3;
  bool has_schema() const;
  void clear_schema() ;
  const std::string& schema() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schema(Arg_&& arg, Args_... args);
  std::string* mutable_schema();
  PROTOBUF_NODISCARD std::string* release_schema();
  void set_allocated_schema(std::string* value);

  private:
  const std::string& _internal_schema() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schema(
      const std::string& value);
  std::string* _internal_mutable_schema();

  public:
  void clear_definition();
  DefinitionCase definition_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CreateInputTableRequest)
 private:
  class _Internal;
  void set_has_source_table_id();
  void set_has_schema();

  inline bool has_definition() const;
  inline void clear_has_definition();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 4, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* kind_;
    union DefinitionUnion {
      constexpr DefinitionUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::io::deephaven::proto::backplane::grpc::TableReference* source_table_id_;
      ::google::protobuf::internal::ArenaStringPtr schema_;
    } definition_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class CompareCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.CompareCondition) */ {
 public:
  inline CompareCondition() : CompareCondition(nullptr) {}
  ~CompareCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CompareCondition(::google::protobuf::internal::ConstantInitialized);

  inline CompareCondition(const CompareCondition& from)
      : CompareCondition(nullptr, from) {}
  CompareCondition(CompareCondition&& from) noexcept
    : CompareCondition() {
    *this = ::std::move(from);
  }

  inline CompareCondition& operator=(const CompareCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompareCondition& operator=(CompareCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompareCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompareCondition* internal_default_instance() {
    return reinterpret_cast<const CompareCondition*>(
               &_CompareCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(CompareCondition& a, CompareCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(CompareCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompareCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompareCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompareCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const CompareCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const CompareCondition& from) {
    CompareCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(CompareCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.CompareCondition";
  }
  protected:
  explicit CompareCondition(::google::protobuf::Arena* arena);
  CompareCondition(::google::protobuf::Arena* arena, const CompareCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using CompareOperation = CompareCondition_CompareOperation;
  static constexpr CompareOperation LESS_THAN = CompareCondition_CompareOperation_LESS_THAN;
  static constexpr CompareOperation LESS_THAN_OR_EQUAL = CompareCondition_CompareOperation_LESS_THAN_OR_EQUAL;
  static constexpr CompareOperation GREATER_THAN = CompareCondition_CompareOperation_GREATER_THAN;
  static constexpr CompareOperation GREATER_THAN_OR_EQUAL = CompareCondition_CompareOperation_GREATER_THAN_OR_EQUAL;
  static constexpr CompareOperation EQUALS = CompareCondition_CompareOperation_EQUALS;
  static constexpr CompareOperation NOT_EQUALS = CompareCondition_CompareOperation_NOT_EQUALS;
  static inline bool CompareOperation_IsValid(int value) {
    return CompareCondition_CompareOperation_IsValid(value);
  }
  static constexpr CompareOperation CompareOperation_MIN = CompareCondition_CompareOperation_CompareOperation_MIN;
  static constexpr CompareOperation CompareOperation_MAX = CompareCondition_CompareOperation_CompareOperation_MAX;
  static constexpr int CompareOperation_ARRAYSIZE = CompareCondition_CompareOperation_CompareOperation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* CompareOperation_descriptor() {
    return CompareCondition_CompareOperation_descriptor();
  }
  template <typename T>
  static inline const std::string& CompareOperation_Name(T value) {
    return CompareCondition_CompareOperation_Name(value);
  }
  static inline bool CompareOperation_Parse(absl::string_view name, CompareOperation* value) {
    return CompareCondition_CompareOperation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLhsFieldNumber = 3,
    kRhsFieldNumber = 4,
    kOperationFieldNumber = 1,
    kCaseSensitivityFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.Value lhs = 3;
  bool has_lhs() const;
  void clear_lhs() ;
  const ::io::deephaven::proto::backplane::grpc::Value& lhs() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Value* release_lhs();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_lhs();
  void set_allocated_lhs(::io::deephaven::proto::backplane::grpc::Value* value);
  void unsafe_arena_set_allocated_lhs(::io::deephaven::proto::backplane::grpc::Value* value);
  ::io::deephaven::proto::backplane::grpc::Value* unsafe_arena_release_lhs();

  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_lhs() const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_mutable_lhs();

  public:
  // .io.deephaven.proto.backplane.grpc.Value rhs = 4;
  bool has_rhs() const;
  void clear_rhs() ;
  const ::io::deephaven::proto::backplane::grpc::Value& rhs() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Value* release_rhs();
  ::io::deephaven::proto::backplane::grpc::Value* mutable_rhs();
  void set_allocated_rhs(::io::deephaven::proto::backplane::grpc::Value* value);
  void unsafe_arena_set_allocated_rhs(::io::deephaven::proto::backplane::grpc::Value* value);
  ::io::deephaven::proto::backplane::grpc::Value* unsafe_arena_release_rhs();

  private:
  const ::io::deephaven::proto::backplane::grpc::Value& _internal_rhs() const;
  ::io::deephaven::proto::backplane::grpc::Value* _internal_mutable_rhs();

  public:
  // .io.deephaven.proto.backplane.grpc.CompareCondition.CompareOperation operation = 1;
  void clear_operation() ;
  ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation operation() const;
  void set_operation(::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation value);

  private:
  ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation _internal_operation() const;
  void _internal_set_operation(::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation value);

  public:
  // .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 2;
  void clear_case_sensitivity() ;
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity case_sensitivity() const;
  void set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);

  private:
  ::io::deephaven::proto::backplane::grpc::CaseSensitivity _internal_case_sensitivity() const;
  void _internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.CompareCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::Value* lhs_;
    ::io::deephaven::proto::backplane::grpc::Value* rhs_;
    int operation_;
    int case_sensitivity_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class ComboAggregateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ComboAggregateRequest) */ {
 public:
  inline ComboAggregateRequest() : ComboAggregateRequest(nullptr) {}
  ~ComboAggregateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ComboAggregateRequest(::google::protobuf::internal::ConstantInitialized);

  inline ComboAggregateRequest(const ComboAggregateRequest& from)
      : ComboAggregateRequest(nullptr, from) {}
  ComboAggregateRequest(ComboAggregateRequest&& from) noexcept
    : ComboAggregateRequest() {
    *this = ::std::move(from);
  }

  inline ComboAggregateRequest& operator=(const ComboAggregateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComboAggregateRequest& operator=(ComboAggregateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComboAggregateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComboAggregateRequest* internal_default_instance() {
    return reinterpret_cast<const ComboAggregateRequest*>(
               &_ComboAggregateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(ComboAggregateRequest& a, ComboAggregateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ComboAggregateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComboAggregateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComboAggregateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComboAggregateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ComboAggregateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ComboAggregateRequest& from) {
    ComboAggregateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ComboAggregateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ComboAggregateRequest";
  }
  protected:
  explicit ComboAggregateRequest(::google::protobuf::Arena* arena);
  ComboAggregateRequest(::google::protobuf::Arena* arena, const ComboAggregateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Aggregate = ComboAggregateRequest_Aggregate;

  using AggType = ComboAggregateRequest_AggType;
  static constexpr AggType SUM = ComboAggregateRequest_AggType_SUM;
  static constexpr AggType ABS_SUM = ComboAggregateRequest_AggType_ABS_SUM;
  static constexpr AggType GROUP = ComboAggregateRequest_AggType_GROUP;
  static constexpr AggType AVG = ComboAggregateRequest_AggType_AVG;
  static constexpr AggType COUNT = ComboAggregateRequest_AggType_COUNT;
  static constexpr AggType FIRST = ComboAggregateRequest_AggType_FIRST;
  static constexpr AggType LAST = ComboAggregateRequest_AggType_LAST;
  static constexpr AggType MIN = ComboAggregateRequest_AggType_MIN;
  static constexpr AggType MAX = ComboAggregateRequest_AggType_MAX;
  static constexpr AggType MEDIAN = ComboAggregateRequest_AggType_MEDIAN;
  static constexpr AggType PERCENTILE = ComboAggregateRequest_AggType_PERCENTILE;
  static constexpr AggType STD = ComboAggregateRequest_AggType_STD;
  static constexpr AggType VAR = ComboAggregateRequest_AggType_VAR;
  static constexpr AggType WEIGHTED_AVG = ComboAggregateRequest_AggType_WEIGHTED_AVG;
  static inline bool AggType_IsValid(int value) {
    return ComboAggregateRequest_AggType_IsValid(value);
  }
  static constexpr AggType AggType_MIN = ComboAggregateRequest_AggType_AggType_MIN;
  static constexpr AggType AggType_MAX = ComboAggregateRequest_AggType_AggType_MAX;
  static constexpr int AggType_ARRAYSIZE = ComboAggregateRequest_AggType_AggType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* AggType_descriptor() {
    return ComboAggregateRequest_AggType_descriptor();
  }
  template <typename T>
  static inline const std::string& AggType_Name(T value) {
    return ComboAggregateRequest_AggType_Name(value);
  }
  static inline bool AggType_Parse(absl::string_view name, AggType* value) {
    return ComboAggregateRequest_AggType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAggregatesFieldNumber = 3,
    kGroupByColumnsFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kForceComboFieldNumber = 5,
  };
  // repeated .io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate aggregates = 3;
  int aggregates_size() const;
  private:
  int _internal_aggregates_size() const;

  public:
  void clear_aggregates() ;
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* mutable_aggregates(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate >*
      mutable_aggregates();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate>& _internal_aggregates() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate>* _internal_mutable_aggregates();
  public:
  const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate& aggregates(int index) const;
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* add_aggregates();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate >&
      aggregates() const;
  // repeated string group_by_columns = 4;
  int group_by_columns_size() const;
  private:
  int _internal_group_by_columns_size() const;

  public:
  void clear_group_by_columns() ;
  const std::string& group_by_columns(int index) const;
  std::string* mutable_group_by_columns(int index);
  void set_group_by_columns(int index, const std::string& value);
  void set_group_by_columns(int index, std::string&& value);
  void set_group_by_columns(int index, const char* value);
  void set_group_by_columns(int index, const char* value, std::size_t size);
  void set_group_by_columns(int index, absl::string_view value);
  std::string* add_group_by_columns();
  void add_group_by_columns(const std::string& value);
  void add_group_by_columns(std::string&& value);
  void add_group_by_columns(const char* value);
  void add_group_by_columns(const char* value, std::size_t size);
  void add_group_by_columns(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& group_by_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_group_by_columns();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_group_by_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_group_by_columns();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // bool force_combo = 5;
  void clear_force_combo() ;
  bool force_combo() const;
  void set_force_combo(bool value);

  private:
  bool _internal_force_combo() const;
  void _internal_set_force_combo(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ComboAggregateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 3,
      80, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate > aggregates_;
    ::google::protobuf::RepeatedPtrField<std::string> group_by_columns_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    bool force_combo_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class ColumnStatisticsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest) */ {
 public:
  inline ColumnStatisticsRequest() : ColumnStatisticsRequest(nullptr) {}
  ~ColumnStatisticsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ColumnStatisticsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ColumnStatisticsRequest(const ColumnStatisticsRequest& from)
      : ColumnStatisticsRequest(nullptr, from) {}
  ColumnStatisticsRequest(ColumnStatisticsRequest&& from) noexcept
    : ColumnStatisticsRequest() {
    *this = ::std::move(from);
  }

  inline ColumnStatisticsRequest& operator=(const ColumnStatisticsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnStatisticsRequest& operator=(ColumnStatisticsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnStatisticsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnStatisticsRequest* internal_default_instance() {
    return reinterpret_cast<const ColumnStatisticsRequest*>(
               &_ColumnStatisticsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    121;

  friend void swap(ColumnStatisticsRequest& a, ColumnStatisticsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnStatisticsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnStatisticsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnStatisticsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnStatisticsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ColumnStatisticsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ColumnStatisticsRequest& from) {
    ColumnStatisticsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ColumnStatisticsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest";
  }
  protected:
  explicit ColumnStatisticsRequest(::google::protobuf::Arena* arena);
  ColumnStatisticsRequest(::google::protobuf::Arena* arena, const ColumnStatisticsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnNameFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kUniqueValueLimitFieldNumber = 4,
  };
  // string column_name = 3;
  void clear_column_name() ;
  const std::string& column_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_column_name(Arg_&& arg, Args_... args);
  std::string* mutable_column_name();
  PROTOBUF_NODISCARD std::string* release_column_name();
  void set_allocated_column_name(std::string* value);

  private:
  const std::string& _internal_column_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column_name(
      const std::string& value);
  std::string* _internal_mutable_column_name();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // optional int32 unique_value_limit = 4;
  bool has_unique_value_limit() const;
  void clear_unique_value_limit() ;
  ::int32_t unique_value_limit() const;
  void set_unique_value_limit(::int32_t value);

  private:
  ::int32_t _internal_unique_value_limit() const;
  void _internal_set_unique_value_limit(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      77, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr column_name_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    ::int32_t unique_value_limit_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AsOfJoinTablesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest) */ {
 public:
  inline AsOfJoinTablesRequest() : AsOfJoinTablesRequest(nullptr) {}
  ~AsOfJoinTablesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AsOfJoinTablesRequest(::google::protobuf::internal::ConstantInitialized);

  inline AsOfJoinTablesRequest(const AsOfJoinTablesRequest& from)
      : AsOfJoinTablesRequest(nullptr, from) {}
  AsOfJoinTablesRequest(AsOfJoinTablesRequest&& from) noexcept
    : AsOfJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline AsOfJoinTablesRequest& operator=(const AsOfJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AsOfJoinTablesRequest& operator=(AsOfJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AsOfJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AsOfJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const AsOfJoinTablesRequest*>(
               &_AsOfJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(AsOfJoinTablesRequest& a, AsOfJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AsOfJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AsOfJoinTablesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AsOfJoinTablesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AsOfJoinTablesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AsOfJoinTablesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AsOfJoinTablesRequest& from) {
    AsOfJoinTablesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AsOfJoinTablesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest";
  }
  protected:
  explicit AsOfJoinTablesRequest(::google::protobuf::Arena* arena);
  AsOfJoinTablesRequest(::google::protobuf::Arena* arena, const AsOfJoinTablesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using MatchRule = AsOfJoinTablesRequest_MatchRule;
  static constexpr MatchRule LESS_THAN_EQUAL = AsOfJoinTablesRequest_MatchRule_LESS_THAN_EQUAL;
  static constexpr MatchRule LESS_THAN = AsOfJoinTablesRequest_MatchRule_LESS_THAN;
  static constexpr MatchRule GREATER_THAN_EQUAL = AsOfJoinTablesRequest_MatchRule_GREATER_THAN_EQUAL;
  static constexpr MatchRule GREATER_THAN = AsOfJoinTablesRequest_MatchRule_GREATER_THAN;
  static inline bool MatchRule_IsValid(int value) {
    return AsOfJoinTablesRequest_MatchRule_IsValid(value);
  }
  static constexpr MatchRule MatchRule_MIN = AsOfJoinTablesRequest_MatchRule_MatchRule_MIN;
  static constexpr MatchRule MatchRule_MAX = AsOfJoinTablesRequest_MatchRule_MatchRule_MAX;
  static constexpr int MatchRule_ARRAYSIZE = AsOfJoinTablesRequest_MatchRule_MatchRule_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MatchRule_descriptor() {
    return AsOfJoinTablesRequest_MatchRule_descriptor();
  }
  template <typename T>
  static inline const std::string& MatchRule_Name(T value) {
    return AsOfJoinTablesRequest_MatchRule_Name(value);
  }
  static inline bool MatchRule_Parse(absl::string_view name, MatchRule* value) {
    return AsOfJoinTablesRequest_MatchRule_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsToMatchFieldNumber = 4,
    kColumnsToAddFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
    kAsOfMatchRuleFieldNumber = 7,
  };
  // repeated string columns_to_match = 4;
  int columns_to_match_size() const;
  private:
  int _internal_columns_to_match_size() const;

  public:
  void clear_columns_to_match() ;
  const std::string& columns_to_match(int index) const;
  std::string* mutable_columns_to_match(int index);
  void set_columns_to_match(int index, const std::string& value);
  void set_columns_to_match(int index, std::string&& value);
  void set_columns_to_match(int index, const char* value);
  void set_columns_to_match(int index, const char* value, std::size_t size);
  void set_columns_to_match(int index, absl::string_view value);
  std::string* add_columns_to_match();
  void add_columns_to_match(const std::string& value);
  void add_columns_to_match(std::string&& value);
  void add_columns_to_match(const char* value);
  void add_columns_to_match(const char* value, std::size_t size);
  void add_columns_to_match(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_match();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_match() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_match();

  public:
  // repeated string columns_to_add = 5;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;

  public:
  void clear_columns_to_add() ;
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, std::size_t size);
  void set_columns_to_add(int index, absl::string_view value);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, std::size_t size);
  void add_columns_to_add(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_add();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_add();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  void clear_left_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  void clear_right_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();

  public:
  // .io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.MatchRule as_of_match_rule = 7;
  void clear_as_of_match_rule() ;
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule as_of_match_rule() const;
  void set_as_of_match_rule(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule value);

  private:
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule _internal_as_of_match_rule() const;
  void _internal_set_as_of_match_rule(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      94, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_match_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_add_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
    int as_of_match_rule_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class ApplyPreviewColumnsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest) */ {
 public:
  inline ApplyPreviewColumnsRequest() : ApplyPreviewColumnsRequest(nullptr) {}
  ~ApplyPreviewColumnsRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ApplyPreviewColumnsRequest(::google::protobuf::internal::ConstantInitialized);

  inline ApplyPreviewColumnsRequest(const ApplyPreviewColumnsRequest& from)
      : ApplyPreviewColumnsRequest(nullptr, from) {}
  ApplyPreviewColumnsRequest(ApplyPreviewColumnsRequest&& from) noexcept
    : ApplyPreviewColumnsRequest() {
    *this = ::std::move(from);
  }

  inline ApplyPreviewColumnsRequest& operator=(const ApplyPreviewColumnsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ApplyPreviewColumnsRequest& operator=(ApplyPreviewColumnsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ApplyPreviewColumnsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ApplyPreviewColumnsRequest* internal_default_instance() {
    return reinterpret_cast<const ApplyPreviewColumnsRequest*>(
               &_ApplyPreviewColumnsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ApplyPreviewColumnsRequest& a, ApplyPreviewColumnsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ApplyPreviewColumnsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ApplyPreviewColumnsRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ApplyPreviewColumnsRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ApplyPreviewColumnsRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ApplyPreviewColumnsRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ApplyPreviewColumnsRequest& from) {
    ApplyPreviewColumnsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ApplyPreviewColumnsRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest";
  }
  protected:
  explicit ApplyPreviewColumnsRequest(::google::protobuf::Arena* arena);
  ApplyPreviewColumnsRequest(::google::protobuf::Arena* arena, const ApplyPreviewColumnsRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceIdFieldNumber = 1,
    kResultIdFieldNumber = 2,
  };
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AjRajTablesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AjRajTablesRequest) */ {
 public:
  inline AjRajTablesRequest() : AjRajTablesRequest(nullptr) {}
  ~AjRajTablesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AjRajTablesRequest(::google::protobuf::internal::ConstantInitialized);

  inline AjRajTablesRequest(const AjRajTablesRequest& from)
      : AjRajTablesRequest(nullptr, from) {}
  AjRajTablesRequest(AjRajTablesRequest&& from) noexcept
    : AjRajTablesRequest() {
    *this = ::std::move(from);
  }

  inline AjRajTablesRequest& operator=(const AjRajTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AjRajTablesRequest& operator=(AjRajTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AjRajTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AjRajTablesRequest* internal_default_instance() {
    return reinterpret_cast<const AjRajTablesRequest*>(
               &_AjRajTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(AjRajTablesRequest& a, AjRajTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AjRajTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AjRajTablesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AjRajTablesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AjRajTablesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AjRajTablesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AjRajTablesRequest& from) {
    AjRajTablesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AjRajTablesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AjRajTablesRequest";
  }
  protected:
  explicit AjRajTablesRequest(::google::protobuf::Arena* arena);
  AjRajTablesRequest(::google::protobuf::Arena* arena, const AjRajTablesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExactMatchColumnsFieldNumber = 4,
    kColumnsToAddFieldNumber = 6,
    kAsOfColumnFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
  };
  // repeated string exact_match_columns = 4;
  int exact_match_columns_size() const;
  private:
  int _internal_exact_match_columns_size() const;

  public:
  void clear_exact_match_columns() ;
  const std::string& exact_match_columns(int index) const;
  std::string* mutable_exact_match_columns(int index);
  void set_exact_match_columns(int index, const std::string& value);
  void set_exact_match_columns(int index, std::string&& value);
  void set_exact_match_columns(int index, const char* value);
  void set_exact_match_columns(int index, const char* value, std::size_t size);
  void set_exact_match_columns(int index, absl::string_view value);
  std::string* add_exact_match_columns();
  void add_exact_match_columns(const std::string& value);
  void add_exact_match_columns(std::string&& value);
  void add_exact_match_columns(const char* value);
  void add_exact_match_columns(const char* value, std::size_t size);
  void add_exact_match_columns(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& exact_match_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_exact_match_columns();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_exact_match_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_exact_match_columns();

  public:
  // repeated string columns_to_add = 6;
  int columns_to_add_size() const;
  private:
  int _internal_columns_to_add_size() const;

  public:
  void clear_columns_to_add() ;
  const std::string& columns_to_add(int index) const;
  std::string* mutable_columns_to_add(int index);
  void set_columns_to_add(int index, const std::string& value);
  void set_columns_to_add(int index, std::string&& value);
  void set_columns_to_add(int index, const char* value);
  void set_columns_to_add(int index, const char* value, std::size_t size);
  void set_columns_to_add(int index, absl::string_view value);
  std::string* add_columns_to_add();
  void add_columns_to_add(const std::string& value);
  void add_columns_to_add(std::string&& value);
  void add_columns_to_add(const char* value);
  void add_columns_to_add(const char* value, std::size_t size);
  void add_columns_to_add(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_columns_to_add();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_columns_to_add() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_columns_to_add();

  public:
  // string as_of_column = 5;
  void clear_as_of_column() ;
  const std::string& as_of_column() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_as_of_column(Arg_&& arg, Args_... args);
  std::string* mutable_as_of_column();
  PROTOBUF_NODISCARD std::string* release_as_of_column();
  void set_allocated_as_of_column(std::string* value);

  private:
  const std::string& _internal_as_of_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_as_of_column(
      const std::string& value);
  std::string* _internal_mutable_as_of_column();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  void clear_left_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  void clear_right_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AjRajTablesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 3,
      106, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> exact_match_columns_;
    ::google::protobuf::RepeatedPtrField<std::string> columns_to_add_;
    ::google::protobuf::internal::ArenaStringPtr as_of_column_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggSpec final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggSpec) */ {
 public:
  inline AggSpec() : AggSpec(nullptr) {}
  ~AggSpec() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggSpec(::google::protobuf::internal::ConstantInitialized);

  inline AggSpec(const AggSpec& from)
      : AggSpec(nullptr, from) {}
  AggSpec(AggSpec&& from) noexcept
    : AggSpec() {
    *this = ::std::move(from);
  }

  inline AggSpec& operator=(const AggSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggSpec& operator=(AggSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggSpec& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kAbsSum = 1,
    kApproximatePercentile = 2,
    kAvg = 3,
    kCountDistinct = 4,
    kDistinct = 5,
    kFirst = 6,
    kFormula = 7,
    kFreeze = 8,
    kGroup = 9,
    kLast = 10,
    kMax = 11,
    kMedian = 12,
    kMin = 13,
    kPercentile = 14,
    kSortedFirst = 15,
    kSortedLast = 16,
    kStd = 17,
    kSum = 18,
    kTDigest = 19,
    kUnique = 20,
    kWeightedAvg = 21,
    kWeightedSum = 22,
    kVar = 23,
    TYPE_NOT_SET = 0,
  };

  static inline const AggSpec* internal_default_instance() {
    return reinterpret_cast<const AggSpec*>(
               &_AggSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(AggSpec& a, AggSpec& b) {
    a.Swap(&b);
  }
  inline void Swap(AggSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggSpec* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggSpec* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggSpec>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggSpec& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggSpec& from) {
    AggSpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggSpec* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggSpec";
  }
  protected:
  explicit AggSpec(::google::protobuf::Arena* arena);
  AggSpec(::google::protobuf::Arena* arena, const AggSpec& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using AggSpecApproximatePercentile = AggSpec_AggSpecApproximatePercentile;
  using AggSpecCountDistinct = AggSpec_AggSpecCountDistinct;
  using AggSpecDistinct = AggSpec_AggSpecDistinct;
  using AggSpecFormula = AggSpec_AggSpecFormula;
  using AggSpecMedian = AggSpec_AggSpecMedian;
  using AggSpecPercentile = AggSpec_AggSpecPercentile;
  using AggSpecSorted = AggSpec_AggSpecSorted;
  using AggSpecSortedColumn = AggSpec_AggSpecSortedColumn;
  using AggSpecTDigest = AggSpec_AggSpecTDigest;
  using AggSpecUnique = AggSpec_AggSpecUnique;
  using AggSpecNonUniqueSentinel = AggSpec_AggSpecNonUniqueSentinel;
  using AggSpecWeighted = AggSpec_AggSpecWeighted;
  using AggSpecAbsSum = AggSpec_AggSpecAbsSum;
  using AggSpecAvg = AggSpec_AggSpecAvg;
  using AggSpecFirst = AggSpec_AggSpecFirst;
  using AggSpecFreeze = AggSpec_AggSpecFreeze;
  using AggSpecGroup = AggSpec_AggSpecGroup;
  using AggSpecLast = AggSpec_AggSpecLast;
  using AggSpecMax = AggSpec_AggSpecMax;
  using AggSpecMin = AggSpec_AggSpecMin;
  using AggSpecStd = AggSpec_AggSpecStd;
  using AggSpecSum = AggSpec_AggSpecSum;
  using AggSpecVar = AggSpec_AggSpecVar;

  // accessors -------------------------------------------------------

  enum : int {
    kAbsSumFieldNumber = 1,
    kApproximatePercentileFieldNumber = 2,
    kAvgFieldNumber = 3,
    kCountDistinctFieldNumber = 4,
    kDistinctFieldNumber = 5,
    kFirstFieldNumber = 6,
    kFormulaFieldNumber = 7,
    kFreezeFieldNumber = 8,
    kGroupFieldNumber = 9,
    kLastFieldNumber = 10,
    kMaxFieldNumber = 11,
    kMedianFieldNumber = 12,
    kMinFieldNumber = 13,
    kPercentileFieldNumber = 14,
    kSortedFirstFieldNumber = 15,
    kSortedLastFieldNumber = 16,
    kStdFieldNumber = 17,
    kSumFieldNumber = 18,
    kTDigestFieldNumber = 19,
    kUniqueFieldNumber = 20,
    kWeightedAvgFieldNumber = 21,
    kWeightedSumFieldNumber = 22,
    kVarFieldNumber = 23,
  };
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAbsSum abs_sum = 1;
  bool has_abs_sum() const;
  private:
  bool _internal_has_abs_sum() const;

  public:
  void clear_abs_sum() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum& abs_sum() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* release_abs_sum();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* mutable_abs_sum();
  void set_allocated_abs_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* value);
  void unsafe_arena_set_allocated_abs_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* unsafe_arena_release_abs_sum();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum& _internal_abs_sum() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* _internal_mutable_abs_sum();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile approximate_percentile = 2;
  bool has_approximate_percentile() const;
  private:
  bool _internal_has_approximate_percentile() const;

  public:
  void clear_approximate_percentile() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile& approximate_percentile() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* release_approximate_percentile();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* mutable_approximate_percentile();
  void set_allocated_approximate_percentile(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* value);
  void unsafe_arena_set_allocated_approximate_percentile(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* unsafe_arena_release_approximate_percentile();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile& _internal_approximate_percentile() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* _internal_mutable_approximate_percentile();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAvg avg = 3;
  bool has_avg() const;
  private:
  bool _internal_has_avg() const;

  public:
  void clear_avg() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg& avg() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* release_avg();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* mutable_avg();
  void set_allocated_avg(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* value);
  void unsafe_arena_set_allocated_avg(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* unsafe_arena_release_avg();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg& _internal_avg() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* _internal_mutable_avg();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct count_distinct = 4;
  bool has_count_distinct() const;
  private:
  bool _internal_has_count_distinct() const;

  public:
  void clear_count_distinct() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct& count_distinct() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* release_count_distinct();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* mutable_count_distinct();
  void set_allocated_count_distinct(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* value);
  void unsafe_arena_set_allocated_count_distinct(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* unsafe_arena_release_count_distinct();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct& _internal_count_distinct() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* _internal_mutable_count_distinct();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct distinct = 5;
  bool has_distinct() const;
  private:
  bool _internal_has_distinct() const;

  public:
  void clear_distinct() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct& distinct() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* release_distinct();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* mutable_distinct();
  void set_allocated_distinct(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* value);
  void unsafe_arena_set_allocated_distinct(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* unsafe_arena_release_distinct();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct& _internal_distinct() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* _internal_mutable_distinct();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFirst first = 6;
  bool has_first() const;
  private:
  bool _internal_has_first() const;

  public:
  void clear_first() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst& first() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* release_first();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* mutable_first();
  void set_allocated_first(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* value);
  void unsafe_arena_set_allocated_first(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* unsafe_arena_release_first();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst& _internal_first() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* _internal_mutable_first();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula formula = 7;
  bool has_formula() const;
  private:
  bool _internal_has_formula() const;

  public:
  void clear_formula() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula& formula() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* release_formula();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* mutable_formula();
  void set_allocated_formula(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* value);
  void unsafe_arena_set_allocated_formula(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* unsafe_arena_release_formula();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula& _internal_formula() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* _internal_mutable_formula();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFreeze freeze = 8;
  bool has_freeze() const;
  private:
  bool _internal_has_freeze() const;

  public:
  void clear_freeze() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze& freeze() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* release_freeze();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* mutable_freeze();
  void set_allocated_freeze(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* value);
  void unsafe_arena_set_allocated_freeze(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* unsafe_arena_release_freeze();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze& _internal_freeze() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* _internal_mutable_freeze();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecGroup group = 9;
  bool has_group() const;
  private:
  bool _internal_has_group() const;

  public:
  void clear_group() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup& group() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* release_group();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* mutable_group();
  void set_allocated_group(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* value);
  void unsafe_arena_set_allocated_group(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* unsafe_arena_release_group();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup& _internal_group() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* _internal_mutable_group();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecLast last = 10;
  bool has_last() const;
  private:
  bool _internal_has_last() const;

  public:
  void clear_last() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast& last() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* release_last();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* mutable_last();
  void set_allocated_last(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* value);
  void unsafe_arena_set_allocated_last(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* unsafe_arena_release_last();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast& _internal_last() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* _internal_mutable_last();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMax max = 11;
  bool has_max() const;
  private:
  bool _internal_has_max() const;

  public:
  void clear_max() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax& max() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* release_max();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* mutable_max();
  void set_allocated_max(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* value);
  void unsafe_arena_set_allocated_max(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* unsafe_arena_release_max();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax& _internal_max() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* _internal_mutable_max();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian median = 12;
  bool has_median() const;
  private:
  bool _internal_has_median() const;

  public:
  void clear_median() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian& median() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* release_median();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* mutable_median();
  void set_allocated_median(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* value);
  void unsafe_arena_set_allocated_median(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* unsafe_arena_release_median();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian& _internal_median() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* _internal_mutable_median();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMin min = 13;
  bool has_min() const;
  private:
  bool _internal_has_min() const;

  public:
  void clear_min() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin& min() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* release_min();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* mutable_min();
  void set_allocated_min(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* value);
  void unsafe_arena_set_allocated_min(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* unsafe_arena_release_min();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin& _internal_min() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* _internal_mutable_min();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile percentile = 14;
  bool has_percentile() const;
  private:
  bool _internal_has_percentile() const;

  public:
  void clear_percentile() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile& percentile() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* release_percentile();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* mutable_percentile();
  void set_allocated_percentile(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* value);
  void unsafe_arena_set_allocated_percentile(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* unsafe_arena_release_percentile();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile& _internal_percentile() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* _internal_mutable_percentile();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted sorted_first = 15;
  bool has_sorted_first() const;
  private:
  bool _internal_has_sorted_first() const;

  public:
  void clear_sorted_first() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& sorted_first() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* release_sorted_first();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* mutable_sorted_first();
  void set_allocated_sorted_first(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* value);
  void unsafe_arena_set_allocated_sorted_first(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* unsafe_arena_release_sorted_first();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& _internal_sorted_first() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* _internal_mutable_sorted_first();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted sorted_last = 16;
  bool has_sorted_last() const;
  private:
  bool _internal_has_sorted_last() const;

  public:
  void clear_sorted_last() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& sorted_last() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* release_sorted_last();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* mutable_sorted_last();
  void set_allocated_sorted_last(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* value);
  void unsafe_arena_set_allocated_sorted_last(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* unsafe_arena_release_sorted_last();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& _internal_sorted_last() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* _internal_mutable_sorted_last();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecStd std = 17;
  bool has_std() const;
  private:
  bool _internal_has_std() const;

  public:
  void clear_std() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd& std() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* release_std();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* mutable_std();
  void set_allocated_std(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* value);
  void unsafe_arena_set_allocated_std(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* unsafe_arena_release_std();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd& _internal_std() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* _internal_mutable_std();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSum sum = 18;
  bool has_sum() const;
  private:
  bool _internal_has_sum() const;

  public:
  void clear_sum() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum& sum() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* release_sum();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* mutable_sum();
  void set_allocated_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* value);
  void unsafe_arena_set_allocated_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* unsafe_arena_release_sum();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum& _internal_sum() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* _internal_mutable_sum();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest t_digest = 19;
  bool has_t_digest() const;
  private:
  bool _internal_has_t_digest() const;

  public:
  void clear_t_digest() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest& t_digest() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* release_t_digest();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* mutable_t_digest();
  void set_allocated_t_digest(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* value);
  void unsafe_arena_set_allocated_t_digest(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* unsafe_arena_release_t_digest();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest& _internal_t_digest() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* _internal_mutable_t_digest();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique unique = 20;
  bool has_unique() const;
  private:
  bool _internal_has_unique() const;

  public:
  void clear_unique() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique& unique() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* release_unique();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* mutable_unique();
  void set_allocated_unique(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* value);
  void unsafe_arena_set_allocated_unique(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* unsafe_arena_release_unique();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique& _internal_unique() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* _internal_mutable_unique();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted weighted_avg = 21;
  bool has_weighted_avg() const;
  private:
  bool _internal_has_weighted_avg() const;

  public:
  void clear_weighted_avg() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& weighted_avg() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* release_weighted_avg();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* mutable_weighted_avg();
  void set_allocated_weighted_avg(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* value);
  void unsafe_arena_set_allocated_weighted_avg(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* unsafe_arena_release_weighted_avg();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& _internal_weighted_avg() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* _internal_mutable_weighted_avg();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted weighted_sum = 22;
  bool has_weighted_sum() const;
  private:
  bool _internal_has_weighted_sum() const;

  public:
  void clear_weighted_sum() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& weighted_sum() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* release_weighted_sum();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* mutable_weighted_sum();
  void set_allocated_weighted_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* value);
  void unsafe_arena_set_allocated_weighted_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* unsafe_arena_release_weighted_sum();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& _internal_weighted_sum() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* _internal_mutable_weighted_sum();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecVar var = 23;
  bool has_var() const;
  private:
  bool _internal_has_var() const;

  public:
  void clear_var() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar& var() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* release_var();
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* mutable_var();
  void set_allocated_var(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* value);
  void unsafe_arena_set_allocated_var(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* unsafe_arena_release_var();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar& _internal_var() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* _internal_mutable_var();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggSpec)
 private:
  class _Internal;
  void set_has_abs_sum();
  void set_has_approximate_percentile();
  void set_has_avg();
  void set_has_count_distinct();
  void set_has_distinct();
  void set_has_first();
  void set_has_formula();
  void set_has_freeze();
  void set_has_group();
  void set_has_last();
  void set_has_max();
  void set_has_median();
  void set_has_min();
  void set_has_percentile();
  void set_has_sorted_first();
  void set_has_sorted_last();
  void set_has_std();
  void set_has_sum();
  void set_has_t_digest();
  void set_has_unique();
  void set_has_weighted_avg();
  void set_has_weighted_sum();
  void set_has_var();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 23, 23,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* abs_sum_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* approximate_percentile_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* avg_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* count_distinct_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* distinct_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* first_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* formula_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* freeze_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* group_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* last_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* max_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* median_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* min_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* percentile_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* sorted_first_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* sorted_last_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* std_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* sum_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* t_digest_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* unique_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* weighted_avg_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* weighted_sum_;
      ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* var_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec() : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kSum = 1,
    kMin = 2,
    kMax = 3,
    kProduct = 4,
    kFill = 5,
    kEma = 6,
    kRollingSum = 7,
    kRollingGroup = 8,
    kRollingAvg = 9,
    kRollingMin = 10,
    kRollingMax = 11,
    kRollingProduct = 12,
    kDelta = 13,
    kEms = 14,
    kEmMin = 15,
    kEmMax = 16,
    kEmStd = 17,
    kRollingCount = 18,
    kRollingStd = 19,
    kRollingWavg = 20,
    kRollingFormula = 21,
    TYPE_NOT_SET = 0,
  };

  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& a, UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using UpdateByCumulativeSum = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum;
  using UpdateByCumulativeMin = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin;
  using UpdateByCumulativeMax = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax;
  using UpdateByCumulativeProduct = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct;
  using UpdateByFill = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill;
  using UpdateByEma = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma;
  using UpdateByEms = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms;
  using UpdateByEmMin = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin;
  using UpdateByEmMax = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax;
  using UpdateByEmStd = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd;
  using UpdateByDelta = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta;
  using UpdateByRollingSum = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum;
  using UpdateByRollingGroup = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup;
  using UpdateByRollingAvg = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg;
  using UpdateByRollingMin = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin;
  using UpdateByRollingMax = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax;
  using UpdateByRollingProduct = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct;
  using UpdateByRollingCount = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount;
  using UpdateByRollingStd = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd;
  using UpdateByRollingWAvg = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg;
  using UpdateByRollingFormula = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula;

  // accessors -------------------------------------------------------

  enum : int {
    kSumFieldNumber = 1,
    kMinFieldNumber = 2,
    kMaxFieldNumber = 3,
    kProductFieldNumber = 4,
    kFillFieldNumber = 5,
    kEmaFieldNumber = 6,
    kRollingSumFieldNumber = 7,
    kRollingGroupFieldNumber = 8,
    kRollingAvgFieldNumber = 9,
    kRollingMinFieldNumber = 10,
    kRollingMaxFieldNumber = 11,
    kRollingProductFieldNumber = 12,
    kDeltaFieldNumber = 13,
    kEmsFieldNumber = 14,
    kEmMinFieldNumber = 15,
    kEmMaxFieldNumber = 16,
    kEmStdFieldNumber = 17,
    kRollingCountFieldNumber = 18,
    kRollingStdFieldNumber = 19,
    kRollingWavgFieldNumber = 20,
    kRollingFormulaFieldNumber = 21,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeSum sum = 1;
  bool has_sum() const;
  private:
  bool _internal_has_sum() const;

  public:
  void clear_sum() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& sum() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* release_sum();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* mutable_sum();
  void set_allocated_sum(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* value);
  void unsafe_arena_set_allocated_sum(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* unsafe_arena_release_sum();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& _internal_sum() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* _internal_mutable_sum();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMin min = 2;
  bool has_min() const;
  private:
  bool _internal_has_min() const;

  public:
  void clear_min() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& min() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* release_min();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* mutable_min();
  void set_allocated_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* value);
  void unsafe_arena_set_allocated_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* unsafe_arena_release_min();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& _internal_min() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* _internal_mutable_min();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMax max = 3;
  bool has_max() const;
  private:
  bool _internal_has_max() const;

  public:
  void clear_max() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& max() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* release_max();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* mutable_max();
  void set_allocated_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* value);
  void unsafe_arena_set_allocated_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* unsafe_arena_release_max();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& _internal_max() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* _internal_mutable_max();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeProduct product = 4;
  bool has_product() const;
  private:
  bool _internal_has_product() const;

  public:
  void clear_product() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& product() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* release_product();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* mutable_product();
  void set_allocated_product(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* value);
  void unsafe_arena_set_allocated_product(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* unsafe_arena_release_product();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& _internal_product() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* _internal_mutable_product();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByFill fill = 5;
  bool has_fill() const;
  private:
  bool _internal_has_fill() const;

  public:
  void clear_fill() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& fill() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* release_fill();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* mutable_fill();
  void set_allocated_fill(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* value);
  void unsafe_arena_set_allocated_fill(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* unsafe_arena_release_fill();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& _internal_fill() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* _internal_mutable_fill();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma ema = 6;
  bool has_ema() const;
  private:
  bool _internal_has_ema() const;

  public:
  void clear_ema() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& ema() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* release_ema();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* mutable_ema();
  void set_allocated_ema(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* value);
  void unsafe_arena_set_allocated_ema(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* unsafe_arena_release_ema();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& _internal_ema() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* _internal_mutable_ema();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum rolling_sum = 7;
  bool has_rolling_sum() const;
  private:
  bool _internal_has_rolling_sum() const;

  public:
  void clear_rolling_sum() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& rolling_sum() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* release_rolling_sum();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* mutable_rolling_sum();
  void set_allocated_rolling_sum(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* value);
  void unsafe_arena_set_allocated_rolling_sum(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* unsafe_arena_release_rolling_sum();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& _internal_rolling_sum() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* _internal_mutable_rolling_sum();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup rolling_group = 8;
  bool has_rolling_group() const;
  private:
  bool _internal_has_rolling_group() const;

  public:
  void clear_rolling_group() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& rolling_group() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* release_rolling_group();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* mutable_rolling_group();
  void set_allocated_rolling_group(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* value);
  void unsafe_arena_set_allocated_rolling_group(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* unsafe_arena_release_rolling_group();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& _internal_rolling_group() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* _internal_mutable_rolling_group();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg rolling_avg = 9;
  bool has_rolling_avg() const;
  private:
  bool _internal_has_rolling_avg() const;

  public:
  void clear_rolling_avg() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& rolling_avg() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* release_rolling_avg();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* mutable_rolling_avg();
  void set_allocated_rolling_avg(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* value);
  void unsafe_arena_set_allocated_rolling_avg(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* unsafe_arena_release_rolling_avg();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& _internal_rolling_avg() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* _internal_mutable_rolling_avg();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin rolling_min = 10;
  bool has_rolling_min() const;
  private:
  bool _internal_has_rolling_min() const;

  public:
  void clear_rolling_min() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& rolling_min() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* release_rolling_min();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* mutable_rolling_min();
  void set_allocated_rolling_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* value);
  void unsafe_arena_set_allocated_rolling_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* unsafe_arena_release_rolling_min();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& _internal_rolling_min() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* _internal_mutable_rolling_min();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax rolling_max = 11;
  bool has_rolling_max() const;
  private:
  bool _internal_has_rolling_max() const;

  public:
  void clear_rolling_max() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& rolling_max() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* release_rolling_max();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* mutable_rolling_max();
  void set_allocated_rolling_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* value);
  void unsafe_arena_set_allocated_rolling_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* unsafe_arena_release_rolling_max();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& _internal_rolling_max() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* _internal_mutable_rolling_max();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct rolling_product = 12;
  bool has_rolling_product() const;
  private:
  bool _internal_has_rolling_product() const;

  public:
  void clear_rolling_product() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& rolling_product() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* release_rolling_product();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* mutable_rolling_product();
  void set_allocated_rolling_product(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* value);
  void unsafe_arena_set_allocated_rolling_product(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* unsafe_arena_release_rolling_product();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& _internal_rolling_product() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* _internal_mutable_rolling_product();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta delta = 13;
  bool has_delta() const;
  private:
  bool _internal_has_delta() const;

  public:
  void clear_delta() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& delta() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* release_delta();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* mutable_delta();
  void set_allocated_delta(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* value);
  void unsafe_arena_set_allocated_delta(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* unsafe_arena_release_delta();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& _internal_delta() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* _internal_mutable_delta();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms ems = 14;
  bool has_ems() const;
  private:
  bool _internal_has_ems() const;

  public:
  void clear_ems() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& ems() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* release_ems();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* mutable_ems();
  void set_allocated_ems(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* value);
  void unsafe_arena_set_allocated_ems(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* unsafe_arena_release_ems();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& _internal_ems() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* _internal_mutable_ems();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin em_min = 15;
  bool has_em_min() const;
  private:
  bool _internal_has_em_min() const;

  public:
  void clear_em_min() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& em_min() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* release_em_min();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* mutable_em_min();
  void set_allocated_em_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* value);
  void unsafe_arena_set_allocated_em_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* unsafe_arena_release_em_min();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& _internal_em_min() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* _internal_mutable_em_min();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax em_max = 16;
  bool has_em_max() const;
  private:
  bool _internal_has_em_max() const;

  public:
  void clear_em_max() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& em_max() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* release_em_max();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* mutable_em_max();
  void set_allocated_em_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* value);
  void unsafe_arena_set_allocated_em_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* unsafe_arena_release_em_max();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& _internal_em_max() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* _internal_mutable_em_max();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd em_std = 17;
  bool has_em_std() const;
  private:
  bool _internal_has_em_std() const;

  public:
  void clear_em_std() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& em_std() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* release_em_std();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* mutable_em_std();
  void set_allocated_em_std(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* value);
  void unsafe_arena_set_allocated_em_std(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* unsafe_arena_release_em_std();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& _internal_em_std() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* _internal_mutable_em_std();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount rolling_count = 18;
  bool has_rolling_count() const;
  private:
  bool _internal_has_rolling_count() const;

  public:
  void clear_rolling_count() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& rolling_count() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* release_rolling_count();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* mutable_rolling_count();
  void set_allocated_rolling_count(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* value);
  void unsafe_arena_set_allocated_rolling_count(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* unsafe_arena_release_rolling_count();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& _internal_rolling_count() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* _internal_mutable_rolling_count();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd rolling_std = 19;
  bool has_rolling_std() const;
  private:
  bool _internal_has_rolling_std() const;

  public:
  void clear_rolling_std() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& rolling_std() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* release_rolling_std();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* mutable_rolling_std();
  void set_allocated_rolling_std(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* value);
  void unsafe_arena_set_allocated_rolling_std(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* unsafe_arena_release_rolling_std();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& _internal_rolling_std() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* _internal_mutable_rolling_std();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg rolling_wavg = 20;
  bool has_rolling_wavg() const;
  private:
  bool _internal_has_rolling_wavg() const;

  public:
  void clear_rolling_wavg() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& rolling_wavg() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* release_rolling_wavg();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* mutable_rolling_wavg();
  void set_allocated_rolling_wavg(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* value);
  void unsafe_arena_set_allocated_rolling_wavg(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* unsafe_arena_release_rolling_wavg();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& _internal_rolling_wavg() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* _internal_mutable_rolling_wavg();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula rolling_formula = 21;
  bool has_rolling_formula() const;
  private:
  bool _internal_has_rolling_formula() const;

  public:
  void clear_rolling_formula() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& rolling_formula() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* release_rolling_formula();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* mutable_rolling_formula();
  void set_allocated_rolling_formula(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* value);
  void unsafe_arena_set_allocated_rolling_formula(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* unsafe_arena_release_rolling_formula();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& _internal_rolling_formula() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* _internal_mutable_rolling_formula();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec)
 private:
  class _Internal;
  void set_has_sum();
  void set_has_min();
  void set_has_max();
  void set_has_product();
  void set_has_fill();
  void set_has_ema();
  void set_has_rolling_sum();
  void set_has_rolling_group();
  void set_has_rolling_avg();
  void set_has_rolling_min();
  void set_has_rolling_max();
  void set_has_rolling_product();
  void set_has_delta();
  void set_has_ems();
  void set_has_em_min();
  void set_has_em_max();
  void set_has_em_std();
  void set_has_rolling_count();
  void set_has_rolling_std();
  void set_has_rolling_wavg();
  void set_has_rolling_formula();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 21, 21,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* sum_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* min_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* max_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* product_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* fill_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* ema_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* rolling_sum_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* rolling_group_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* rolling_avg_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* rolling_min_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* rolling_max_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* rolling_product_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* delta_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* ems_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* em_min_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* em_max_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* em_std_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* rolling_count_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* rolling_std_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* rolling_wavg_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* rolling_formula_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class MultiJoinTablesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest) */ {
 public:
  inline MultiJoinTablesRequest() : MultiJoinTablesRequest(nullptr) {}
  ~MultiJoinTablesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR MultiJoinTablesRequest(::google::protobuf::internal::ConstantInitialized);

  inline MultiJoinTablesRequest(const MultiJoinTablesRequest& from)
      : MultiJoinTablesRequest(nullptr, from) {}
  MultiJoinTablesRequest(MultiJoinTablesRequest&& from) noexcept
    : MultiJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline MultiJoinTablesRequest& operator=(const MultiJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiJoinTablesRequest& operator=(MultiJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const MultiJoinTablesRequest*>(
               &_MultiJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(MultiJoinTablesRequest& a, MultiJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiJoinTablesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiJoinTablesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiJoinTablesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MultiJoinTablesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const MultiJoinTablesRequest& from) {
    MultiJoinTablesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MultiJoinTablesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest";
  }
  protected:
  explicit MultiJoinTablesRequest(::google::protobuf::Arena* arena);
  MultiJoinTablesRequest(::google::protobuf::Arena* arena, const MultiJoinTablesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMultiJoinInputsFieldNumber = 2,
    kResultIdFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.MultiJoinInput multi_join_inputs = 2;
  int multi_join_inputs_size() const;
  private:
  int _internal_multi_join_inputs_size() const;

  public:
  void clear_multi_join_inputs() ;
  ::io::deephaven::proto::backplane::grpc::MultiJoinInput* mutable_multi_join_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::MultiJoinInput >*
      mutable_multi_join_inputs();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::MultiJoinInput>& _internal_multi_join_inputs() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::MultiJoinInput>* _internal_mutable_multi_join_inputs();
  public:
  const ::io::deephaven::proto::backplane::grpc::MultiJoinInput& multi_join_inputs(int index) const;
  ::io::deephaven::proto::backplane::grpc::MultiJoinInput* add_multi_join_inputs();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::MultiJoinInput >&
      multi_join_inputs() const;
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::MultiJoinInput > multi_join_inputs_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AndCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AndCondition) */ {
 public:
  inline AndCondition() : AndCondition(nullptr) {}
  ~AndCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AndCondition(::google::protobuf::internal::ConstantInitialized);

  inline AndCondition(const AndCondition& from)
      : AndCondition(nullptr, from) {}
  AndCondition(AndCondition&& from) noexcept
    : AndCondition() {
    *this = ::std::move(from);
  }

  inline AndCondition& operator=(const AndCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline AndCondition& operator=(AndCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AndCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const AndCondition* internal_default_instance() {
    return reinterpret_cast<const AndCondition*>(
               &_AndCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(AndCondition& a, AndCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(AndCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AndCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AndCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AndCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AndCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AndCondition& from) {
    AndCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AndCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AndCondition";
  }
  protected:
  explicit AndCondition(::google::protobuf::Arena* arena);
  AndCondition(::google::protobuf::Arena* arena, const AndCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Condition filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;

  public:
  void clear_filters() ;
  ::io::deephaven::proto::backplane::grpc::Condition* mutable_filters(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
      mutable_filters();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>& _internal_filters() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>* _internal_mutable_filters();
  public:
  const ::io::deephaven::proto::backplane::grpc::Condition& filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* add_filters();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
      filters() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AndCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition > filters_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class Condition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Condition) */ {
 public:
  inline Condition() : Condition(nullptr) {}
  ~Condition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Condition(::google::protobuf::internal::ConstantInitialized);

  inline Condition(const Condition& from)
      : Condition(nullptr, from) {}
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Condition& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kAnd = 1,
    kOr = 2,
    kNot = 3,
    kCompare = 4,
    kIn = 5,
    kInvoke = 6,
    kIsNull = 7,
    kMatches = 8,
    kContains = 9,
    kSearch = 10,
    DATA_NOT_SET = 0,
  };

  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Condition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Condition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Condition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Condition& from) {
    Condition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Condition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Condition";
  }
  protected:
  explicit Condition(::google::protobuf::Arena* arena);
  Condition(::google::protobuf::Arena* arena, const Condition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAndFieldNumber = 1,
    kOrFieldNumber = 2,
    kNotFieldNumber = 3,
    kCompareFieldNumber = 4,
    kInFieldNumber = 5,
    kInvokeFieldNumber = 6,
    kIsNullFieldNumber = 7,
    kMatchesFieldNumber = 8,
    kContainsFieldNumber = 9,
    kSearchFieldNumber = 10,
  };
  // .io.deephaven.proto.backplane.grpc.AndCondition and = 1;
  bool has_and_() const;
  private:
  bool _internal_has_and_() const;

  public:
  void clear_and_() ;
  const ::io::deephaven::proto::backplane::grpc::AndCondition& and_() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AndCondition* release_and_();
  ::io::deephaven::proto::backplane::grpc::AndCondition* mutable_and_();
  void set_allocated_and_(::io::deephaven::proto::backplane::grpc::AndCondition* value);
  void unsafe_arena_set_allocated_and_(::io::deephaven::proto::backplane::grpc::AndCondition* value);
  ::io::deephaven::proto::backplane::grpc::AndCondition* unsafe_arena_release_and_();

  private:
  const ::io::deephaven::proto::backplane::grpc::AndCondition& _internal_and_() const;
  ::io::deephaven::proto::backplane::grpc::AndCondition* _internal_mutable_and_();

  public:
  // .io.deephaven.proto.backplane.grpc.OrCondition or = 2;
  bool has_or_() const;
  private:
  bool _internal_has_or_() const;

  public:
  void clear_or_() ;
  const ::io::deephaven::proto::backplane::grpc::OrCondition& or_() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::OrCondition* release_or_();
  ::io::deephaven::proto::backplane::grpc::OrCondition* mutable_or_();
  void set_allocated_or_(::io::deephaven::proto::backplane::grpc::OrCondition* value);
  void unsafe_arena_set_allocated_or_(::io::deephaven::proto::backplane::grpc::OrCondition* value);
  ::io::deephaven::proto::backplane::grpc::OrCondition* unsafe_arena_release_or_();

  private:
  const ::io::deephaven::proto::backplane::grpc::OrCondition& _internal_or_() const;
  ::io::deephaven::proto::backplane::grpc::OrCondition* _internal_mutable_or_();

  public:
  // .io.deephaven.proto.backplane.grpc.NotCondition not = 3;
  bool has_not_() const;
  private:
  bool _internal_has_not_() const;

  public:
  void clear_not_() ;
  const ::io::deephaven::proto::backplane::grpc::NotCondition& not_() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::NotCondition* release_not_();
  ::io::deephaven::proto::backplane::grpc::NotCondition* mutable_not_();
  void set_allocated_not_(::io::deephaven::proto::backplane::grpc::NotCondition* value);
  void unsafe_arena_set_allocated_not_(::io::deephaven::proto::backplane::grpc::NotCondition* value);
  ::io::deephaven::proto::backplane::grpc::NotCondition* unsafe_arena_release_not_();

  private:
  const ::io::deephaven::proto::backplane::grpc::NotCondition& _internal_not_() const;
  ::io::deephaven::proto::backplane::grpc::NotCondition* _internal_mutable_not_();

  public:
  // .io.deephaven.proto.backplane.grpc.CompareCondition compare = 4;
  bool has_compare() const;
  private:
  bool _internal_has_compare() const;

  public:
  void clear_compare() ;
  const ::io::deephaven::proto::backplane::grpc::CompareCondition& compare() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CompareCondition* release_compare();
  ::io::deephaven::proto::backplane::grpc::CompareCondition* mutable_compare();
  void set_allocated_compare(::io::deephaven::proto::backplane::grpc::CompareCondition* value);
  void unsafe_arena_set_allocated_compare(::io::deephaven::proto::backplane::grpc::CompareCondition* value);
  ::io::deephaven::proto::backplane::grpc::CompareCondition* unsafe_arena_release_compare();

  private:
  const ::io::deephaven::proto::backplane::grpc::CompareCondition& _internal_compare() const;
  ::io::deephaven::proto::backplane::grpc::CompareCondition* _internal_mutable_compare();

  public:
  // .io.deephaven.proto.backplane.grpc.InCondition in = 5;
  bool has_in() const;
  private:
  bool _internal_has_in() const;

  public:
  void clear_in() ;
  const ::io::deephaven::proto::backplane::grpc::InCondition& in() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::InCondition* release_in();
  ::io::deephaven::proto::backplane::grpc::InCondition* mutable_in();
  void set_allocated_in(::io::deephaven::proto::backplane::grpc::InCondition* value);
  void unsafe_arena_set_allocated_in(::io::deephaven::proto::backplane::grpc::InCondition* value);
  ::io::deephaven::proto::backplane::grpc::InCondition* unsafe_arena_release_in();

  private:
  const ::io::deephaven::proto::backplane::grpc::InCondition& _internal_in() const;
  ::io::deephaven::proto::backplane::grpc::InCondition* _internal_mutable_in();

  public:
  // .io.deephaven.proto.backplane.grpc.InvokeCondition invoke = 6;
  bool has_invoke() const;
  private:
  bool _internal_has_invoke() const;

  public:
  void clear_invoke() ;
  const ::io::deephaven::proto::backplane::grpc::InvokeCondition& invoke() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::InvokeCondition* release_invoke();
  ::io::deephaven::proto::backplane::grpc::InvokeCondition* mutable_invoke();
  void set_allocated_invoke(::io::deephaven::proto::backplane::grpc::InvokeCondition* value);
  void unsafe_arena_set_allocated_invoke(::io::deephaven::proto::backplane::grpc::InvokeCondition* value);
  ::io::deephaven::proto::backplane::grpc::InvokeCondition* unsafe_arena_release_invoke();

  private:
  const ::io::deephaven::proto::backplane::grpc::InvokeCondition& _internal_invoke() const;
  ::io::deephaven::proto::backplane::grpc::InvokeCondition* _internal_mutable_invoke();

  public:
  // .io.deephaven.proto.backplane.grpc.IsNullCondition is_null = 7;
  bool has_is_null() const;
  private:
  bool _internal_has_is_null() const;

  public:
  void clear_is_null() ;
  const ::io::deephaven::proto::backplane::grpc::IsNullCondition& is_null() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::IsNullCondition* release_is_null();
  ::io::deephaven::proto::backplane::grpc::IsNullCondition* mutable_is_null();
  void set_allocated_is_null(::io::deephaven::proto::backplane::grpc::IsNullCondition* value);
  void unsafe_arena_set_allocated_is_null(::io::deephaven::proto::backplane::grpc::IsNullCondition* value);
  ::io::deephaven::proto::backplane::grpc::IsNullCondition* unsafe_arena_release_is_null();

  private:
  const ::io::deephaven::proto::backplane::grpc::IsNullCondition& _internal_is_null() const;
  ::io::deephaven::proto::backplane::grpc::IsNullCondition* _internal_mutable_is_null();

  public:
  // .io.deephaven.proto.backplane.grpc.MatchesCondition matches = 8;
  bool has_matches() const;
  private:
  bool _internal_has_matches() const;

  public:
  void clear_matches() ;
  const ::io::deephaven::proto::backplane::grpc::MatchesCondition& matches() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::MatchesCondition* release_matches();
  ::io::deephaven::proto::backplane::grpc::MatchesCondition* mutable_matches();
  void set_allocated_matches(::io::deephaven::proto::backplane::grpc::MatchesCondition* value);
  void unsafe_arena_set_allocated_matches(::io::deephaven::proto::backplane::grpc::MatchesCondition* value);
  ::io::deephaven::proto::backplane::grpc::MatchesCondition* unsafe_arena_release_matches();

  private:
  const ::io::deephaven::proto::backplane::grpc::MatchesCondition& _internal_matches() const;
  ::io::deephaven::proto::backplane::grpc::MatchesCondition* _internal_mutable_matches();

  public:
  // .io.deephaven.proto.backplane.grpc.ContainsCondition contains = 9;
  bool has_contains() const;
  private:
  bool _internal_has_contains() const;

  public:
  void clear_contains() ;
  const ::io::deephaven::proto::backplane::grpc::ContainsCondition& contains() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::ContainsCondition* release_contains();
  ::io::deephaven::proto::backplane::grpc::ContainsCondition* mutable_contains();
  void set_allocated_contains(::io::deephaven::proto::backplane::grpc::ContainsCondition* value);
  void unsafe_arena_set_allocated_contains(::io::deephaven::proto::backplane::grpc::ContainsCondition* value);
  ::io::deephaven::proto::backplane::grpc::ContainsCondition* unsafe_arena_release_contains();

  private:
  const ::io::deephaven::proto::backplane::grpc::ContainsCondition& _internal_contains() const;
  ::io::deephaven::proto::backplane::grpc::ContainsCondition* _internal_mutable_contains();

  public:
  // .io.deephaven.proto.backplane.grpc.SearchCondition search = 10;
  bool has_search() const;
  private:
  bool _internal_has_search() const;

  public:
  void clear_search() ;
  const ::io::deephaven::proto::backplane::grpc::SearchCondition& search() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SearchCondition* release_search();
  ::io::deephaven::proto::backplane::grpc::SearchCondition* mutable_search();
  void set_allocated_search(::io::deephaven::proto::backplane::grpc::SearchCondition* value);
  void unsafe_arena_set_allocated_search(::io::deephaven::proto::backplane::grpc::SearchCondition* value);
  ::io::deephaven::proto::backplane::grpc::SearchCondition* unsafe_arena_release_search();

  private:
  const ::io::deephaven::proto::backplane::grpc::SearchCondition& _internal_search() const;
  ::io::deephaven::proto::backplane::grpc::SearchCondition* _internal_mutable_search();

  public:
  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Condition)
 private:
  class _Internal;
  void set_has_and_();
  void set_has_or_();
  void set_has_not_();
  void set_has_compare();
  void set_has_in();
  void set_has_invoke();
  void set_has_is_null();
  void set_has_matches();
  void set_has_contains();
  void set_has_search();

  inline bool has_data() const;
  inline void clear_has_data();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 10, 10,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::io::deephaven::proto::backplane::grpc::AndCondition* and__;
      ::io::deephaven::proto::backplane::grpc::OrCondition* or__;
      ::io::deephaven::proto::backplane::grpc::NotCondition* not__;
      ::io::deephaven::proto::backplane::grpc::CompareCondition* compare_;
      ::io::deephaven::proto::backplane::grpc::InCondition* in_;
      ::io::deephaven::proto::backplane::grpc::InvokeCondition* invoke_;
      ::io::deephaven::proto::backplane::grpc::IsNullCondition* is_null_;
      ::io::deephaven::proto::backplane::grpc::MatchesCondition* matches_;
      ::io::deephaven::proto::backplane::grpc::ContainsCondition* contains_;
      ::io::deephaven::proto::backplane::grpc::SearchCondition* search_;
    } data_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class NotCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.NotCondition) */ {
 public:
  inline NotCondition() : NotCondition(nullptr) {}
  ~NotCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NotCondition(::google::protobuf::internal::ConstantInitialized);

  inline NotCondition(const NotCondition& from)
      : NotCondition(nullptr, from) {}
  NotCondition(NotCondition&& from) noexcept
    : NotCondition() {
    *this = ::std::move(from);
  }

  inline NotCondition& operator=(const NotCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline NotCondition& operator=(NotCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NotCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const NotCondition* internal_default_instance() {
    return reinterpret_cast<const NotCondition*>(
               &_NotCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(NotCondition& a, NotCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(NotCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NotCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NotCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NotCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NotCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const NotCondition& from) {
    NotCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(NotCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.NotCondition";
  }
  protected:
  explicit NotCondition(::google::protobuf::Arena* arena);
  NotCondition(::google::protobuf::Arena* arena, const NotCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.Condition filter = 1;
  bool has_filter() const;
  void clear_filter() ;
  const ::io::deephaven::proto::backplane::grpc::Condition& filter() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Condition* release_filter();
  ::io::deephaven::proto::backplane::grpc::Condition* mutable_filter();
  void set_allocated_filter(::io::deephaven::proto::backplane::grpc::Condition* value);
  void unsafe_arena_set_allocated_filter(::io::deephaven::proto::backplane::grpc::Condition* value);
  ::io::deephaven::proto::backplane::grpc::Condition* unsafe_arena_release_filter();

  private:
  const ::io::deephaven::proto::backplane::grpc::Condition& _internal_filter() const;
  ::io::deephaven::proto::backplane::grpc::Condition* _internal_mutable_filter();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.NotCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::io::deephaven::proto::backplane::grpc::Condition* filter_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class OrCondition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.OrCondition) */ {
 public:
  inline OrCondition() : OrCondition(nullptr) {}
  ~OrCondition() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR OrCondition(::google::protobuf::internal::ConstantInitialized);

  inline OrCondition(const OrCondition& from)
      : OrCondition(nullptr, from) {}
  OrCondition(OrCondition&& from) noexcept
    : OrCondition() {
    *this = ::std::move(from);
  }

  inline OrCondition& operator=(const OrCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline OrCondition& operator=(OrCondition&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OrCondition& default_instance() {
    return *internal_default_instance();
  }
  static inline const OrCondition* internal_default_instance() {
    return reinterpret_cast<const OrCondition*>(
               &_OrCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(OrCondition& a, OrCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(OrCondition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OrCondition* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OrCondition* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OrCondition>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const OrCondition& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const OrCondition& from) {
    OrCondition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(OrCondition* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.OrCondition";
  }
  protected:
  explicit OrCondition(::google::protobuf::Arena* arena);
  OrCondition(::google::protobuf::Arena* arena, const OrCondition& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Condition filters = 1;
  int filters_size() const;
  private:
  int _internal_filters_size() const;

  public:
  void clear_filters() ;
  ::io::deephaven::proto::backplane::grpc::Condition* mutable_filters(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
      mutable_filters();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>& _internal_filters() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>* _internal_mutable_filters();
  public:
  const ::io::deephaven::proto::backplane::grpc::Condition& filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* add_filters();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
      filters() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.OrCondition)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition > filters_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class Aggregation_AggregationColumns final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns) */ {
 public:
  inline Aggregation_AggregationColumns() : Aggregation_AggregationColumns(nullptr) {}
  ~Aggregation_AggregationColumns() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Aggregation_AggregationColumns(::google::protobuf::internal::ConstantInitialized);

  inline Aggregation_AggregationColumns(const Aggregation_AggregationColumns& from)
      : Aggregation_AggregationColumns(nullptr, from) {}
  Aggregation_AggregationColumns(Aggregation_AggregationColumns&& from) noexcept
    : Aggregation_AggregationColumns() {
    *this = ::std::move(from);
  }

  inline Aggregation_AggregationColumns& operator=(const Aggregation_AggregationColumns& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aggregation_AggregationColumns& operator=(Aggregation_AggregationColumns&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aggregation_AggregationColumns& default_instance() {
    return *internal_default_instance();
  }
  static inline const Aggregation_AggregationColumns* internal_default_instance() {
    return reinterpret_cast<const Aggregation_AggregationColumns*>(
               &_Aggregation_AggregationColumns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(Aggregation_AggregationColumns& a, Aggregation_AggregationColumns& b) {
    a.Swap(&b);
  }
  inline void Swap(Aggregation_AggregationColumns* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aggregation_AggregationColumns* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aggregation_AggregationColumns* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aggregation_AggregationColumns>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Aggregation_AggregationColumns& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Aggregation_AggregationColumns& from) {
    Aggregation_AggregationColumns::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Aggregation_AggregationColumns* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns";
  }
  protected:
  explicit Aggregation_AggregationColumns(::google::protobuf::Arena* arena);
  Aggregation_AggregationColumns(::google::protobuf::Arena* arena, const Aggregation_AggregationColumns& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchPairsFieldNumber = 2,
    kSpecFieldNumber = 1,
  };
  // repeated string match_pairs = 2;
  int match_pairs_size() const;
  private:
  int _internal_match_pairs_size() const;

  public:
  void clear_match_pairs() ;
  const std::string& match_pairs(int index) const;
  std::string* mutable_match_pairs(int index);
  void set_match_pairs(int index, const std::string& value);
  void set_match_pairs(int index, std::string&& value);
  void set_match_pairs(int index, const char* value);
  void set_match_pairs(int index, const char* value, std::size_t size);
  void set_match_pairs(int index, absl::string_view value);
  std::string* add_match_pairs();
  void add_match_pairs(const std::string& value);
  void add_match_pairs(std::string&& value);
  void add_match_pairs(const char* value);
  void add_match_pairs(const char* value, std::size_t size);
  void add_match_pairs(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& match_pairs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_match_pairs();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_match_pairs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_match_pairs();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec spec = 1;
  bool has_spec() const;
  void clear_spec() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec& spec() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec* release_spec();
  ::io::deephaven::proto::backplane::grpc::AggSpec* mutable_spec();
  void set_allocated_spec(::io::deephaven::proto::backplane::grpc::AggSpec* value);
  void unsafe_arena_set_allocated_spec(::io::deephaven::proto::backplane::grpc::AggSpec* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec* unsafe_arena_release_spec();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec& _internal_spec() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec* _internal_mutable_spec();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      84, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> match_pairs_;
    ::io::deephaven::proto::backplane::grpc::AggSpec* spec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggregateAllRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggregateAllRequest) */ {
 public:
  inline AggregateAllRequest() : AggregateAllRequest(nullptr) {}
  ~AggregateAllRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggregateAllRequest(::google::protobuf::internal::ConstantInitialized);

  inline AggregateAllRequest(const AggregateAllRequest& from)
      : AggregateAllRequest(nullptr, from) {}
  AggregateAllRequest(AggregateAllRequest&& from) noexcept
    : AggregateAllRequest() {
    *this = ::std::move(from);
  }

  inline AggregateAllRequest& operator=(const AggregateAllRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateAllRequest& operator=(AggregateAllRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateAllRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateAllRequest* internal_default_instance() {
    return reinterpret_cast<const AggregateAllRequest*>(
               &_AggregateAllRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(AggregateAllRequest& a, AggregateAllRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregateAllRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateAllRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateAllRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregateAllRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggregateAllRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggregateAllRequest& from) {
    AggregateAllRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggregateAllRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggregateAllRequest";
  }
  protected:
  explicit AggregateAllRequest(::google::protobuf::Arena* arena);
  AggregateAllRequest(::google::protobuf::Arena* arena, const AggregateAllRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupByColumnsFieldNumber = 4,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kSpecFieldNumber = 3,
  };
  // repeated string group_by_columns = 4;
  int group_by_columns_size() const;
  private:
  int _internal_group_by_columns_size() const;

  public:
  void clear_group_by_columns() ;
  const std::string& group_by_columns(int index) const;
  std::string* mutable_group_by_columns(int index);
  void set_group_by_columns(int index, const std::string& value);
  void set_group_by_columns(int index, std::string&& value);
  void set_group_by_columns(int index, const char* value);
  void set_group_by_columns(int index, const char* value, std::size_t size);
  void set_group_by_columns(int index, absl::string_view value);
  std::string* add_group_by_columns();
  void add_group_by_columns(const std::string& value);
  void add_group_by_columns(std::string&& value);
  void add_group_by_columns(const char* value);
  void add_group_by_columns(const char* value, std::size_t size);
  void add_group_by_columns(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& group_by_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_group_by_columns();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_group_by_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_group_by_columns();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // .io.deephaven.proto.backplane.grpc.AggSpec spec = 3;
  bool has_spec() const;
  void clear_spec() ;
  const ::io::deephaven::proto::backplane::grpc::AggSpec& spec() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggSpec* release_spec();
  ::io::deephaven::proto::backplane::grpc::AggSpec* mutable_spec();
  void set_allocated_spec(::io::deephaven::proto::backplane::grpc::AggSpec* value);
  void unsafe_arena_set_allocated_spec(::io::deephaven::proto::backplane::grpc::AggSpec* value);
  ::io::deephaven::proto::backplane::grpc::AggSpec* unsafe_arena_release_spec();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggSpec& _internal_spec() const;
  ::io::deephaven::proto::backplane::grpc::AggSpec* _internal_mutable_spec();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggregateAllRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 3,
      78, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> group_by_columns_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    ::io::deephaven::proto::backplane::grpc::AggSpec* spec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation_UpdateByColumn final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn) */ {
 public:
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn() : UpdateByRequest_UpdateByOperation_UpdateByColumn(nullptr) {}
  ~UpdateByRequest_UpdateByOperation_UpdateByColumn() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation_UpdateByColumn(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn(const UpdateByRequest_UpdateByOperation_UpdateByColumn& from)
      : UpdateByRequest_UpdateByOperation_UpdateByColumn(nullptr, from) {}
  UpdateByRequest_UpdateByOperation_UpdateByColumn(UpdateByRequest_UpdateByOperation_UpdateByColumn&& from) noexcept
    : UpdateByRequest_UpdateByOperation_UpdateByColumn() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation_UpdateByColumn& operator=(const UpdateByRequest_UpdateByOperation_UpdateByColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation_UpdateByColumn& operator=(UpdateByRequest_UpdateByOperation_UpdateByColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation_UpdateByColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest_UpdateByOperation_UpdateByColumn* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation_UpdateByColumn*>(
               &_UpdateByRequest_UpdateByOperation_UpdateByColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(UpdateByRequest_UpdateByOperation_UpdateByColumn& a, UpdateByRequest_UpdateByOperation_UpdateByColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation_UpdateByColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation_UpdateByColumn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation_UpdateByColumn>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation_UpdateByColumn& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation_UpdateByColumn& from) {
    UpdateByRequest_UpdateByOperation_UpdateByColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation_UpdateByColumn* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation_UpdateByColumn(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation_UpdateByColumn(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation_UpdateByColumn& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using UpdateBySpec = UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec;

  // accessors -------------------------------------------------------

  enum : int {
    kMatchPairsFieldNumber = 2,
    kSpecFieldNumber = 1,
  };
  // repeated string match_pairs = 2;
  int match_pairs_size() const;
  private:
  int _internal_match_pairs_size() const;

  public:
  void clear_match_pairs() ;
  const std::string& match_pairs(int index) const;
  std::string* mutable_match_pairs(int index);
  void set_match_pairs(int index, const std::string& value);
  void set_match_pairs(int index, std::string&& value);
  void set_match_pairs(int index, const char* value);
  void set_match_pairs(int index, const char* value, std::size_t size);
  void set_match_pairs(int index, absl::string_view value);
  std::string* add_match_pairs();
  void add_match_pairs(const std::string& value);
  void add_match_pairs(std::string&& value);
  void add_match_pairs(const char* value);
  void add_match_pairs(const char* value, std::size_t size);
  void add_match_pairs(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& match_pairs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_match_pairs();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_match_pairs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_match_pairs();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec spec = 1;
  bool has_spec() const;
  void clear_spec() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& spec() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* release_spec();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* mutable_spec();
  void set_allocated_spec(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* value);
  void unsafe_arena_set_allocated_spec(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* unsafe_arena_release_spec();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& _internal_spec() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* _internal_mutable_spec();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      102, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> match_pairs_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* spec_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class FilterTableRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.FilterTableRequest) */ {
 public:
  inline FilterTableRequest() : FilterTableRequest(nullptr) {}
  ~FilterTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FilterTableRequest(::google::protobuf::internal::ConstantInitialized);

  inline FilterTableRequest(const FilterTableRequest& from)
      : FilterTableRequest(nullptr, from) {}
  FilterTableRequest(FilterTableRequest&& from) noexcept
    : FilterTableRequest() {
    *this = ::std::move(from);
  }

  inline FilterTableRequest& operator=(const FilterTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterTableRequest& operator=(FilterTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FilterTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FilterTableRequest* internal_default_instance() {
    return reinterpret_cast<const FilterTableRequest*>(
               &_FilterTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(FilterTableRequest& a, FilterTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FilterTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FilterTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FilterTableRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FilterTableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const FilterTableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const FilterTableRequest& from) {
    FilterTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(FilterTableRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.FilterTableRequest";
  }
  protected:
  explicit FilterTableRequest(::google::protobuf::Arena* arena);
  FilterTableRequest(::google::protobuf::Arena* arena, const FilterTableRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 3,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Condition filters = 3;
  int filters_size() const;
  private:
  int _internal_filters_size() const;

  public:
  void clear_filters() ;
  ::io::deephaven::proto::backplane::grpc::Condition* mutable_filters(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >*
      mutable_filters();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>& _internal_filters() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>* _internal_mutable_filters();
  public:
  const ::io::deephaven::proto::backplane::grpc::Condition& filters(int index) const;
  ::io::deephaven::proto::backplane::grpc::Condition* add_filters();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition >&
      filters() const;
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.FilterTableRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Condition > filters_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class Aggregation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.Aggregation) */ {
 public:
  inline Aggregation() : Aggregation(nullptr) {}
  ~Aggregation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Aggregation(::google::protobuf::internal::ConstantInitialized);

  inline Aggregation(const Aggregation& from)
      : Aggregation(nullptr, from) {}
  Aggregation(Aggregation&& from) noexcept
    : Aggregation() {
    *this = ::std::move(from);
  }

  inline Aggregation& operator=(const Aggregation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Aggregation& operator=(Aggregation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Aggregation& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kColumns = 1,
    kCount = 2,
    kFirstRowKey = 3,
    kLastRowKey = 4,
    kPartition = 5,
    TYPE_NOT_SET = 0,
  };

  static inline const Aggregation* internal_default_instance() {
    return reinterpret_cast<const Aggregation*>(
               &_Aggregation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(Aggregation& a, Aggregation& b) {
    a.Swap(&b);
  }
  inline void Swap(Aggregation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Aggregation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Aggregation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Aggregation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Aggregation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Aggregation& from) {
    Aggregation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Aggregation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.Aggregation";
  }
  protected:
  explicit Aggregation(::google::protobuf::Arena* arena);
  Aggregation(::google::protobuf::Arena* arena, const Aggregation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using AggregationColumns = Aggregation_AggregationColumns;
  using AggregationCount = Aggregation_AggregationCount;
  using AggregationRowKey = Aggregation_AggregationRowKey;
  using AggregationPartition = Aggregation_AggregationPartition;

  // accessors -------------------------------------------------------

  enum : int {
    kColumnsFieldNumber = 1,
    kCountFieldNumber = 2,
    kFirstRowKeyFieldNumber = 3,
    kLastRowKeyFieldNumber = 4,
    kPartitionFieldNumber = 5,
  };
  // .io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns columns = 1;
  bool has_columns() const;
  private:
  bool _internal_has_columns() const;

  public:
  void clear_columns() ;
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns& columns() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* release_columns();
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* mutable_columns();
  void set_allocated_columns(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* value);
  void unsafe_arena_set_allocated_columns(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* value);
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* unsafe_arena_release_columns();

  private:
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns& _internal_columns() const;
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* _internal_mutable_columns();

  public:
  // .io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;

  public:
  void clear_count() ;
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount& count() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* release_count();
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* mutable_count();
  void set_allocated_count(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* value);
  void unsafe_arena_set_allocated_count(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* value);
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* unsafe_arena_release_count();

  private:
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount& _internal_count() const;
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* _internal_mutable_count();

  public:
  // .io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey first_row_key = 3;
  bool has_first_row_key() const;
  private:
  bool _internal_has_first_row_key() const;

  public:
  void clear_first_row_key() ;
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& first_row_key() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* release_first_row_key();
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* mutable_first_row_key();
  void set_allocated_first_row_key(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* value);
  void unsafe_arena_set_allocated_first_row_key(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* value);
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* unsafe_arena_release_first_row_key();

  private:
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& _internal_first_row_key() const;
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* _internal_mutable_first_row_key();

  public:
  // .io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey last_row_key = 4;
  bool has_last_row_key() const;
  private:
  bool _internal_has_last_row_key() const;

  public:
  void clear_last_row_key() ;
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& last_row_key() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* release_last_row_key();
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* mutable_last_row_key();
  void set_allocated_last_row_key(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* value);
  void unsafe_arena_set_allocated_last_row_key(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* value);
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* unsafe_arena_release_last_row_key();

  private:
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& _internal_last_row_key() const;
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* _internal_mutable_last_row_key();

  public:
  // .io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition partition = 5;
  bool has_partition() const;
  private:
  bool _internal_has_partition() const;

  public:
  void clear_partition() ;
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition& partition() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* release_partition();
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* mutable_partition();
  void set_allocated_partition(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* value);
  void unsafe_arena_set_allocated_partition(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* value);
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* unsafe_arena_release_partition();

  private:
  const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition& _internal_partition() const;
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* _internal_mutable_partition();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.Aggregation)
 private:
  class _Internal;
  void set_has_columns();
  void set_has_count();
  void set_has_first_row_key();
  void set_has_last_row_key();
  void set_has_partition();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 5, 5,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* columns_;
      ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* count_;
      ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* first_row_key_;
      ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* last_row_key_;
      ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* partition_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest_UpdateByOperation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation) */ {
 public:
  inline UpdateByRequest_UpdateByOperation() : UpdateByRequest_UpdateByOperation(nullptr) {}
  ~UpdateByRequest_UpdateByOperation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest_UpdateByOperation(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest_UpdateByOperation(const UpdateByRequest_UpdateByOperation& from)
      : UpdateByRequest_UpdateByOperation(nullptr, from) {}
  UpdateByRequest_UpdateByOperation(UpdateByRequest_UpdateByOperation&& from) noexcept
    : UpdateByRequest_UpdateByOperation() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest_UpdateByOperation& operator=(const UpdateByRequest_UpdateByOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest_UpdateByOperation& operator=(UpdateByRequest_UpdateByOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest_UpdateByOperation& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kColumn = 1,
    TYPE_NOT_SET = 0,
  };

  static inline const UpdateByRequest_UpdateByOperation* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest_UpdateByOperation*>(
               &_UpdateByRequest_UpdateByOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(UpdateByRequest_UpdateByOperation& a, UpdateByRequest_UpdateByOperation& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest_UpdateByOperation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest_UpdateByOperation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest_UpdateByOperation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest_UpdateByOperation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest_UpdateByOperation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest_UpdateByOperation& from) {
    UpdateByRequest_UpdateByOperation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest_UpdateByOperation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation";
  }
  protected:
  explicit UpdateByRequest_UpdateByOperation(::google::protobuf::Arena* arena);
  UpdateByRequest_UpdateByOperation(::google::protobuf::Arena* arena, const UpdateByRequest_UpdateByOperation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using UpdateByColumn = UpdateByRequest_UpdateByOperation_UpdateByColumn;

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFieldNumber = 1,
  };
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn column = 1;
  bool has_column() const;
  private:
  bool _internal_has_column() const;

  public:
  void clear_column() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn& column() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* release_column();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* mutable_column();
  void set_allocated_column(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* value);
  void unsafe_arena_set_allocated_column(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* unsafe_arena_release_column();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn& _internal_column() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* _internal_mutable_column();

  public:
  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation)
 private:
  class _Internal;
  void set_has_column();

  inline bool has_type() const;
  inline void clear_has_type();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union TypeUnion {
      constexpr TypeUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* column_;
    } type_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class RangeJoinTablesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest) */ {
 public:
  inline RangeJoinTablesRequest() : RangeJoinTablesRequest(nullptr) {}
  ~RangeJoinTablesRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RangeJoinTablesRequest(::google::protobuf::internal::ConstantInitialized);

  inline RangeJoinTablesRequest(const RangeJoinTablesRequest& from)
      : RangeJoinTablesRequest(nullptr, from) {}
  RangeJoinTablesRequest(RangeJoinTablesRequest&& from) noexcept
    : RangeJoinTablesRequest() {
    *this = ::std::move(from);
  }

  inline RangeJoinTablesRequest& operator=(const RangeJoinTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeJoinTablesRequest& operator=(RangeJoinTablesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RangeJoinTablesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RangeJoinTablesRequest* internal_default_instance() {
    return reinterpret_cast<const RangeJoinTablesRequest*>(
               &_RangeJoinTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(RangeJoinTablesRequest& a, RangeJoinTablesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeJoinTablesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RangeJoinTablesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RangeJoinTablesRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RangeJoinTablesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RangeJoinTablesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const RangeJoinTablesRequest& from) {
    RangeJoinTablesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(RangeJoinTablesRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest";
  }
  protected:
  explicit RangeJoinTablesRequest(::google::protobuf::Arena* arena);
  RangeJoinTablesRequest(::google::protobuf::Arena* arena, const RangeJoinTablesRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using RangeStartRule = RangeJoinTablesRequest_RangeStartRule;
  static constexpr RangeStartRule START_UNSPECIFIED = RangeJoinTablesRequest_RangeStartRule_START_UNSPECIFIED;
  static constexpr RangeStartRule LESS_THAN = RangeJoinTablesRequest_RangeStartRule_LESS_THAN;
  static constexpr RangeStartRule LESS_THAN_OR_EQUAL = RangeJoinTablesRequest_RangeStartRule_LESS_THAN_OR_EQUAL;
  static constexpr RangeStartRule LESS_THAN_OR_EQUAL_ALLOW_PRECEDING = RangeJoinTablesRequest_RangeStartRule_LESS_THAN_OR_EQUAL_ALLOW_PRECEDING;
  static inline bool RangeStartRule_IsValid(int value) {
    return RangeJoinTablesRequest_RangeStartRule_IsValid(value);
  }
  static constexpr RangeStartRule RangeStartRule_MIN = RangeJoinTablesRequest_RangeStartRule_RangeStartRule_MIN;
  static constexpr RangeStartRule RangeStartRule_MAX = RangeJoinTablesRequest_RangeStartRule_RangeStartRule_MAX;
  static constexpr int RangeStartRule_ARRAYSIZE = RangeJoinTablesRequest_RangeStartRule_RangeStartRule_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RangeStartRule_descriptor() {
    return RangeJoinTablesRequest_RangeStartRule_descriptor();
  }
  template <typename T>
  static inline const std::string& RangeStartRule_Name(T value) {
    return RangeJoinTablesRequest_RangeStartRule_Name(value);
  }
  static inline bool RangeStartRule_Parse(absl::string_view name, RangeStartRule* value) {
    return RangeJoinTablesRequest_RangeStartRule_Parse(name, value);
  }

  using RangeEndRule = RangeJoinTablesRequest_RangeEndRule;
  static constexpr RangeEndRule END_UNSPECIFIED = RangeJoinTablesRequest_RangeEndRule_END_UNSPECIFIED;
  static constexpr RangeEndRule GREATER_THAN = RangeJoinTablesRequest_RangeEndRule_GREATER_THAN;
  static constexpr RangeEndRule GREATER_THAN_OR_EQUAL = RangeJoinTablesRequest_RangeEndRule_GREATER_THAN_OR_EQUAL;
  static constexpr RangeEndRule GREATER_THAN_OR_EQUAL_ALLOW_FOLLOWING = RangeJoinTablesRequest_RangeEndRule_GREATER_THAN_OR_EQUAL_ALLOW_FOLLOWING;
  static inline bool RangeEndRule_IsValid(int value) {
    return RangeJoinTablesRequest_RangeEndRule_IsValid(value);
  }
  static constexpr RangeEndRule RangeEndRule_MIN = RangeJoinTablesRequest_RangeEndRule_RangeEndRule_MIN;
  static constexpr RangeEndRule RangeEndRule_MAX = RangeJoinTablesRequest_RangeEndRule_RangeEndRule_MAX;
  static constexpr int RangeEndRule_ARRAYSIZE = RangeJoinTablesRequest_RangeEndRule_RangeEndRule_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RangeEndRule_descriptor() {
    return RangeJoinTablesRequest_RangeEndRule_descriptor();
  }
  template <typename T>
  static inline const std::string& RangeEndRule_Name(T value) {
    return RangeJoinTablesRequest_RangeEndRule_Name(value);
  }
  static inline bool RangeEndRule_Parse(absl::string_view name, RangeEndRule* value) {
    return RangeJoinTablesRequest_RangeEndRule_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExactMatchColumnsFieldNumber = 4,
    kAggregationsFieldNumber = 10,
    kLeftStartColumnFieldNumber = 5,
    kRightRangeColumnFieldNumber = 7,
    kLeftEndColumnFieldNumber = 9,
    kRangeMatchFieldNumber = 11,
    kResultIdFieldNumber = 1,
    kLeftIdFieldNumber = 2,
    kRightIdFieldNumber = 3,
    kRangeStartRuleFieldNumber = 6,
    kRangeEndRuleFieldNumber = 8,
  };
  // repeated string exact_match_columns = 4;
  int exact_match_columns_size() const;
  private:
  int _internal_exact_match_columns_size() const;

  public:
  void clear_exact_match_columns() ;
  const std::string& exact_match_columns(int index) const;
  std::string* mutable_exact_match_columns(int index);
  void set_exact_match_columns(int index, const std::string& value);
  void set_exact_match_columns(int index, std::string&& value);
  void set_exact_match_columns(int index, const char* value);
  void set_exact_match_columns(int index, const char* value, std::size_t size);
  void set_exact_match_columns(int index, absl::string_view value);
  std::string* add_exact_match_columns();
  void add_exact_match_columns(const std::string& value);
  void add_exact_match_columns(std::string&& value);
  void add_exact_match_columns(const char* value);
  void add_exact_match_columns(const char* value, std::size_t size);
  void add_exact_match_columns(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& exact_match_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_exact_match_columns();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_exact_match_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_exact_match_columns();

  public:
  // repeated .io.deephaven.proto.backplane.grpc.Aggregation aggregations = 10;
  int aggregations_size() const;
  private:
  int _internal_aggregations_size() const;

  public:
  void clear_aggregations() ;
  ::io::deephaven::proto::backplane::grpc::Aggregation* mutable_aggregations(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation >*
      mutable_aggregations();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Aggregation>& _internal_aggregations() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Aggregation>* _internal_mutable_aggregations();
  public:
  const ::io::deephaven::proto::backplane::grpc::Aggregation& aggregations(int index) const;
  ::io::deephaven::proto::backplane::grpc::Aggregation* add_aggregations();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation >&
      aggregations() const;
  // string left_start_column = 5;
  void clear_left_start_column() ;
  const std::string& left_start_column() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_left_start_column(Arg_&& arg, Args_... args);
  std::string* mutable_left_start_column();
  PROTOBUF_NODISCARD std::string* release_left_start_column();
  void set_allocated_left_start_column(std::string* value);

  private:
  const std::string& _internal_left_start_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_left_start_column(
      const std::string& value);
  std::string* _internal_mutable_left_start_column();

  public:
  // string right_range_column = 7;
  void clear_right_range_column() ;
  const std::string& right_range_column() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_right_range_column(Arg_&& arg, Args_... args);
  std::string* mutable_right_range_column();
  PROTOBUF_NODISCARD std::string* release_right_range_column();
  void set_allocated_right_range_column(std::string* value);

  private:
  const std::string& _internal_right_range_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_right_range_column(
      const std::string& value);
  std::string* _internal_mutable_right_range_column();

  public:
  // string left_end_column = 9;
  void clear_left_end_column() ;
  const std::string& left_end_column() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_left_end_column(Arg_&& arg, Args_... args);
  std::string* mutable_left_end_column();
  PROTOBUF_NODISCARD std::string* release_left_end_column();
  void set_allocated_left_end_column(std::string* value);

  private:
  const std::string& _internal_left_end_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_left_end_column(
      const std::string& value);
  std::string* _internal_mutable_left_end_column();

  public:
  // string range_match = 11;
  void clear_range_match() ;
  const std::string& range_match() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_range_match(Arg_&& arg, Args_... args);
  std::string* mutable_range_match();
  PROTOBUF_NODISCARD std::string* release_range_match();
  void set_allocated_range_match(std::string* value);

  private:
  const std::string& _internal_range_match() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_range_match(
      const std::string& value);
  std::string* _internal_mutable_range_match();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
  bool has_left_id() const;
  void clear_left_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& left_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_left_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_left_id();
  void set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_left_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_left_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_left_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
  bool has_right_id() const;
  void clear_right_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& right_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_right_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_right_id();
  void set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_right_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_right_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_right_id();

  public:
  // .io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.RangeStartRule range_start_rule = 6;
  void clear_range_start_rule() ;
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule range_start_rule() const;
  void set_range_start_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule value);

  private:
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule _internal_range_start_rule() const;
  void _internal_set_range_start_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule value);

  public:
  // .io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.RangeEndRule range_end_rule = 8;
  void clear_range_end_rule() ;
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule range_end_rule() const;
  void set_range_end_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule value);

  private:
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule _internal_range_end_rule() const;
  void _internal_set_range_end_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 11, 4,
      153, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> exact_match_columns_;
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation > aggregations_;
    ::google::protobuf::internal::ArenaStringPtr left_start_column_;
    ::google::protobuf::internal::ArenaStringPtr right_range_column_;
    ::google::protobuf::internal::ArenaStringPtr left_end_column_;
    ::google::protobuf::internal::ArenaStringPtr range_match_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* left_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* right_id_;
    int range_start_rule_;
    int range_end_rule_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class AggregateRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.AggregateRequest) */ {
 public:
  inline AggregateRequest() : AggregateRequest(nullptr) {}
  ~AggregateRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR AggregateRequest(::google::protobuf::internal::ConstantInitialized);

  inline AggregateRequest(const AggregateRequest& from)
      : AggregateRequest(nullptr, from) {}
  AggregateRequest(AggregateRequest&& from) noexcept
    : AggregateRequest() {
    *this = ::std::move(from);
  }

  inline AggregateRequest& operator=(const AggregateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AggregateRequest& operator=(AggregateRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AggregateRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AggregateRequest* internal_default_instance() {
    return reinterpret_cast<const AggregateRequest*>(
               &_AggregateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(AggregateRequest& a, AggregateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AggregateRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AggregateRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AggregateRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AggregateRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const AggregateRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const AggregateRequest& from) {
    AggregateRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(AggregateRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.AggregateRequest";
  }
  protected:
  explicit AggregateRequest(::google::protobuf::Arena* arena);
  AggregateRequest(::google::protobuf::Arena* arena, const AggregateRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAggregationsFieldNumber = 5,
    kGroupByColumnsFieldNumber = 6,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kInitialGroupsIdFieldNumber = 3,
    kPreserveEmptyFieldNumber = 4,
  };
  // repeated .io.deephaven.proto.backplane.grpc.Aggregation aggregations = 5;
  int aggregations_size() const;
  private:
  int _internal_aggregations_size() const;

  public:
  void clear_aggregations() ;
  ::io::deephaven::proto::backplane::grpc::Aggregation* mutable_aggregations(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation >*
      mutable_aggregations();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Aggregation>& _internal_aggregations() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Aggregation>* _internal_mutable_aggregations();
  public:
  const ::io::deephaven::proto::backplane::grpc::Aggregation& aggregations(int index) const;
  ::io::deephaven::proto::backplane::grpc::Aggregation* add_aggregations();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation >&
      aggregations() const;
  // repeated string group_by_columns = 6;
  int group_by_columns_size() const;
  private:
  int _internal_group_by_columns_size() const;

  public:
  void clear_group_by_columns() ;
  const std::string& group_by_columns(int index) const;
  std::string* mutable_group_by_columns(int index);
  void set_group_by_columns(int index, const std::string& value);
  void set_group_by_columns(int index, std::string&& value);
  void set_group_by_columns(int index, const char* value);
  void set_group_by_columns(int index, const char* value, std::size_t size);
  void set_group_by_columns(int index, absl::string_view value);
  std::string* add_group_by_columns();
  void add_group_by_columns(const std::string& value);
  void add_group_by_columns(std::string&& value);
  void add_group_by_columns(const char* value);
  void add_group_by_columns(const char* value, std::size_t size);
  void add_group_by_columns(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& group_by_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_group_by_columns();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_group_by_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_group_by_columns();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference initial_groups_id = 3;
  bool has_initial_groups_id() const;
  void clear_initial_groups_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& initial_groups_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_initial_groups_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_initial_groups_id();
  void set_allocated_initial_groups_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_initial_groups_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_initial_groups_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_initial_groups_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_initial_groups_id();

  public:
  // bool preserve_empty = 4;
  void clear_preserve_empty() ;
  bool preserve_empty() const;
  void set_preserve_empty(bool value);

  private:
  bool _internal_preserve_empty() const;
  void _internal_set_preserve_empty(bool value);

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.AggregateRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 4,
      75, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::Aggregation > aggregations_;
    ::google::protobuf::RepeatedPtrField<std::string> group_by_columns_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* initial_groups_id_;
    bool preserve_empty_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class UpdateByRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.UpdateByRequest) */ {
 public:
  inline UpdateByRequest() : UpdateByRequest(nullptr) {}
  ~UpdateByRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateByRequest(::google::protobuf::internal::ConstantInitialized);

  inline UpdateByRequest(const UpdateByRequest& from)
      : UpdateByRequest(nullptr, from) {}
  UpdateByRequest(UpdateByRequest&& from) noexcept
    : UpdateByRequest() {
    *this = ::std::move(from);
  }

  inline UpdateByRequest& operator=(const UpdateByRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateByRequest& operator=(UpdateByRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateByRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateByRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateByRequest*>(
               &_UpdateByRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(UpdateByRequest& a, UpdateByRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateByRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateByRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateByRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateByRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UpdateByRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const UpdateByRequest& from) {
    UpdateByRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UpdateByRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.UpdateByRequest";
  }
  protected:
  explicit UpdateByRequest(::google::protobuf::Arena* arena);
  UpdateByRequest(::google::protobuf::Arena* arena, const UpdateByRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using UpdateByOptions = UpdateByRequest_UpdateByOptions;
  using UpdateByOperation = UpdateByRequest_UpdateByOperation;

  // accessors -------------------------------------------------------

  enum : int {
    kOperationsFieldNumber = 4,
    kGroupByColumnsFieldNumber = 5,
    kResultIdFieldNumber = 1,
    kSourceIdFieldNumber = 2,
    kOptionsFieldNumber = 3,
  };
  // repeated .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation operations = 4;
  int operations_size() const;
  private:
  int _internal_operations_size() const;

  public:
  void clear_operations() ;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* mutable_operations(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation >*
      mutable_operations();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation>& _internal_operations() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation>* _internal_mutable_operations();
  public:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation& operations(int index) const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* add_operations();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation >&
      operations() const;
  // repeated string group_by_columns = 5;
  int group_by_columns_size() const;
  private:
  int _internal_group_by_columns_size() const;

  public:
  void clear_group_by_columns() ;
  const std::string& group_by_columns(int index) const;
  std::string* mutable_group_by_columns(int index);
  void set_group_by_columns(int index, const std::string& value);
  void set_group_by_columns(int index, std::string&& value);
  void set_group_by_columns(int index, const char* value);
  void set_group_by_columns(int index, const char* value, std::size_t size);
  void set_group_by_columns(int index, absl::string_view value);
  std::string* add_group_by_columns();
  void add_group_by_columns(const std::string& value);
  void add_group_by_columns(std::string&& value);
  void add_group_by_columns(const char* value);
  void add_group_by_columns(const char* value, std::size_t size);
  void add_group_by_columns(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& group_by_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_group_by_columns();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_group_by_columns() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_group_by_columns();

  public:
  // .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
  bool has_result_id() const;
  void clear_result_id() ;
  const ::io::deephaven::proto::backplane::grpc::Ticket& result_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::Ticket* release_result_id();
  ::io::deephaven::proto::backplane::grpc::Ticket* mutable_result_id();
  void set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  void unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value);
  ::io::deephaven::proto::backplane::grpc::Ticket* unsafe_arena_release_result_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::Ticket& _internal_result_id() const;
  ::io::deephaven::proto::backplane::grpc::Ticket* _internal_mutable_result_id();

  public:
  // .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
  bool has_source_id() const;
  void clear_source_id() ;
  const ::io::deephaven::proto::backplane::grpc::TableReference& source_id() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TableReference* release_source_id();
  ::io::deephaven::proto::backplane::grpc::TableReference* mutable_source_id();
  void set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  void unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value);
  ::io::deephaven::proto::backplane::grpc::TableReference* unsafe_arena_release_source_id();

  private:
  const ::io::deephaven::proto::backplane::grpc::TableReference& _internal_source_id() const;
  ::io::deephaven::proto::backplane::grpc::TableReference* _internal_mutable_source_id();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions options = 3;
  bool has_options() const;
  void clear_options() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions& options() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* release_options();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* mutable_options();
  void set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* value);
  void unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* unsafe_arena_release_options();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions& _internal_options() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* _internal_mutable_options();

  public:
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.UpdateByRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 4,
      74, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation > operations_;
    ::google::protobuf::RepeatedPtrField<std::string> group_by_columns_;
    ::io::deephaven::proto::backplane::grpc::Ticket* result_id_;
    ::io::deephaven::proto::backplane::grpc::TableReference* source_id_;
    ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* options_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class BatchTableRequest_Operation final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation) */ {
 public:
  inline BatchTableRequest_Operation() : BatchTableRequest_Operation(nullptr) {}
  ~BatchTableRequest_Operation() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BatchTableRequest_Operation(::google::protobuf::internal::ConstantInitialized);

  inline BatchTableRequest_Operation(const BatchTableRequest_Operation& from)
      : BatchTableRequest_Operation(nullptr, from) {}
  BatchTableRequest_Operation(BatchTableRequest_Operation&& from) noexcept
    : BatchTableRequest_Operation() {
    *this = ::std::move(from);
  }

  inline BatchTableRequest_Operation& operator=(const BatchTableRequest_Operation& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchTableRequest_Operation& operator=(BatchTableRequest_Operation&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchTableRequest_Operation& default_instance() {
    return *internal_default_instance();
  }
  enum OpCase {
    kEmptyTable = 1,
    kTimeTable = 2,
    kDropColumns = 3,
    kUpdate = 4,
    kLazyUpdate = 5,
    kView = 6,
    kUpdateView = 7,
    kSelect = 8,
    kSelectDistinct = 9,
    kFilter = 10,
    kUnstructuredFilter = 11,
    kSort = 12,
    kHead = 13,
    kTail = 14,
    kHeadBy = 15,
    kTailBy = 16,
    kUngroup = 17,
    kMerge = 18,
    kComboAggregate = 19,
    kFlatten = 21,
    kRunChartDownsample = 22,
    kCrossJoin = 23,
    kNaturalJoin = 24,
    kExactJoin = 25,
    kLeftJoin = 26,
    kAsOfJoin = 27,
    kFetchTable = 28,
    kApplyPreviewColumns = 30,
    kCreateInputTable = 31,
    kUpdateBy = 32,
    kWhereIn = 33,
    kAggregateAll = 34,
    kAggregate = 35,
    kSnapshot = 36,
    kSnapshotWhen = 37,
    kMetaTable = 38,
    kRangeJoin = 39,
    kAj = 40,
    kRaj = 41,
    kColumnStatistics = 42,
    kMultiJoin = 43,
    OP_NOT_SET = 0,
  };

  static inline const BatchTableRequest_Operation* internal_default_instance() {
    return reinterpret_cast<const BatchTableRequest_Operation*>(
               &_BatchTableRequest_Operation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    122;

  friend void swap(BatchTableRequest_Operation& a, BatchTableRequest_Operation& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchTableRequest_Operation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchTableRequest_Operation* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchTableRequest_Operation* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchTableRequest_Operation>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BatchTableRequest_Operation& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BatchTableRequest_Operation& from) {
    BatchTableRequest_Operation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BatchTableRequest_Operation* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation";
  }
  protected:
  explicit BatchTableRequest_Operation(::google::protobuf::Arena* arena);
  BatchTableRequest_Operation(::google::protobuf::Arena* arena, const BatchTableRequest_Operation& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEmptyTableFieldNumber = 1,
    kTimeTableFieldNumber = 2,
    kDropColumnsFieldNumber = 3,
    kUpdateFieldNumber = 4,
    kLazyUpdateFieldNumber = 5,
    kViewFieldNumber = 6,
    kUpdateViewFieldNumber = 7,
    kSelectFieldNumber = 8,
    kSelectDistinctFieldNumber = 9,
    kFilterFieldNumber = 10,
    kUnstructuredFilterFieldNumber = 11,
    kSortFieldNumber = 12,
    kHeadFieldNumber = 13,
    kTailFieldNumber = 14,
    kHeadByFieldNumber = 15,
    kTailByFieldNumber = 16,
    kUngroupFieldNumber = 17,
    kMergeFieldNumber = 18,
    kComboAggregateFieldNumber = 19,
    kFlattenFieldNumber = 21,
    kRunChartDownsampleFieldNumber = 22,
    kCrossJoinFieldNumber = 23,
    kNaturalJoinFieldNumber = 24,
    kExactJoinFieldNumber = 25,
    kLeftJoinFieldNumber = 26,
    kAsOfJoinFieldNumber = 27,
    kFetchTableFieldNumber = 28,
    kApplyPreviewColumnsFieldNumber = 30,
    kCreateInputTableFieldNumber = 31,
    kUpdateByFieldNumber = 32,
    kWhereInFieldNumber = 33,
    kAggregateAllFieldNumber = 34,
    kAggregateFieldNumber = 35,
    kSnapshotFieldNumber = 36,
    kSnapshotWhenFieldNumber = 37,
    kMetaTableFieldNumber = 38,
    kRangeJoinFieldNumber = 39,
    kAjFieldNumber = 40,
    kRajFieldNumber = 41,
    kColumnStatisticsFieldNumber = 42,
    kMultiJoinFieldNumber = 43,
  };
  // .io.deephaven.proto.backplane.grpc.EmptyTableRequest empty_table = 1;
  bool has_empty_table() const;
  private:
  bool _internal_has_empty_table() const;

  public:
  void clear_empty_table() ;
  const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& empty_table() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* release_empty_table();
  ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* mutable_empty_table();
  void set_allocated_empty_table(::io::deephaven::proto::backplane::grpc::EmptyTableRequest* value);
  void unsafe_arena_set_allocated_empty_table(::io::deephaven::proto::backplane::grpc::EmptyTableRequest* value);
  ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* unsafe_arena_release_empty_table();

  private:
  const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& _internal_empty_table() const;
  ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* _internal_mutable_empty_table();

  public:
  // .io.deephaven.proto.backplane.grpc.TimeTableRequest time_table = 2;
  bool has_time_table() const;
  private:
  bool _internal_has_time_table() const;

  public:
  void clear_time_table() ;
  const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& time_table() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::TimeTableRequest* release_time_table();
  ::io::deephaven::proto::backplane::grpc::TimeTableRequest* mutable_time_table();
  void set_allocated_time_table(::io::deephaven::proto::backplane::grpc::TimeTableRequest* value);
  void unsafe_arena_set_allocated_time_table(::io::deephaven::proto::backplane::grpc::TimeTableRequest* value);
  ::io::deephaven::proto::backplane::grpc::TimeTableRequest* unsafe_arena_release_time_table();

  private:
  const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& _internal_time_table() const;
  ::io::deephaven::proto::backplane::grpc::TimeTableRequest* _internal_mutable_time_table();

  public:
  // .io.deephaven.proto.backplane.grpc.DropColumnsRequest drop_columns = 3;
  bool has_drop_columns() const;
  private:
  bool _internal_has_drop_columns() const;

  public:
  void clear_drop_columns() ;
  const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& drop_columns() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* release_drop_columns();
  ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* mutable_drop_columns();
  void set_allocated_drop_columns(::io::deephaven::proto::backplane::grpc::DropColumnsRequest* value);
  void unsafe_arena_set_allocated_drop_columns(::io::deephaven::proto::backplane::grpc::DropColumnsRequest* value);
  ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* unsafe_arena_release_drop_columns();

  private:
  const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& _internal_drop_columns() const;
  ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* _internal_mutable_drop_columns();

  public:
  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest update = 4;
  bool has_update() const;
  private:
  bool _internal_has_update() const;

  public:
  void clear_update() ;
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& update() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_update();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_update();
  void set_allocated_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value);
  void unsafe_arena_set_allocated_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_update();

  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_update() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_update();

  public:
  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest lazy_update = 5;
  bool has_lazy_update() const;
  private:
  bool _internal_has_lazy_update() const;

  public:
  void clear_lazy_update() ;
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& lazy_update() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_lazy_update();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_lazy_update();
  void set_allocated_lazy_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value);
  void unsafe_arena_set_allocated_lazy_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_lazy_update();

  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_lazy_update() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_lazy_update();

  public:
  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest view = 6;
  bool has_view() const;
  private:
  bool _internal_has_view() const;

  public:
  void clear_view() ;
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& view() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_view();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_view();
  void set_allocated_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value);
  void unsafe_arena_set_allocated_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_view();

  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_view() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_view();

  public:
  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest update_view = 7;
  bool has_update_view() const;
  private:
  bool _internal_has_update_view() const;

  public:
  void clear_update_view() ;
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& update_view() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_update_view();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_update_view();
  void set_allocated_update_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value);
  void unsafe_arena_set_allocated_update_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_update_view();

  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_update_view() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_update_view();

  public:
  // .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest select = 8;
  bool has_select() const;
  private:
  bool _internal_has_select() const;

  public:
  void clear_select() ;
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& select() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* release_select();
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* mutable_select();
  void set_allocated_select(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value);
  void unsafe_arena_set_allocated_select(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value);
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* unsafe_arena_release_select();

  private:
  const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& _internal_select() const;
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _internal_mutable_select();

  public:
  // .io.deephaven.proto.backplane.grpc.SelectDistinctRequest select_distinct = 9;
  bool has_select_distinct() const;
  private:
  bool _internal_has_select_distinct() const;

  public:
  void clear_select_distinct() ;
  const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& select_distinct() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* release_select_distinct();
  ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* mutable_select_distinct();
  void set_allocated_select_distinct(::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* value);
  void unsafe_arena_set_allocated_select_distinct(::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* value);
  ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* unsafe_arena_release_select_distinct();

  private:
  const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& _internal_select_distinct() const;
  ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* _internal_mutable_select_distinct();

  public:
  // .io.deephaven.proto.backplane.grpc.FilterTableRequest filter = 10;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;

  public:
  void clear_filter() ;
  const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& filter() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::FilterTableRequest* release_filter();
  ::io::deephaven::proto::backplane::grpc::FilterTableRequest* mutable_filter();
  void set_allocated_filter(::io::deephaven::proto::backplane::grpc::FilterTableRequest* value);
  void unsafe_arena_set_allocated_filter(::io::deephaven::proto::backplane::grpc::FilterTableRequest* value);
  ::io::deephaven::proto::backplane::grpc::FilterTableRequest* unsafe_arena_release_filter();

  private:
  const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& _internal_filter() const;
  ::io::deephaven::proto::backplane::grpc::FilterTableRequest* _internal_mutable_filter();

  public:
  // .io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest unstructured_filter = 11;
  bool has_unstructured_filter() const;
  private:
  bool _internal_has_unstructured_filter() const;

  public:
  void clear_unstructured_filter() ;
  const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& unstructured_filter() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* release_unstructured_filter();
  ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* mutable_unstructured_filter();
  void set_allocated_unstructured_filter(::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* value);
  void unsafe_arena_set_allocated_unstructured_filter(::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* value);
  ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* unsafe_arena_release_unstructured_filter();

  private:
  const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& _internal_unstructured_filter() const;
  ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* _internal_mutable_unstructured_filter();

  public:
  // .io.deephaven.proto.backplane.grpc.SortTableRequest sort = 12;
  bool has_sort() const;
  private:
  bool _internal_has_sort() const;

  public:
  void clear_sort() ;
  const ::io::deephaven::proto::backplane::grpc::SortTableRequest& sort() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SortTableRequest* release_sort();
  ::io::deephaven::proto::backplane::grpc::SortTableRequest* mutable_sort();
  void set_allocated_sort(::io::deephaven::proto::backplane::grpc::SortTableRequest* value);
  void unsafe_arena_set_allocated_sort(::io::deephaven::proto::backplane::grpc::SortTableRequest* value);
  ::io::deephaven::proto::backplane::grpc::SortTableRequest* unsafe_arena_release_sort();

  private:
  const ::io::deephaven::proto::backplane::grpc::SortTableRequest& _internal_sort() const;
  ::io::deephaven::proto::backplane::grpc::SortTableRequest* _internal_mutable_sort();

  public:
  // .io.deephaven.proto.backplane.grpc.HeadOrTailRequest head = 13;
  bool has_head() const;
  private:
  bool _internal_has_head() const;

  public:
  void clear_head() ;
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& head() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* release_head();
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* mutable_head();
  void set_allocated_head(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* value);
  void unsafe_arena_set_allocated_head(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* value);
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* unsafe_arena_release_head();

  private:
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& _internal_head() const;
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* _internal_mutable_head();

  public:
  // .io.deephaven.proto.backplane.grpc.HeadOrTailRequest tail = 14;
  bool has_tail() const;
  private:
  bool _internal_has_tail() const;

  public:
  void clear_tail() ;
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& tail() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* release_tail();
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* mutable_tail();
  void set_allocated_tail(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* value);
  void unsafe_arena_set_allocated_tail(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* value);
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* unsafe_arena_release_tail();

  private:
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& _internal_tail() const;
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* _internal_mutable_tail();

  public:
  // .io.deephaven.proto.backplane.grpc.HeadOrTailByRequest head_by = 15;
  bool has_head_by() const;
  private:
  bool _internal_has_head_by() const;

  public:
  void clear_head_by() ;
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& head_by() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* release_head_by();
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* mutable_head_by();
  void set_allocated_head_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* value);
  void unsafe_arena_set_allocated_head_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* value);
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* unsafe_arena_release_head_by();

  private:
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& _internal_head_by() const;
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* _internal_mutable_head_by();

  public:
  // .io.deephaven.proto.backplane.grpc.HeadOrTailByRequest tail_by = 16;
  bool has_tail_by() const;
  private:
  bool _internal_has_tail_by() const;

  public:
  void clear_tail_by() ;
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& tail_by() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* release_tail_by();
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* mutable_tail_by();
  void set_allocated_tail_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* value);
  void unsafe_arena_set_allocated_tail_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* value);
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* unsafe_arena_release_tail_by();

  private:
  const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& _internal_tail_by() const;
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* _internal_mutable_tail_by();

  public:
  // .io.deephaven.proto.backplane.grpc.UngroupRequest ungroup = 17;
  bool has_ungroup() const;
  private:
  bool _internal_has_ungroup() const;

  public:
  void clear_ungroup() ;
  const ::io::deephaven::proto::backplane::grpc::UngroupRequest& ungroup() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UngroupRequest* release_ungroup();
  ::io::deephaven::proto::backplane::grpc::UngroupRequest* mutable_ungroup();
  void set_allocated_ungroup(::io::deephaven::proto::backplane::grpc::UngroupRequest* value);
  void unsafe_arena_set_allocated_ungroup(::io::deephaven::proto::backplane::grpc::UngroupRequest* value);
  ::io::deephaven::proto::backplane::grpc::UngroupRequest* unsafe_arena_release_ungroup();

  private:
  const ::io::deephaven::proto::backplane::grpc::UngroupRequest& _internal_ungroup() const;
  ::io::deephaven::proto::backplane::grpc::UngroupRequest* _internal_mutable_ungroup();

  public:
  // .io.deephaven.proto.backplane.grpc.MergeTablesRequest merge = 18;
  bool has_merge() const;
  private:
  bool _internal_has_merge() const;

  public:
  void clear_merge() ;
  const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& merge() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* release_merge();
  ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* mutable_merge();
  void set_allocated_merge(::io::deephaven::proto::backplane::grpc::MergeTablesRequest* value);
  void unsafe_arena_set_allocated_merge(::io::deephaven::proto::backplane::grpc::MergeTablesRequest* value);
  ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* unsafe_arena_release_merge();

  private:
  const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& _internal_merge() const;
  ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* _internal_mutable_merge();

  public:
  // .io.deephaven.proto.backplane.grpc.ComboAggregateRequest combo_aggregate = 19;
  bool has_combo_aggregate() const;
  private:
  bool _internal_has_combo_aggregate() const;

  public:
  void clear_combo_aggregate() ;
  const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& combo_aggregate() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* release_combo_aggregate();
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* mutable_combo_aggregate();
  void set_allocated_combo_aggregate(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* value);
  void unsafe_arena_set_allocated_combo_aggregate(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* value);
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* unsafe_arena_release_combo_aggregate();

  private:
  const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& _internal_combo_aggregate() const;
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* _internal_mutable_combo_aggregate();

  public:
  // .io.deephaven.proto.backplane.grpc.FlattenRequest flatten = 21;
  bool has_flatten() const;
  private:
  bool _internal_has_flatten() const;

  public:
  void clear_flatten() ;
  const ::io::deephaven::proto::backplane::grpc::FlattenRequest& flatten() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::FlattenRequest* release_flatten();
  ::io::deephaven::proto::backplane::grpc::FlattenRequest* mutable_flatten();
  void set_allocated_flatten(::io::deephaven::proto::backplane::grpc::FlattenRequest* value);
  void unsafe_arena_set_allocated_flatten(::io::deephaven::proto::backplane::grpc::FlattenRequest* value);
  ::io::deephaven::proto::backplane::grpc::FlattenRequest* unsafe_arena_release_flatten();

  private:
  const ::io::deephaven::proto::backplane::grpc::FlattenRequest& _internal_flatten() const;
  ::io::deephaven::proto::backplane::grpc::FlattenRequest* _internal_mutable_flatten();

  public:
  // .io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest run_chart_downsample = 22;
  bool has_run_chart_downsample() const;
  private:
  bool _internal_has_run_chart_downsample() const;

  public:
  void clear_run_chart_downsample() ;
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& run_chart_downsample() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* release_run_chart_downsample();
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* mutable_run_chart_downsample();
  void set_allocated_run_chart_downsample(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* value);
  void unsafe_arena_set_allocated_run_chart_downsample(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* value);
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* unsafe_arena_release_run_chart_downsample();

  private:
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& _internal_run_chart_downsample() const;
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* _internal_mutable_run_chart_downsample();

  public:
  // .io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest cross_join = 23;
  bool has_cross_join() const;
  private:
  bool _internal_has_cross_join() const;

  public:
  void clear_cross_join() ;
  const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& cross_join() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* release_cross_join();
  ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* mutable_cross_join();
  void set_allocated_cross_join(::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* value);
  void unsafe_arena_set_allocated_cross_join(::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* value);
  ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* unsafe_arena_release_cross_join();

  private:
  const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& _internal_cross_join() const;
  ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* _internal_mutable_cross_join();

  public:
  // .io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest natural_join = 24;
  bool has_natural_join() const;
  private:
  bool _internal_has_natural_join() const;

  public:
  void clear_natural_join() ;
  const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& natural_join() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* release_natural_join();
  ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* mutable_natural_join();
  void set_allocated_natural_join(::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* value);
  void unsafe_arena_set_allocated_natural_join(::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* value);
  ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* unsafe_arena_release_natural_join();

  private:
  const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& _internal_natural_join() const;
  ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* _internal_mutable_natural_join();

  public:
  // .io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest exact_join = 25;
  bool has_exact_join() const;
  private:
  bool _internal_has_exact_join() const;

  public:
  void clear_exact_join() ;
  const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& exact_join() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* release_exact_join();
  ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* mutable_exact_join();
  void set_allocated_exact_join(::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* value);
  void unsafe_arena_set_allocated_exact_join(::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* value);
  ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* unsafe_arena_release_exact_join();

  private:
  const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& _internal_exact_join() const;
  ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* _internal_mutable_exact_join();

  public:
  // .io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest left_join = 26;
  bool has_left_join() const;
  private:
  bool _internal_has_left_join() const;

  public:
  void clear_left_join() ;
  const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& left_join() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* release_left_join();
  ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* mutable_left_join();
  void set_allocated_left_join(::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* value);
  void unsafe_arena_set_allocated_left_join(::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* value);
  ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* unsafe_arena_release_left_join();

  private:
  const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& _internal_left_join() const;
  ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* _internal_mutable_left_join();

  public:
  // .io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest as_of_join = 27 [deprecated = true];
  [[deprecated]]  bool has_as_of_join() const;
  private:
  bool _internal_has_as_of_join() const;

  public:
  [[deprecated]]  void clear_as_of_join() ;
  [[deprecated]] const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& as_of_join() const;
  [[deprecated]] PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* release_as_of_join();
  [[deprecated]] ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* mutable_as_of_join();
  [[deprecated]] void set_allocated_as_of_join(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* value);
  [[deprecated]] void unsafe_arena_set_allocated_as_of_join(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* value);
  [[deprecated]] ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* unsafe_arena_release_as_of_join();

  private:
  const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& _internal_as_of_join() const;
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* _internal_mutable_as_of_join();

  public:
  // .io.deephaven.proto.backplane.grpc.FetchTableRequest fetch_table = 28;
  bool has_fetch_table() const;
  private:
  bool _internal_has_fetch_table() const;

  public:
  void clear_fetch_table() ;
  const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& fetch_table() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::FetchTableRequest* release_fetch_table();
  ::io::deephaven::proto::backplane::grpc::FetchTableRequest* mutable_fetch_table();
  void set_allocated_fetch_table(::io::deephaven::proto::backplane::grpc::FetchTableRequest* value);
  void unsafe_arena_set_allocated_fetch_table(::io::deephaven::proto::backplane::grpc::FetchTableRequest* value);
  ::io::deephaven::proto::backplane::grpc::FetchTableRequest* unsafe_arena_release_fetch_table();

  private:
  const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& _internal_fetch_table() const;
  ::io::deephaven::proto::backplane::grpc::FetchTableRequest* _internal_mutable_fetch_table();

  public:
  // .io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest apply_preview_columns = 30;
  bool has_apply_preview_columns() const;
  private:
  bool _internal_has_apply_preview_columns() const;

  public:
  void clear_apply_preview_columns() ;
  const ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest& apply_preview_columns() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* release_apply_preview_columns();
  ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* mutable_apply_preview_columns();
  void set_allocated_apply_preview_columns(::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* value);
  void unsafe_arena_set_allocated_apply_preview_columns(::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* value);
  ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* unsafe_arena_release_apply_preview_columns();

  private:
  const ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest& _internal_apply_preview_columns() const;
  ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* _internal_mutable_apply_preview_columns();

  public:
  // .io.deephaven.proto.backplane.grpc.CreateInputTableRequest create_input_table = 31;
  bool has_create_input_table() const;
  private:
  bool _internal_has_create_input_table() const;

  public:
  void clear_create_input_table() ;
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest& create_input_table() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* release_create_input_table();
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* mutable_create_input_table();
  void set_allocated_create_input_table(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* value);
  void unsafe_arena_set_allocated_create_input_table(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* value);
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* unsafe_arena_release_create_input_table();

  private:
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest& _internal_create_input_table() const;
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* _internal_mutable_create_input_table();

  public:
  // .io.deephaven.proto.backplane.grpc.UpdateByRequest update_by = 32;
  bool has_update_by() const;
  private:
  bool _internal_has_update_by() const;

  public:
  void clear_update_by() ;
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest& update_by() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::UpdateByRequest* release_update_by();
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest* mutable_update_by();
  void set_allocated_update_by(::io::deephaven::proto::backplane::grpc::UpdateByRequest* value);
  void unsafe_arena_set_allocated_update_by(::io::deephaven::proto::backplane::grpc::UpdateByRequest* value);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest* unsafe_arena_release_update_by();

  private:
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest& _internal_update_by() const;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest* _internal_mutable_update_by();

  public:
  // .io.deephaven.proto.backplane.grpc.WhereInRequest where_in = 33;
  bool has_where_in() const;
  private:
  bool _internal_has_where_in() const;

  public:
  void clear_where_in() ;
  const ::io::deephaven::proto::backplane::grpc::WhereInRequest& where_in() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::WhereInRequest* release_where_in();
  ::io::deephaven::proto::backplane::grpc::WhereInRequest* mutable_where_in();
  void set_allocated_where_in(::io::deephaven::proto::backplane::grpc::WhereInRequest* value);
  void unsafe_arena_set_allocated_where_in(::io::deephaven::proto::backplane::grpc::WhereInRequest* value);
  ::io::deephaven::proto::backplane::grpc::WhereInRequest* unsafe_arena_release_where_in();

  private:
  const ::io::deephaven::proto::backplane::grpc::WhereInRequest& _internal_where_in() const;
  ::io::deephaven::proto::backplane::grpc::WhereInRequest* _internal_mutable_where_in();

  public:
  // .io.deephaven.proto.backplane.grpc.AggregateAllRequest aggregate_all = 34;
  bool has_aggregate_all() const;
  private:
  bool _internal_has_aggregate_all() const;

  public:
  void clear_aggregate_all() ;
  const ::io::deephaven::proto::backplane::grpc::AggregateAllRequest& aggregate_all() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* release_aggregate_all();
  ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* mutable_aggregate_all();
  void set_allocated_aggregate_all(::io::deephaven::proto::backplane::grpc::AggregateAllRequest* value);
  void unsafe_arena_set_allocated_aggregate_all(::io::deephaven::proto::backplane::grpc::AggregateAllRequest* value);
  ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* unsafe_arena_release_aggregate_all();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggregateAllRequest& _internal_aggregate_all() const;
  ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* _internal_mutable_aggregate_all();

  public:
  // .io.deephaven.proto.backplane.grpc.AggregateRequest aggregate = 35;
  bool has_aggregate() const;
  private:
  bool _internal_has_aggregate() const;

  public:
  void clear_aggregate() ;
  const ::io::deephaven::proto::backplane::grpc::AggregateRequest& aggregate() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AggregateRequest* release_aggregate();
  ::io::deephaven::proto::backplane::grpc::AggregateRequest* mutable_aggregate();
  void set_allocated_aggregate(::io::deephaven::proto::backplane::grpc::AggregateRequest* value);
  void unsafe_arena_set_allocated_aggregate(::io::deephaven::proto::backplane::grpc::AggregateRequest* value);
  ::io::deephaven::proto::backplane::grpc::AggregateRequest* unsafe_arena_release_aggregate();

  private:
  const ::io::deephaven::proto::backplane::grpc::AggregateRequest& _internal_aggregate() const;
  ::io::deephaven::proto::backplane::grpc::AggregateRequest* _internal_mutable_aggregate();

  public:
  // .io.deephaven.proto.backplane.grpc.SnapshotTableRequest snapshot = 36;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;

  public:
  void clear_snapshot() ;
  const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& snapshot() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* release_snapshot();
  ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* mutable_snapshot();
  void set_allocated_snapshot(::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* value);
  void unsafe_arena_set_allocated_snapshot(::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* value);
  ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* unsafe_arena_release_snapshot();

  private:
  const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& _internal_snapshot() const;
  ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* _internal_mutable_snapshot();

  public:
  // .io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest snapshot_when = 37;
  bool has_snapshot_when() const;
  private:
  bool _internal_has_snapshot_when() const;

  public:
  void clear_snapshot_when() ;
  const ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest& snapshot_when() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* release_snapshot_when();
  ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* mutable_snapshot_when();
  void set_allocated_snapshot_when(::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* value);
  void unsafe_arena_set_allocated_snapshot_when(::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* value);
  ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* unsafe_arena_release_snapshot_when();

  private:
  const ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest& _internal_snapshot_when() const;
  ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* _internal_mutable_snapshot_when();

  public:
  // .io.deephaven.proto.backplane.grpc.MetaTableRequest meta_table = 38;
  bool has_meta_table() const;
  private:
  bool _internal_has_meta_table() const;

  public:
  void clear_meta_table() ;
  const ::io::deephaven::proto::backplane::grpc::MetaTableRequest& meta_table() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::MetaTableRequest* release_meta_table();
  ::io::deephaven::proto::backplane::grpc::MetaTableRequest* mutable_meta_table();
  void set_allocated_meta_table(::io::deephaven::proto::backplane::grpc::MetaTableRequest* value);
  void unsafe_arena_set_allocated_meta_table(::io::deephaven::proto::backplane::grpc::MetaTableRequest* value);
  ::io::deephaven::proto::backplane::grpc::MetaTableRequest* unsafe_arena_release_meta_table();

  private:
  const ::io::deephaven::proto::backplane::grpc::MetaTableRequest& _internal_meta_table() const;
  ::io::deephaven::proto::backplane::grpc::MetaTableRequest* _internal_mutable_meta_table();

  public:
  // .io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest range_join = 39;
  bool has_range_join() const;
  private:
  bool _internal_has_range_join() const;

  public:
  void clear_range_join() ;
  const ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest& range_join() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* release_range_join();
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* mutable_range_join();
  void set_allocated_range_join(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* value);
  void unsafe_arena_set_allocated_range_join(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* value);
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* unsafe_arena_release_range_join();

  private:
  const ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest& _internal_range_join() const;
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* _internal_mutable_range_join();

  public:
  // .io.deephaven.proto.backplane.grpc.AjRajTablesRequest aj = 40;
  bool has_aj() const;
  private:
  bool _internal_has_aj() const;

  public:
  void clear_aj() ;
  const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& aj() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* release_aj();
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* mutable_aj();
  void set_allocated_aj(::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* value);
  void unsafe_arena_set_allocated_aj(::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* value);
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* unsafe_arena_release_aj();

  private:
  const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& _internal_aj() const;
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* _internal_mutable_aj();

  public:
  // .io.deephaven.proto.backplane.grpc.AjRajTablesRequest raj = 41;
  bool has_raj() const;
  private:
  bool _internal_has_raj() const;

  public:
  void clear_raj() ;
  const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& raj() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* release_raj();
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* mutable_raj();
  void set_allocated_raj(::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* value);
  void unsafe_arena_set_allocated_raj(::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* value);
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* unsafe_arena_release_raj();

  private:
  const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& _internal_raj() const;
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* _internal_mutable_raj();

  public:
  // .io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest column_statistics = 42;
  bool has_column_statistics() const;
  private:
  bool _internal_has_column_statistics() const;

  public:
  void clear_column_statistics() ;
  const ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest& column_statistics() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* release_column_statistics();
  ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* mutable_column_statistics();
  void set_allocated_column_statistics(::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* value);
  void unsafe_arena_set_allocated_column_statistics(::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* value);
  ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* unsafe_arena_release_column_statistics();

  private:
  const ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest& _internal_column_statistics() const;
  ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* _internal_mutable_column_statistics();

  public:
  // .io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest multi_join = 43;
  bool has_multi_join() const;
  private:
  bool _internal_has_multi_join() const;

  public:
  void clear_multi_join() ;
  const ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest& multi_join() const;
  PROTOBUF_NODISCARD ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* release_multi_join();
  ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* mutable_multi_join();
  void set_allocated_multi_join(::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* value);
  void unsafe_arena_set_allocated_multi_join(::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* value);
  ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* unsafe_arena_release_multi_join();

  private:
  const ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest& _internal_multi_join() const;
  ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* _internal_mutable_multi_join();

  public:
  void clear_op();
  OpCase op_case() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation)
 private:
  class _Internal;
  void set_has_empty_table();
  void set_has_time_table();
  void set_has_drop_columns();
  void set_has_update();
  void set_has_lazy_update();
  void set_has_view();
  void set_has_update_view();
  void set_has_select();
  void set_has_select_distinct();
  void set_has_filter();
  void set_has_unstructured_filter();
  void set_has_sort();
  void set_has_head();
  void set_has_tail();
  void set_has_head_by();
  void set_has_tail_by();
  void set_has_ungroup();
  void set_has_merge();
  void set_has_combo_aggregate();
  void set_has_flatten();
  void set_has_run_chart_downsample();
  void set_has_cross_join();
  void set_has_natural_join();
  void set_has_exact_join();
  void set_has_left_join();
  void set_has_as_of_join();
  void set_has_fetch_table();
  void set_has_apply_preview_columns();
  void set_has_create_input_table();
  void set_has_update_by();
  void set_has_where_in();
  void set_has_aggregate_all();
  void set_has_aggregate();
  void set_has_snapshot();
  void set_has_snapshot_when();
  void set_has_meta_table();
  void set_has_range_join();
  void set_has_aj();
  void set_has_raj();
  void set_has_column_statistics();
  void set_has_multi_join();

  inline bool has_op() const;
  inline void clear_has_op();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 41, 41,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union OpUnion {
      constexpr OpUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* empty_table_;
      ::io::deephaven::proto::backplane::grpc::TimeTableRequest* time_table_;
      ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* drop_columns_;
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update_;
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* lazy_update_;
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* view_;
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* update_view_;
      ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* select_;
      ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* select_distinct_;
      ::io::deephaven::proto::backplane::grpc::FilterTableRequest* filter_;
      ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* unstructured_filter_;
      ::io::deephaven::proto::backplane::grpc::SortTableRequest* sort_;
      ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* head_;
      ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* tail_;
      ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* head_by_;
      ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* tail_by_;
      ::io::deephaven::proto::backplane::grpc::UngroupRequest* ungroup_;
      ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* merge_;
      ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* combo_aggregate_;
      ::io::deephaven::proto::backplane::grpc::FlattenRequest* flatten_;
      ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* run_chart_downsample_;
      ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* cross_join_;
      ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* natural_join_;
      ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* exact_join_;
      ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* left_join_;
      ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* as_of_join_;
      ::io::deephaven::proto::backplane::grpc::FetchTableRequest* fetch_table_;
      ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* apply_preview_columns_;
      ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* create_input_table_;
      ::io::deephaven::proto::backplane::grpc::UpdateByRequest* update_by_;
      ::io::deephaven::proto::backplane::grpc::WhereInRequest* where_in_;
      ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* aggregate_all_;
      ::io::deephaven::proto::backplane::grpc::AggregateRequest* aggregate_;
      ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* snapshot_;
      ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* snapshot_when_;
      ::io::deephaven::proto::backplane::grpc::MetaTableRequest* meta_table_;
      ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* range_join_;
      ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* aj_;
      ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* raj_;
      ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* column_statistics_;
      ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* multi_join_;
    } op_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};// -------------------------------------------------------------------

class BatchTableRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:io.deephaven.proto.backplane.grpc.BatchTableRequest) */ {
 public:
  inline BatchTableRequest() : BatchTableRequest(nullptr) {}
  ~BatchTableRequest() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR BatchTableRequest(::google::protobuf::internal::ConstantInitialized);

  inline BatchTableRequest(const BatchTableRequest& from)
      : BatchTableRequest(nullptr, from) {}
  BatchTableRequest(BatchTableRequest&& from) noexcept
    : BatchTableRequest() {
    *this = ::std::move(from);
  }

  inline BatchTableRequest& operator=(const BatchTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BatchTableRequest& operator=(BatchTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BatchTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BatchTableRequest* internal_default_instance() {
    return reinterpret_cast<const BatchTableRequest*>(
               &_BatchTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    123;

  friend void swap(BatchTableRequest& a, BatchTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BatchTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BatchTableRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BatchTableRequest* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BatchTableRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BatchTableRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const BatchTableRequest& from) {
    BatchTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(BatchTableRequest* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "io.deephaven.proto.backplane.grpc.BatchTableRequest";
  }
  protected:
  explicit BatchTableRequest(::google::protobuf::Arena* arena);
  BatchTableRequest(::google::protobuf::Arena* arena, const BatchTableRequest& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Operation = BatchTableRequest_Operation;

  // accessors -------------------------------------------------------

  enum : int {
    kOpsFieldNumber = 1,
  };
  // repeated .io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation ops = 1;
  int ops_size() const;
  private:
  int _internal_ops_size() const;

  public:
  void clear_ops() ;
  ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* mutable_ops(int index);
  ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation >*
      mutable_ops();
  private:
  const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation>& _internal_ops() const;
  ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation>* _internal_mutable_ops();
  public:
  const ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation& ops(int index) const;
  ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* add_ops();
  const ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation >&
      ops() const;
  // @@protoc_insertion_point(class_scope:io.deephaven.proto.backplane.grpc.BatchTableRequest)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation > ops_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_deephaven_2fproto_2ftable_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TableReference

// .io.deephaven.proto.backplane.grpc.Ticket ticket = 1;
inline bool TableReference::has_ticket() const {
  return ref_case() == kTicket;
}
inline bool TableReference::_internal_has_ticket() const {
  return ref_case() == kTicket;
}
inline void TableReference::set_has_ticket() {
  _impl_._oneof_case_[0] = kTicket;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TableReference::release_ticket() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.TableReference.ticket)
  if (ref_case() == kTicket) {
    clear_has_ref();
    auto* temp = _impl_.ref_.ticket_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ref_.ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& TableReference::_internal_ticket() const {
  return ref_case() == kTicket ? *_impl_.ref_.ticket_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& TableReference::ticket() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TableReference.ticket)
  return _internal_ticket();
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TableReference::unsafe_arena_release_ticket() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.TableReference.ticket)
  if (ref_case() == kTicket) {
    clear_has_ref();
    auto* temp = _impl_.ref_.ticket_;
    _impl_.ref_.ticket_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TableReference::unsafe_arena_set_allocated_ticket(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_ref();
  if (value) {
    set_has_ticket();
    _impl_.ref_.ticket_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.TableReference.ticket)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TableReference::_internal_mutable_ticket() {
  if (ref_case() != kTicket) {
    clear_ref();
    set_has_ticket();
    _impl_.ref_.ticket_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
  }
  return _impl_.ref_.ticket_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TableReference::mutable_ticket() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_ticket();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.TableReference.ticket)
  return _msg;
}

// sint32 batch_offset = 2;
inline bool TableReference::has_batch_offset() const {
  return ref_case() == kBatchOffset;
}
inline void TableReference::set_has_batch_offset() {
  _impl_._oneof_case_[0] = kBatchOffset;
}
inline void TableReference::clear_batch_offset() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (ref_case() == kBatchOffset) {
    _impl_.ref_.batch_offset_ = 0;
    clear_has_ref();
  }
}
inline ::int32_t TableReference::batch_offset() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TableReference.batch_offset)
  return _internal_batch_offset();
}
inline void TableReference::set_batch_offset(::int32_t value) {
  _internal_set_batch_offset(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.TableReference.batch_offset)
}
inline ::int32_t TableReference::_internal_batch_offset() const {
  if (ref_case() == kBatchOffset) {
    return _impl_.ref_.batch_offset_;
  }
  return 0;
}
inline void TableReference::_internal_set_batch_offset(::int32_t value) {
  if (ref_case() != kBatchOffset) {
    clear_ref();
    set_has_batch_offset();
  }
  _impl_.ref_.batch_offset_ = value;
}

inline bool TableReference::has_ref() const {
  return ref_case() != REF_NOT_SET;
}
inline void TableReference::clear_has_ref() {
  _impl_._oneof_case_[0] = REF_NOT_SET;
}
inline TableReference::RefCase TableReference::ref_case() const {
  return TableReference::RefCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExportedTableCreationResponse

// .io.deephaven.proto.backplane.grpc.TableReference result_id = 1;
inline bool ExportedTableCreationResponse::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline void ExportedTableCreationResponse::clear_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.result_id_ != nullptr) _impl_.result_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExportedTableCreationResponse::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExportedTableCreationResponse::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
  return _internal_result_id();
}
inline void ExportedTableCreationResponse::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExportedTableCreationResponse::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExportedTableCreationResponse::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExportedTableCreationResponse::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExportedTableCreationResponse::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
  return _msg;
}
inline void ExportedTableCreationResponse::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.result_id)
}

// bool success = 2;
inline void ExportedTableCreationResponse::clear_success() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.success_ = false;
}
inline bool ExportedTableCreationResponse::success() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.success)
  return _internal_success();
}
inline void ExportedTableCreationResponse::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.success)
}
inline bool ExportedTableCreationResponse::_internal_success() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.success_;
}
inline void ExportedTableCreationResponse::_internal_set_success(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.success_ = value;
}

// string error_info = 3;
inline void ExportedTableCreationResponse::clear_error_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_info_.ClearToEmpty();
}
inline const std::string& ExportedTableCreationResponse::error_info() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
  return _internal_error_info();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExportedTableCreationResponse::set_error_info(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_info_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
}
inline std::string* ExportedTableCreationResponse::mutable_error_info() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_error_info();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
  return _s;
}
inline const std::string& ExportedTableCreationResponse::_internal_error_info() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.error_info_.Get();
}
inline void ExportedTableCreationResponse::_internal_set_error_info(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.error_info_.Set(value, GetArena());
}
inline std::string* ExportedTableCreationResponse::_internal_mutable_error_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.error_info_.Mutable( GetArena());
}
inline std::string* ExportedTableCreationResponse::release_error_info() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
  return _impl_.error_info_.Release();
}
inline void ExportedTableCreationResponse::set_allocated_error_info(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.error_info_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.error_info_.IsDefault()) {
          _impl_.error_info_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.error_info)
}

// bytes schema_header = 4;
inline void ExportedTableCreationResponse::clear_schema_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.schema_header_.ClearToEmpty();
}
inline const std::string& ExportedTableCreationResponse::schema_header() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
  return _internal_schema_header();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExportedTableCreationResponse::set_schema_header(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.schema_header_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
}
inline std::string* ExportedTableCreationResponse::mutable_schema_header() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schema_header();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
  return _s;
}
inline const std::string& ExportedTableCreationResponse::_internal_schema_header() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.schema_header_.Get();
}
inline void ExportedTableCreationResponse::_internal_set_schema_header(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.schema_header_.Set(value, GetArena());
}
inline std::string* ExportedTableCreationResponse::_internal_mutable_schema_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.schema_header_.Mutable( GetArena());
}
inline std::string* ExportedTableCreationResponse::release_schema_header() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
  return _impl_.schema_header_.Release();
}
inline void ExportedTableCreationResponse::set_allocated_schema_header(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.schema_header_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schema_header_.IsDefault()) {
          _impl_.schema_header_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.schema_header)
}

// bool is_static = 5;
inline void ExportedTableCreationResponse::clear_is_static() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_static_ = false;
}
inline bool ExportedTableCreationResponse::is_static() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.is_static)
  return _internal_is_static();
}
inline void ExportedTableCreationResponse::set_is_static(bool value) {
  _internal_set_is_static(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.is_static)
}
inline bool ExportedTableCreationResponse::_internal_is_static() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_static_;
}
inline void ExportedTableCreationResponse::_internal_set_is_static(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_static_ = value;
}

// sint64 size = 6 [jstype = JS_STRING];
inline void ExportedTableCreationResponse::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = ::int64_t{0};
}
inline ::int64_t ExportedTableCreationResponse::size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.size)
  return _internal_size();
}
inline void ExportedTableCreationResponse::set_size(::int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableCreationResponse.size)
}
inline ::int64_t ExportedTableCreationResponse::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void ExportedTableCreationResponse::_internal_set_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// FetchTableRequest

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
inline bool FetchTableRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void FetchTableRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FetchTableRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FetchTableRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
  return _internal_source_id();
}
inline void FetchTableRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FetchTableRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
  return _msg;
}
inline void FetchTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
inline bool FetchTableRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FetchTableRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FetchTableRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
  return _internal_result_id();
}
inline void FetchTableRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FetchTableRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
  return _msg;
}
inline void FetchTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FetchTableRequest.result_id)
}

// -------------------------------------------------------------------

// ApplyPreviewColumnsRequest

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
inline bool ApplyPreviewColumnsRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void ApplyPreviewColumnsRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ApplyPreviewColumnsRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ApplyPreviewColumnsRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.source_id)
  return _internal_source_id();
}
inline void ApplyPreviewColumnsRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ApplyPreviewColumnsRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ApplyPreviewColumnsRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ApplyPreviewColumnsRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ApplyPreviewColumnsRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.source_id)
  return _msg;
}
inline void ApplyPreviewColumnsRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 2;
inline bool ApplyPreviewColumnsRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ApplyPreviewColumnsRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ApplyPreviewColumnsRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.result_id)
  return _internal_result_id();
}
inline void ApplyPreviewColumnsRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ApplyPreviewColumnsRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ApplyPreviewColumnsRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ApplyPreviewColumnsRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ApplyPreviewColumnsRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.result_id)
  return _msg;
}
inline void ApplyPreviewColumnsRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest.result_id)
}

// -------------------------------------------------------------------

// ExportedTableUpdatesRequest

// -------------------------------------------------------------------

// ExportedTableUpdateMessage

// .io.deephaven.proto.backplane.grpc.Ticket export_id = 1;
inline bool ExportedTableUpdateMessage::has_export_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.export_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExportedTableUpdateMessage::_internal_export_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.export_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExportedTableUpdateMessage::export_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
  return _internal_export_id();
}
inline void ExportedTableUpdateMessage::unsafe_arena_set_allocated_export_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.export_id_);
  }
  _impl_.export_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExportedTableUpdateMessage::release_export_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.export_id_;
  _impl_.export_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExportedTableUpdateMessage::unsafe_arena_release_export_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.export_id_;
  _impl_.export_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExportedTableUpdateMessage::_internal_mutable_export_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.export_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.export_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.export_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExportedTableUpdateMessage::mutable_export_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_export_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
  return _msg;
}
inline void ExportedTableUpdateMessage::set_allocated_export_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.export_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.export_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.export_id)
}

// sint64 size = 2 [jstype = JS_STRING];
inline void ExportedTableUpdateMessage::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = ::int64_t{0};
}
inline ::int64_t ExportedTableUpdateMessage::size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.size)
  return _internal_size();
}
inline void ExportedTableUpdateMessage::set_size(::int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.size)
}
inline ::int64_t ExportedTableUpdateMessage::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void ExportedTableUpdateMessage::_internal_set_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_ = value;
}

// string update_failure_message = 3;
inline void ExportedTableUpdateMessage::clear_update_failure_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.update_failure_message_.ClearToEmpty();
}
inline const std::string& ExportedTableUpdateMessage::update_failure_message() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
  return _internal_update_failure_message();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ExportedTableUpdateMessage::set_update_failure_message(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.update_failure_message_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
}
inline std::string* ExportedTableUpdateMessage::mutable_update_failure_message() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_update_failure_message();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
  return _s;
}
inline const std::string& ExportedTableUpdateMessage::_internal_update_failure_message() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.update_failure_message_.Get();
}
inline void ExportedTableUpdateMessage::_internal_set_update_failure_message(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.update_failure_message_.Set(value, GetArena());
}
inline std::string* ExportedTableUpdateMessage::_internal_mutable_update_failure_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.update_failure_message_.Mutable( GetArena());
}
inline std::string* ExportedTableUpdateMessage::release_update_failure_message() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
  return _impl_.update_failure_message_.Release();
}
inline void ExportedTableUpdateMessage::set_allocated_update_failure_message(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.update_failure_message_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.update_failure_message_.IsDefault()) {
          _impl_.update_failure_message_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExportedTableUpdateMessage.update_failure_message)
}

// -------------------------------------------------------------------

// EmptyTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool EmptyTableRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& EmptyTableRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& EmptyTableRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
  return _internal_result_id();
}
inline void EmptyTableRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* EmptyTableRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* EmptyTableRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* EmptyTableRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* EmptyTableRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
  return _msg;
}
inline void EmptyTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.EmptyTableRequest.result_id)
}

// sint64 size = 2 [jstype = JS_STRING];
inline void EmptyTableRequest::clear_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.size_ = ::int64_t{0};
}
inline ::int64_t EmptyTableRequest::size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.EmptyTableRequest.size)
  return _internal_size();
}
inline void EmptyTableRequest::set_size(::int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.EmptyTableRequest.size)
}
inline ::int64_t EmptyTableRequest::_internal_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.size_;
}
inline void EmptyTableRequest::_internal_set_size(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.size_ = value;
}

// -------------------------------------------------------------------

// TimeTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool TimeTableRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& TimeTableRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& TimeTableRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
  return _internal_result_id();
}
inline void TimeTableRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TimeTableRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TimeTableRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TimeTableRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* TimeTableRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
  return _msg;
}
inline void TimeTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.TimeTableRequest.result_id)
}

// sint64 start_time_nanos = 2 [jstype = JS_STRING];
inline bool TimeTableRequest::has_start_time_nanos() const {
  return start_time_case() == kStartTimeNanos;
}
inline void TimeTableRequest::set_has_start_time_nanos() {
  _impl_._oneof_case_[0] = kStartTimeNanos;
}
inline void TimeTableRequest::clear_start_time_nanos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (start_time_case() == kStartTimeNanos) {
    _impl_.start_time_.start_time_nanos_ = ::int64_t{0};
    clear_has_start_time();
  }
}
inline ::int64_t TimeTableRequest::start_time_nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TimeTableRequest.start_time_nanos)
  return _internal_start_time_nanos();
}
inline void TimeTableRequest::set_start_time_nanos(::int64_t value) {
  _internal_set_start_time_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.TimeTableRequest.start_time_nanos)
}
inline ::int64_t TimeTableRequest::_internal_start_time_nanos() const {
  if (start_time_case() == kStartTimeNanos) {
    return _impl_.start_time_.start_time_nanos_;
  }
  return ::int64_t{0};
}
inline void TimeTableRequest::_internal_set_start_time_nanos(::int64_t value) {
  if (start_time_case() != kStartTimeNanos) {
    clear_start_time();
    set_has_start_time_nanos();
  }
  _impl_.start_time_.start_time_nanos_ = value;
}

// string start_time_string = 5;
inline bool TimeTableRequest::has_start_time_string() const {
  return start_time_case() == kStartTimeString;
}
inline void TimeTableRequest::set_has_start_time_string() {
  _impl_._oneof_case_[0] = kStartTimeString;
}
inline void TimeTableRequest::clear_start_time_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (start_time_case() == kStartTimeString) {
    _impl_.start_time_.start_time_string_.Destroy();
    clear_has_start_time();
  }
}
inline const std::string& TimeTableRequest::start_time_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TimeTableRequest.start_time_string)
  return _internal_start_time_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TimeTableRequest::set_start_time_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (start_time_case() != kStartTimeString) {
    clear_start_time();

    set_has_start_time_string();
    _impl_.start_time_.start_time_string_.InitDefault();
  }
  _impl_.start_time_.start_time_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.TimeTableRequest.start_time_string)
}
inline std::string* TimeTableRequest::mutable_start_time_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_start_time_string();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.TimeTableRequest.start_time_string)
  return _s;
}
inline const std::string& TimeTableRequest::_internal_start_time_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (start_time_case() != kStartTimeString) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.start_time_.start_time_string_.Get();
}
inline void TimeTableRequest::_internal_set_start_time_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (start_time_case() != kStartTimeString) {
    clear_start_time();

    set_has_start_time_string();
    _impl_.start_time_.start_time_string_.InitDefault();
  }
  _impl_.start_time_.start_time_string_.Set(value, GetArena());
}
inline std::string* TimeTableRequest::_internal_mutable_start_time_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (start_time_case() != kStartTimeString) {
    clear_start_time();

    set_has_start_time_string();
    _impl_.start_time_.start_time_string_.InitDefault();
  }
  return _impl_.start_time_.start_time_string_.Mutable( GetArena());
}
inline std::string* TimeTableRequest::release_start_time_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.TimeTableRequest.start_time_string)
  if (start_time_case() != kStartTimeString) {
    return nullptr;
  }
  clear_has_start_time();
  return _impl_.start_time_.start_time_string_.Release();
}
inline void TimeTableRequest::set_allocated_start_time_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_start_time()) {
    clear_start_time();
  }
  if (value != nullptr) {
    set_has_start_time_string();
    _impl_.start_time_.start_time_string_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.TimeTableRequest.start_time_string)
}

// sint64 period_nanos = 3 [jstype = JS_STRING];
inline bool TimeTableRequest::has_period_nanos() const {
  return period_case() == kPeriodNanos;
}
inline void TimeTableRequest::set_has_period_nanos() {
  _impl_._oneof_case_[1] = kPeriodNanos;
}
inline void TimeTableRequest::clear_period_nanos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (period_case() == kPeriodNanos) {
    _impl_.period_.period_nanos_ = ::int64_t{0};
    clear_has_period();
  }
}
inline ::int64_t TimeTableRequest::period_nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TimeTableRequest.period_nanos)
  return _internal_period_nanos();
}
inline void TimeTableRequest::set_period_nanos(::int64_t value) {
  _internal_set_period_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.TimeTableRequest.period_nanos)
}
inline ::int64_t TimeTableRequest::_internal_period_nanos() const {
  if (period_case() == kPeriodNanos) {
    return _impl_.period_.period_nanos_;
  }
  return ::int64_t{0};
}
inline void TimeTableRequest::_internal_set_period_nanos(::int64_t value) {
  if (period_case() != kPeriodNanos) {
    clear_period();
    set_has_period_nanos();
  }
  _impl_.period_.period_nanos_ = value;
}

// string period_string = 6;
inline bool TimeTableRequest::has_period_string() const {
  return period_case() == kPeriodString;
}
inline void TimeTableRequest::set_has_period_string() {
  _impl_._oneof_case_[1] = kPeriodString;
}
inline void TimeTableRequest::clear_period_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (period_case() == kPeriodString) {
    _impl_.period_.period_string_.Destroy();
    clear_has_period();
  }
}
inline const std::string& TimeTableRequest::period_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TimeTableRequest.period_string)
  return _internal_period_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TimeTableRequest::set_period_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (period_case() != kPeriodString) {
    clear_period();

    set_has_period_string();
    _impl_.period_.period_string_.InitDefault();
  }
  _impl_.period_.period_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.TimeTableRequest.period_string)
}
inline std::string* TimeTableRequest::mutable_period_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_period_string();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.TimeTableRequest.period_string)
  return _s;
}
inline const std::string& TimeTableRequest::_internal_period_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (period_case() != kPeriodString) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.period_.period_string_.Get();
}
inline void TimeTableRequest::_internal_set_period_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (period_case() != kPeriodString) {
    clear_period();

    set_has_period_string();
    _impl_.period_.period_string_.InitDefault();
  }
  _impl_.period_.period_string_.Set(value, GetArena());
}
inline std::string* TimeTableRequest::_internal_mutable_period_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (period_case() != kPeriodString) {
    clear_period();

    set_has_period_string();
    _impl_.period_.period_string_.InitDefault();
  }
  return _impl_.period_.period_string_.Mutable( GetArena());
}
inline std::string* TimeTableRequest::release_period_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.TimeTableRequest.period_string)
  if (period_case() != kPeriodString) {
    return nullptr;
  }
  clear_has_period();
  return _impl_.period_.period_string_.Release();
}
inline void TimeTableRequest::set_allocated_period_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_period()) {
    clear_period();
  }
  if (value != nullptr) {
    set_has_period_string();
    _impl_.period_.period_string_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.TimeTableRequest.period_string)
}

// bool blink_table = 4;
inline void TimeTableRequest::clear_blink_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.blink_table_ = false;
}
inline bool TimeTableRequest::blink_table() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.TimeTableRequest.blink_table)
  return _internal_blink_table();
}
inline void TimeTableRequest::set_blink_table(bool value) {
  _internal_set_blink_table(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.TimeTableRequest.blink_table)
}
inline bool TimeTableRequest::_internal_blink_table() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.blink_table_;
}
inline void TimeTableRequest::_internal_set_blink_table(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.blink_table_ = value;
}

inline bool TimeTableRequest::has_start_time() const {
  return start_time_case() != START_TIME_NOT_SET;
}
inline void TimeTableRequest::clear_has_start_time() {
  _impl_._oneof_case_[0] = START_TIME_NOT_SET;
}
inline bool TimeTableRequest::has_period() const {
  return period_case() != PERIOD_NOT_SET;
}
inline void TimeTableRequest::clear_has_period() {
  _impl_._oneof_case_[1] = PERIOD_NOT_SET;
}
inline TimeTableRequest::StartTimeCase TimeTableRequest::start_time_case() const {
  return TimeTableRequest::StartTimeCase(_impl_._oneof_case_[0]);
}
inline TimeTableRequest::PeriodCase TimeTableRequest::period_case() const {
  return TimeTableRequest::PeriodCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// SelectOrUpdateRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SelectOrUpdateRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SelectOrUpdateRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SelectOrUpdateRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
  return _internal_result_id();
}
inline void SelectOrUpdateRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectOrUpdateRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectOrUpdateRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectOrUpdateRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectOrUpdateRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
  return _msg;
}
inline void SelectOrUpdateRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool SelectOrUpdateRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void SelectOrUpdateRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SelectOrUpdateRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SelectOrUpdateRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
  return _internal_source_id();
}
inline void SelectOrUpdateRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectOrUpdateRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectOrUpdateRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectOrUpdateRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectOrUpdateRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
  return _msg;
}
inline void SelectOrUpdateRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.source_id)
}

// repeated string column_specs = 3;
inline int SelectOrUpdateRequest::_internal_column_specs_size() const {
  return _internal_column_specs().size();
}
inline int SelectOrUpdateRequest::column_specs_size() const {
  return _internal_column_specs_size();
}
inline void SelectOrUpdateRequest::clear_column_specs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_specs_.Clear();
}
inline std::string* SelectOrUpdateRequest::add_column_specs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_column_specs()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return _s;
}
inline const std::string& SelectOrUpdateRequest::column_specs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return _internal_column_specs().Get(index);
}
inline std::string* SelectOrUpdateRequest::mutable_column_specs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return _internal_mutable_column_specs()->Mutable(index);
}
inline void SelectOrUpdateRequest::set_column_specs(int index, const std::string& value) {
  _internal_mutable_column_specs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::set_column_specs(int index, std::string&& value) {
  _internal_mutable_column_specs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::set_column_specs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_column_specs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::set_column_specs(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_column_specs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::set_column_specs(int index, absl::string_view value) {
  _internal_mutable_column_specs()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::add_column_specs(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_specs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::add_column_specs(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_specs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::add_column_specs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_specs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::add_column_specs(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_specs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline void SelectOrUpdateRequest::add_column_specs(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_specs()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SelectOrUpdateRequest::column_specs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  return _internal_column_specs();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SelectOrUpdateRequest::mutable_column_specs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest.column_specs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_column_specs();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SelectOrUpdateRequest::_internal_column_specs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_specs_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SelectOrUpdateRequest::_internal_mutable_column_specs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.column_specs_;
}

// -------------------------------------------------------------------

// MathContext

// sint32 precision = 1;
inline void MathContext::clear_precision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.precision_ = 0;
}
inline ::int32_t MathContext::precision() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MathContext.precision)
  return _internal_precision();
}
inline void MathContext::set_precision(::int32_t value) {
  _internal_set_precision(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MathContext.precision)
}
inline ::int32_t MathContext::_internal_precision() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.precision_;
}
inline void MathContext::_internal_set_precision(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.precision_ = value;
}

// .io.deephaven.proto.backplane.grpc.MathContext.RoundingMode rounding_mode = 2;
inline void MathContext::clear_rounding_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.rounding_mode_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode MathContext::rounding_mode() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MathContext.rounding_mode)
  return _internal_rounding_mode();
}
inline void MathContext::set_rounding_mode(::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode value) {
  _internal_set_rounding_mode(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MathContext.rounding_mode)
}
inline ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode MathContext::_internal_rounding_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode>(_impl_.rounding_mode_);
}
inline void MathContext::_internal_set_rounding_mode(::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.rounding_mode_ = value;
}

// -------------------------------------------------------------------

// UpdateByWindowScale_UpdateByWindowTicks

// double ticks = 1;
inline void UpdateByWindowScale_UpdateByWindowTicks::clear_ticks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ticks_ = 0;
}
inline double UpdateByWindowScale_UpdateByWindowTicks::ticks() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks.ticks)
  return _internal_ticks();
}
inline void UpdateByWindowScale_UpdateByWindowTicks::set_ticks(double value) {
  _internal_set_ticks(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks.ticks)
}
inline double UpdateByWindowScale_UpdateByWindowTicks::_internal_ticks() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ticks_;
}
inline void UpdateByWindowScale_UpdateByWindowTicks::_internal_set_ticks(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.ticks_ = value;
}

// -------------------------------------------------------------------

// UpdateByWindowScale_UpdateByWindowTime

// string column = 1;
inline void UpdateByWindowScale_UpdateByWindowTime::clear_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_.ClearToEmpty();
}
inline const std::string& UpdateByWindowScale_UpdateByWindowTime::column() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.column)
  return _internal_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateByWindowScale_UpdateByWindowTime::set_column(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.column)
}
inline std::string* UpdateByWindowScale_UpdateByWindowTime::mutable_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.column)
  return _s;
}
inline const std::string& UpdateByWindowScale_UpdateByWindowTime::_internal_column() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_.Get();
}
inline void UpdateByWindowScale_UpdateByWindowTime::_internal_set_column(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_.Set(value, GetArena());
}
inline std::string* UpdateByWindowScale_UpdateByWindowTime::_internal_mutable_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.column_.Mutable( GetArena());
}
inline std::string* UpdateByWindowScale_UpdateByWindowTime::release_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.column)
  return _impl_.column_.Release();
}
inline void UpdateByWindowScale_UpdateByWindowTime::set_allocated_column(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_.IsDefault()) {
          _impl_.column_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.column)
}

// sint64 nanos = 2 [jstype = JS_STRING];
inline bool UpdateByWindowScale_UpdateByWindowTime::has_nanos() const {
  return window_case() == kNanos;
}
inline void UpdateByWindowScale_UpdateByWindowTime::set_has_nanos() {
  _impl_._oneof_case_[0] = kNanos;
}
inline void UpdateByWindowScale_UpdateByWindowTime::clear_nanos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (window_case() == kNanos) {
    _impl_.window_.nanos_ = ::int64_t{0};
    clear_has_window();
  }
}
inline ::int64_t UpdateByWindowScale_UpdateByWindowTime::nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.nanos)
  return _internal_nanos();
}
inline void UpdateByWindowScale_UpdateByWindowTime::set_nanos(::int64_t value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.nanos)
}
inline ::int64_t UpdateByWindowScale_UpdateByWindowTime::_internal_nanos() const {
  if (window_case() == kNanos) {
    return _impl_.window_.nanos_;
  }
  return ::int64_t{0};
}
inline void UpdateByWindowScale_UpdateByWindowTime::_internal_set_nanos(::int64_t value) {
  if (window_case() != kNanos) {
    clear_window();
    set_has_nanos();
  }
  _impl_.window_.nanos_ = value;
}

// string duration_string = 3;
inline bool UpdateByWindowScale_UpdateByWindowTime::has_duration_string() const {
  return window_case() == kDurationString;
}
inline void UpdateByWindowScale_UpdateByWindowTime::set_has_duration_string() {
  _impl_._oneof_case_[0] = kDurationString;
}
inline void UpdateByWindowScale_UpdateByWindowTime::clear_duration_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (window_case() == kDurationString) {
    _impl_.window_.duration_string_.Destroy();
    clear_has_window();
  }
}
inline const std::string& UpdateByWindowScale_UpdateByWindowTime::duration_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.duration_string)
  return _internal_duration_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateByWindowScale_UpdateByWindowTime::set_duration_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (window_case() != kDurationString) {
    clear_window();

    set_has_duration_string();
    _impl_.window_.duration_string_.InitDefault();
  }
  _impl_.window_.duration_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.duration_string)
}
inline std::string* UpdateByWindowScale_UpdateByWindowTime::mutable_duration_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_duration_string();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.duration_string)
  return _s;
}
inline const std::string& UpdateByWindowScale_UpdateByWindowTime::_internal_duration_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (window_case() != kDurationString) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.window_.duration_string_.Get();
}
inline void UpdateByWindowScale_UpdateByWindowTime::_internal_set_duration_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (window_case() != kDurationString) {
    clear_window();

    set_has_duration_string();
    _impl_.window_.duration_string_.InitDefault();
  }
  _impl_.window_.duration_string_.Set(value, GetArena());
}
inline std::string* UpdateByWindowScale_UpdateByWindowTime::_internal_mutable_duration_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (window_case() != kDurationString) {
    clear_window();

    set_has_duration_string();
    _impl_.window_.duration_string_.InitDefault();
  }
  return _impl_.window_.duration_string_.Mutable( GetArena());
}
inline std::string* UpdateByWindowScale_UpdateByWindowTime::release_duration_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.duration_string)
  if (window_case() != kDurationString) {
    return nullptr;
  }
  clear_has_window();
  return _impl_.window_.duration_string_.Release();
}
inline void UpdateByWindowScale_UpdateByWindowTime::set_allocated_duration_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_window()) {
    clear_window();
  }
  if (value != nullptr) {
    set_has_duration_string();
    _impl_.window_.duration_string_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime.duration_string)
}

inline bool UpdateByWindowScale_UpdateByWindowTime::has_window() const {
  return window_case() != WINDOW_NOT_SET;
}
inline void UpdateByWindowScale_UpdateByWindowTime::clear_has_window() {
  _impl_._oneof_case_[0] = WINDOW_NOT_SET;
}
inline UpdateByWindowScale_UpdateByWindowTime::WindowCase UpdateByWindowScale_UpdateByWindowTime::window_case() const {
  return UpdateByWindowScale_UpdateByWindowTime::WindowCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateByWindowScale

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTicks ticks = 1;
inline bool UpdateByWindowScale::has_ticks() const {
  return type_case() == kTicks;
}
inline bool UpdateByWindowScale::_internal_has_ticks() const {
  return type_case() == kTicks;
}
inline void UpdateByWindowScale::set_has_ticks() {
  _impl_._oneof_case_[0] = kTicks;
}
inline void UpdateByWindowScale::clear_ticks() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kTicks) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.ticks_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* UpdateByWindowScale::release_ticks() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.ticks)
  if (type_case() == kTicks) {
    clear_has_type();
    auto* temp = _impl_.type_.ticks_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.ticks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks& UpdateByWindowScale::_internal_ticks() const {
  return type_case() == kTicks ? *_impl_.type_.ticks_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_UpdateByWindowTicks_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks& UpdateByWindowScale::ticks() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.ticks)
  return _internal_ticks();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* UpdateByWindowScale::unsafe_arena_release_ticks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.ticks)
  if (type_case() == kTicks) {
    clear_has_type();
    auto* temp = _impl_.type_.ticks_;
    _impl_.type_.ticks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByWindowScale::unsafe_arena_set_allocated_ticks(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_ticks();
    _impl_.type_.ticks_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.ticks)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* UpdateByWindowScale::_internal_mutable_ticks() {
  if (type_case() != kTicks) {
    clear_type();
    set_has_ticks();
    _impl_.type_.ticks_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks>(GetArena());
  }
  return _impl_.type_.ticks_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* UpdateByWindowScale::mutable_ticks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTicks* _msg = _internal_mutable_ticks();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.ticks)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale.UpdateByWindowTime time = 2;
inline bool UpdateByWindowScale::has_time() const {
  return type_case() == kTime;
}
inline bool UpdateByWindowScale::_internal_has_time() const {
  return type_case() == kTime;
}
inline void UpdateByWindowScale::set_has_time() {
  _impl_._oneof_case_[0] = kTime;
}
inline void UpdateByWindowScale::clear_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kTime) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.time_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* UpdateByWindowScale::release_time() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.time)
  if (type_case() == kTime) {
    clear_has_type();
    auto* temp = _impl_.type_.time_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime& UpdateByWindowScale::_internal_time() const {
  return type_case() == kTime ? *_impl_.type_.time_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_UpdateByWindowTime_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime& UpdateByWindowScale::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.time)
  return _internal_time();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* UpdateByWindowScale::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.time)
  if (type_case() == kTime) {
    clear_has_type();
    auto* temp = _impl_.type_.time_;
    _impl_.type_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByWindowScale::unsafe_arena_set_allocated_time(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_time();
    _impl_.type_.time_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.time)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* UpdateByWindowScale::_internal_mutable_time() {
  if (type_case() != kTime) {
    clear_type();
    set_has_time();
    _impl_.type_.time_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime>(GetArena());
  }
  return _impl_.type_.time_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* UpdateByWindowScale::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale_UpdateByWindowTime* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByWindowScale.time)
  return _msg;
}

inline bool UpdateByWindowScale::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void UpdateByWindowScale::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline UpdateByWindowScale::TypeCase UpdateByWindowScale::type_case() const {
  return UpdateByWindowScale::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateByEmOptions

// .io.deephaven.proto.backplane.grpc.BadDataBehavior on_null_value = 1;
inline void UpdateByEmOptions::clear_on_null_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.on_null_value_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::on_null_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_null_value)
  return _internal_on_null_value();
}
inline void UpdateByEmOptions::set_on_null_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  _internal_set_on_null_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_null_value)
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::_internal_on_null_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::BadDataBehavior>(_impl_.on_null_value_);
}
inline void UpdateByEmOptions::_internal_set_on_null_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.on_null_value_ = value;
}

// .io.deephaven.proto.backplane.grpc.BadDataBehavior on_nan_value = 2;
inline void UpdateByEmOptions::clear_on_nan_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.on_nan_value_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::on_nan_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_nan_value)
  return _internal_on_nan_value();
}
inline void UpdateByEmOptions::set_on_nan_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  _internal_set_on_nan_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_nan_value)
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::_internal_on_nan_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::BadDataBehavior>(_impl_.on_nan_value_);
}
inline void UpdateByEmOptions::_internal_set_on_nan_value(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.on_nan_value_ = value;
}

// .io.deephaven.proto.backplane.grpc.BadDataBehavior on_null_time = 3;
inline void UpdateByEmOptions::clear_on_null_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.on_null_time_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::on_null_time() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_null_time)
  return _internal_on_null_time();
}
inline void UpdateByEmOptions::set_on_null_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  _internal_set_on_null_time(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_null_time)
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::_internal_on_null_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::BadDataBehavior>(_impl_.on_null_time_);
}
inline void UpdateByEmOptions::_internal_set_on_null_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.on_null_time_ = value;
}

// .io.deephaven.proto.backplane.grpc.BadDataBehavior on_negative_delta_time = 4;
inline void UpdateByEmOptions::clear_on_negative_delta_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.on_negative_delta_time_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::on_negative_delta_time() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_negative_delta_time)
  return _internal_on_negative_delta_time();
}
inline void UpdateByEmOptions::set_on_negative_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  _internal_set_on_negative_delta_time(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_negative_delta_time)
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::_internal_on_negative_delta_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::BadDataBehavior>(_impl_.on_negative_delta_time_);
}
inline void UpdateByEmOptions::_internal_set_on_negative_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.on_negative_delta_time_ = value;
}

// .io.deephaven.proto.backplane.grpc.BadDataBehavior on_zero_delta_time = 5;
inline void UpdateByEmOptions::clear_on_zero_delta_time() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.on_zero_delta_time_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::on_zero_delta_time() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_zero_delta_time)
  return _internal_on_zero_delta_time();
}
inline void UpdateByEmOptions::set_on_zero_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  _internal_set_on_zero_delta_time(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.on_zero_delta_time)
}
inline ::io::deephaven::proto::backplane::grpc::BadDataBehavior UpdateByEmOptions::_internal_on_zero_delta_time() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::BadDataBehavior>(_impl_.on_zero_delta_time_);
}
inline void UpdateByEmOptions::_internal_set_on_zero_delta_time(::io::deephaven::proto::backplane::grpc::BadDataBehavior value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.on_zero_delta_time_ = value;
}

// .io.deephaven.proto.backplane.grpc.MathContext big_value_context = 6;
inline bool UpdateByEmOptions::has_big_value_context() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.big_value_context_ != nullptr);
  return value;
}
inline void UpdateByEmOptions::clear_big_value_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.big_value_context_ != nullptr) _impl_.big_value_context_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::MathContext& UpdateByEmOptions::_internal_big_value_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::MathContext* p = _impl_.big_value_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::MathContext&>(::io::deephaven::proto::backplane::grpc::_MathContext_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MathContext& UpdateByEmOptions::big_value_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.big_value_context)
  return _internal_big_value_context();
}
inline void UpdateByEmOptions::unsafe_arena_set_allocated_big_value_context(::io::deephaven::proto::backplane::grpc::MathContext* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.big_value_context_);
  }
  _impl_.big_value_context_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::MathContext*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.big_value_context)
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByEmOptions::release_big_value_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::MathContext* released = _impl_.big_value_context_;
  _impl_.big_value_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByEmOptions::unsafe_arena_release_big_value_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.big_value_context)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::MathContext* temp = _impl_.big_value_context_;
  _impl_.big_value_context_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByEmOptions::_internal_mutable_big_value_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.big_value_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MathContext>(GetArena());
    _impl_.big_value_context_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::MathContext*>(p);
  }
  return _impl_.big_value_context_;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByEmOptions::mutable_big_value_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::MathContext* _msg = _internal_mutable_big_value_context();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.big_value_context)
  return _msg;
}
inline void UpdateByEmOptions::set_allocated_big_value_context(::io::deephaven::proto::backplane::grpc::MathContext* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::MathContext*>(_impl_.big_value_context_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::MathContext*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.big_value_context_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::MathContext*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByEmOptions.big_value_context)
}

// -------------------------------------------------------------------

// UpdateByDeltaOptions

// .io.deephaven.proto.backplane.grpc.UpdateByNullBehavior null_behavior = 1;
inline void UpdateByDeltaOptions::clear_null_behavior() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.null_behavior_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior UpdateByDeltaOptions::null_behavior() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions.null_behavior)
  return _internal_null_behavior();
}
inline void UpdateByDeltaOptions::set_null_behavior(::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior value) {
  _internal_set_null_behavior(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions.null_behavior)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior UpdateByDeltaOptions::_internal_null_behavior() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior>(_impl_.null_behavior_);
}
inline void UpdateByDeltaOptions::_internal_set_null_behavior(::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.null_behavior_ = value;
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOptions

// optional bool use_redirection = 1;
inline bool UpdateByRequest_UpdateByOptions::has_use_redirection() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void UpdateByRequest_UpdateByOptions::clear_use_redirection() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.use_redirection_ = false;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline bool UpdateByRequest_UpdateByOptions::use_redirection() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.use_redirection)
  return _internal_use_redirection();
}
inline void UpdateByRequest_UpdateByOptions::set_use_redirection(bool value) {
  _internal_set_use_redirection(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.use_redirection)
}
inline bool UpdateByRequest_UpdateByOptions::_internal_use_redirection() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.use_redirection_;
}
inline void UpdateByRequest_UpdateByOptions::_internal_set_use_redirection(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.use_redirection_ = value;
}

// optional int32 chunk_capacity = 2;
inline bool UpdateByRequest_UpdateByOptions::has_chunk_capacity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void UpdateByRequest_UpdateByOptions::clear_chunk_capacity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.chunk_capacity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t UpdateByRequest_UpdateByOptions::chunk_capacity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.chunk_capacity)
  return _internal_chunk_capacity();
}
inline void UpdateByRequest_UpdateByOptions::set_chunk_capacity(::int32_t value) {
  _internal_set_chunk_capacity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.chunk_capacity)
}
inline ::int32_t UpdateByRequest_UpdateByOptions::_internal_chunk_capacity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.chunk_capacity_;
}
inline void UpdateByRequest_UpdateByOptions::_internal_set_chunk_capacity(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.chunk_capacity_ = value;
}

// optional double max_static_sparse_memory_overhead = 3;
inline bool UpdateByRequest_UpdateByOptions::has_max_static_sparse_memory_overhead() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline void UpdateByRequest_UpdateByOptions::clear_max_static_sparse_memory_overhead() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_static_sparse_memory_overhead_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline double UpdateByRequest_UpdateByOptions::max_static_sparse_memory_overhead() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.max_static_sparse_memory_overhead)
  return _internal_max_static_sparse_memory_overhead();
}
inline void UpdateByRequest_UpdateByOptions::set_max_static_sparse_memory_overhead(double value) {
  _internal_set_max_static_sparse_memory_overhead(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.max_static_sparse_memory_overhead)
}
inline double UpdateByRequest_UpdateByOptions::_internal_max_static_sparse_memory_overhead() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_static_sparse_memory_overhead_;
}
inline void UpdateByRequest_UpdateByOptions::_internal_set_max_static_sparse_memory_overhead(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.max_static_sparse_memory_overhead_ = value;
}

// optional int32 initial_hash_table_size = 4;
inline bool UpdateByRequest_UpdateByOptions::has_initial_hash_table_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline void UpdateByRequest_UpdateByOptions::clear_initial_hash_table_size() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.initial_hash_table_size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline ::int32_t UpdateByRequest_UpdateByOptions::initial_hash_table_size() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.initial_hash_table_size)
  return _internal_initial_hash_table_size();
}
inline void UpdateByRequest_UpdateByOptions::set_initial_hash_table_size(::int32_t value) {
  _internal_set_initial_hash_table_size(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.initial_hash_table_size)
}
inline ::int32_t UpdateByRequest_UpdateByOptions::_internal_initial_hash_table_size() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.initial_hash_table_size_;
}
inline void UpdateByRequest_UpdateByOptions::_internal_set_initial_hash_table_size(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.initial_hash_table_size_ = value;
}

// optional double maximum_load_factor = 5;
inline bool UpdateByRequest_UpdateByOptions::has_maximum_load_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline void UpdateByRequest_UpdateByOptions::clear_maximum_load_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.maximum_load_factor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline double UpdateByRequest_UpdateByOptions::maximum_load_factor() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.maximum_load_factor)
  return _internal_maximum_load_factor();
}
inline void UpdateByRequest_UpdateByOptions::set_maximum_load_factor(double value) {
  _internal_set_maximum_load_factor(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.maximum_load_factor)
}
inline double UpdateByRequest_UpdateByOptions::_internal_maximum_load_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.maximum_load_factor_;
}
inline void UpdateByRequest_UpdateByOptions::_internal_set_maximum_load_factor(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.maximum_load_factor_ = value;
}

// optional double target_load_factor = 6;
inline bool UpdateByRequest_UpdateByOptions::has_target_load_factor() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline void UpdateByRequest_UpdateByOptions::clear_target_load_factor() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.target_load_factor_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline double UpdateByRequest_UpdateByOptions::target_load_factor() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.target_load_factor)
  return _internal_target_load_factor();
}
inline void UpdateByRequest_UpdateByOptions::set_target_load_factor(double value) {
  _internal_set_target_load_factor(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.target_load_factor)
}
inline double UpdateByRequest_UpdateByOptions::_internal_target_load_factor() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.target_load_factor_;
}
inline void UpdateByRequest_UpdateByOptions::_internal_set_target_load_factor(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.target_load_factor_ = value;
}

// .io.deephaven.proto.backplane.grpc.MathContext math_context = 7;
inline bool UpdateByRequest_UpdateByOptions::has_math_context() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.math_context_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOptions::clear_math_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.math_context_ != nullptr) _impl_.math_context_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::MathContext& UpdateByRequest_UpdateByOptions::_internal_math_context() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::MathContext* p = _impl_.math_context_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::MathContext&>(::io::deephaven::proto::backplane::grpc::_MathContext_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MathContext& UpdateByRequest_UpdateByOptions::math_context() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.math_context)
  return _internal_math_context();
}
inline void UpdateByRequest_UpdateByOptions::unsafe_arena_set_allocated_math_context(::io::deephaven::proto::backplane::grpc::MathContext* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.math_context_);
  }
  _impl_.math_context_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::MathContext*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.math_context)
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByRequest_UpdateByOptions::release_math_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::MathContext* released = _impl_.math_context_;
  _impl_.math_context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByRequest_UpdateByOptions::unsafe_arena_release_math_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.math_context)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::MathContext* temp = _impl_.math_context_;
  _impl_.math_context_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByRequest_UpdateByOptions::_internal_mutable_math_context() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.math_context_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MathContext>(GetArena());
    _impl_.math_context_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::MathContext*>(p);
  }
  return _impl_.math_context_;
}
inline ::io::deephaven::proto::backplane::grpc::MathContext* UpdateByRequest_UpdateByOptions::mutable_math_context() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::MathContext* _msg = _internal_mutable_math_context();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.math_context)
  return _msg;
}
inline void UpdateByRequest_UpdateByOptions::set_allocated_math_context(::io::deephaven::proto::backplane::grpc::MathContext* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::MathContext*>(_impl_.math_context_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::MathContext*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.math_context_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::MathContext*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions.math_context)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma

// .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions&>(::io::deephaven::proto::backplane::grpc::_UpdateByEmOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.options)
  return _internal_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::unsafe_arena_release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions>(GetArena());
    _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(p);
  }
  return _impl_.options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.options)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.options)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::has_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::clear_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.window_scale_ != nullptr) _impl_.window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::_internal_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.window_scale)
  return _internal_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::unsafe_arena_set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.window_scale_);
  }
  _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::release_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.window_scale_;
  _impl_.window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::unsafe_arena_release_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.window_scale_;
  _impl_.window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::_internal_mutable_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::mutable_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma::set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma.window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms

// .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions&>(::io::deephaven::proto::backplane::grpc::_UpdateByEmOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.options)
  return _internal_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::unsafe_arena_release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions>(GetArena());
    _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(p);
  }
  return _impl_.options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.options)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.options)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::has_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::clear_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.window_scale_ != nullptr) _impl_.window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::_internal_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.window_scale)
  return _internal_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::unsafe_arena_set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.window_scale_);
  }
  _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::release_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.window_scale_;
  _impl_.window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::unsafe_arena_release_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.window_scale_;
  _impl_.window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::_internal_mutable_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::mutable_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms::set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms.window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin

// .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions&>(::io::deephaven::proto::backplane::grpc::_UpdateByEmOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.options)
  return _internal_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::unsafe_arena_release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions>(GetArena());
    _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(p);
  }
  return _impl_.options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.options)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.options)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::has_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::clear_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.window_scale_ != nullptr) _impl_.window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::_internal_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.window_scale)
  return _internal_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::unsafe_arena_set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.window_scale_);
  }
  _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::release_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.window_scale_;
  _impl_.window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::unsafe_arena_release_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.window_scale_;
  _impl_.window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::_internal_mutable_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::mutable_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin::set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin.window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax

// .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions&>(::io::deephaven::proto::backplane::grpc::_UpdateByEmOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.options)
  return _internal_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::unsafe_arena_release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions>(GetArena());
    _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(p);
  }
  return _impl_.options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.options)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.options)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::has_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::clear_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.window_scale_ != nullptr) _impl_.window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::_internal_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.window_scale)
  return _internal_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::unsafe_arena_set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.window_scale_);
  }
  _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::release_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.window_scale_;
  _impl_.window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::unsafe_arena_release_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.window_scale_;
  _impl_.window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::_internal_mutable_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::mutable_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax::set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax.window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd

// .io.deephaven.proto.backplane.grpc.UpdateByEmOptions options = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions&>(::io::deephaven::proto::backplane::grpc::_UpdateByEmOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.options)
  return _internal_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::unsafe_arena_release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions>(GetArena());
    _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(p);
  }
  return _impl_.options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.options)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByEmOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByEmOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.options)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::has_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::clear_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.window_scale_ != nullptr) _impl_.window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::_internal_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.window_scale)
  return _internal_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::unsafe_arena_set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.window_scale_);
  }
  _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::release_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.window_scale_;
  _impl_.window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::unsafe_arena_release_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.window_scale_;
  _impl_.window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::_internal_mutable_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::mutable_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd::set_allocated_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd.window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta

// .io.deephaven.proto.backplane.grpc.UpdateByDeltaOptions options = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions&>(::io::deephaven::proto::backplane::grpc::_UpdateByDeltaOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta.options)
  return _internal_options();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::unsafe_arena_release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta.options)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions>(GetArena());
    _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions*>(p);
  }
  return _impl_.options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta.options)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByDeltaOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta.options)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::has_reverse_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reverse_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::clear_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reverse_window_scale_ != nullptr) _impl_.reverse_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::_internal_reverse_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::reverse_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reverse_window_scale_);
  }
  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::unsafe_arena_release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.reverse_window_scale)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::_internal_mutable_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::mutable_reverse_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.reverse_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::has_forward_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forward_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::clear_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.forward_window_scale_ != nullptr) _impl_.forward_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::_internal_forward_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::forward_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_window_scale_);
  }
  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::unsafe_arena_release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.forward_window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::_internal_mutable_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::mutable_forward_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.forward_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::has_reverse_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reverse_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::clear_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reverse_window_scale_ != nullptr) _impl_.reverse_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::_internal_reverse_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::reverse_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reverse_window_scale_);
  }
  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::unsafe_arena_release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.reverse_window_scale)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::_internal_mutable_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::mutable_reverse_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.reverse_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::has_forward_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forward_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::clear_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.forward_window_scale_ != nullptr) _impl_.forward_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::_internal_forward_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::forward_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_window_scale_);
  }
  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::unsafe_arena_release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.forward_window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::_internal_mutable_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::mutable_forward_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.forward_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::has_reverse_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reverse_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::clear_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reverse_window_scale_ != nullptr) _impl_.reverse_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::_internal_reverse_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::reverse_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reverse_window_scale_);
  }
  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::unsafe_arena_release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.reverse_window_scale)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::_internal_mutable_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::mutable_reverse_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.reverse_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::has_forward_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forward_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::clear_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.forward_window_scale_ != nullptr) _impl_.forward_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::_internal_forward_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::forward_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_window_scale_);
  }
  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::unsafe_arena_release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.forward_window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::_internal_mutable_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::mutable_forward_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.forward_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::has_reverse_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reverse_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::clear_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reverse_window_scale_ != nullptr) _impl_.reverse_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::_internal_reverse_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::reverse_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reverse_window_scale_);
  }
  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::unsafe_arena_release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.reverse_window_scale)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::_internal_mutable_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::mutable_reverse_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.reverse_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::has_forward_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forward_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::clear_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.forward_window_scale_ != nullptr) _impl_.forward_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::_internal_forward_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::forward_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_window_scale_);
  }
  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::unsafe_arena_release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.forward_window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::_internal_mutable_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::mutable_forward_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.forward_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::has_reverse_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reverse_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::clear_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reverse_window_scale_ != nullptr) _impl_.reverse_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::_internal_reverse_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::reverse_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reverse_window_scale_);
  }
  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::unsafe_arena_release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.reverse_window_scale)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::_internal_mutable_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::mutable_reverse_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.reverse_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::has_forward_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forward_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::clear_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.forward_window_scale_ != nullptr) _impl_.forward_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::_internal_forward_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::forward_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_window_scale_);
  }
  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::unsafe_arena_release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.forward_window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::_internal_mutable_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::mutable_forward_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.forward_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::has_reverse_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reverse_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::clear_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reverse_window_scale_ != nullptr) _impl_.reverse_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::_internal_reverse_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::reverse_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reverse_window_scale_);
  }
  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::unsafe_arena_release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.reverse_window_scale)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::_internal_mutable_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::mutable_reverse_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.reverse_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::has_forward_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forward_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::clear_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.forward_window_scale_ != nullptr) _impl_.forward_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::_internal_forward_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::forward_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_window_scale_);
  }
  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::unsafe_arena_release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.forward_window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::_internal_mutable_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::mutable_forward_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.forward_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::has_reverse_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reverse_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::clear_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reverse_window_scale_ != nullptr) _impl_.reverse_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::_internal_reverse_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::reverse_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reverse_window_scale_);
  }
  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::unsafe_arena_release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.reverse_window_scale)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::_internal_mutable_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::mutable_reverse_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.reverse_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::has_forward_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forward_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::clear_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.forward_window_scale_ != nullptr) _impl_.forward_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::_internal_forward_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::forward_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_window_scale_);
  }
  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::unsafe_arena_release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.forward_window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::_internal_mutable_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::mutable_forward_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.forward_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::has_reverse_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reverse_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::clear_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reverse_window_scale_ != nullptr) _impl_.reverse_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::_internal_reverse_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::reverse_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reverse_window_scale_);
  }
  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::unsafe_arena_release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.reverse_window_scale)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::_internal_mutable_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::mutable_reverse_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.reverse_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::has_forward_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forward_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::clear_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.forward_window_scale_ != nullptr) _impl_.forward_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::_internal_forward_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::forward_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_window_scale_);
  }
  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::unsafe_arena_release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.forward_window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::_internal_mutable_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::mutable_forward_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.forward_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd.forward_window_scale)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::has_reverse_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reverse_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::clear_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reverse_window_scale_ != nullptr) _impl_.reverse_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_reverse_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::reverse_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reverse_window_scale_);
  }
  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::unsafe_arena_release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.reverse_window_scale)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_mutable_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::mutable_reverse_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.reverse_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::has_forward_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forward_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::clear_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.forward_window_scale_ != nullptr) _impl_.forward_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_forward_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::forward_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_window_scale_);
  }
  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::unsafe_arena_release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.forward_window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_mutable_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::mutable_forward_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.forward_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.forward_window_scale)
}

// string weight_column = 3;
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::clear_weight_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weight_column_.ClearToEmpty();
}
inline const std::string& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::weight_column() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.weight_column)
  return _internal_weight_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::set_weight_column(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weight_column_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.weight_column)
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::mutable_weight_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_weight_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.weight_column)
  return _s;
}
inline const std::string& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_weight_column() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weight_column_.Get();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_set_weight_column(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weight_column_.Set(value, GetArena());
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::_internal_mutable_weight_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.weight_column_.Mutable( GetArena());
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::release_weight_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.weight_column)
  return _impl_.weight_column_.Release();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg::set_allocated_weight_column(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weight_column_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.weight_column_.IsDefault()) {
          _impl_.weight_column_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg.weight_column)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale reverse_window_scale = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::has_reverse_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reverse_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::clear_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reverse_window_scale_ != nullptr) _impl_.reverse_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::_internal_reverse_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.reverse_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::reverse_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.reverse_window_scale)
  return _internal_reverse_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::unsafe_arena_set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reverse_window_scale_);
  }
  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.reverse_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::unsafe_arena_release_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.reverse_window_scale)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.reverse_window_scale_;
  _impl_.reverse_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::_internal_mutable_reverse_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reverse_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.reverse_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::mutable_reverse_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_reverse_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.reverse_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::set_allocated_reverse_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.reverse_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reverse_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.reverse_window_scale)
}

// .io.deephaven.proto.backplane.grpc.UpdateByWindowScale forward_window_scale = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::has_forward_window_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.forward_window_scale_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::clear_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.forward_window_scale_ != nullptr) _impl_.forward_window_scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::_internal_forward_window_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* p = _impl_.forward_window_scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale&>(::io::deephaven::proto::backplane::grpc::_UpdateByWindowScale_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::forward_window_scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.forward_window_scale)
  return _internal_forward_window_scale();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::unsafe_arena_set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.forward_window_scale_);
  }
  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.forward_window_scale)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* released = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::unsafe_arena_release_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.forward_window_scale)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* temp = _impl_.forward_window_scale_;
  _impl_.forward_window_scale_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::_internal_mutable_forward_window_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.forward_window_scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale>(GetArena());
    _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(p);
  }
  return _impl_.forward_window_scale_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::mutable_forward_window_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* _msg = _internal_mutable_forward_window_scale();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.forward_window_scale)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::set_allocated_forward_window_scale(::io::deephaven::proto::backplane::grpc::UpdateByWindowScale* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(_impl_.forward_window_scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.forward_window_scale_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByWindowScale*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.forward_window_scale)
}

// string formula = 3;
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::clear_formula() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.formula_.ClearToEmpty();
}
inline const std::string& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::formula() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.formula)
  return _internal_formula();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::set_formula(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.formula_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.formula)
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::mutable_formula() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_formula();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.formula)
  return _s;
}
inline const std::string& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::_internal_formula() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.formula_.Get();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::_internal_set_formula(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.formula_.Set(value, GetArena());
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::_internal_mutable_formula() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.formula_.Mutable( GetArena());
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::release_formula() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.formula)
  return _impl_.formula_.Release();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::set_allocated_formula(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.formula_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.formula_.IsDefault()) {
          _impl_.formula_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.formula)
}

// string param_token = 4;
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::clear_param_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.param_token_.ClearToEmpty();
}
inline const std::string& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::param_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.param_token)
  return _internal_param_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::set_param_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.param_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.param_token)
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::mutable_param_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_param_token();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.param_token)
  return _s;
}
inline const std::string& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::_internal_param_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.param_token_.Get();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::_internal_set_param_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.param_token_.Set(value, GetArena());
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::_internal_mutable_param_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.param_token_.Mutable( GetArena());
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::release_param_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.param_token)
  return _impl_.param_token_.Release();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula::set_allocated_param_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.param_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.param_token_.IsDefault()) {
          _impl_.param_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula.param_token)
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeSum sum = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_sum() const {
  return type_case() == kSum;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_sum() const {
  return type_case() == kSum;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_sum() {
  _impl_._oneof_case_[0] = kSum;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_sum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kSum) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.sum_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_sum() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.sum)
  if (type_case() == kSum) {
    clear_has_type();
    auto* temp = _impl_.type_.sum_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_sum() const {
  return type_case() == kSum ? *_impl_.type_.sum_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::sum() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.sum)
  return _internal_sum();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.sum)
  if (type_case() == kSum) {
    clear_has_type();
    auto* temp = _impl_.type_.sum_;
    _impl_.type_.sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_sum(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_sum();
    _impl_.type_.sum_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.sum)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_sum() {
  if (type_case() != kSum) {
    clear_type();
    set_has_sum();
    _impl_.type_.sum_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum>(GetArena());
  }
  return _impl_.type_.sum_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_sum() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeSum* _msg = _internal_mutable_sum();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.sum)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMin min = 2;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_min() const {
  return type_case() == kMin;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_min() const {
  return type_case() == kMin;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_min() {
  _impl_._oneof_case_[0] = kMin;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kMin) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.min_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_min() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.min)
  if (type_case() == kMin) {
    clear_has_type();
    auto* temp = _impl_.type_.min_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_min() const {
  return type_case() == kMin ? *_impl_.type_.min_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::min() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.min)
  return _internal_min();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_min() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.min)
  if (type_case() == kMin) {
    clear_has_type();
    auto* temp = _impl_.type_.min_;
    _impl_.type_.min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_min();
    _impl_.type_.min_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.min)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_min() {
  if (type_case() != kMin) {
    clear_type();
    set_has_min();
    _impl_.type_.min_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin>(GetArena());
  }
  return _impl_.type_.min_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_min() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMin* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.min)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeMax max = 3;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_max() const {
  return type_case() == kMax;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_max() const {
  return type_case() == kMax;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_max() {
  _impl_._oneof_case_[0] = kMax;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kMax) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.max_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_max() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.max)
  if (type_case() == kMax) {
    clear_has_type();
    auto* temp = _impl_.type_.max_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_max() const {
  return type_case() == kMax ? *_impl_.type_.max_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::max() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.max)
  return _internal_max();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_max() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.max)
  if (type_case() == kMax) {
    clear_has_type();
    auto* temp = _impl_.type_.max_;
    _impl_.type_.max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_max();
    _impl_.type_.max_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.max)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_max() {
  if (type_case() != kMax) {
    clear_type();
    set_has_max();
    _impl_.type_.max_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax>(GetArena());
  }
  return _impl_.type_.max_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_max() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeMax* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.max)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByCumulativeProduct product = 4;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_product() const {
  return type_case() == kProduct;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_product() const {
  return type_case() == kProduct;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_product() {
  _impl_._oneof_case_[0] = kProduct;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kProduct) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.product_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_product() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.product)
  if (type_case() == kProduct) {
    clear_has_type();
    auto* temp = _impl_.type_.product_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_product() const {
  return type_case() == kProduct ? *_impl_.type_.product_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::product() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.product)
  return _internal_product();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_product() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.product)
  if (type_case() == kProduct) {
    clear_has_type();
    auto* temp = _impl_.type_.product_;
    _impl_.type_.product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_product(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_product();
    _impl_.type_.product_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.product)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_product() {
  if (type_case() != kProduct) {
    clear_type();
    set_has_product();
    _impl_.type_.product_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct>(GetArena());
  }
  return _impl_.type_.product_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_product() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByCumulativeProduct* _msg = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.product)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByFill fill = 5;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_fill() const {
  return type_case() == kFill;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_fill() const {
  return type_case() == kFill;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_fill() {
  _impl_._oneof_case_[0] = kFill;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kFill) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.fill_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_fill() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.fill)
  if (type_case() == kFill) {
    clear_has_type();
    auto* temp = _impl_.type_.fill_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.fill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_fill() const {
  return type_case() == kFill ? *_impl_.type_.fill_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::fill() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.fill)
  return _internal_fill();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_fill() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.fill)
  if (type_case() == kFill) {
    clear_has_type();
    auto* temp = _impl_.type_.fill_;
    _impl_.type_.fill_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_fill(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_fill();
    _impl_.type_.fill_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.fill)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_fill() {
  if (type_case() != kFill) {
    clear_type();
    set_has_fill();
    _impl_.type_.fill_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill>(GetArena());
  }
  return _impl_.type_.fill_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_fill() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByFill* _msg = _internal_mutable_fill();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.fill)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEma ema = 6;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_ema() const {
  return type_case() == kEma;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_ema() const {
  return type_case() == kEma;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_ema() {
  _impl_._oneof_case_[0] = kEma;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_ema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kEma) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.ema_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_ema() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ema)
  if (type_case() == kEma) {
    clear_has_type();
    auto* temp = _impl_.type_.ema_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.ema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_ema() const {
  return type_case() == kEma ? *_impl_.type_.ema_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::ema() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ema)
  return _internal_ema();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_ema() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ema)
  if (type_case() == kEma) {
    clear_has_type();
    auto* temp = _impl_.type_.ema_;
    _impl_.type_.ema_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_ema(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_ema();
    _impl_.type_.ema_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ema)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_ema() {
  if (type_case() != kEma) {
    clear_type();
    set_has_ema();
    _impl_.type_.ema_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma>(GetArena());
  }
  return _impl_.type_.ema_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_ema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEma* _msg = _internal_mutable_ema();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ema)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingSum rolling_sum = 7;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_sum() const {
  return type_case() == kRollingSum;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_sum() const {
  return type_case() == kRollingSum;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_sum() {
  _impl_._oneof_case_[0] = kRollingSum;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_sum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRollingSum) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rolling_sum_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_sum() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_sum)
  if (type_case() == kRollingSum) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_sum_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rolling_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_sum() const {
  return type_case() == kRollingSum ? *_impl_.type_.rolling_sum_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_sum() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_sum)
  return _internal_rolling_sum();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_sum)
  if (type_case() == kRollingSum) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_sum_;
    _impl_.type_.rolling_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_sum(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rolling_sum();
    _impl_.type_.rolling_sum_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_sum)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_sum() {
  if (type_case() != kRollingSum) {
    clear_type();
    set_has_rolling_sum();
    _impl_.type_.rolling_sum_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum>(GetArena());
  }
  return _impl_.type_.rolling_sum_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_sum() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingSum* _msg = _internal_mutable_rolling_sum();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_sum)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingGroup rolling_group = 8;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_group() const {
  return type_case() == kRollingGroup;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_group() const {
  return type_case() == kRollingGroup;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_group() {
  _impl_._oneof_case_[0] = kRollingGroup;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRollingGroup) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rolling_group_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_group() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_group)
  if (type_case() == kRollingGroup) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_group_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rolling_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_group() const {
  return type_case() == kRollingGroup ? *_impl_.type_.rolling_group_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_group)
  return _internal_rolling_group();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_group)
  if (type_case() == kRollingGroup) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_group_;
    _impl_.type_.rolling_group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_group(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rolling_group();
    _impl_.type_.rolling_group_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_group)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_group() {
  if (type_case() != kRollingGroup) {
    clear_type();
    set_has_rolling_group();
    _impl_.type_.rolling_group_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup>(GetArena());
  }
  return _impl_.type_.rolling_group_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingGroup* _msg = _internal_mutable_rolling_group();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_group)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingAvg rolling_avg = 9;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_avg() const {
  return type_case() == kRollingAvg;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_avg() const {
  return type_case() == kRollingAvg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_avg() {
  _impl_._oneof_case_[0] = kRollingAvg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_avg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRollingAvg) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rolling_avg_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_avg() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_avg)
  if (type_case() == kRollingAvg) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_avg_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rolling_avg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_avg() const {
  return type_case() == kRollingAvg ? *_impl_.type_.rolling_avg_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_avg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_avg)
  return _internal_rolling_avg();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_avg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_avg)
  if (type_case() == kRollingAvg) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_avg_;
    _impl_.type_.rolling_avg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_avg(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rolling_avg();
    _impl_.type_.rolling_avg_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_avg)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_avg() {
  if (type_case() != kRollingAvg) {
    clear_type();
    set_has_rolling_avg();
    _impl_.type_.rolling_avg_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg>(GetArena());
  }
  return _impl_.type_.rolling_avg_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_avg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingAvg* _msg = _internal_mutable_rolling_avg();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_avg)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMin rolling_min = 10;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_min() const {
  return type_case() == kRollingMin;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_min() const {
  return type_case() == kRollingMin;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_min() {
  _impl_._oneof_case_[0] = kRollingMin;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRollingMin) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rolling_min_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_min() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_min)
  if (type_case() == kRollingMin) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_min_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rolling_min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_min() const {
  return type_case() == kRollingMin ? *_impl_.type_.rolling_min_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_min() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_min)
  return _internal_rolling_min();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_min() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_min)
  if (type_case() == kRollingMin) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_min_;
    _impl_.type_.rolling_min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rolling_min();
    _impl_.type_.rolling_min_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_min)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_min() {
  if (type_case() != kRollingMin) {
    clear_type();
    set_has_rolling_min();
    _impl_.type_.rolling_min_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin>(GetArena());
  }
  return _impl_.type_.rolling_min_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_min() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMin* _msg = _internal_mutable_rolling_min();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_min)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingMax rolling_max = 11;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_max() const {
  return type_case() == kRollingMax;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_max() const {
  return type_case() == kRollingMax;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_max() {
  _impl_._oneof_case_[0] = kRollingMax;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRollingMax) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rolling_max_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_max() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_max)
  if (type_case() == kRollingMax) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_max_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rolling_max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_max() const {
  return type_case() == kRollingMax ? *_impl_.type_.rolling_max_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_max() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_max)
  return _internal_rolling_max();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_max() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_max)
  if (type_case() == kRollingMax) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_max_;
    _impl_.type_.rolling_max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rolling_max();
    _impl_.type_.rolling_max_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_max)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_max() {
  if (type_case() != kRollingMax) {
    clear_type();
    set_has_rolling_max();
    _impl_.type_.rolling_max_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax>(GetArena());
  }
  return _impl_.type_.rolling_max_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_max() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingMax* _msg = _internal_mutable_rolling_max();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_max)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingProduct rolling_product = 12;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_product() const {
  return type_case() == kRollingProduct;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_product() const {
  return type_case() == kRollingProduct;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_product() {
  _impl_._oneof_case_[0] = kRollingProduct;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_product() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRollingProduct) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rolling_product_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_product() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_product)
  if (type_case() == kRollingProduct) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_product_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rolling_product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_product() const {
  return type_case() == kRollingProduct ? *_impl_.type_.rolling_product_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_product() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_product)
  return _internal_rolling_product();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_product() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_product)
  if (type_case() == kRollingProduct) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_product_;
    _impl_.type_.rolling_product_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_product(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rolling_product();
    _impl_.type_.rolling_product_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_product)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_product() {
  if (type_case() != kRollingProduct) {
    clear_type();
    set_has_rolling_product();
    _impl_.type_.rolling_product_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct>(GetArena());
  }
  return _impl_.type_.rolling_product_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_product() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingProduct* _msg = _internal_mutable_rolling_product();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_product)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByDelta delta = 13;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_delta() const {
  return type_case() == kDelta;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_delta() const {
  return type_case() == kDelta;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_delta() {
  _impl_._oneof_case_[0] = kDelta;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_delta() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kDelta) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.delta_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_delta() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.delta)
  if (type_case() == kDelta) {
    clear_has_type();
    auto* temp = _impl_.type_.delta_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.delta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_delta() const {
  return type_case() == kDelta ? *_impl_.type_.delta_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::delta() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.delta)
  return _internal_delta();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_delta() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.delta)
  if (type_case() == kDelta) {
    clear_has_type();
    auto* temp = _impl_.type_.delta_;
    _impl_.type_.delta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_delta(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_delta();
    _impl_.type_.delta_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.delta)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_delta() {
  if (type_case() != kDelta) {
    clear_type();
    set_has_delta();
    _impl_.type_.delta_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta>(GetArena());
  }
  return _impl_.type_.delta_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_delta() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByDelta* _msg = _internal_mutable_delta();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.delta)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEms ems = 14;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_ems() const {
  return type_case() == kEms;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_ems() const {
  return type_case() == kEms;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_ems() {
  _impl_._oneof_case_[0] = kEms;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_ems() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kEms) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.ems_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_ems() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ems)
  if (type_case() == kEms) {
    clear_has_type();
    auto* temp = _impl_.type_.ems_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.ems_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_ems() const {
  return type_case() == kEms ? *_impl_.type_.ems_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::ems() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ems)
  return _internal_ems();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_ems() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ems)
  if (type_case() == kEms) {
    clear_has_type();
    auto* temp = _impl_.type_.ems_;
    _impl_.type_.ems_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_ems(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_ems();
    _impl_.type_.ems_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ems)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_ems() {
  if (type_case() != kEms) {
    clear_type();
    set_has_ems();
    _impl_.type_.ems_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms>(GetArena());
  }
  return _impl_.type_.ems_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_ems() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEms* _msg = _internal_mutable_ems();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.ems)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMin em_min = 15;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_em_min() const {
  return type_case() == kEmMin;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_em_min() const {
  return type_case() == kEmMin;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_em_min() {
  _impl_._oneof_case_[0] = kEmMin;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_em_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kEmMin) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.em_min_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_em_min() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_min)
  if (type_case() == kEmMin) {
    clear_has_type();
    auto* temp = _impl_.type_.em_min_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.em_min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_em_min() const {
  return type_case() == kEmMin ? *_impl_.type_.em_min_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::em_min() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_min)
  return _internal_em_min();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_em_min() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_min)
  if (type_case() == kEmMin) {
    clear_has_type();
    auto* temp = _impl_.type_.em_min_;
    _impl_.type_.em_min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_em_min(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_em_min();
    _impl_.type_.em_min_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_min)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_em_min() {
  if (type_case() != kEmMin) {
    clear_type();
    set_has_em_min();
    _impl_.type_.em_min_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin>(GetArena());
  }
  return _impl_.type_.em_min_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_em_min() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMin* _msg = _internal_mutable_em_min();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_min)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmMax em_max = 16;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_em_max() const {
  return type_case() == kEmMax;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_em_max() const {
  return type_case() == kEmMax;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_em_max() {
  _impl_._oneof_case_[0] = kEmMax;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_em_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kEmMax) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.em_max_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_em_max() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_max)
  if (type_case() == kEmMax) {
    clear_has_type();
    auto* temp = _impl_.type_.em_max_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.em_max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_em_max() const {
  return type_case() == kEmMax ? *_impl_.type_.em_max_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::em_max() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_max)
  return _internal_em_max();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_em_max() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_max)
  if (type_case() == kEmMax) {
    clear_has_type();
    auto* temp = _impl_.type_.em_max_;
    _impl_.type_.em_max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_em_max(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_em_max();
    _impl_.type_.em_max_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_max)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_em_max() {
  if (type_case() != kEmMax) {
    clear_type();
    set_has_em_max();
    _impl_.type_.em_max_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax>(GetArena());
  }
  return _impl_.type_.em_max_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_em_max() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmMax* _msg = _internal_mutable_em_max();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_max)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByEmStd em_std = 17;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_em_std() const {
  return type_case() == kEmStd;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_em_std() const {
  return type_case() == kEmStd;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_em_std() {
  _impl_._oneof_case_[0] = kEmStd;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_em_std() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kEmStd) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.em_std_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_em_std() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_std)
  if (type_case() == kEmStd) {
    clear_has_type();
    auto* temp = _impl_.type_.em_std_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.em_std_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_em_std() const {
  return type_case() == kEmStd ? *_impl_.type_.em_std_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::em_std() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_std)
  return _internal_em_std();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_em_std() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_std)
  if (type_case() == kEmStd) {
    clear_has_type();
    auto* temp = _impl_.type_.em_std_;
    _impl_.type_.em_std_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_em_std(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_em_std();
    _impl_.type_.em_std_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_std)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_em_std() {
  if (type_case() != kEmStd) {
    clear_type();
    set_has_em_std();
    _impl_.type_.em_std_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd>(GetArena());
  }
  return _impl_.type_.em_std_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_em_std() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByEmStd* _msg = _internal_mutable_em_std();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.em_std)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingCount rolling_count = 18;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_count() const {
  return type_case() == kRollingCount;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_count() const {
  return type_case() == kRollingCount;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_count() {
  _impl_._oneof_case_[0] = kRollingCount;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRollingCount) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rolling_count_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_count() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_count)
  if (type_case() == kRollingCount) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_count_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rolling_count_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_count() const {
  return type_case() == kRollingCount ? *_impl_.type_.rolling_count_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_count() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_count)
  return _internal_rolling_count();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_count() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_count)
  if (type_case() == kRollingCount) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_count_;
    _impl_.type_.rolling_count_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_count(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rolling_count();
    _impl_.type_.rolling_count_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_count)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_count() {
  if (type_case() != kRollingCount) {
    clear_type();
    set_has_rolling_count();
    _impl_.type_.rolling_count_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount>(GetArena());
  }
  return _impl_.type_.rolling_count_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_count() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingCount* _msg = _internal_mutable_rolling_count();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_count)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingStd rolling_std = 19;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_std() const {
  return type_case() == kRollingStd;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_std() const {
  return type_case() == kRollingStd;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_std() {
  _impl_._oneof_case_[0] = kRollingStd;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_std() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRollingStd) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rolling_std_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_std() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_std)
  if (type_case() == kRollingStd) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_std_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rolling_std_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_std() const {
  return type_case() == kRollingStd ? *_impl_.type_.rolling_std_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_std() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_std)
  return _internal_rolling_std();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_std() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_std)
  if (type_case() == kRollingStd) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_std_;
    _impl_.type_.rolling_std_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_std(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rolling_std();
    _impl_.type_.rolling_std_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_std)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_std() {
  if (type_case() != kRollingStd) {
    clear_type();
    set_has_rolling_std();
    _impl_.type_.rolling_std_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd>(GetArena());
  }
  return _impl_.type_.rolling_std_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_std() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingStd* _msg = _internal_mutable_rolling_std();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_std)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingWAvg rolling_wavg = 20;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_wavg() const {
  return type_case() == kRollingWavg;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_wavg() const {
  return type_case() == kRollingWavg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_wavg() {
  _impl_._oneof_case_[0] = kRollingWavg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_wavg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRollingWavg) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rolling_wavg_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_wavg() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_wavg)
  if (type_case() == kRollingWavg) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_wavg_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rolling_wavg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_wavg() const {
  return type_case() == kRollingWavg ? *_impl_.type_.rolling_wavg_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_wavg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_wavg)
  return _internal_rolling_wavg();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_wavg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_wavg)
  if (type_case() == kRollingWavg) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_wavg_;
    _impl_.type_.rolling_wavg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_wavg(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rolling_wavg();
    _impl_.type_.rolling_wavg_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_wavg)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_wavg() {
  if (type_case() != kRollingWavg) {
    clear_type();
    set_has_rolling_wavg();
    _impl_.type_.rolling_wavg_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg>(GetArena());
  }
  return _impl_.type_.rolling_wavg_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_wavg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingWAvg* _msg = _internal_mutable_rolling_wavg();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_wavg)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.UpdateByRollingFormula rolling_formula = 21;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_rolling_formula() const {
  return type_case() == kRollingFormula;
}
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_has_rolling_formula() const {
  return type_case() == kRollingFormula;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::set_has_rolling_formula() {
  _impl_._oneof_case_[0] = kRollingFormula;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_rolling_formula() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kRollingFormula) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.rolling_formula_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::release_rolling_formula() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_formula)
  if (type_case() == kRollingFormula) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_formula_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.rolling_formula_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_rolling_formula() const {
  return type_case() == kRollingFormula ? *_impl_.type_.rolling_formula_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula& UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::rolling_formula() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_formula)
  return _internal_rolling_formula();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_release_rolling_formula() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_formula)
  if (type_case() == kRollingFormula) {
    clear_has_type();
    auto* temp = _impl_.type_.rolling_formula_;
    _impl_.type_.rolling_formula_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::unsafe_arena_set_allocated_rolling_formula(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_rolling_formula();
    _impl_.type_.rolling_formula_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_formula)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::_internal_mutable_rolling_formula() {
  if (type_case() != kRollingFormula) {
    clear_type();
    set_has_rolling_formula();
    _impl_.type_.rolling_formula_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula>(GetArena());
  }
  return _impl_.type_.rolling_formula_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::mutable_rolling_formula() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_UpdateByRollingFormula* _msg = _internal_mutable_rolling_formula();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec.rolling_formula)
  return _msg;
}

inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::TypeCase UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::type_case() const {
  return UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation_UpdateByColumn

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.UpdateBySpec spec = 1;
inline bool UpdateByRequest_UpdateByOperation_UpdateByColumn::has_spec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spec_ != nullptr);
  return value;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::clear_spec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.spec_ != nullptr) _impl_.spec_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& UpdateByRequest_UpdateByOperation_UpdateByColumn::_internal_spec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* p = _impl_.spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec& UpdateByRequest_UpdateByOperation_UpdateByColumn::spec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.spec)
  return _internal_spec();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::unsafe_arena_set_allocated_spec(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spec_);
  }
  _impl_.spec_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.spec)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* UpdateByRequest_UpdateByOperation_UpdateByColumn::release_spec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* released = _impl_.spec_;
  _impl_.spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* UpdateByRequest_UpdateByOperation_UpdateByColumn::unsafe_arena_release_spec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.spec)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* UpdateByRequest_UpdateByOperation_UpdateByColumn::_internal_mutable_spec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec>(GetArena());
    _impl_.spec_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec*>(p);
  }
  return _impl_.spec_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* UpdateByRequest_UpdateByOperation_UpdateByColumn::mutable_spec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.spec)
  return _msg;
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::set_allocated_spec(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec*>(_impl_.spec_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.spec_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn_UpdateBySpec*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.spec)
}

// repeated string match_pairs = 2;
inline int UpdateByRequest_UpdateByOperation_UpdateByColumn::_internal_match_pairs_size() const {
  return _internal_match_pairs().size();
}
inline int UpdateByRequest_UpdateByOperation_UpdateByColumn::match_pairs_size() const {
  return _internal_match_pairs_size();
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::clear_match_pairs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.match_pairs_.Clear();
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn::add_match_pairs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_match_pairs()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
  return _s;
}
inline const std::string& UpdateByRequest_UpdateByOperation_UpdateByColumn::match_pairs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
  return _internal_match_pairs().Get(index);
}
inline std::string* UpdateByRequest_UpdateByOperation_UpdateByColumn::mutable_match_pairs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
  return _internal_mutable_match_pairs()->Mutable(index);
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::set_match_pairs(int index, const std::string& value) {
  _internal_mutable_match_pairs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::set_match_pairs(int index, std::string&& value) {
  _internal_mutable_match_pairs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::set_match_pairs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_match_pairs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::set_match_pairs(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_match_pairs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::set_match_pairs(int index, absl::string_view value) {
  _internal_mutable_match_pairs()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::add_match_pairs(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::add_match_pairs(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::add_match_pairs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::add_match_pairs(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline void UpdateByRequest_UpdateByOperation_UpdateByColumn::add_match_pairs(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdateByRequest_UpdateByOperation_UpdateByColumn::match_pairs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
  return _internal_match_pairs();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UpdateByRequest_UpdateByOperation_UpdateByColumn::mutable_match_pairs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn.match_pairs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_match_pairs();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdateByRequest_UpdateByOperation_UpdateByColumn::_internal_match_pairs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.match_pairs_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UpdateByRequest_UpdateByOperation_UpdateByColumn::_internal_mutable_match_pairs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.match_pairs_;
}

// -------------------------------------------------------------------

// UpdateByRequest_UpdateByOperation

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.UpdateByColumn column = 1;
inline bool UpdateByRequest_UpdateByOperation::has_column() const {
  return type_case() == kColumn;
}
inline bool UpdateByRequest_UpdateByOperation::_internal_has_column() const {
  return type_case() == kColumn;
}
inline void UpdateByRequest_UpdateByOperation::set_has_column() {
  _impl_._oneof_case_[0] = kColumn;
}
inline void UpdateByRequest_UpdateByOperation::clear_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kColumn) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.column_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* UpdateByRequest_UpdateByOperation::release_column() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.column)
  if (type_case() == kColumn) {
    clear_has_type();
    auto* temp = _impl_.type_.column_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.column_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn& UpdateByRequest_UpdateByOperation::_internal_column() const {
  return type_case() == kColumn ? *_impl_.type_.column_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOperation_UpdateByColumn_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn& UpdateByRequest_UpdateByOperation::column() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.column)
  return _internal_column();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* UpdateByRequest_UpdateByOperation::unsafe_arena_release_column() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.column)
  if (type_case() == kColumn) {
    clear_has_type();
    auto* temp = _impl_.type_.column_;
    _impl_.type_.column_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateByRequest_UpdateByOperation::unsafe_arena_set_allocated_column(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_column();
    _impl_.type_.column_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.column)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* UpdateByRequest_UpdateByOperation::_internal_mutable_column() {
  if (type_case() != kColumn) {
    clear_type();
    set_has_column();
    _impl_.type_.column_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn>(GetArena());
  }
  return _impl_.type_.column_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* UpdateByRequest_UpdateByOperation::mutable_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation_UpdateByColumn* _msg = _internal_mutable_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation.column)
  return _msg;
}

inline bool UpdateByRequest_UpdateByOperation::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void UpdateByRequest_UpdateByOperation::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline UpdateByRequest_UpdateByOperation::TypeCase UpdateByRequest_UpdateByOperation::type_case() const {
  return UpdateByRequest_UpdateByOperation::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// UpdateByRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool UpdateByRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UpdateByRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UpdateByRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.result_id)
  return _internal_result_id();
}
inline void UpdateByRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UpdateByRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UpdateByRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UpdateByRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UpdateByRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.result_id)
  return _msg;
}
inline void UpdateByRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool UpdateByRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void UpdateByRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UpdateByRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UpdateByRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.source_id)
  return _internal_source_id();
}
inline void UpdateByRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UpdateByRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UpdateByRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UpdateByRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UpdateByRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.source_id)
  return _msg;
}
inline void UpdateByRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOptions options = 3;
inline bool UpdateByRequest::has_options() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.options_ != nullptr);
  return value;
}
inline void UpdateByRequest::clear_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.options_ != nullptr) _impl_.options_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions& UpdateByRequest::_internal_options() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* p = _impl_.options_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_UpdateByOptions_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions& UpdateByRequest::options() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.options)
  return _internal_options();
}
inline void UpdateByRequest::unsafe_arena_set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.options_);
  }
  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.options)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* UpdateByRequest::release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* released = _impl_.options_;
  _impl_.options_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* UpdateByRequest::unsafe_arena_release_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UpdateByRequest.options)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* temp = _impl_.options_;
  _impl_.options_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* UpdateByRequest::_internal_mutable_options() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.options_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions>(GetArena());
    _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions*>(p);
  }
  return _impl_.options_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* UpdateByRequest::mutable_options() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* _msg = _internal_mutable_options();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.options)
  return _msg;
}
inline void UpdateByRequest::set_allocated_options(::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions*>(_impl_.options_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.options_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOptions*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UpdateByRequest.options)
}

// repeated .io.deephaven.proto.backplane.grpc.UpdateByRequest.UpdateByOperation operations = 4;
inline int UpdateByRequest::_internal_operations_size() const {
  return _internal_operations().size();
}
inline int UpdateByRequest::operations_size() const {
  return _internal_operations_size();
}
inline void UpdateByRequest::clear_operations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operations_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* UpdateByRequest::mutable_operations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.operations)
  return _internal_mutable_operations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation>* UpdateByRequest::mutable_operations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.UpdateByRequest.operations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_operations();
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation& UpdateByRequest::operations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.operations)
  return _internal_operations().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* UpdateByRequest::add_operations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation* _add = _internal_mutable_operations()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UpdateByRequest.operations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation>& UpdateByRequest::operations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.UpdateByRequest.operations)
  return _internal_operations();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation>&
UpdateByRequest::_internal_operations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.operations_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::UpdateByRequest_UpdateByOperation>*
UpdateByRequest::_internal_mutable_operations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.operations_;
}

// repeated string group_by_columns = 5;
inline int UpdateByRequest::_internal_group_by_columns_size() const {
  return _internal_group_by_columns().size();
}
inline int UpdateByRequest::group_by_columns_size() const {
  return _internal_group_by_columns_size();
}
inline void UpdateByRequest::clear_group_by_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_by_columns_.Clear();
}
inline std::string* UpdateByRequest::add_group_by_columns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_group_by_columns()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
  return _s;
}
inline const std::string& UpdateByRequest::group_by_columns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
  return _internal_group_by_columns().Get(index);
}
inline std::string* UpdateByRequest::mutable_group_by_columns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
  return _internal_mutable_group_by_columns()->Mutable(index);
}
inline void UpdateByRequest::set_group_by_columns(int index, const std::string& value) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::set_group_by_columns(int index, std::string&& value) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::set_group_by_columns(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_group_by_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::set_group_by_columns(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::set_group_by_columns(int index, absl::string_view value) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::add_group_by_columns(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::add_group_by_columns(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::add_group_by_columns(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::add_group_by_columns(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline void UpdateByRequest::add_group_by_columns(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdateByRequest::group_by_columns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
  return _internal_group_by_columns();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UpdateByRequest::mutable_group_by_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.UpdateByRequest.group_by_columns)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_group_by_columns();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UpdateByRequest::_internal_group_by_columns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_by_columns_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UpdateByRequest::_internal_mutable_group_by_columns() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.group_by_columns_;
}

// -------------------------------------------------------------------

// SelectDistinctRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SelectDistinctRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SelectDistinctRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SelectDistinctRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
  return _internal_result_id();
}
inline void SelectDistinctRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectDistinctRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectDistinctRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectDistinctRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SelectDistinctRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
  return _msg;
}
inline void SelectDistinctRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool SelectDistinctRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void SelectDistinctRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SelectDistinctRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SelectDistinctRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
  return _internal_source_id();
}
inline void SelectDistinctRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectDistinctRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectDistinctRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectDistinctRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SelectDistinctRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
  return _msg;
}
inline void SelectDistinctRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.source_id)
}

// repeated string column_names = 3;
inline int SelectDistinctRequest::_internal_column_names_size() const {
  return _internal_column_names().size();
}
inline int SelectDistinctRequest::column_names_size() const {
  return _internal_column_names_size();
}
inline void SelectDistinctRequest::clear_column_names() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_names_.Clear();
}
inline std::string* SelectDistinctRequest::add_column_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_column_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return _s;
}
inline const std::string& SelectDistinctRequest::column_names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return _internal_column_names().Get(index);
}
inline std::string* SelectDistinctRequest::mutable_column_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return _internal_mutable_column_names()->Mutable(index);
}
inline void SelectDistinctRequest::set_column_names(int index, const std::string& value) {
  _internal_mutable_column_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::set_column_names(int index, std::string&& value) {
  _internal_mutable_column_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::set_column_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_column_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::set_column_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_column_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::set_column_names(int index, absl::string_view value) {
  _internal_mutable_column_names()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::add_column_names(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::add_column_names(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::add_column_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::add_column_names(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline void SelectDistinctRequest::add_column_names(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_names()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SelectDistinctRequest::column_names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  return _internal_column_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SelectDistinctRequest::mutable_column_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SelectDistinctRequest.column_names)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_column_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SelectDistinctRequest::_internal_column_names() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SelectDistinctRequest::_internal_mutable_column_names() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.column_names_;
}

// -------------------------------------------------------------------

// DropColumnsRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool DropColumnsRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& DropColumnsRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& DropColumnsRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
  return _internal_result_id();
}
inline void DropColumnsRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* DropColumnsRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* DropColumnsRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* DropColumnsRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* DropColumnsRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
  return _msg;
}
inline void DropColumnsRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.DropColumnsRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool DropColumnsRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void DropColumnsRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& DropColumnsRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& DropColumnsRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
  return _internal_source_id();
}
inline void DropColumnsRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* DropColumnsRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* DropColumnsRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* DropColumnsRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* DropColumnsRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
  return _msg;
}
inline void DropColumnsRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.DropColumnsRequest.source_id)
}

// repeated string column_names = 3;
inline int DropColumnsRequest::_internal_column_names_size() const {
  return _internal_column_names().size();
}
inline int DropColumnsRequest::column_names_size() const {
  return _internal_column_names_size();
}
inline void DropColumnsRequest::clear_column_names() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_names_.Clear();
}
inline std::string* DropColumnsRequest::add_column_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_column_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return _s;
}
inline const std::string& DropColumnsRequest::column_names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return _internal_column_names().Get(index);
}
inline std::string* DropColumnsRequest::mutable_column_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return _internal_mutable_column_names()->Mutable(index);
}
inline void DropColumnsRequest::set_column_names(int index, const std::string& value) {
  _internal_mutable_column_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::set_column_names(int index, std::string&& value) {
  _internal_mutable_column_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::set_column_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_column_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::set_column_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_column_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::set_column_names(int index, absl::string_view value) {
  _internal_mutable_column_names()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::add_column_names(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::add_column_names(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::add_column_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::add_column_names(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline void DropColumnsRequest::add_column_names(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_column_names()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DropColumnsRequest::column_names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  return _internal_column_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DropColumnsRequest::mutable_column_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.DropColumnsRequest.column_names)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_column_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DropColumnsRequest::_internal_column_names() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DropColumnsRequest::_internal_mutable_column_names() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.column_names_;
}

// -------------------------------------------------------------------

// UnstructuredFilterTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool UnstructuredFilterTableRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UnstructuredFilterTableRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UnstructuredFilterTableRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
  return _internal_result_id();
}
inline void UnstructuredFilterTableRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UnstructuredFilterTableRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UnstructuredFilterTableRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UnstructuredFilterTableRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UnstructuredFilterTableRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
  return _msg;
}
inline void UnstructuredFilterTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool UnstructuredFilterTableRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void UnstructuredFilterTableRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UnstructuredFilterTableRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UnstructuredFilterTableRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
  return _internal_source_id();
}
inline void UnstructuredFilterTableRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UnstructuredFilterTableRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UnstructuredFilterTableRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UnstructuredFilterTableRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UnstructuredFilterTableRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
  return _msg;
}
inline void UnstructuredFilterTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.source_id)
}

// repeated string filters = 3;
inline int UnstructuredFilterTableRequest::_internal_filters_size() const {
  return _internal_filters().size();
}
inline int UnstructuredFilterTableRequest::filters_size() const {
  return _internal_filters_size();
}
inline void UnstructuredFilterTableRequest::clear_filters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filters_.Clear();
}
inline std::string* UnstructuredFilterTableRequest::add_filters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_filters()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return _s;
}
inline const std::string& UnstructuredFilterTableRequest::filters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return _internal_filters().Get(index);
}
inline std::string* UnstructuredFilterTableRequest::mutable_filters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return _internal_mutable_filters()->Mutable(index);
}
inline void UnstructuredFilterTableRequest::set_filters(int index, const std::string& value) {
  _internal_mutable_filters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::set_filters(int index, std::string&& value) {
  _internal_mutable_filters()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::set_filters(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_filters()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::set_filters(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_filters()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::set_filters(int index, absl::string_view value) {
  _internal_mutable_filters()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::add_filters(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::add_filters(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filters()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::add_filters(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filters()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::add_filters(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filters()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline void UnstructuredFilterTableRequest::add_filters(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_filters()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UnstructuredFilterTableRequest::filters() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  return _internal_filters();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UnstructuredFilterTableRequest::mutable_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest.filters)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_filters();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UnstructuredFilterTableRequest::_internal_filters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filters_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UnstructuredFilterTableRequest::_internal_mutable_filters() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.filters_;
}

// -------------------------------------------------------------------

// HeadOrTailRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool HeadOrTailRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& HeadOrTailRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& HeadOrTailRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
  return _internal_result_id();
}
inline void HeadOrTailRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
  return _msg;
}
inline void HeadOrTailRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool HeadOrTailRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void HeadOrTailRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& HeadOrTailRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& HeadOrTailRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
  return _internal_source_id();
}
inline void HeadOrTailRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
  return _msg;
}
inline void HeadOrTailRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.source_id)
}

// sint64 num_rows = 3 [jstype = JS_STRING];
inline void HeadOrTailRequest::clear_num_rows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_rows_ = ::int64_t{0};
}
inline ::int64_t HeadOrTailRequest::num_rows() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.num_rows)
  return _internal_num_rows();
}
inline void HeadOrTailRequest::set_num_rows(::int64_t value) {
  _internal_set_num_rows(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.HeadOrTailRequest.num_rows)
}
inline ::int64_t HeadOrTailRequest::_internal_num_rows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_rows_;
}
inline void HeadOrTailRequest::_internal_set_num_rows(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_rows_ = value;
}

// -------------------------------------------------------------------

// HeadOrTailByRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool HeadOrTailByRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& HeadOrTailByRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& HeadOrTailByRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
  return _internal_result_id();
}
inline void HeadOrTailByRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailByRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailByRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailByRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* HeadOrTailByRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
  return _msg;
}
inline void HeadOrTailByRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool HeadOrTailByRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void HeadOrTailByRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& HeadOrTailByRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& HeadOrTailByRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
  return _internal_source_id();
}
inline void HeadOrTailByRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailByRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailByRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailByRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* HeadOrTailByRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
  return _msg;
}
inline void HeadOrTailByRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.source_id)
}

// sint64 num_rows = 3 [jstype = JS_STRING];
inline void HeadOrTailByRequest::clear_num_rows() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.num_rows_ = ::int64_t{0};
}
inline ::int64_t HeadOrTailByRequest::num_rows() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.num_rows)
  return _internal_num_rows();
}
inline void HeadOrTailByRequest::set_num_rows(::int64_t value) {
  _internal_set_num_rows(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.num_rows)
}
inline ::int64_t HeadOrTailByRequest::_internal_num_rows() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.num_rows_;
}
inline void HeadOrTailByRequest::_internal_set_num_rows(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.num_rows_ = value;
}

// repeated string group_by_column_specs = 4;
inline int HeadOrTailByRequest::_internal_group_by_column_specs_size() const {
  return _internal_group_by_column_specs().size();
}
inline int HeadOrTailByRequest::group_by_column_specs_size() const {
  return _internal_group_by_column_specs_size();
}
inline void HeadOrTailByRequest::clear_group_by_column_specs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_by_column_specs_.Clear();
}
inline std::string* HeadOrTailByRequest::add_group_by_column_specs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_group_by_column_specs()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return _s;
}
inline const std::string& HeadOrTailByRequest::group_by_column_specs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return _internal_group_by_column_specs().Get(index);
}
inline std::string* HeadOrTailByRequest::mutable_group_by_column_specs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return _internal_mutable_group_by_column_specs()->Mutable(index);
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, const std::string& value) {
  _internal_mutable_group_by_column_specs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, std::string&& value) {
  _internal_mutable_group_by_column_specs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_group_by_column_specs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_group_by_column_specs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::set_group_by_column_specs(int index, absl::string_view value) {
  _internal_mutable_group_by_column_specs()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::add_group_by_column_specs(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_column_specs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::add_group_by_column_specs(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_column_specs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::add_group_by_column_specs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_column_specs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::add_group_by_column_specs(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_column_specs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline void HeadOrTailByRequest::add_group_by_column_specs(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_column_specs()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HeadOrTailByRequest::group_by_column_specs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  return _internal_group_by_column_specs();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HeadOrTailByRequest::mutable_group_by_column_specs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.HeadOrTailByRequest.group_by_column_specs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_group_by_column_specs();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
HeadOrTailByRequest::_internal_group_by_column_specs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_by_column_specs_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
HeadOrTailByRequest::_internal_mutable_group_by_column_specs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.group_by_column_specs_;
}

// -------------------------------------------------------------------

// UngroupRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool UngroupRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UngroupRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& UngroupRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
  return _internal_result_id();
}
inline void UngroupRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UngroupRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UngroupRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UngroupRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* UngroupRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
  return _msg;
}
inline void UngroupRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UngroupRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool UngroupRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void UngroupRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UngroupRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& UngroupRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
  return _internal_source_id();
}
inline void UngroupRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UngroupRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UngroupRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UngroupRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* UngroupRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
  return _msg;
}
inline void UngroupRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.UngroupRequest.source_id)
}

// bool null_fill = 3;
inline void UngroupRequest::clear_null_fill() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.null_fill_ = false;
}
inline bool UngroupRequest::null_fill() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UngroupRequest.null_fill)
  return _internal_null_fill();
}
inline void UngroupRequest::set_null_fill(bool value) {
  _internal_set_null_fill(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UngroupRequest.null_fill)
}
inline bool UngroupRequest::_internal_null_fill() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.null_fill_;
}
inline void UngroupRequest::_internal_set_null_fill(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.null_fill_ = value;
}

// repeated string columns_to_ungroup = 4;
inline int UngroupRequest::_internal_columns_to_ungroup_size() const {
  return _internal_columns_to_ungroup().size();
}
inline int UngroupRequest::columns_to_ungroup_size() const {
  return _internal_columns_to_ungroup_size();
}
inline void UngroupRequest::clear_columns_to_ungroup() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_ungroup_.Clear();
}
inline std::string* UngroupRequest::add_columns_to_ungroup()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_ungroup()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return _s;
}
inline const std::string& UngroupRequest::columns_to_ungroup(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return _internal_columns_to_ungroup().Get(index);
}
inline std::string* UngroupRequest::mutable_columns_to_ungroup(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return _internal_mutable_columns_to_ungroup()->Mutable(index);
}
inline void UngroupRequest::set_columns_to_ungroup(int index, const std::string& value) {
  _internal_mutable_columns_to_ungroup()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::set_columns_to_ungroup(int index, std::string&& value) {
  _internal_mutable_columns_to_ungroup()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::set_columns_to_ungroup(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_ungroup()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::set_columns_to_ungroup(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_ungroup()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::set_columns_to_ungroup(int index, absl::string_view value) {
  _internal_mutable_columns_to_ungroup()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::add_columns_to_ungroup(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_ungroup()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::add_columns_to_ungroup(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_ungroup()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::add_columns_to_ungroup(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_ungroup()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::add_columns_to_ungroup(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_ungroup()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline void UngroupRequest::add_columns_to_ungroup(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_ungroup()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UngroupRequest::columns_to_ungroup() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  return _internal_columns_to_ungroup();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UngroupRequest::mutable_columns_to_ungroup() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.UngroupRequest.columns_to_ungroup)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_ungroup();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
UngroupRequest::_internal_columns_to_ungroup() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_ungroup_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
UngroupRequest::_internal_mutable_columns_to_ungroup() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_ungroup_;
}

// -------------------------------------------------------------------

// MergeTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool MergeTablesRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& MergeTablesRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& MergeTablesRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
  return _internal_result_id();
}
inline void MergeTablesRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MergeTablesRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MergeTablesRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MergeTablesRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MergeTablesRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
  return _msg;
}
inline void MergeTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MergeTablesRequest.result_id)
}

// repeated .io.deephaven.proto.backplane.grpc.TableReference source_ids = 2;
inline int MergeTablesRequest::_internal_source_ids_size() const {
  return _internal_source_ids().size();
}
inline int MergeTablesRequest::source_ids_size() const {
  return _internal_source_ids_size();
}
inline void MergeTablesRequest::clear_source_ids() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_ids_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MergeTablesRequest::mutable_source_ids(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return _internal_mutable_source_ids()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::TableReference>* MergeTablesRequest::mutable_source_ids()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_source_ids();
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& MergeTablesRequest::source_ids(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return _internal_source_ids().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MergeTablesRequest::add_source_ids() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::TableReference* _add = _internal_mutable_source_ids()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::TableReference>& MergeTablesRequest::source_ids() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.MergeTablesRequest.source_ids)
  return _internal_source_ids();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::TableReference>&
MergeTablesRequest::_internal_source_ids() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_ids_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::TableReference>*
MergeTablesRequest::_internal_mutable_source_ids() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.source_ids_;
}

// string key_column = 3;
inline void MergeTablesRequest::clear_key_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_column_.ClearToEmpty();
}
inline const std::string& MergeTablesRequest::key_column() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
  return _internal_key_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MergeTablesRequest::set_key_column(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_column_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
}
inline std::string* MergeTablesRequest::mutable_key_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_key_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
  return _s;
}
inline const std::string& MergeTablesRequest::_internal_key_column() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_column_.Get();
}
inline void MergeTablesRequest::_internal_set_key_column(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.key_column_.Set(value, GetArena());
}
inline std::string* MergeTablesRequest::_internal_mutable_key_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.key_column_.Mutable( GetArena());
}
inline std::string* MergeTablesRequest::release_key_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
  return _impl_.key_column_.Release();
}
inline void MergeTablesRequest::set_allocated_key_column(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_column_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.key_column_.IsDefault()) {
          _impl_.key_column_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MergeTablesRequest.key_column)
}

// -------------------------------------------------------------------

// SnapshotTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SnapshotTableRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SnapshotTableRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SnapshotTableRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
  return _internal_result_id();
}
inline void SnapshotTableRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotTableRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotTableRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotTableRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotTableRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
  return _msg;
}
inline void SnapshotTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool SnapshotTableRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void SnapshotTableRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotTableRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotTableRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.source_id)
  return _internal_source_id();
}
inline void SnapshotTableRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotTableRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.source_id)
  return _msg;
}
inline void SnapshotTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotTableRequest.source_id)
}

// -------------------------------------------------------------------

// SnapshotWhenTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SnapshotWhenTableRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SnapshotWhenTableRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SnapshotWhenTableRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.result_id)
  return _internal_result_id();
}
inline void SnapshotWhenTableRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotWhenTableRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotWhenTableRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotWhenTableRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SnapshotWhenTableRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.result_id)
  return _msg;
}
inline void SnapshotWhenTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference base_id = 2;
inline bool SnapshotWhenTableRequest::has_base_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.base_id_ != nullptr);
  return value;
}
inline void SnapshotWhenTableRequest::clear_base_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.base_id_ != nullptr) _impl_.base_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotWhenTableRequest::_internal_base_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.base_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotWhenTableRequest::base_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.base_id)
  return _internal_base_id();
}
inline void SnapshotWhenTableRequest::unsafe_arena_set_allocated_base_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.base_id_);
  }
  _impl_.base_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.base_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::release_base_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.base_id_;
  _impl_.base_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::unsafe_arena_release_base_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.base_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.base_id_;
  _impl_.base_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::_internal_mutable_base_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.base_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.base_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.base_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::mutable_base_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_base_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.base_id)
  return _msg;
}
inline void SnapshotWhenTableRequest::set_allocated_base_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.base_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.base_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.base_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference trigger_id = 3;
inline bool SnapshotWhenTableRequest::has_trigger_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.trigger_id_ != nullptr);
  return value;
}
inline void SnapshotWhenTableRequest::clear_trigger_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.trigger_id_ != nullptr) _impl_.trigger_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotWhenTableRequest::_internal_trigger_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.trigger_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SnapshotWhenTableRequest::trigger_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.trigger_id)
  return _internal_trigger_id();
}
inline void SnapshotWhenTableRequest::unsafe_arena_set_allocated_trigger_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.trigger_id_);
  }
  _impl_.trigger_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.trigger_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::release_trigger_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.trigger_id_;
  _impl_.trigger_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::unsafe_arena_release_trigger_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.trigger_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.trigger_id_;
  _impl_.trigger_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::_internal_mutable_trigger_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.trigger_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.trigger_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.trigger_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SnapshotWhenTableRequest::mutable_trigger_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_trigger_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.trigger_id)
  return _msg;
}
inline void SnapshotWhenTableRequest::set_allocated_trigger_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.trigger_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.trigger_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.trigger_id)
}

// bool initial = 4;
inline void SnapshotWhenTableRequest::clear_initial() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.initial_ = false;
}
inline bool SnapshotWhenTableRequest::initial() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.initial)
  return _internal_initial();
}
inline void SnapshotWhenTableRequest::set_initial(bool value) {
  _internal_set_initial(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.initial)
}
inline bool SnapshotWhenTableRequest::_internal_initial() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.initial_;
}
inline void SnapshotWhenTableRequest::_internal_set_initial(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.initial_ = value;
}

// bool incremental = 5;
inline void SnapshotWhenTableRequest::clear_incremental() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.incremental_ = false;
}
inline bool SnapshotWhenTableRequest::incremental() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.incremental)
  return _internal_incremental();
}
inline void SnapshotWhenTableRequest::set_incremental(bool value) {
  _internal_set_incremental(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.incremental)
}
inline bool SnapshotWhenTableRequest::_internal_incremental() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.incremental_;
}
inline void SnapshotWhenTableRequest::_internal_set_incremental(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.incremental_ = value;
}

// bool history = 6;
inline void SnapshotWhenTableRequest::clear_history() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.history_ = false;
}
inline bool SnapshotWhenTableRequest::history() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.history)
  return _internal_history();
}
inline void SnapshotWhenTableRequest::set_history(bool value) {
  _internal_set_history(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.history)
}
inline bool SnapshotWhenTableRequest::_internal_history() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.history_;
}
inline void SnapshotWhenTableRequest::_internal_set_history(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.history_ = value;
}

// repeated string stamp_columns = 7;
inline int SnapshotWhenTableRequest::_internal_stamp_columns_size() const {
  return _internal_stamp_columns().size();
}
inline int SnapshotWhenTableRequest::stamp_columns_size() const {
  return _internal_stamp_columns_size();
}
inline void SnapshotWhenTableRequest::clear_stamp_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.stamp_columns_.Clear();
}
inline std::string* SnapshotWhenTableRequest::add_stamp_columns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_stamp_columns()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
  return _s;
}
inline const std::string& SnapshotWhenTableRequest::stamp_columns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
  return _internal_stamp_columns().Get(index);
}
inline std::string* SnapshotWhenTableRequest::mutable_stamp_columns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
  return _internal_mutable_stamp_columns()->Mutable(index);
}
inline void SnapshotWhenTableRequest::set_stamp_columns(int index, const std::string& value) {
  _internal_mutable_stamp_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::set_stamp_columns(int index, std::string&& value) {
  _internal_mutable_stamp_columns()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::set_stamp_columns(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_stamp_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::set_stamp_columns(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_stamp_columns()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::set_stamp_columns(int index, absl::string_view value) {
  _internal_mutable_stamp_columns()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::add_stamp_columns(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_stamp_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::add_stamp_columns(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_stamp_columns()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::add_stamp_columns(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_stamp_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::add_stamp_columns(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_stamp_columns()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline void SnapshotWhenTableRequest::add_stamp_columns(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_stamp_columns()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SnapshotWhenTableRequest::stamp_columns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
  return _internal_stamp_columns();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SnapshotWhenTableRequest::mutable_stamp_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest.stamp_columns)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_stamp_columns();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SnapshotWhenTableRequest::_internal_stamp_columns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.stamp_columns_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SnapshotWhenTableRequest::_internal_mutable_stamp_columns() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.stamp_columns_;
}

// -------------------------------------------------------------------

// CrossJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool CrossJoinTablesRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CrossJoinTablesRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CrossJoinTablesRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void CrossJoinTablesRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CrossJoinTablesRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CrossJoinTablesRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CrossJoinTablesRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CrossJoinTablesRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
  return _msg;
}
inline void CrossJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool CrossJoinTablesRequest::has_left_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_id_ != nullptr);
  return value;
}
inline void CrossJoinTablesRequest::clear_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.left_id_ != nullptr) _impl_.left_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CrossJoinTablesRequest::_internal_left_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CrossJoinTablesRequest::left_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void CrossJoinTablesRequest::unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_id_);
  }
  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::unsafe_arena_release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::_internal_mutable_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::mutable_left_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
  return _msg;
}
inline void CrossJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.left_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool CrossJoinTablesRequest::has_right_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_id_ != nullptr);
  return value;
}
inline void CrossJoinTablesRequest::clear_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_id_ != nullptr) _impl_.right_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CrossJoinTablesRequest::_internal_right_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CrossJoinTablesRequest::right_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void CrossJoinTablesRequest::unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_id_);
  }
  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::unsafe_arena_release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::_internal_mutable_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CrossJoinTablesRequest::mutable_right_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
  return _msg;
}
inline void CrossJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.right_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int CrossJoinTablesRequest::_internal_columns_to_match_size() const {
  return _internal_columns_to_match().size();
}
inline int CrossJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void CrossJoinTablesRequest::clear_columns_to_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_match_.Clear();
}
inline std::string* CrossJoinTablesRequest::add_columns_to_match()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_match()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& CrossJoinTablesRequest::columns_to_match(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match().Get(index);
}
inline std::string* CrossJoinTablesRequest::mutable_columns_to_match(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return _internal_mutable_columns_to_match()->Mutable(index);
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::set_columns_to_match(int index, absl::string_view value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::add_columns_to_match(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::add_columns_to_match(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::add_columns_to_match(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::add_columns_to_match(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline void CrossJoinTablesRequest::add_columns_to_match(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CrossJoinTablesRequest::columns_to_match() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CrossJoinTablesRequest::mutable_columns_to_match() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_match)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_match();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CrossJoinTablesRequest::_internal_columns_to_match() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_match_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CrossJoinTablesRequest::_internal_mutable_columns_to_match() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int CrossJoinTablesRequest::_internal_columns_to_add_size() const {
  return _internal_columns_to_add().size();
}
inline int CrossJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void CrossJoinTablesRequest::clear_columns_to_add() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_add_.Clear();
}
inline std::string* CrossJoinTablesRequest::add_columns_to_add()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_add()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& CrossJoinTablesRequest::columns_to_add(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add().Get(index);
}
inline std::string* CrossJoinTablesRequest::mutable_columns_to_add(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return _internal_mutable_columns_to_add()->Mutable(index);
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::set_columns_to_add(int index, absl::string_view value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::add_columns_to_add(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::add_columns_to_add(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::add_columns_to_add(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::add_columns_to_add(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline void CrossJoinTablesRequest::add_columns_to_add(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CrossJoinTablesRequest::columns_to_add() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CrossJoinTablesRequest::mutable_columns_to_add() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.columns_to_add)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_add();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CrossJoinTablesRequest::_internal_columns_to_add() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_add_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CrossJoinTablesRequest::_internal_mutable_columns_to_add() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_add_;
}

// int32 reserve_bits = 6;
inline void CrossJoinTablesRequest::clear_reserve_bits() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.reserve_bits_ = 0;
}
inline ::int32_t CrossJoinTablesRequest::reserve_bits() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.reserve_bits)
  return _internal_reserve_bits();
}
inline void CrossJoinTablesRequest::set_reserve_bits(::int32_t value) {
  _internal_set_reserve_bits(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest.reserve_bits)
}
inline ::int32_t CrossJoinTablesRequest::_internal_reserve_bits() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.reserve_bits_;
}
inline void CrossJoinTablesRequest::_internal_set_reserve_bits(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.reserve_bits_ = value;
}

// -------------------------------------------------------------------

// NaturalJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool NaturalJoinTablesRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& NaturalJoinTablesRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& NaturalJoinTablesRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void NaturalJoinTablesRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* NaturalJoinTablesRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* NaturalJoinTablesRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* NaturalJoinTablesRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* NaturalJoinTablesRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
  return _msg;
}
inline void NaturalJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool NaturalJoinTablesRequest::has_left_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_id_ != nullptr);
  return value;
}
inline void NaturalJoinTablesRequest::clear_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.left_id_ != nullptr) _impl_.left_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& NaturalJoinTablesRequest::_internal_left_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& NaturalJoinTablesRequest::left_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void NaturalJoinTablesRequest::unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_id_);
  }
  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::unsafe_arena_release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::_internal_mutable_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::mutable_left_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
  return _msg;
}
inline void NaturalJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.left_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool NaturalJoinTablesRequest::has_right_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_id_ != nullptr);
  return value;
}
inline void NaturalJoinTablesRequest::clear_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_id_ != nullptr) _impl_.right_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& NaturalJoinTablesRequest::_internal_right_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& NaturalJoinTablesRequest::right_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void NaturalJoinTablesRequest::unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_id_);
  }
  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::unsafe_arena_release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::_internal_mutable_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* NaturalJoinTablesRequest::mutable_right_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
  return _msg;
}
inline void NaturalJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.right_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int NaturalJoinTablesRequest::_internal_columns_to_match_size() const {
  return _internal_columns_to_match().size();
}
inline int NaturalJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void NaturalJoinTablesRequest::clear_columns_to_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_match_.Clear();
}
inline std::string* NaturalJoinTablesRequest::add_columns_to_match()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_match()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& NaturalJoinTablesRequest::columns_to_match(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match().Get(index);
}
inline std::string* NaturalJoinTablesRequest::mutable_columns_to_match(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return _internal_mutable_columns_to_match()->Mutable(index);
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::set_columns_to_match(int index, absl::string_view value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::add_columns_to_match(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::add_columns_to_match(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::add_columns_to_match(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::add_columns_to_match(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline void NaturalJoinTablesRequest::add_columns_to_match(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
NaturalJoinTablesRequest::columns_to_match() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
NaturalJoinTablesRequest::mutable_columns_to_match() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_match)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_match();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
NaturalJoinTablesRequest::_internal_columns_to_match() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_match_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
NaturalJoinTablesRequest::_internal_mutable_columns_to_match() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int NaturalJoinTablesRequest::_internal_columns_to_add_size() const {
  return _internal_columns_to_add().size();
}
inline int NaturalJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void NaturalJoinTablesRequest::clear_columns_to_add() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_add_.Clear();
}
inline std::string* NaturalJoinTablesRequest::add_columns_to_add()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_add()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& NaturalJoinTablesRequest::columns_to_add(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add().Get(index);
}
inline std::string* NaturalJoinTablesRequest::mutable_columns_to_add(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return _internal_mutable_columns_to_add()->Mutable(index);
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::set_columns_to_add(int index, absl::string_view value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::add_columns_to_add(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::add_columns_to_add(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::add_columns_to_add(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::add_columns_to_add(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline void NaturalJoinTablesRequest::add_columns_to_add(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
NaturalJoinTablesRequest::columns_to_add() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
NaturalJoinTablesRequest::mutable_columns_to_add() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest.columns_to_add)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_add();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
NaturalJoinTablesRequest::_internal_columns_to_add() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_add_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
NaturalJoinTablesRequest::_internal_mutable_columns_to_add() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_add_;
}

// -------------------------------------------------------------------

// ExactJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool ExactJoinTablesRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExactJoinTablesRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ExactJoinTablesRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void ExactJoinTablesRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExactJoinTablesRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExactJoinTablesRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExactJoinTablesRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ExactJoinTablesRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
  return _msg;
}
inline void ExactJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool ExactJoinTablesRequest::has_left_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_id_ != nullptr);
  return value;
}
inline void ExactJoinTablesRequest::clear_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.left_id_ != nullptr) _impl_.left_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExactJoinTablesRequest::_internal_left_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExactJoinTablesRequest::left_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void ExactJoinTablesRequest::unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_id_);
  }
  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::unsafe_arena_release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::_internal_mutable_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::mutable_left_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
  return _msg;
}
inline void ExactJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.left_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool ExactJoinTablesRequest::has_right_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_id_ != nullptr);
  return value;
}
inline void ExactJoinTablesRequest::clear_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_id_ != nullptr) _impl_.right_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExactJoinTablesRequest::_internal_right_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ExactJoinTablesRequest::right_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void ExactJoinTablesRequest::unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_id_);
  }
  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::unsafe_arena_release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::_internal_mutable_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ExactJoinTablesRequest::mutable_right_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
  return _msg;
}
inline void ExactJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.right_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int ExactJoinTablesRequest::_internal_columns_to_match_size() const {
  return _internal_columns_to_match().size();
}
inline int ExactJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void ExactJoinTablesRequest::clear_columns_to_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_match_.Clear();
}
inline std::string* ExactJoinTablesRequest::add_columns_to_match()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_match()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& ExactJoinTablesRequest::columns_to_match(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match().Get(index);
}
inline std::string* ExactJoinTablesRequest::mutable_columns_to_match(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return _internal_mutable_columns_to_match()->Mutable(index);
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::set_columns_to_match(int index, absl::string_view value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::add_columns_to_match(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::add_columns_to_match(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::add_columns_to_match(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::add_columns_to_match(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline void ExactJoinTablesRequest::add_columns_to_match(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ExactJoinTablesRequest::columns_to_match() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ExactJoinTablesRequest::mutable_columns_to_match() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_match)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_match();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ExactJoinTablesRequest::_internal_columns_to_match() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_match_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ExactJoinTablesRequest::_internal_mutable_columns_to_match() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int ExactJoinTablesRequest::_internal_columns_to_add_size() const {
  return _internal_columns_to_add().size();
}
inline int ExactJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void ExactJoinTablesRequest::clear_columns_to_add() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_add_.Clear();
}
inline std::string* ExactJoinTablesRequest::add_columns_to_add()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_add()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& ExactJoinTablesRequest::columns_to_add(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add().Get(index);
}
inline std::string* ExactJoinTablesRequest::mutable_columns_to_add(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return _internal_mutable_columns_to_add()->Mutable(index);
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::set_columns_to_add(int index, absl::string_view value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::add_columns_to_add(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::add_columns_to_add(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::add_columns_to_add(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::add_columns_to_add(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline void ExactJoinTablesRequest::add_columns_to_add(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ExactJoinTablesRequest::columns_to_add() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ExactJoinTablesRequest::mutable_columns_to_add() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest.columns_to_add)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_add();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ExactJoinTablesRequest::_internal_columns_to_add() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_add_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ExactJoinTablesRequest::_internal_mutable_columns_to_add() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_add_;
}

// -------------------------------------------------------------------

// LeftJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool LeftJoinTablesRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& LeftJoinTablesRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& LeftJoinTablesRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void LeftJoinTablesRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* LeftJoinTablesRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* LeftJoinTablesRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* LeftJoinTablesRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* LeftJoinTablesRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
  return _msg;
}
inline void LeftJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool LeftJoinTablesRequest::has_left_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_id_ != nullptr);
  return value;
}
inline void LeftJoinTablesRequest::clear_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.left_id_ != nullptr) _impl_.left_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& LeftJoinTablesRequest::_internal_left_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& LeftJoinTablesRequest::left_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void LeftJoinTablesRequest::unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_id_);
  }
  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::unsafe_arena_release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::_internal_mutable_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::mutable_left_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
  return _msg;
}
inline void LeftJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.left_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool LeftJoinTablesRequest::has_right_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_id_ != nullptr);
  return value;
}
inline void LeftJoinTablesRequest::clear_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_id_ != nullptr) _impl_.right_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& LeftJoinTablesRequest::_internal_right_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& LeftJoinTablesRequest::right_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void LeftJoinTablesRequest::unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_id_);
  }
  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::unsafe_arena_release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::_internal_mutable_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* LeftJoinTablesRequest::mutable_right_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
  return _msg;
}
inline void LeftJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.right_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int LeftJoinTablesRequest::_internal_columns_to_match_size() const {
  return _internal_columns_to_match().size();
}
inline int LeftJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void LeftJoinTablesRequest::clear_columns_to_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_match_.Clear();
}
inline std::string* LeftJoinTablesRequest::add_columns_to_match()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_match()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& LeftJoinTablesRequest::columns_to_match(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match().Get(index);
}
inline std::string* LeftJoinTablesRequest::mutable_columns_to_match(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return _internal_mutable_columns_to_match()->Mutable(index);
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::set_columns_to_match(int index, absl::string_view value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::add_columns_to_match(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::add_columns_to_match(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::add_columns_to_match(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::add_columns_to_match(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline void LeftJoinTablesRequest::add_columns_to_match(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LeftJoinTablesRequest::columns_to_match() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
LeftJoinTablesRequest::mutable_columns_to_match() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_match)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_match();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LeftJoinTablesRequest::_internal_columns_to_match() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_match_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
LeftJoinTablesRequest::_internal_mutable_columns_to_match() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int LeftJoinTablesRequest::_internal_columns_to_add_size() const {
  return _internal_columns_to_add().size();
}
inline int LeftJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void LeftJoinTablesRequest::clear_columns_to_add() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_add_.Clear();
}
inline std::string* LeftJoinTablesRequest::add_columns_to_add()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_add()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& LeftJoinTablesRequest::columns_to_add(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add().Get(index);
}
inline std::string* LeftJoinTablesRequest::mutable_columns_to_add(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return _internal_mutable_columns_to_add()->Mutable(index);
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::set_columns_to_add(int index, absl::string_view value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::add_columns_to_add(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::add_columns_to_add(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::add_columns_to_add(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::add_columns_to_add(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline void LeftJoinTablesRequest::add_columns_to_add(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LeftJoinTablesRequest::columns_to_add() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
LeftJoinTablesRequest::mutable_columns_to_add() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest.columns_to_add)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_add();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
LeftJoinTablesRequest::_internal_columns_to_add() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_add_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
LeftJoinTablesRequest::_internal_mutable_columns_to_add() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_add_;
}

// -------------------------------------------------------------------

// AsOfJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool AsOfJoinTablesRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AsOfJoinTablesRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AsOfJoinTablesRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void AsOfJoinTablesRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AsOfJoinTablesRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AsOfJoinTablesRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AsOfJoinTablesRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AsOfJoinTablesRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
  return _msg;
}
inline void AsOfJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool AsOfJoinTablesRequest::has_left_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_id_ != nullptr);
  return value;
}
inline void AsOfJoinTablesRequest::clear_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.left_id_ != nullptr) _impl_.left_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AsOfJoinTablesRequest::_internal_left_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AsOfJoinTablesRequest::left_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void AsOfJoinTablesRequest::unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_id_);
  }
  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::unsafe_arena_release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::_internal_mutable_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::mutable_left_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
  return _msg;
}
inline void AsOfJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.left_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool AsOfJoinTablesRequest::has_right_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_id_ != nullptr);
  return value;
}
inline void AsOfJoinTablesRequest::clear_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_id_ != nullptr) _impl_.right_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AsOfJoinTablesRequest::_internal_right_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AsOfJoinTablesRequest::right_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void AsOfJoinTablesRequest::unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_id_);
  }
  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::unsafe_arena_release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::_internal_mutable_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AsOfJoinTablesRequest::mutable_right_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
  return _msg;
}
inline void AsOfJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.right_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.right_id)
}

// repeated string columns_to_match = 4;
inline int AsOfJoinTablesRequest::_internal_columns_to_match_size() const {
  return _internal_columns_to_match().size();
}
inline int AsOfJoinTablesRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void AsOfJoinTablesRequest::clear_columns_to_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_match_.Clear();
}
inline std::string* AsOfJoinTablesRequest::add_columns_to_match()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_match()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return _s;
}
inline const std::string& AsOfJoinTablesRequest::columns_to_match(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match().Get(index);
}
inline std::string* AsOfJoinTablesRequest::mutable_columns_to_match(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return _internal_mutable_columns_to_match()->Mutable(index);
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, const std::string& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, std::string&& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::set_columns_to_match(int index, absl::string_view value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::add_columns_to_match(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::add_columns_to_match(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::add_columns_to_match(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::add_columns_to_match(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline void AsOfJoinTablesRequest::add_columns_to_match(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AsOfJoinTablesRequest::columns_to_match() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  return _internal_columns_to_match();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AsOfJoinTablesRequest::mutable_columns_to_match() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_match)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_match();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AsOfJoinTablesRequest::_internal_columns_to_match() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_match_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AsOfJoinTablesRequest::_internal_mutable_columns_to_match() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_match_;
}

// repeated string columns_to_add = 5;
inline int AsOfJoinTablesRequest::_internal_columns_to_add_size() const {
  return _internal_columns_to_add().size();
}
inline int AsOfJoinTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void AsOfJoinTablesRequest::clear_columns_to_add() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_add_.Clear();
}
inline std::string* AsOfJoinTablesRequest::add_columns_to_add()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_add()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& AsOfJoinTablesRequest::columns_to_add(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add().Get(index);
}
inline std::string* AsOfJoinTablesRequest::mutable_columns_to_add(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return _internal_mutable_columns_to_add()->Mutable(index);
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, const std::string& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, std::string&& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::set_columns_to_add(int index, absl::string_view value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::add_columns_to_add(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::add_columns_to_add(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::add_columns_to_add(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::add_columns_to_add(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline void AsOfJoinTablesRequest::add_columns_to_add(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AsOfJoinTablesRequest::columns_to_add() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  return _internal_columns_to_add();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AsOfJoinTablesRequest::mutable_columns_to_add() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.columns_to_add)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_add();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AsOfJoinTablesRequest::_internal_columns_to_add() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_add_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AsOfJoinTablesRequest::_internal_mutable_columns_to_add() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_add_;
}

// .io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.MatchRule as_of_match_rule = 7;
inline void AsOfJoinTablesRequest::clear_as_of_match_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.as_of_match_rule_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule AsOfJoinTablesRequest::as_of_match_rule() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.as_of_match_rule)
  return _internal_as_of_match_rule();
}
inline void AsOfJoinTablesRequest::set_as_of_match_rule(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule value) {
  _internal_set_as_of_match_rule(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest.as_of_match_rule)
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule AsOfJoinTablesRequest::_internal_as_of_match_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule>(_impl_.as_of_match_rule_);
}
inline void AsOfJoinTablesRequest::_internal_set_as_of_match_rule(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.as_of_match_rule_ = value;
}

// -------------------------------------------------------------------

// AjRajTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool AjRajTablesRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AjRajTablesRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AjRajTablesRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.result_id)
  return _internal_result_id();
}
inline void AjRajTablesRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AjRajTablesRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AjRajTablesRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AjRajTablesRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AjRajTablesRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.result_id)
  return _msg;
}
inline void AjRajTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool AjRajTablesRequest::has_left_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_id_ != nullptr);
  return value;
}
inline void AjRajTablesRequest::clear_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.left_id_ != nullptr) _impl_.left_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AjRajTablesRequest::_internal_left_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AjRajTablesRequest::left_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.left_id)
  return _internal_left_id();
}
inline void AjRajTablesRequest::unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_id_);
  }
  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::unsafe_arena_release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.left_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::_internal_mutable_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::mutable_left_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.left_id)
  return _msg;
}
inline void AjRajTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.left_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool AjRajTablesRequest::has_right_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_id_ != nullptr);
  return value;
}
inline void AjRajTablesRequest::clear_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_id_ != nullptr) _impl_.right_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AjRajTablesRequest::_internal_right_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AjRajTablesRequest::right_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.right_id)
  return _internal_right_id();
}
inline void AjRajTablesRequest::unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_id_);
  }
  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::unsafe_arena_release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.right_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::_internal_mutable_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AjRajTablesRequest::mutable_right_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.right_id)
  return _msg;
}
inline void AjRajTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.right_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.right_id)
}

// repeated string exact_match_columns = 4;
inline int AjRajTablesRequest::_internal_exact_match_columns_size() const {
  return _internal_exact_match_columns().size();
}
inline int AjRajTablesRequest::exact_match_columns_size() const {
  return _internal_exact_match_columns_size();
}
inline void AjRajTablesRequest::clear_exact_match_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exact_match_columns_.Clear();
}
inline std::string* AjRajTablesRequest::add_exact_match_columns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_exact_match_columns()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
  return _s;
}
inline const std::string& AjRajTablesRequest::exact_match_columns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
  return _internal_exact_match_columns().Get(index);
}
inline std::string* AjRajTablesRequest::mutable_exact_match_columns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
  return _internal_mutable_exact_match_columns()->Mutable(index);
}
inline void AjRajTablesRequest::set_exact_match_columns(int index, const std::string& value) {
  _internal_mutable_exact_match_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::set_exact_match_columns(int index, std::string&& value) {
  _internal_mutable_exact_match_columns()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::set_exact_match_columns(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_exact_match_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::set_exact_match_columns(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_exact_match_columns()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::set_exact_match_columns(int index, absl::string_view value) {
  _internal_mutable_exact_match_columns()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::add_exact_match_columns(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_exact_match_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::add_exact_match_columns(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_exact_match_columns()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::add_exact_match_columns(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_exact_match_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::add_exact_match_columns(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_exact_match_columns()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline void AjRajTablesRequest::add_exact_match_columns(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_exact_match_columns()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AjRajTablesRequest::exact_match_columns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
  return _internal_exact_match_columns();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AjRajTablesRequest::mutable_exact_match_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.exact_match_columns)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_exact_match_columns();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AjRajTablesRequest::_internal_exact_match_columns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exact_match_columns_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AjRajTablesRequest::_internal_mutable_exact_match_columns() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.exact_match_columns_;
}

// string as_of_column = 5;
inline void AjRajTablesRequest::clear_as_of_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.as_of_column_.ClearToEmpty();
}
inline const std::string& AjRajTablesRequest::as_of_column() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.as_of_column)
  return _internal_as_of_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AjRajTablesRequest::set_as_of_column(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.as_of_column_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.as_of_column)
}
inline std::string* AjRajTablesRequest::mutable_as_of_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_as_of_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.as_of_column)
  return _s;
}
inline const std::string& AjRajTablesRequest::_internal_as_of_column() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.as_of_column_.Get();
}
inline void AjRajTablesRequest::_internal_set_as_of_column(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.as_of_column_.Set(value, GetArena());
}
inline std::string* AjRajTablesRequest::_internal_mutable_as_of_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.as_of_column_.Mutable( GetArena());
}
inline std::string* AjRajTablesRequest::release_as_of_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.as_of_column)
  return _impl_.as_of_column_.Release();
}
inline void AjRajTablesRequest::set_allocated_as_of_column(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.as_of_column_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.as_of_column_.IsDefault()) {
          _impl_.as_of_column_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.as_of_column)
}

// repeated string columns_to_add = 6;
inline int AjRajTablesRequest::_internal_columns_to_add_size() const {
  return _internal_columns_to_add().size();
}
inline int AjRajTablesRequest::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void AjRajTablesRequest::clear_columns_to_add() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_add_.Clear();
}
inline std::string* AjRajTablesRequest::add_columns_to_add()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_add()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
  return _s;
}
inline const std::string& AjRajTablesRequest::columns_to_add(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
  return _internal_columns_to_add().Get(index);
}
inline std::string* AjRajTablesRequest::mutable_columns_to_add(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
  return _internal_mutable_columns_to_add()->Mutable(index);
}
inline void AjRajTablesRequest::set_columns_to_add(int index, const std::string& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::set_columns_to_add(int index, std::string&& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::set_columns_to_add(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::set_columns_to_add(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::set_columns_to_add(int index, absl::string_view value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::add_columns_to_add(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::add_columns_to_add(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::add_columns_to_add(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::add_columns_to_add(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline void AjRajTablesRequest::add_columns_to_add(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AjRajTablesRequest::columns_to_add() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
  return _internal_columns_to_add();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AjRajTablesRequest::mutable_columns_to_add() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AjRajTablesRequest.columns_to_add)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_add();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AjRajTablesRequest::_internal_columns_to_add() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_add_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AjRajTablesRequest::_internal_mutable_columns_to_add() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_add_;
}

// -------------------------------------------------------------------

// MultiJoinInput

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 1;
inline bool MultiJoinInput::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void MultiJoinInput::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& MultiJoinInput::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& MultiJoinInput::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MultiJoinInput.source_id)
  return _internal_source_id();
}
inline void MultiJoinInput::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.MultiJoinInput.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MultiJoinInput::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MultiJoinInput::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MultiJoinInput.source_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MultiJoinInput::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MultiJoinInput::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MultiJoinInput.source_id)
  return _msg;
}
inline void MultiJoinInput::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MultiJoinInput.source_id)
}

// repeated string columns_to_match = 2;
inline int MultiJoinInput::_internal_columns_to_match_size() const {
  return _internal_columns_to_match().size();
}
inline int MultiJoinInput::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void MultiJoinInput::clear_columns_to_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_match_.Clear();
}
inline std::string* MultiJoinInput::add_columns_to_match()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_match()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
  return _s;
}
inline const std::string& MultiJoinInput::columns_to_match(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
  return _internal_columns_to_match().Get(index);
}
inline std::string* MultiJoinInput::mutable_columns_to_match(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
  return _internal_mutable_columns_to_match()->Mutable(index);
}
inline void MultiJoinInput::set_columns_to_match(int index, const std::string& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
}
inline void MultiJoinInput::set_columns_to_match(int index, std::string&& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
}
inline void MultiJoinInput::set_columns_to_match(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
}
inline void MultiJoinInput::set_columns_to_match(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
}
inline void MultiJoinInput::set_columns_to_match(int index, absl::string_view value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
}
inline void MultiJoinInput::add_columns_to_match(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
}
inline void MultiJoinInput::add_columns_to_match(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
}
inline void MultiJoinInput::add_columns_to_match(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
}
inline void MultiJoinInput::add_columns_to_match(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
}
inline void MultiJoinInput::add_columns_to_match(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MultiJoinInput::columns_to_match() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
  return _internal_columns_to_match();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MultiJoinInput::mutable_columns_to_match() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_match)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_match();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MultiJoinInput::_internal_columns_to_match() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_match_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MultiJoinInput::_internal_mutable_columns_to_match() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_match_;
}

// repeated string columns_to_add = 3;
inline int MultiJoinInput::_internal_columns_to_add_size() const {
  return _internal_columns_to_add().size();
}
inline int MultiJoinInput::columns_to_add_size() const {
  return _internal_columns_to_add_size();
}
inline void MultiJoinInput::clear_columns_to_add() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_add_.Clear();
}
inline std::string* MultiJoinInput::add_columns_to_add()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_add()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
  return _s;
}
inline const std::string& MultiJoinInput::columns_to_add(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
  return _internal_columns_to_add().Get(index);
}
inline std::string* MultiJoinInput::mutable_columns_to_add(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
  return _internal_mutable_columns_to_add()->Mutable(index);
}
inline void MultiJoinInput::set_columns_to_add(int index, const std::string& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
}
inline void MultiJoinInput::set_columns_to_add(int index, std::string&& value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
}
inline void MultiJoinInput::set_columns_to_add(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
}
inline void MultiJoinInput::set_columns_to_add(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
}
inline void MultiJoinInput::set_columns_to_add(int index, absl::string_view value) {
  _internal_mutable_columns_to_add()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
}
inline void MultiJoinInput::add_columns_to_add(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
}
inline void MultiJoinInput::add_columns_to_add(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
}
inline void MultiJoinInput::add_columns_to_add(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
}
inline void MultiJoinInput::add_columns_to_add(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
}
inline void MultiJoinInput::add_columns_to_add(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_add()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MultiJoinInput::columns_to_add() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
  return _internal_columns_to_add();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MultiJoinInput::mutable_columns_to_add() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.MultiJoinInput.columns_to_add)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_add();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MultiJoinInput::_internal_columns_to_add() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_add_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MultiJoinInput::_internal_mutable_columns_to_add() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_add_;
}

// -------------------------------------------------------------------

// MultiJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool MultiJoinTablesRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& MultiJoinTablesRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& MultiJoinTablesRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void MultiJoinTablesRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MultiJoinTablesRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MultiJoinTablesRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MultiJoinTablesRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MultiJoinTablesRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest.result_id)
  return _msg;
}
inline void MultiJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest.result_id)
}

// repeated .io.deephaven.proto.backplane.grpc.MultiJoinInput multi_join_inputs = 2;
inline int MultiJoinTablesRequest::_internal_multi_join_inputs_size() const {
  return _internal_multi_join_inputs().size();
}
inline int MultiJoinTablesRequest::multi_join_inputs_size() const {
  return _internal_multi_join_inputs_size();
}
inline void MultiJoinTablesRequest::clear_multi_join_inputs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.multi_join_inputs_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::MultiJoinInput* MultiJoinTablesRequest::mutable_multi_join_inputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest.multi_join_inputs)
  return _internal_mutable_multi_join_inputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::MultiJoinInput>* MultiJoinTablesRequest::mutable_multi_join_inputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest.multi_join_inputs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_multi_join_inputs();
}
inline const ::io::deephaven::proto::backplane::grpc::MultiJoinInput& MultiJoinTablesRequest::multi_join_inputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest.multi_join_inputs)
  return _internal_multi_join_inputs().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::MultiJoinInput* MultiJoinTablesRequest::add_multi_join_inputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::MultiJoinInput* _add = _internal_mutable_multi_join_inputs()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest.multi_join_inputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::MultiJoinInput>& MultiJoinTablesRequest::multi_join_inputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest.multi_join_inputs)
  return _internal_multi_join_inputs();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::MultiJoinInput>&
MultiJoinTablesRequest::_internal_multi_join_inputs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.multi_join_inputs_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::MultiJoinInput>*
MultiJoinTablesRequest::_internal_mutable_multi_join_inputs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.multi_join_inputs_;
}

// -------------------------------------------------------------------

// RangeJoinTablesRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool RangeJoinTablesRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& RangeJoinTablesRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& RangeJoinTablesRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.result_id)
  return _internal_result_id();
}
inline void RangeJoinTablesRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RangeJoinTablesRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RangeJoinTablesRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RangeJoinTablesRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RangeJoinTablesRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.result_id)
  return _msg;
}
inline void RangeJoinTablesRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool RangeJoinTablesRequest::has_left_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_id_ != nullptr);
  return value;
}
inline void RangeJoinTablesRequest::clear_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.left_id_ != nullptr) _impl_.left_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RangeJoinTablesRequest::_internal_left_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RangeJoinTablesRequest::left_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_id)
  return _internal_left_id();
}
inline void RangeJoinTablesRequest::unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_id_);
  }
  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::unsafe_arena_release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::_internal_mutable_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::mutable_left_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_id)
  return _msg;
}
inline void RangeJoinTablesRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.left_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool RangeJoinTablesRequest::has_right_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_id_ != nullptr);
  return value;
}
inline void RangeJoinTablesRequest::clear_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_id_ != nullptr) _impl_.right_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RangeJoinTablesRequest::_internal_right_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RangeJoinTablesRequest::right_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_id)
  return _internal_right_id();
}
inline void RangeJoinTablesRequest::unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_id_);
  }
  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::unsafe_arena_release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::_internal_mutable_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RangeJoinTablesRequest::mutable_right_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_id)
  return _msg;
}
inline void RangeJoinTablesRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.right_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_id)
}

// repeated string exact_match_columns = 4;
inline int RangeJoinTablesRequest::_internal_exact_match_columns_size() const {
  return _internal_exact_match_columns().size();
}
inline int RangeJoinTablesRequest::exact_match_columns_size() const {
  return _internal_exact_match_columns_size();
}
inline void RangeJoinTablesRequest::clear_exact_match_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.exact_match_columns_.Clear();
}
inline std::string* RangeJoinTablesRequest::add_exact_match_columns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_exact_match_columns()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
  return _s;
}
inline const std::string& RangeJoinTablesRequest::exact_match_columns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
  return _internal_exact_match_columns().Get(index);
}
inline std::string* RangeJoinTablesRequest::mutable_exact_match_columns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
  return _internal_mutable_exact_match_columns()->Mutable(index);
}
inline void RangeJoinTablesRequest::set_exact_match_columns(int index, const std::string& value) {
  _internal_mutable_exact_match_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::set_exact_match_columns(int index, std::string&& value) {
  _internal_mutable_exact_match_columns()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::set_exact_match_columns(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_exact_match_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::set_exact_match_columns(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_exact_match_columns()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::set_exact_match_columns(int index, absl::string_view value) {
  _internal_mutable_exact_match_columns()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::add_exact_match_columns(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_exact_match_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::add_exact_match_columns(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_exact_match_columns()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::add_exact_match_columns(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_exact_match_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::add_exact_match_columns(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_exact_match_columns()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline void RangeJoinTablesRequest::add_exact_match_columns(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_exact_match_columns()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RangeJoinTablesRequest::exact_match_columns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
  return _internal_exact_match_columns();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RangeJoinTablesRequest::mutable_exact_match_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.exact_match_columns)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_exact_match_columns();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RangeJoinTablesRequest::_internal_exact_match_columns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.exact_match_columns_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RangeJoinTablesRequest::_internal_mutable_exact_match_columns() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.exact_match_columns_;
}

// string left_start_column = 5;
inline void RangeJoinTablesRequest::clear_left_start_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.left_start_column_.ClearToEmpty();
}
inline const std::string& RangeJoinTablesRequest::left_start_column() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_start_column)
  return _internal_left_start_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RangeJoinTablesRequest::set_left_start_column(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.left_start_column_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_start_column)
}
inline std::string* RangeJoinTablesRequest::mutable_left_start_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_left_start_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_start_column)
  return _s;
}
inline const std::string& RangeJoinTablesRequest::_internal_left_start_column() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.left_start_column_.Get();
}
inline void RangeJoinTablesRequest::_internal_set_left_start_column(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.left_start_column_.Set(value, GetArena());
}
inline std::string* RangeJoinTablesRequest::_internal_mutable_left_start_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.left_start_column_.Mutable( GetArena());
}
inline std::string* RangeJoinTablesRequest::release_left_start_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_start_column)
  return _impl_.left_start_column_.Release();
}
inline void RangeJoinTablesRequest::set_allocated_left_start_column(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.left_start_column_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.left_start_column_.IsDefault()) {
          _impl_.left_start_column_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_start_column)
}

// .io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.RangeStartRule range_start_rule = 6;
inline void RangeJoinTablesRequest::clear_range_start_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.range_start_rule_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule RangeJoinTablesRequest::range_start_rule() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_start_rule)
  return _internal_range_start_rule();
}
inline void RangeJoinTablesRequest::set_range_start_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule value) {
  _internal_set_range_start_rule(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_start_rule)
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule RangeJoinTablesRequest::_internal_range_start_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule>(_impl_.range_start_rule_);
}
inline void RangeJoinTablesRequest::_internal_set_range_start_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.range_start_rule_ = value;
}

// string right_range_column = 7;
inline void RangeJoinTablesRequest::clear_right_range_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.right_range_column_.ClearToEmpty();
}
inline const std::string& RangeJoinTablesRequest::right_range_column() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_range_column)
  return _internal_right_range_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RangeJoinTablesRequest::set_right_range_column(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.right_range_column_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_range_column)
}
inline std::string* RangeJoinTablesRequest::mutable_right_range_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_right_range_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_range_column)
  return _s;
}
inline const std::string& RangeJoinTablesRequest::_internal_right_range_column() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.right_range_column_.Get();
}
inline void RangeJoinTablesRequest::_internal_set_right_range_column(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.right_range_column_.Set(value, GetArena());
}
inline std::string* RangeJoinTablesRequest::_internal_mutable_right_range_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.right_range_column_.Mutable( GetArena());
}
inline std::string* RangeJoinTablesRequest::release_right_range_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_range_column)
  return _impl_.right_range_column_.Release();
}
inline void RangeJoinTablesRequest::set_allocated_right_range_column(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.right_range_column_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.right_range_column_.IsDefault()) {
          _impl_.right_range_column_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.right_range_column)
}

// .io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.RangeEndRule range_end_rule = 8;
inline void RangeJoinTablesRequest::clear_range_end_rule() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.range_end_rule_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule RangeJoinTablesRequest::range_end_rule() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_end_rule)
  return _internal_range_end_rule();
}
inline void RangeJoinTablesRequest::set_range_end_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule value) {
  _internal_set_range_end_rule(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_end_rule)
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule RangeJoinTablesRequest::_internal_range_end_rule() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule>(_impl_.range_end_rule_);
}
inline void RangeJoinTablesRequest::_internal_set_range_end_rule(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.range_end_rule_ = value;
}

// string left_end_column = 9;
inline void RangeJoinTablesRequest::clear_left_end_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.left_end_column_.ClearToEmpty();
}
inline const std::string& RangeJoinTablesRequest::left_end_column() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_end_column)
  return _internal_left_end_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RangeJoinTablesRequest::set_left_end_column(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.left_end_column_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_end_column)
}
inline std::string* RangeJoinTablesRequest::mutable_left_end_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_left_end_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_end_column)
  return _s;
}
inline const std::string& RangeJoinTablesRequest::_internal_left_end_column() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.left_end_column_.Get();
}
inline void RangeJoinTablesRequest::_internal_set_left_end_column(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.left_end_column_.Set(value, GetArena());
}
inline std::string* RangeJoinTablesRequest::_internal_mutable_left_end_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.left_end_column_.Mutable( GetArena());
}
inline std::string* RangeJoinTablesRequest::release_left_end_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_end_column)
  return _impl_.left_end_column_.Release();
}
inline void RangeJoinTablesRequest::set_allocated_left_end_column(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.left_end_column_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.left_end_column_.IsDefault()) {
          _impl_.left_end_column_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.left_end_column)
}

// repeated .io.deephaven.proto.backplane.grpc.Aggregation aggregations = 10;
inline int RangeJoinTablesRequest::_internal_aggregations_size() const {
  return _internal_aggregations().size();
}
inline int RangeJoinTablesRequest::aggregations_size() const {
  return _internal_aggregations_size();
}
inline void RangeJoinTablesRequest::clear_aggregations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.aggregations_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation* RangeJoinTablesRequest::mutable_aggregations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.aggregations)
  return _internal_mutable_aggregations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Aggregation>* RangeJoinTablesRequest::mutable_aggregations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.aggregations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_aggregations();
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation& RangeJoinTablesRequest::aggregations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.aggregations)
  return _internal_aggregations().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation* RangeJoinTablesRequest::add_aggregations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::Aggregation* _add = _internal_mutable_aggregations()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.aggregations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Aggregation>& RangeJoinTablesRequest::aggregations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.aggregations)
  return _internal_aggregations();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Aggregation>&
RangeJoinTablesRequest::_internal_aggregations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.aggregations_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Aggregation>*
RangeJoinTablesRequest::_internal_mutable_aggregations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.aggregations_;
}

// string range_match = 11;
inline void RangeJoinTablesRequest::clear_range_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.range_match_.ClearToEmpty();
}
inline const std::string& RangeJoinTablesRequest::range_match() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_match)
  return _internal_range_match();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RangeJoinTablesRequest::set_range_match(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.range_match_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_match)
}
inline std::string* RangeJoinTablesRequest::mutable_range_match() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_range_match();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_match)
  return _s;
}
inline const std::string& RangeJoinTablesRequest::_internal_range_match() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.range_match_.Get();
}
inline void RangeJoinTablesRequest::_internal_set_range_match(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.range_match_.Set(value, GetArena());
}
inline std::string* RangeJoinTablesRequest::_internal_mutable_range_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.range_match_.Mutable( GetArena());
}
inline std::string* RangeJoinTablesRequest::release_range_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_match)
  return _impl_.range_match_.Release();
}
inline void RangeJoinTablesRequest::set_allocated_range_match(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.range_match_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.range_match_.IsDefault()) {
          _impl_.range_match_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest.range_match)
}

// -------------------------------------------------------------------

// ComboAggregateRequest_Aggregate

// .io.deephaven.proto.backplane.grpc.ComboAggregateRequest.AggType type = 1;
inline void ComboAggregateRequest_Aggregate::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType ComboAggregateRequest_Aggregate::type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.type)
  return _internal_type();
}
inline void ComboAggregateRequest_Aggregate::set_type(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.type)
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType ComboAggregateRequest_Aggregate::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType>(_impl_.type_);
}
inline void ComboAggregateRequest_Aggregate::_internal_set_type(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_ = value;
}

// repeated string match_pairs = 2;
inline int ComboAggregateRequest_Aggregate::_internal_match_pairs_size() const {
  return _internal_match_pairs().size();
}
inline int ComboAggregateRequest_Aggregate::match_pairs_size() const {
  return _internal_match_pairs_size();
}
inline void ComboAggregateRequest_Aggregate::clear_match_pairs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.match_pairs_.Clear();
}
inline std::string* ComboAggregateRequest_Aggregate::add_match_pairs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_match_pairs()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return _s;
}
inline const std::string& ComboAggregateRequest_Aggregate::match_pairs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return _internal_match_pairs().Get(index);
}
inline std::string* ComboAggregateRequest_Aggregate::mutable_match_pairs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return _internal_mutable_match_pairs()->Mutable(index);
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, const std::string& value) {
  _internal_mutable_match_pairs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, std::string&& value) {
  _internal_mutable_match_pairs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_match_pairs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_match_pairs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::set_match_pairs(int index, absl::string_view value) {
  _internal_mutable_match_pairs()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline void ComboAggregateRequest_Aggregate::add_match_pairs(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ComboAggregateRequest_Aggregate::match_pairs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  return _internal_match_pairs();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ComboAggregateRequest_Aggregate::mutable_match_pairs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.match_pairs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_match_pairs();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ComboAggregateRequest_Aggregate::_internal_match_pairs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.match_pairs_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ComboAggregateRequest_Aggregate::_internal_mutable_match_pairs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.match_pairs_;
}

// string column_name = 3;
inline void ComboAggregateRequest_Aggregate::clear_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& ComboAggregateRequest_Aggregate::column_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
  return _internal_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ComboAggregateRequest_Aggregate::set_column_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
}
inline std::string* ComboAggregateRequest_Aggregate::mutable_column_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
  return _s;
}
inline const std::string& ComboAggregateRequest_Aggregate::_internal_column_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_name_.Get();
}
inline void ComboAggregateRequest_Aggregate::_internal_set_column_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(value, GetArena());
}
inline std::string* ComboAggregateRequest_Aggregate::_internal_mutable_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.column_name_.Mutable( GetArena());
}
inline std::string* ComboAggregateRequest_Aggregate::release_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
  return _impl_.column_name_.Release();
}
inline void ComboAggregateRequest_Aggregate::set_allocated_column_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_name_.IsDefault()) {
          _impl_.column_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.column_name)
}

// double percentile = 4;
inline void ComboAggregateRequest_Aggregate::clear_percentile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.percentile_ = 0;
}
inline double ComboAggregateRequest_Aggregate::percentile() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.percentile)
  return _internal_percentile();
}
inline void ComboAggregateRequest_Aggregate::set_percentile(double value) {
  _internal_set_percentile(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.percentile)
}
inline double ComboAggregateRequest_Aggregate::_internal_percentile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.percentile_;
}
inline void ComboAggregateRequest_Aggregate::_internal_set_percentile(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.percentile_ = value;
}

// bool avg_median = 5;
inline void ComboAggregateRequest_Aggregate::clear_avg_median() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.avg_median_ = false;
}
inline bool ComboAggregateRequest_Aggregate::avg_median() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.avg_median)
  return _internal_avg_median();
}
inline void ComboAggregateRequest_Aggregate::set_avg_median(bool value) {
  _internal_set_avg_median(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate.avg_median)
}
inline bool ComboAggregateRequest_Aggregate::_internal_avg_median() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.avg_median_;
}
inline void ComboAggregateRequest_Aggregate::_internal_set_avg_median(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.avg_median_ = value;
}

// -------------------------------------------------------------------

// ComboAggregateRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool ComboAggregateRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ComboAggregateRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ComboAggregateRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
  return _internal_result_id();
}
inline void ComboAggregateRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ComboAggregateRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ComboAggregateRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ComboAggregateRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ComboAggregateRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
  return _msg;
}
inline void ComboAggregateRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool ComboAggregateRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void ComboAggregateRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ComboAggregateRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ComboAggregateRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
  return _internal_source_id();
}
inline void ComboAggregateRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ComboAggregateRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ComboAggregateRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ComboAggregateRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ComboAggregateRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
  return _msg;
}
inline void ComboAggregateRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.source_id)
}

// repeated .io.deephaven.proto.backplane.grpc.ComboAggregateRequest.Aggregate aggregates = 3;
inline int ComboAggregateRequest::_internal_aggregates_size() const {
  return _internal_aggregates().size();
}
inline int ComboAggregateRequest::aggregates_size() const {
  return _internal_aggregates_size();
}
inline void ComboAggregateRequest::clear_aggregates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.aggregates_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* ComboAggregateRequest::mutable_aggregates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return _internal_mutable_aggregates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate>* ComboAggregateRequest::mutable_aggregates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_aggregates();
}
inline const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate& ComboAggregateRequest::aggregates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return _internal_aggregates().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* ComboAggregateRequest::add_aggregates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate* _add = _internal_mutable_aggregates()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate>& ComboAggregateRequest::aggregates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.aggregates)
  return _internal_aggregates();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate>&
ComboAggregateRequest::_internal_aggregates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.aggregates_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_Aggregate>*
ComboAggregateRequest::_internal_mutable_aggregates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.aggregates_;
}

// repeated string group_by_columns = 4;
inline int ComboAggregateRequest::_internal_group_by_columns_size() const {
  return _internal_group_by_columns().size();
}
inline int ComboAggregateRequest::group_by_columns_size() const {
  return _internal_group_by_columns_size();
}
inline void ComboAggregateRequest::clear_group_by_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_by_columns_.Clear();
}
inline std::string* ComboAggregateRequest::add_group_by_columns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_group_by_columns()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return _s;
}
inline const std::string& ComboAggregateRequest::group_by_columns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return _internal_group_by_columns().Get(index);
}
inline std::string* ComboAggregateRequest::mutable_group_by_columns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return _internal_mutable_group_by_columns()->Mutable(index);
}
inline void ComboAggregateRequest::set_group_by_columns(int index, const std::string& value) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::set_group_by_columns(int index, std::string&& value) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::set_group_by_columns(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_group_by_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::set_group_by_columns(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::set_group_by_columns(int index, absl::string_view value) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::add_group_by_columns(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::add_group_by_columns(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::add_group_by_columns(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::add_group_by_columns(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline void ComboAggregateRequest::add_group_by_columns(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ComboAggregateRequest::group_by_columns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  return _internal_group_by_columns();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ComboAggregateRequest::mutable_group_by_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.group_by_columns)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_group_by_columns();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
ComboAggregateRequest::_internal_group_by_columns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_by_columns_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
ComboAggregateRequest::_internal_mutable_group_by_columns() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.group_by_columns_;
}

// bool force_combo = 5;
inline void ComboAggregateRequest::clear_force_combo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.force_combo_ = false;
}
inline bool ComboAggregateRequest::force_combo() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.force_combo)
  return _internal_force_combo();
}
inline void ComboAggregateRequest::set_force_combo(bool value) {
  _internal_set_force_combo(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ComboAggregateRequest.force_combo)
}
inline bool ComboAggregateRequest::_internal_force_combo() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.force_combo_;
}
inline void ComboAggregateRequest::_internal_set_force_combo(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.force_combo_ = value;
}

// -------------------------------------------------------------------

// AggregateAllRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool AggregateAllRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AggregateAllRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AggregateAllRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateAllRequest.result_id)
  return _internal_result_id();
}
inline void AggregateAllRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggregateAllRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateAllRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateAllRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggregateAllRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateAllRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateAllRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateAllRequest.result_id)
  return _msg;
}
inline void AggregateAllRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggregateAllRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool AggregateAllRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void AggregateAllRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AggregateAllRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AggregateAllRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateAllRequest.source_id)
  return _internal_source_id();
}
inline void AggregateAllRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggregateAllRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateAllRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateAllRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggregateAllRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateAllRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateAllRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateAllRequest.source_id)
  return _msg;
}
inline void AggregateAllRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggregateAllRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.AggSpec spec = 3;
inline bool AggregateAllRequest::has_spec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spec_ != nullptr);
  return value;
}
inline void AggregateAllRequest::clear_spec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.spec_ != nullptr) _impl_.spec_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec& AggregateAllRequest::_internal_spec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::AggSpec* p = _impl_.spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::AggSpec&>(::io::deephaven::proto::backplane::grpc::_AggSpec_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec& AggregateAllRequest::spec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateAllRequest.spec)
  return _internal_spec();
}
inline void AggregateAllRequest::unsafe_arena_set_allocated_spec(::io::deephaven::proto::backplane::grpc::AggSpec* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spec_);
  }
  _impl_.spec_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggregateAllRequest.spec)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* AggregateAllRequest::release_spec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::AggSpec* released = _impl_.spec_;
  _impl_.spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* AggregateAllRequest::unsafe_arena_release_spec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggregateAllRequest.spec)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::AggSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* AggregateAllRequest::_internal_mutable_spec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec>(GetArena());
    _impl_.spec_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec*>(p);
  }
  return _impl_.spec_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* AggregateAllRequest::mutable_spec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateAllRequest.spec)
  return _msg;
}
inline void AggregateAllRequest::set_allocated_spec(::io::deephaven::proto::backplane::grpc::AggSpec* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec*>(_impl_.spec_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.spec_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggregateAllRequest.spec)
}

// repeated string group_by_columns = 4;
inline int AggregateAllRequest::_internal_group_by_columns_size() const {
  return _internal_group_by_columns().size();
}
inline int AggregateAllRequest::group_by_columns_size() const {
  return _internal_group_by_columns_size();
}
inline void AggregateAllRequest::clear_group_by_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_by_columns_.Clear();
}
inline std::string* AggregateAllRequest::add_group_by_columns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_group_by_columns()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
  return _s;
}
inline const std::string& AggregateAllRequest::group_by_columns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
  return _internal_group_by_columns().Get(index);
}
inline std::string* AggregateAllRequest::mutable_group_by_columns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
  return _internal_mutable_group_by_columns()->Mutable(index);
}
inline void AggregateAllRequest::set_group_by_columns(int index, const std::string& value) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::set_group_by_columns(int index, std::string&& value) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::set_group_by_columns(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_group_by_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::set_group_by_columns(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::set_group_by_columns(int index, absl::string_view value) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::add_group_by_columns(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::add_group_by_columns(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::add_group_by_columns(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::add_group_by_columns(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline void AggregateAllRequest::add_group_by_columns(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AggregateAllRequest::group_by_columns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
  return _internal_group_by_columns();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AggregateAllRequest::mutable_group_by_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AggregateAllRequest.group_by_columns)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_group_by_columns();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AggregateAllRequest::_internal_group_by_columns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_by_columns_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AggregateAllRequest::_internal_mutable_group_by_columns() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.group_by_columns_;
}

// -------------------------------------------------------------------

// AggSpec_AggSpecApproximatePercentile

// double percentile = 1;
inline void AggSpec_AggSpecApproximatePercentile::clear_percentile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.percentile_ = 0;
}
inline double AggSpec_AggSpecApproximatePercentile::percentile() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile.percentile)
  return _internal_percentile();
}
inline void AggSpec_AggSpecApproximatePercentile::set_percentile(double value) {
  _internal_set_percentile(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile.percentile)
}
inline double AggSpec_AggSpecApproximatePercentile::_internal_percentile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.percentile_;
}
inline void AggSpec_AggSpecApproximatePercentile::_internal_set_percentile(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.percentile_ = value;
}

// optional double compression = 2;
inline bool AggSpec_AggSpecApproximatePercentile::has_compression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AggSpec_AggSpecApproximatePercentile::clear_compression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.compression_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double AggSpec_AggSpecApproximatePercentile::compression() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile.compression)
  return _internal_compression();
}
inline void AggSpec_AggSpecApproximatePercentile::set_compression(double value) {
  _internal_set_compression(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile.compression)
}
inline double AggSpec_AggSpecApproximatePercentile::_internal_compression() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compression_;
}
inline void AggSpec_AggSpecApproximatePercentile::_internal_set_compression(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.compression_ = value;
}

// -------------------------------------------------------------------

// AggSpec_AggSpecCountDistinct

// bool count_nulls = 1;
inline void AggSpec_AggSpecCountDistinct::clear_count_nulls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.count_nulls_ = false;
}
inline bool AggSpec_AggSpecCountDistinct::count_nulls() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct.count_nulls)
  return _internal_count_nulls();
}
inline void AggSpec_AggSpecCountDistinct::set_count_nulls(bool value) {
  _internal_set_count_nulls(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct.count_nulls)
}
inline bool AggSpec_AggSpecCountDistinct::_internal_count_nulls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.count_nulls_;
}
inline void AggSpec_AggSpecCountDistinct::_internal_set_count_nulls(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.count_nulls_ = value;
}

// -------------------------------------------------------------------

// AggSpec_AggSpecDistinct

// bool include_nulls = 1;
inline void AggSpec_AggSpecDistinct::clear_include_nulls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.include_nulls_ = false;
}
inline bool AggSpec_AggSpecDistinct::include_nulls() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct.include_nulls)
  return _internal_include_nulls();
}
inline void AggSpec_AggSpecDistinct::set_include_nulls(bool value) {
  _internal_set_include_nulls(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct.include_nulls)
}
inline bool AggSpec_AggSpecDistinct::_internal_include_nulls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.include_nulls_;
}
inline void AggSpec_AggSpecDistinct::_internal_set_include_nulls(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.include_nulls_ = value;
}

// -------------------------------------------------------------------

// AggSpec_AggSpecFormula

// string formula = 1;
inline void AggSpec_AggSpecFormula::clear_formula() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.formula_.ClearToEmpty();
}
inline const std::string& AggSpec_AggSpecFormula::formula() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.formula)
  return _internal_formula();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AggSpec_AggSpecFormula::set_formula(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.formula_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.formula)
}
inline std::string* AggSpec_AggSpecFormula::mutable_formula() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_formula();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.formula)
  return _s;
}
inline const std::string& AggSpec_AggSpecFormula::_internal_formula() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.formula_.Get();
}
inline void AggSpec_AggSpecFormula::_internal_set_formula(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.formula_.Set(value, GetArena());
}
inline std::string* AggSpec_AggSpecFormula::_internal_mutable_formula() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.formula_.Mutable( GetArena());
}
inline std::string* AggSpec_AggSpecFormula::release_formula() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.formula)
  return _impl_.formula_.Release();
}
inline void AggSpec_AggSpecFormula::set_allocated_formula(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.formula_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.formula_.IsDefault()) {
          _impl_.formula_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.formula)
}

// string param_token = 2;
inline void AggSpec_AggSpecFormula::clear_param_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.param_token_.ClearToEmpty();
}
inline const std::string& AggSpec_AggSpecFormula::param_token() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.param_token)
  return _internal_param_token();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AggSpec_AggSpecFormula::set_param_token(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.param_token_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.param_token)
}
inline std::string* AggSpec_AggSpecFormula::mutable_param_token() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_param_token();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.param_token)
  return _s;
}
inline const std::string& AggSpec_AggSpecFormula::_internal_param_token() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.param_token_.Get();
}
inline void AggSpec_AggSpecFormula::_internal_set_param_token(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.param_token_.Set(value, GetArena());
}
inline std::string* AggSpec_AggSpecFormula::_internal_mutable_param_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.param_token_.Mutable( GetArena());
}
inline std::string* AggSpec_AggSpecFormula::release_param_token() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.param_token)
  return _impl_.param_token_.Release();
}
inline void AggSpec_AggSpecFormula::set_allocated_param_token(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.param_token_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.param_token_.IsDefault()) {
          _impl_.param_token_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula.param_token)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecMedian

// bool average_evenly_divided = 1;
inline void AggSpec_AggSpecMedian::clear_average_evenly_divided() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.average_evenly_divided_ = false;
}
inline bool AggSpec_AggSpecMedian::average_evenly_divided() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian.average_evenly_divided)
  return _internal_average_evenly_divided();
}
inline void AggSpec_AggSpecMedian::set_average_evenly_divided(bool value) {
  _internal_set_average_evenly_divided(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian.average_evenly_divided)
}
inline bool AggSpec_AggSpecMedian::_internal_average_evenly_divided() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.average_evenly_divided_;
}
inline void AggSpec_AggSpecMedian::_internal_set_average_evenly_divided(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.average_evenly_divided_ = value;
}

// -------------------------------------------------------------------

// AggSpec_AggSpecPercentile

// double percentile = 1;
inline void AggSpec_AggSpecPercentile::clear_percentile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.percentile_ = 0;
}
inline double AggSpec_AggSpecPercentile::percentile() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile.percentile)
  return _internal_percentile();
}
inline void AggSpec_AggSpecPercentile::set_percentile(double value) {
  _internal_set_percentile(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile.percentile)
}
inline double AggSpec_AggSpecPercentile::_internal_percentile() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.percentile_;
}
inline void AggSpec_AggSpecPercentile::_internal_set_percentile(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.percentile_ = value;
}

// bool average_evenly_divided = 2;
inline void AggSpec_AggSpecPercentile::clear_average_evenly_divided() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.average_evenly_divided_ = false;
}
inline bool AggSpec_AggSpecPercentile::average_evenly_divided() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile.average_evenly_divided)
  return _internal_average_evenly_divided();
}
inline void AggSpec_AggSpecPercentile::set_average_evenly_divided(bool value) {
  _internal_set_average_evenly_divided(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile.average_evenly_divided)
}
inline bool AggSpec_AggSpecPercentile::_internal_average_evenly_divided() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.average_evenly_divided_;
}
inline void AggSpec_AggSpecPercentile::_internal_set_average_evenly_divided(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.average_evenly_divided_ = value;
}

// -------------------------------------------------------------------

// AggSpec_AggSpecSorted

// repeated .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn columns = 1;
inline int AggSpec_AggSpecSorted::_internal_columns_size() const {
  return _internal_columns().size();
}
inline int AggSpec_AggSpecSorted::columns_size() const {
  return _internal_columns_size();
}
inline void AggSpec_AggSpecSorted::clear_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* AggSpec_AggSpecSorted::mutable_columns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted.columns)
  return _internal_mutable_columns()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn>* AggSpec_AggSpecSorted::mutable_columns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted.columns)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns();
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn& AggSpec_AggSpecSorted::columns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted.columns)
  return _internal_columns().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* AggSpec_AggSpecSorted::add_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn* _add = _internal_mutable_columns()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted.columns)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn>& AggSpec_AggSpecSorted::columns() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted.columns)
  return _internal_columns();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn>&
AggSpec_AggSpecSorted::_internal_columns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSortedColumn>*
AggSpec_AggSpecSorted::_internal_mutable_columns() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_;
}

// -------------------------------------------------------------------

// AggSpec_AggSpecSortedColumn

// string column_name = 1;
inline void AggSpec_AggSpecSortedColumn::clear_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& AggSpec_AggSpecSortedColumn::column_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn.column_name)
  return _internal_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AggSpec_AggSpecSortedColumn::set_column_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn.column_name)
}
inline std::string* AggSpec_AggSpecSortedColumn::mutable_column_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn.column_name)
  return _s;
}
inline const std::string& AggSpec_AggSpecSortedColumn::_internal_column_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_name_.Get();
}
inline void AggSpec_AggSpecSortedColumn::_internal_set_column_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(value, GetArena());
}
inline std::string* AggSpec_AggSpecSortedColumn::_internal_mutable_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.column_name_.Mutable( GetArena());
}
inline std::string* AggSpec_AggSpecSortedColumn::release_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn.column_name)
  return _impl_.column_name_.Release();
}
inline void AggSpec_AggSpecSortedColumn::set_allocated_column_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_name_.IsDefault()) {
          _impl_.column_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSortedColumn.column_name)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecTDigest

// optional double compression = 1;
inline bool AggSpec_AggSpecTDigest::has_compression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void AggSpec_AggSpecTDigest::clear_compression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.compression_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline double AggSpec_AggSpecTDigest::compression() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest.compression)
  return _internal_compression();
}
inline void AggSpec_AggSpecTDigest::set_compression(double value) {
  _internal_set_compression(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest.compression)
}
inline double AggSpec_AggSpecTDigest::_internal_compression() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.compression_;
}
inline void AggSpec_AggSpecTDigest::_internal_set_compression(double value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.compression_ = value;
}

// -------------------------------------------------------------------

// AggSpec_AggSpecUnique

// bool include_nulls = 1;
inline void AggSpec_AggSpecUnique::clear_include_nulls() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.include_nulls_ = false;
}
inline bool AggSpec_AggSpecUnique::include_nulls() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.include_nulls)
  return _internal_include_nulls();
}
inline void AggSpec_AggSpecUnique::set_include_nulls(bool value) {
  _internal_set_include_nulls(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.include_nulls)
}
inline bool AggSpec_AggSpecUnique::_internal_include_nulls() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.include_nulls_;
}
inline void AggSpec_AggSpecUnique::_internal_set_include_nulls(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.include_nulls_ = value;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel non_unique_sentinel = 2;
inline bool AggSpec_AggSpecUnique::has_non_unique_sentinel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.non_unique_sentinel_ != nullptr);
  return value;
}
inline void AggSpec_AggSpecUnique::clear_non_unique_sentinel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.non_unique_sentinel_ != nullptr) _impl_.non_unique_sentinel_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel& AggSpec_AggSpecUnique::_internal_non_unique_sentinel() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* p = _impl_.non_unique_sentinel_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecNonUniqueSentinel_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel& AggSpec_AggSpecUnique::non_unique_sentinel() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.non_unique_sentinel)
  return _internal_non_unique_sentinel();
}
inline void AggSpec_AggSpecUnique::unsafe_arena_set_allocated_non_unique_sentinel(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.non_unique_sentinel_);
  }
  _impl_.non_unique_sentinel_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.non_unique_sentinel)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* AggSpec_AggSpecUnique::release_non_unique_sentinel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* released = _impl_.non_unique_sentinel_;
  _impl_.non_unique_sentinel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* AggSpec_AggSpecUnique::unsafe_arena_release_non_unique_sentinel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.non_unique_sentinel)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* temp = _impl_.non_unique_sentinel_;
  _impl_.non_unique_sentinel_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* AggSpec_AggSpecUnique::_internal_mutable_non_unique_sentinel() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.non_unique_sentinel_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel>(GetArena());
    _impl_.non_unique_sentinel_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel*>(p);
  }
  return _impl_.non_unique_sentinel_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* AggSpec_AggSpecUnique::mutable_non_unique_sentinel() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* _msg = _internal_mutable_non_unique_sentinel();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.non_unique_sentinel)
  return _msg;
}
inline void AggSpec_AggSpecUnique::set_allocated_non_unique_sentinel(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel*>(_impl_.non_unique_sentinel_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.non_unique_sentinel_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecNonUniqueSentinel*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique.non_unique_sentinel)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecNonUniqueSentinel

// .io.deephaven.proto.backplane.grpc.NullValue null_value = 1;
inline bool AggSpec_AggSpecNonUniqueSentinel::has_null_value() const {
  return type_case() == kNullValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_null_value() {
  _impl_._oneof_case_[0] = kNullValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_null_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kNullValue) {
    _impl_.type_.null_value_ = 0;
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::NullValue AggSpec_AggSpecNonUniqueSentinel::null_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.null_value)
  return _internal_null_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_null_value(::io::deephaven::proto::backplane::grpc::NullValue value) {
  _internal_set_null_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.null_value)
}
inline ::io::deephaven::proto::backplane::grpc::NullValue AggSpec_AggSpecNonUniqueSentinel::_internal_null_value() const {
  if (type_case() == kNullValue) {
    return static_cast<::io::deephaven::proto::backplane::grpc::NullValue>(_impl_.type_.null_value_);
  }
  return static_cast<::io::deephaven::proto::backplane::grpc::NullValue>(0);
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_null_value(::io::deephaven::proto::backplane::grpc::NullValue value) {
  if (type_case() != kNullValue) {
    clear_type();
    set_has_null_value();
  }
  _impl_.type_.null_value_ = value;
}

// string string_value = 2;
inline bool AggSpec_AggSpecNonUniqueSentinel::has_string_value() const {
  return type_case() == kStringValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_string_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kStringValue) {
    _impl_.type_.string_value_.Destroy();
    clear_has_type();
  }
}
inline const std::string& AggSpec_AggSpecNonUniqueSentinel::string_value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.string_value)
  return _internal_string_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AggSpec_AggSpecNonUniqueSentinel::set_string_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() != kStringValue) {
    clear_type();

    set_has_string_value();
    _impl_.type_.string_value_.InitDefault();
  }
  _impl_.type_.string_value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.string_value)
}
inline std::string* AggSpec_AggSpecNonUniqueSentinel::mutable_string_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.string_value)
  return _s;
}
inline const std::string& AggSpec_AggSpecNonUniqueSentinel::_internal_string_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (type_case() != kStringValue) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.type_.string_value_.Get();
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_string_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() != kStringValue) {
    clear_type();

    set_has_string_value();
    _impl_.type_.string_value_.InitDefault();
  }
  _impl_.type_.string_value_.Set(value, GetArena());
}
inline std::string* AggSpec_AggSpecNonUniqueSentinel::_internal_mutable_string_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() != kStringValue) {
    clear_type();

    set_has_string_value();
    _impl_.type_.string_value_.InitDefault();
  }
  return _impl_.type_.string_value_.Mutable( GetArena());
}
inline std::string* AggSpec_AggSpecNonUniqueSentinel::release_string_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.string_value)
  if (type_case() != kStringValue) {
    return nullptr;
  }
  clear_has_type();
  return _impl_.type_.string_value_.Release();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_allocated_string_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_type()) {
    clear_type();
  }
  if (value != nullptr) {
    set_has_string_value();
    _impl_.type_.string_value_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.string_value)
}

// sint32 int_value = 3;
inline bool AggSpec_AggSpecNonUniqueSentinel::has_int_value() const {
  return type_case() == kIntValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_int_value() {
  _impl_._oneof_case_[0] = kIntValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_int_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kIntValue) {
    _impl_.type_.int_value_ = 0;
    clear_has_type();
  }
}
inline ::int32_t AggSpec_AggSpecNonUniqueSentinel::int_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.int_value)
  return _internal_int_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_int_value(::int32_t value) {
  _internal_set_int_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.int_value)
}
inline ::int32_t AggSpec_AggSpecNonUniqueSentinel::_internal_int_value() const {
  if (type_case() == kIntValue) {
    return _impl_.type_.int_value_;
  }
  return 0;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_int_value(::int32_t value) {
  if (type_case() != kIntValue) {
    clear_type();
    set_has_int_value();
  }
  _impl_.type_.int_value_ = value;
}

// sint64 long_value = 4 [jstype = JS_STRING];
inline bool AggSpec_AggSpecNonUniqueSentinel::has_long_value() const {
  return type_case() == kLongValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_long_value() {
  _impl_._oneof_case_[0] = kLongValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_long_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kLongValue) {
    _impl_.type_.long_value_ = ::int64_t{0};
    clear_has_type();
  }
}
inline ::int64_t AggSpec_AggSpecNonUniqueSentinel::long_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.long_value)
  return _internal_long_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_long_value(::int64_t value) {
  _internal_set_long_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.long_value)
}
inline ::int64_t AggSpec_AggSpecNonUniqueSentinel::_internal_long_value() const {
  if (type_case() == kLongValue) {
    return _impl_.type_.long_value_;
  }
  return ::int64_t{0};
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_long_value(::int64_t value) {
  if (type_case() != kLongValue) {
    clear_type();
    set_has_long_value();
  }
  _impl_.type_.long_value_ = value;
}

// float float_value = 5;
inline bool AggSpec_AggSpecNonUniqueSentinel::has_float_value() const {
  return type_case() == kFloatValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_float_value() {
  _impl_._oneof_case_[0] = kFloatValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_float_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kFloatValue) {
    _impl_.type_.float_value_ = 0;
    clear_has_type();
  }
}
inline float AggSpec_AggSpecNonUniqueSentinel::float_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.float_value)
  return _internal_float_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_float_value(float value) {
  _internal_set_float_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.float_value)
}
inline float AggSpec_AggSpecNonUniqueSentinel::_internal_float_value() const {
  if (type_case() == kFloatValue) {
    return _impl_.type_.float_value_;
  }
  return 0;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_float_value(float value) {
  if (type_case() != kFloatValue) {
    clear_type();
    set_has_float_value();
  }
  _impl_.type_.float_value_ = value;
}

// double double_value = 6;
inline bool AggSpec_AggSpecNonUniqueSentinel::has_double_value() const {
  return type_case() == kDoubleValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_double_value() {
  _impl_._oneof_case_[0] = kDoubleValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_double_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kDoubleValue) {
    _impl_.type_.double_value_ = 0;
    clear_has_type();
  }
}
inline double AggSpec_AggSpecNonUniqueSentinel::double_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.double_value)
  return _internal_double_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.double_value)
}
inline double AggSpec_AggSpecNonUniqueSentinel::_internal_double_value() const {
  if (type_case() == kDoubleValue) {
    return _impl_.type_.double_value_;
  }
  return 0;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_double_value(double value) {
  if (type_case() != kDoubleValue) {
    clear_type();
    set_has_double_value();
  }
  _impl_.type_.double_value_ = value;
}

// bool bool_value = 7;
inline bool AggSpec_AggSpecNonUniqueSentinel::has_bool_value() const {
  return type_case() == kBoolValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_bool_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kBoolValue) {
    _impl_.type_.bool_value_ = false;
    clear_has_type();
  }
}
inline bool AggSpec_AggSpecNonUniqueSentinel::bool_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.bool_value)
  return _internal_bool_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.bool_value)
}
inline bool AggSpec_AggSpecNonUniqueSentinel::_internal_bool_value() const {
  if (type_case() == kBoolValue) {
    return _impl_.type_.bool_value_;
  }
  return false;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_bool_value(bool value) {
  if (type_case() != kBoolValue) {
    clear_type();
    set_has_bool_value();
  }
  _impl_.type_.bool_value_ = value;
}

// sint32 byte_value = 8;
inline bool AggSpec_AggSpecNonUniqueSentinel::has_byte_value() const {
  return type_case() == kByteValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_byte_value() {
  _impl_._oneof_case_[0] = kByteValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_byte_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kByteValue) {
    _impl_.type_.byte_value_ = 0;
    clear_has_type();
  }
}
inline ::int32_t AggSpec_AggSpecNonUniqueSentinel::byte_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.byte_value)
  return _internal_byte_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_byte_value(::int32_t value) {
  _internal_set_byte_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.byte_value)
}
inline ::int32_t AggSpec_AggSpecNonUniqueSentinel::_internal_byte_value() const {
  if (type_case() == kByteValue) {
    return _impl_.type_.byte_value_;
  }
  return 0;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_byte_value(::int32_t value) {
  if (type_case() != kByteValue) {
    clear_type();
    set_has_byte_value();
  }
  _impl_.type_.byte_value_ = value;
}

// sint32 short_value = 9;
inline bool AggSpec_AggSpecNonUniqueSentinel::has_short_value() const {
  return type_case() == kShortValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_short_value() {
  _impl_._oneof_case_[0] = kShortValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_short_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kShortValue) {
    _impl_.type_.short_value_ = 0;
    clear_has_type();
  }
}
inline ::int32_t AggSpec_AggSpecNonUniqueSentinel::short_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.short_value)
  return _internal_short_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_short_value(::int32_t value) {
  _internal_set_short_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.short_value)
}
inline ::int32_t AggSpec_AggSpecNonUniqueSentinel::_internal_short_value() const {
  if (type_case() == kShortValue) {
    return _impl_.type_.short_value_;
  }
  return 0;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_short_value(::int32_t value) {
  if (type_case() != kShortValue) {
    clear_type();
    set_has_short_value();
  }
  _impl_.type_.short_value_ = value;
}

// sint32 char_value = 10;
inline bool AggSpec_AggSpecNonUniqueSentinel::has_char_value() const {
  return type_case() == kCharValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_has_char_value() {
  _impl_._oneof_case_[0] = kCharValue;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_char_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kCharValue) {
    _impl_.type_.char_value_ = 0;
    clear_has_type();
  }
}
inline ::int32_t AggSpec_AggSpecNonUniqueSentinel::char_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.char_value)
  return _internal_char_value();
}
inline void AggSpec_AggSpecNonUniqueSentinel::set_char_value(::int32_t value) {
  _internal_set_char_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecNonUniqueSentinel.char_value)
}
inline ::int32_t AggSpec_AggSpecNonUniqueSentinel::_internal_char_value() const {
  if (type_case() == kCharValue) {
    return _impl_.type_.char_value_;
  }
  return 0;
}
inline void AggSpec_AggSpecNonUniqueSentinel::_internal_set_char_value(::int32_t value) {
  if (type_case() != kCharValue) {
    clear_type();
    set_has_char_value();
  }
  _impl_.type_.char_value_ = value;
}

inline bool AggSpec_AggSpecNonUniqueSentinel::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void AggSpec_AggSpecNonUniqueSentinel::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline AggSpec_AggSpecNonUniqueSentinel::TypeCase AggSpec_AggSpecNonUniqueSentinel::type_case() const {
  return AggSpec_AggSpecNonUniqueSentinel::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AggSpec_AggSpecWeighted

// string weight_column = 1;
inline void AggSpec_AggSpecWeighted::clear_weight_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weight_column_.ClearToEmpty();
}
inline const std::string& AggSpec_AggSpecWeighted::weight_column() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted.weight_column)
  return _internal_weight_column();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void AggSpec_AggSpecWeighted::set_weight_column(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weight_column_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted.weight_column)
}
inline std::string* AggSpec_AggSpecWeighted::mutable_weight_column() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_weight_column();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted.weight_column)
  return _s;
}
inline const std::string& AggSpec_AggSpecWeighted::_internal_weight_column() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.weight_column_.Get();
}
inline void AggSpec_AggSpecWeighted::_internal_set_weight_column(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.weight_column_.Set(value, GetArena());
}
inline std::string* AggSpec_AggSpecWeighted::_internal_mutable_weight_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.weight_column_.Mutable( GetArena());
}
inline std::string* AggSpec_AggSpecWeighted::release_weight_column() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted.weight_column)
  return _impl_.weight_column_.Release();
}
inline void AggSpec_AggSpecWeighted::set_allocated_weight_column(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.weight_column_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.weight_column_.IsDefault()) {
          _impl_.weight_column_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted.weight_column)
}

// -------------------------------------------------------------------

// AggSpec_AggSpecAbsSum

// -------------------------------------------------------------------

// AggSpec_AggSpecAvg

// -------------------------------------------------------------------

// AggSpec_AggSpecFirst

// -------------------------------------------------------------------

// AggSpec_AggSpecFreeze

// -------------------------------------------------------------------

// AggSpec_AggSpecGroup

// -------------------------------------------------------------------

// AggSpec_AggSpecLast

// -------------------------------------------------------------------

// AggSpec_AggSpecMax

// -------------------------------------------------------------------

// AggSpec_AggSpecMin

// -------------------------------------------------------------------

// AggSpec_AggSpecStd

// -------------------------------------------------------------------

// AggSpec_AggSpecSum

// -------------------------------------------------------------------

// AggSpec_AggSpecVar

// -------------------------------------------------------------------

// AggSpec

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAbsSum abs_sum = 1;
inline bool AggSpec::has_abs_sum() const {
  return type_case() == kAbsSum;
}
inline bool AggSpec::_internal_has_abs_sum() const {
  return type_case() == kAbsSum;
}
inline void AggSpec::set_has_abs_sum() {
  _impl_._oneof_case_[0] = kAbsSum;
}
inline void AggSpec::clear_abs_sum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kAbsSum) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.abs_sum_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* AggSpec::release_abs_sum() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.abs_sum)
  if (type_case() == kAbsSum) {
    clear_has_type();
    auto* temp = _impl_.type_.abs_sum_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.abs_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum& AggSpec::_internal_abs_sum() const {
  return type_case() == kAbsSum ? *_impl_.type_.abs_sum_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecAbsSum_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum& AggSpec::abs_sum() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.abs_sum)
  return _internal_abs_sum();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* AggSpec::unsafe_arena_release_abs_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.abs_sum)
  if (type_case() == kAbsSum) {
    clear_has_type();
    auto* temp = _impl_.type_.abs_sum_;
    _impl_.type_.abs_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_abs_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_abs_sum();
    _impl_.type_.abs_sum_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.abs_sum)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* AggSpec::_internal_mutable_abs_sum() {
  if (type_case() != kAbsSum) {
    clear_type();
    set_has_abs_sum();
    _impl_.type_.abs_sum_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum>(GetArena());
  }
  return _impl_.type_.abs_sum_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* AggSpec::mutable_abs_sum() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAbsSum* _msg = _internal_mutable_abs_sum();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.abs_sum)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecApproximatePercentile approximate_percentile = 2;
inline bool AggSpec::has_approximate_percentile() const {
  return type_case() == kApproximatePercentile;
}
inline bool AggSpec::_internal_has_approximate_percentile() const {
  return type_case() == kApproximatePercentile;
}
inline void AggSpec::set_has_approximate_percentile() {
  _impl_._oneof_case_[0] = kApproximatePercentile;
}
inline void AggSpec::clear_approximate_percentile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kApproximatePercentile) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.approximate_percentile_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* AggSpec::release_approximate_percentile() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.approximate_percentile)
  if (type_case() == kApproximatePercentile) {
    clear_has_type();
    auto* temp = _impl_.type_.approximate_percentile_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.approximate_percentile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile& AggSpec::_internal_approximate_percentile() const {
  return type_case() == kApproximatePercentile ? *_impl_.type_.approximate_percentile_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecApproximatePercentile_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile& AggSpec::approximate_percentile() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.approximate_percentile)
  return _internal_approximate_percentile();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* AggSpec::unsafe_arena_release_approximate_percentile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.approximate_percentile)
  if (type_case() == kApproximatePercentile) {
    clear_has_type();
    auto* temp = _impl_.type_.approximate_percentile_;
    _impl_.type_.approximate_percentile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_approximate_percentile(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_approximate_percentile();
    _impl_.type_.approximate_percentile_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.approximate_percentile)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* AggSpec::_internal_mutable_approximate_percentile() {
  if (type_case() != kApproximatePercentile) {
    clear_type();
    set_has_approximate_percentile();
    _impl_.type_.approximate_percentile_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile>(GetArena());
  }
  return _impl_.type_.approximate_percentile_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* AggSpec::mutable_approximate_percentile() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecApproximatePercentile* _msg = _internal_mutable_approximate_percentile();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.approximate_percentile)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecAvg avg = 3;
inline bool AggSpec::has_avg() const {
  return type_case() == kAvg;
}
inline bool AggSpec::_internal_has_avg() const {
  return type_case() == kAvg;
}
inline void AggSpec::set_has_avg() {
  _impl_._oneof_case_[0] = kAvg;
}
inline void AggSpec::clear_avg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kAvg) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.avg_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* AggSpec::release_avg() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.avg)
  if (type_case() == kAvg) {
    clear_has_type();
    auto* temp = _impl_.type_.avg_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.avg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg& AggSpec::_internal_avg() const {
  return type_case() == kAvg ? *_impl_.type_.avg_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecAvg_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg& AggSpec::avg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.avg)
  return _internal_avg();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* AggSpec::unsafe_arena_release_avg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.avg)
  if (type_case() == kAvg) {
    clear_has_type();
    auto* temp = _impl_.type_.avg_;
    _impl_.type_.avg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_avg(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_avg();
    _impl_.type_.avg_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.avg)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* AggSpec::_internal_mutable_avg() {
  if (type_case() != kAvg) {
    clear_type();
    set_has_avg();
    _impl_.type_.avg_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg>(GetArena());
  }
  return _impl_.type_.avg_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* AggSpec::mutable_avg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecAvg* _msg = _internal_mutable_avg();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.avg)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecCountDistinct count_distinct = 4;
inline bool AggSpec::has_count_distinct() const {
  return type_case() == kCountDistinct;
}
inline bool AggSpec::_internal_has_count_distinct() const {
  return type_case() == kCountDistinct;
}
inline void AggSpec::set_has_count_distinct() {
  _impl_._oneof_case_[0] = kCountDistinct;
}
inline void AggSpec::clear_count_distinct() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kCountDistinct) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.count_distinct_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* AggSpec::release_count_distinct() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.count_distinct)
  if (type_case() == kCountDistinct) {
    clear_has_type();
    auto* temp = _impl_.type_.count_distinct_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.count_distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct& AggSpec::_internal_count_distinct() const {
  return type_case() == kCountDistinct ? *_impl_.type_.count_distinct_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecCountDistinct_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct& AggSpec::count_distinct() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.count_distinct)
  return _internal_count_distinct();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* AggSpec::unsafe_arena_release_count_distinct() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.count_distinct)
  if (type_case() == kCountDistinct) {
    clear_has_type();
    auto* temp = _impl_.type_.count_distinct_;
    _impl_.type_.count_distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_count_distinct(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_count_distinct();
    _impl_.type_.count_distinct_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.count_distinct)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* AggSpec::_internal_mutable_count_distinct() {
  if (type_case() != kCountDistinct) {
    clear_type();
    set_has_count_distinct();
    _impl_.type_.count_distinct_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct>(GetArena());
  }
  return _impl_.type_.count_distinct_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* AggSpec::mutable_count_distinct() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecCountDistinct* _msg = _internal_mutable_count_distinct();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.count_distinct)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecDistinct distinct = 5;
inline bool AggSpec::has_distinct() const {
  return type_case() == kDistinct;
}
inline bool AggSpec::_internal_has_distinct() const {
  return type_case() == kDistinct;
}
inline void AggSpec::set_has_distinct() {
  _impl_._oneof_case_[0] = kDistinct;
}
inline void AggSpec::clear_distinct() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kDistinct) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.distinct_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* AggSpec::release_distinct() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.distinct)
  if (type_case() == kDistinct) {
    clear_has_type();
    auto* temp = _impl_.type_.distinct_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct& AggSpec::_internal_distinct() const {
  return type_case() == kDistinct ? *_impl_.type_.distinct_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecDistinct_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct& AggSpec::distinct() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.distinct)
  return _internal_distinct();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* AggSpec::unsafe_arena_release_distinct() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.distinct)
  if (type_case() == kDistinct) {
    clear_has_type();
    auto* temp = _impl_.type_.distinct_;
    _impl_.type_.distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_distinct(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_distinct();
    _impl_.type_.distinct_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.distinct)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* AggSpec::_internal_mutable_distinct() {
  if (type_case() != kDistinct) {
    clear_type();
    set_has_distinct();
    _impl_.type_.distinct_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct>(GetArena());
  }
  return _impl_.type_.distinct_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* AggSpec::mutable_distinct() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecDistinct* _msg = _internal_mutable_distinct();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.distinct)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFirst first = 6;
inline bool AggSpec::has_first() const {
  return type_case() == kFirst;
}
inline bool AggSpec::_internal_has_first() const {
  return type_case() == kFirst;
}
inline void AggSpec::set_has_first() {
  _impl_._oneof_case_[0] = kFirst;
}
inline void AggSpec::clear_first() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kFirst) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.first_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* AggSpec::release_first() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.first)
  if (type_case() == kFirst) {
    clear_has_type();
    auto* temp = _impl_.type_.first_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst& AggSpec::_internal_first() const {
  return type_case() == kFirst ? *_impl_.type_.first_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecFirst_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst& AggSpec::first() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.first)
  return _internal_first();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* AggSpec::unsafe_arena_release_first() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.first)
  if (type_case() == kFirst) {
    clear_has_type();
    auto* temp = _impl_.type_.first_;
    _impl_.type_.first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_first(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_first();
    _impl_.type_.first_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.first)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* AggSpec::_internal_mutable_first() {
  if (type_case() != kFirst) {
    clear_type();
    set_has_first();
    _impl_.type_.first_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst>(GetArena());
  }
  return _impl_.type_.first_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* AggSpec::mutable_first() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFirst* _msg = _internal_mutable_first();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.first)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFormula formula = 7;
inline bool AggSpec::has_formula() const {
  return type_case() == kFormula;
}
inline bool AggSpec::_internal_has_formula() const {
  return type_case() == kFormula;
}
inline void AggSpec::set_has_formula() {
  _impl_._oneof_case_[0] = kFormula;
}
inline void AggSpec::clear_formula() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kFormula) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.formula_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* AggSpec::release_formula() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.formula)
  if (type_case() == kFormula) {
    clear_has_type();
    auto* temp = _impl_.type_.formula_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.formula_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula& AggSpec::_internal_formula() const {
  return type_case() == kFormula ? *_impl_.type_.formula_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecFormula_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula& AggSpec::formula() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.formula)
  return _internal_formula();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* AggSpec::unsafe_arena_release_formula() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.formula)
  if (type_case() == kFormula) {
    clear_has_type();
    auto* temp = _impl_.type_.formula_;
    _impl_.type_.formula_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_formula(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_formula();
    _impl_.type_.formula_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.formula)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* AggSpec::_internal_mutable_formula() {
  if (type_case() != kFormula) {
    clear_type();
    set_has_formula();
    _impl_.type_.formula_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula>(GetArena());
  }
  return _impl_.type_.formula_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* AggSpec::mutable_formula() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFormula* _msg = _internal_mutable_formula();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.formula)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecFreeze freeze = 8;
inline bool AggSpec::has_freeze() const {
  return type_case() == kFreeze;
}
inline bool AggSpec::_internal_has_freeze() const {
  return type_case() == kFreeze;
}
inline void AggSpec::set_has_freeze() {
  _impl_._oneof_case_[0] = kFreeze;
}
inline void AggSpec::clear_freeze() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kFreeze) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.freeze_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* AggSpec::release_freeze() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.freeze)
  if (type_case() == kFreeze) {
    clear_has_type();
    auto* temp = _impl_.type_.freeze_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.freeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze& AggSpec::_internal_freeze() const {
  return type_case() == kFreeze ? *_impl_.type_.freeze_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecFreeze_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze& AggSpec::freeze() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.freeze)
  return _internal_freeze();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* AggSpec::unsafe_arena_release_freeze() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.freeze)
  if (type_case() == kFreeze) {
    clear_has_type();
    auto* temp = _impl_.type_.freeze_;
    _impl_.type_.freeze_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_freeze(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_freeze();
    _impl_.type_.freeze_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.freeze)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* AggSpec::_internal_mutable_freeze() {
  if (type_case() != kFreeze) {
    clear_type();
    set_has_freeze();
    _impl_.type_.freeze_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze>(GetArena());
  }
  return _impl_.type_.freeze_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* AggSpec::mutable_freeze() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecFreeze* _msg = _internal_mutable_freeze();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.freeze)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecGroup group = 9;
inline bool AggSpec::has_group() const {
  return type_case() == kGroup;
}
inline bool AggSpec::_internal_has_group() const {
  return type_case() == kGroup;
}
inline void AggSpec::set_has_group() {
  _impl_._oneof_case_[0] = kGroup;
}
inline void AggSpec::clear_group() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kGroup) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.group_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* AggSpec::release_group() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.group)
  if (type_case() == kGroup) {
    clear_has_type();
    auto* temp = _impl_.type_.group_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup& AggSpec::_internal_group() const {
  return type_case() == kGroup ? *_impl_.type_.group_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecGroup_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup& AggSpec::group() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.group)
  return _internal_group();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* AggSpec::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.group)
  if (type_case() == kGroup) {
    clear_has_type();
    auto* temp = _impl_.type_.group_;
    _impl_.type_.group_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_group(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_group();
    _impl_.type_.group_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.group)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* AggSpec::_internal_mutable_group() {
  if (type_case() != kGroup) {
    clear_type();
    set_has_group();
    _impl_.type_.group_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup>(GetArena());
  }
  return _impl_.type_.group_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* AggSpec::mutable_group() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecGroup* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.group)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecLast last = 10;
inline bool AggSpec::has_last() const {
  return type_case() == kLast;
}
inline bool AggSpec::_internal_has_last() const {
  return type_case() == kLast;
}
inline void AggSpec::set_has_last() {
  _impl_._oneof_case_[0] = kLast;
}
inline void AggSpec::clear_last() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kLast) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.last_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* AggSpec::release_last() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.last)
  if (type_case() == kLast) {
    clear_has_type();
    auto* temp = _impl_.type_.last_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.last_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast& AggSpec::_internal_last() const {
  return type_case() == kLast ? *_impl_.type_.last_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecLast_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast& AggSpec::last() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.last)
  return _internal_last();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* AggSpec::unsafe_arena_release_last() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.last)
  if (type_case() == kLast) {
    clear_has_type();
    auto* temp = _impl_.type_.last_;
    _impl_.type_.last_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_last(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_last();
    _impl_.type_.last_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.last)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* AggSpec::_internal_mutable_last() {
  if (type_case() != kLast) {
    clear_type();
    set_has_last();
    _impl_.type_.last_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast>(GetArena());
  }
  return _impl_.type_.last_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* AggSpec::mutable_last() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecLast* _msg = _internal_mutable_last();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.last)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMax max = 11;
inline bool AggSpec::has_max() const {
  return type_case() == kMax;
}
inline bool AggSpec::_internal_has_max() const {
  return type_case() == kMax;
}
inline void AggSpec::set_has_max() {
  _impl_._oneof_case_[0] = kMax;
}
inline void AggSpec::clear_max() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kMax) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.max_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* AggSpec::release_max() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.max)
  if (type_case() == kMax) {
    clear_has_type();
    auto* temp = _impl_.type_.max_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax& AggSpec::_internal_max() const {
  return type_case() == kMax ? *_impl_.type_.max_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecMax_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax& AggSpec::max() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.max)
  return _internal_max();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* AggSpec::unsafe_arena_release_max() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.max)
  if (type_case() == kMax) {
    clear_has_type();
    auto* temp = _impl_.type_.max_;
    _impl_.type_.max_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_max(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_max();
    _impl_.type_.max_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.max)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* AggSpec::_internal_mutable_max() {
  if (type_case() != kMax) {
    clear_type();
    set_has_max();
    _impl_.type_.max_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax>(GetArena());
  }
  return _impl_.type_.max_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* AggSpec::mutable_max() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMax* _msg = _internal_mutable_max();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.max)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMedian median = 12;
inline bool AggSpec::has_median() const {
  return type_case() == kMedian;
}
inline bool AggSpec::_internal_has_median() const {
  return type_case() == kMedian;
}
inline void AggSpec::set_has_median() {
  _impl_._oneof_case_[0] = kMedian;
}
inline void AggSpec::clear_median() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kMedian) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.median_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* AggSpec::release_median() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.median)
  if (type_case() == kMedian) {
    clear_has_type();
    auto* temp = _impl_.type_.median_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.median_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian& AggSpec::_internal_median() const {
  return type_case() == kMedian ? *_impl_.type_.median_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecMedian_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian& AggSpec::median() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.median)
  return _internal_median();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* AggSpec::unsafe_arena_release_median() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.median)
  if (type_case() == kMedian) {
    clear_has_type();
    auto* temp = _impl_.type_.median_;
    _impl_.type_.median_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_median(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_median();
    _impl_.type_.median_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.median)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* AggSpec::_internal_mutable_median() {
  if (type_case() != kMedian) {
    clear_type();
    set_has_median();
    _impl_.type_.median_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian>(GetArena());
  }
  return _impl_.type_.median_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* AggSpec::mutable_median() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMedian* _msg = _internal_mutable_median();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.median)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecMin min = 13;
inline bool AggSpec::has_min() const {
  return type_case() == kMin;
}
inline bool AggSpec::_internal_has_min() const {
  return type_case() == kMin;
}
inline void AggSpec::set_has_min() {
  _impl_._oneof_case_[0] = kMin;
}
inline void AggSpec::clear_min() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kMin) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.min_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* AggSpec::release_min() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.min)
  if (type_case() == kMin) {
    clear_has_type();
    auto* temp = _impl_.type_.min_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin& AggSpec::_internal_min() const {
  return type_case() == kMin ? *_impl_.type_.min_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecMin_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin& AggSpec::min() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.min)
  return _internal_min();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* AggSpec::unsafe_arena_release_min() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.min)
  if (type_case() == kMin) {
    clear_has_type();
    auto* temp = _impl_.type_.min_;
    _impl_.type_.min_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_min(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_min();
    _impl_.type_.min_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.min)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* AggSpec::_internal_mutable_min() {
  if (type_case() != kMin) {
    clear_type();
    set_has_min();
    _impl_.type_.min_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin>(GetArena());
  }
  return _impl_.type_.min_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* AggSpec::mutable_min() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecMin* _msg = _internal_mutable_min();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.min)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecPercentile percentile = 14;
inline bool AggSpec::has_percentile() const {
  return type_case() == kPercentile;
}
inline bool AggSpec::_internal_has_percentile() const {
  return type_case() == kPercentile;
}
inline void AggSpec::set_has_percentile() {
  _impl_._oneof_case_[0] = kPercentile;
}
inline void AggSpec::clear_percentile() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kPercentile) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.percentile_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* AggSpec::release_percentile() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.percentile)
  if (type_case() == kPercentile) {
    clear_has_type();
    auto* temp = _impl_.type_.percentile_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.percentile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile& AggSpec::_internal_percentile() const {
  return type_case() == kPercentile ? *_impl_.type_.percentile_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecPercentile_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile& AggSpec::percentile() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.percentile)
  return _internal_percentile();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* AggSpec::unsafe_arena_release_percentile() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.percentile)
  if (type_case() == kPercentile) {
    clear_has_type();
    auto* temp = _impl_.type_.percentile_;
    _impl_.type_.percentile_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_percentile(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_percentile();
    _impl_.type_.percentile_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.percentile)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* AggSpec::_internal_mutable_percentile() {
  if (type_case() != kPercentile) {
    clear_type();
    set_has_percentile();
    _impl_.type_.percentile_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile>(GetArena());
  }
  return _impl_.type_.percentile_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* AggSpec::mutable_percentile() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecPercentile* _msg = _internal_mutable_percentile();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.percentile)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted sorted_first = 15;
inline bool AggSpec::has_sorted_first() const {
  return type_case() == kSortedFirst;
}
inline bool AggSpec::_internal_has_sorted_first() const {
  return type_case() == kSortedFirst;
}
inline void AggSpec::set_has_sorted_first() {
  _impl_._oneof_case_[0] = kSortedFirst;
}
inline void AggSpec::clear_sorted_first() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kSortedFirst) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.sorted_first_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::release_sorted_first() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.sorted_first)
  if (type_case() == kSortedFirst) {
    clear_has_type();
    auto* temp = _impl_.type_.sorted_first_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sorted_first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& AggSpec::_internal_sorted_first() const {
  return type_case() == kSortedFirst ? *_impl_.type_.sorted_first_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecSorted_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& AggSpec::sorted_first() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.sorted_first)
  return _internal_sorted_first();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::unsafe_arena_release_sorted_first() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.sorted_first)
  if (type_case() == kSortedFirst) {
    clear_has_type();
    auto* temp = _impl_.type_.sorted_first_;
    _impl_.type_.sorted_first_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_sorted_first(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_sorted_first();
    _impl_.type_.sorted_first_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.sorted_first)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::_internal_mutable_sorted_first() {
  if (type_case() != kSortedFirst) {
    clear_type();
    set_has_sorted_first();
    _impl_.type_.sorted_first_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted>(GetArena());
  }
  return _impl_.type_.sorted_first_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::mutable_sorted_first() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* _msg = _internal_mutable_sorted_first();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.sorted_first)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSorted sorted_last = 16;
inline bool AggSpec::has_sorted_last() const {
  return type_case() == kSortedLast;
}
inline bool AggSpec::_internal_has_sorted_last() const {
  return type_case() == kSortedLast;
}
inline void AggSpec::set_has_sorted_last() {
  _impl_._oneof_case_[0] = kSortedLast;
}
inline void AggSpec::clear_sorted_last() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kSortedLast) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.sorted_last_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::release_sorted_last() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.sorted_last)
  if (type_case() == kSortedLast) {
    clear_has_type();
    auto* temp = _impl_.type_.sorted_last_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sorted_last_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& AggSpec::_internal_sorted_last() const {
  return type_case() == kSortedLast ? *_impl_.type_.sorted_last_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecSorted_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted& AggSpec::sorted_last() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.sorted_last)
  return _internal_sorted_last();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::unsafe_arena_release_sorted_last() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.sorted_last)
  if (type_case() == kSortedLast) {
    clear_has_type();
    auto* temp = _impl_.type_.sorted_last_;
    _impl_.type_.sorted_last_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_sorted_last(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_sorted_last();
    _impl_.type_.sorted_last_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.sorted_last)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::_internal_mutable_sorted_last() {
  if (type_case() != kSortedLast) {
    clear_type();
    set_has_sorted_last();
    _impl_.type_.sorted_last_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted>(GetArena());
  }
  return _impl_.type_.sorted_last_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* AggSpec::mutable_sorted_last() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSorted* _msg = _internal_mutable_sorted_last();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.sorted_last)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecStd std = 17;
inline bool AggSpec::has_std() const {
  return type_case() == kStd;
}
inline bool AggSpec::_internal_has_std() const {
  return type_case() == kStd;
}
inline void AggSpec::set_has_std() {
  _impl_._oneof_case_[0] = kStd;
}
inline void AggSpec::clear_std() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kStd) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.std_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* AggSpec::release_std() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.std)
  if (type_case() == kStd) {
    clear_has_type();
    auto* temp = _impl_.type_.std_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.std_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd& AggSpec::_internal_std() const {
  return type_case() == kStd ? *_impl_.type_.std_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecStd_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd& AggSpec::std() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.std)
  return _internal_std();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* AggSpec::unsafe_arena_release_std() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.std)
  if (type_case() == kStd) {
    clear_has_type();
    auto* temp = _impl_.type_.std_;
    _impl_.type_.std_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_std(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_std();
    _impl_.type_.std_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.std)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* AggSpec::_internal_mutable_std() {
  if (type_case() != kStd) {
    clear_type();
    set_has_std();
    _impl_.type_.std_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd>(GetArena());
  }
  return _impl_.type_.std_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* AggSpec::mutable_std() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecStd* _msg = _internal_mutable_std();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.std)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecSum sum = 18;
inline bool AggSpec::has_sum() const {
  return type_case() == kSum;
}
inline bool AggSpec::_internal_has_sum() const {
  return type_case() == kSum;
}
inline void AggSpec::set_has_sum() {
  _impl_._oneof_case_[0] = kSum;
}
inline void AggSpec::clear_sum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kSum) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.sum_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* AggSpec::release_sum() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.sum)
  if (type_case() == kSum) {
    clear_has_type();
    auto* temp = _impl_.type_.sum_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum& AggSpec::_internal_sum() const {
  return type_case() == kSum ? *_impl_.type_.sum_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecSum_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum& AggSpec::sum() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.sum)
  return _internal_sum();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* AggSpec::unsafe_arena_release_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.sum)
  if (type_case() == kSum) {
    clear_has_type();
    auto* temp = _impl_.type_.sum_;
    _impl_.type_.sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_sum();
    _impl_.type_.sum_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.sum)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* AggSpec::_internal_mutable_sum() {
  if (type_case() != kSum) {
    clear_type();
    set_has_sum();
    _impl_.type_.sum_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum>(GetArena());
  }
  return _impl_.type_.sum_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* AggSpec::mutable_sum() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecSum* _msg = _internal_mutable_sum();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.sum)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecTDigest t_digest = 19;
inline bool AggSpec::has_t_digest() const {
  return type_case() == kTDigest;
}
inline bool AggSpec::_internal_has_t_digest() const {
  return type_case() == kTDigest;
}
inline void AggSpec::set_has_t_digest() {
  _impl_._oneof_case_[0] = kTDigest;
}
inline void AggSpec::clear_t_digest() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kTDigest) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.t_digest_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* AggSpec::release_t_digest() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.t_digest)
  if (type_case() == kTDigest) {
    clear_has_type();
    auto* temp = _impl_.type_.t_digest_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.t_digest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest& AggSpec::_internal_t_digest() const {
  return type_case() == kTDigest ? *_impl_.type_.t_digest_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecTDigest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest& AggSpec::t_digest() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.t_digest)
  return _internal_t_digest();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* AggSpec::unsafe_arena_release_t_digest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.t_digest)
  if (type_case() == kTDigest) {
    clear_has_type();
    auto* temp = _impl_.type_.t_digest_;
    _impl_.type_.t_digest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_t_digest(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_t_digest();
    _impl_.type_.t_digest_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.t_digest)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* AggSpec::_internal_mutable_t_digest() {
  if (type_case() != kTDigest) {
    clear_type();
    set_has_t_digest();
    _impl_.type_.t_digest_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest>(GetArena());
  }
  return _impl_.type_.t_digest_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* AggSpec::mutable_t_digest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecTDigest* _msg = _internal_mutable_t_digest();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.t_digest)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecUnique unique = 20;
inline bool AggSpec::has_unique() const {
  return type_case() == kUnique;
}
inline bool AggSpec::_internal_has_unique() const {
  return type_case() == kUnique;
}
inline void AggSpec::set_has_unique() {
  _impl_._oneof_case_[0] = kUnique;
}
inline void AggSpec::clear_unique() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kUnique) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.unique_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* AggSpec::release_unique() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.unique)
  if (type_case() == kUnique) {
    clear_has_type();
    auto* temp = _impl_.type_.unique_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.unique_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique& AggSpec::_internal_unique() const {
  return type_case() == kUnique ? *_impl_.type_.unique_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecUnique_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique& AggSpec::unique() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.unique)
  return _internal_unique();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* AggSpec::unsafe_arena_release_unique() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.unique)
  if (type_case() == kUnique) {
    clear_has_type();
    auto* temp = _impl_.type_.unique_;
    _impl_.type_.unique_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_unique(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_unique();
    _impl_.type_.unique_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.unique)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* AggSpec::_internal_mutable_unique() {
  if (type_case() != kUnique) {
    clear_type();
    set_has_unique();
    _impl_.type_.unique_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique>(GetArena());
  }
  return _impl_.type_.unique_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* AggSpec::mutable_unique() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecUnique* _msg = _internal_mutable_unique();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.unique)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted weighted_avg = 21;
inline bool AggSpec::has_weighted_avg() const {
  return type_case() == kWeightedAvg;
}
inline bool AggSpec::_internal_has_weighted_avg() const {
  return type_case() == kWeightedAvg;
}
inline void AggSpec::set_has_weighted_avg() {
  _impl_._oneof_case_[0] = kWeightedAvg;
}
inline void AggSpec::clear_weighted_avg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kWeightedAvg) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.weighted_avg_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::release_weighted_avg() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.weighted_avg)
  if (type_case() == kWeightedAvg) {
    clear_has_type();
    auto* temp = _impl_.type_.weighted_avg_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.weighted_avg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& AggSpec::_internal_weighted_avg() const {
  return type_case() == kWeightedAvg ? *_impl_.type_.weighted_avg_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecWeighted_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& AggSpec::weighted_avg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.weighted_avg)
  return _internal_weighted_avg();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::unsafe_arena_release_weighted_avg() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.weighted_avg)
  if (type_case() == kWeightedAvg) {
    clear_has_type();
    auto* temp = _impl_.type_.weighted_avg_;
    _impl_.type_.weighted_avg_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_weighted_avg(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_weighted_avg();
    _impl_.type_.weighted_avg_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.weighted_avg)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::_internal_mutable_weighted_avg() {
  if (type_case() != kWeightedAvg) {
    clear_type();
    set_has_weighted_avg();
    _impl_.type_.weighted_avg_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted>(GetArena());
  }
  return _impl_.type_.weighted_avg_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::mutable_weighted_avg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* _msg = _internal_mutable_weighted_avg();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.weighted_avg)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecWeighted weighted_sum = 22;
inline bool AggSpec::has_weighted_sum() const {
  return type_case() == kWeightedSum;
}
inline bool AggSpec::_internal_has_weighted_sum() const {
  return type_case() == kWeightedSum;
}
inline void AggSpec::set_has_weighted_sum() {
  _impl_._oneof_case_[0] = kWeightedSum;
}
inline void AggSpec::clear_weighted_sum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kWeightedSum) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.weighted_sum_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::release_weighted_sum() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.weighted_sum)
  if (type_case() == kWeightedSum) {
    clear_has_type();
    auto* temp = _impl_.type_.weighted_sum_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.weighted_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& AggSpec::_internal_weighted_sum() const {
  return type_case() == kWeightedSum ? *_impl_.type_.weighted_sum_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecWeighted_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted& AggSpec::weighted_sum() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.weighted_sum)
  return _internal_weighted_sum();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::unsafe_arena_release_weighted_sum() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.weighted_sum)
  if (type_case() == kWeightedSum) {
    clear_has_type();
    auto* temp = _impl_.type_.weighted_sum_;
    _impl_.type_.weighted_sum_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_weighted_sum(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_weighted_sum();
    _impl_.type_.weighted_sum_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.weighted_sum)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::_internal_mutable_weighted_sum() {
  if (type_case() != kWeightedSum) {
    clear_type();
    set_has_weighted_sum();
    _impl_.type_.weighted_sum_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted>(GetArena());
  }
  return _impl_.type_.weighted_sum_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* AggSpec::mutable_weighted_sum() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecWeighted* _msg = _internal_mutable_weighted_sum();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.weighted_sum)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggSpec.AggSpecVar var = 23;
inline bool AggSpec::has_var() const {
  return type_case() == kVar;
}
inline bool AggSpec::_internal_has_var() const {
  return type_case() == kVar;
}
inline void AggSpec::set_has_var() {
  _impl_._oneof_case_[0] = kVar;
}
inline void AggSpec::clear_var() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kVar) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.var_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* AggSpec::release_var() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggSpec.var)
  if (type_case() == kVar) {
    clear_has_type();
    auto* temp = _impl_.type_.var_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.var_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar& AggSpec::_internal_var() const {
  return type_case() == kVar ? *_impl_.type_.var_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar&>(::io::deephaven::proto::backplane::grpc::_AggSpec_AggSpecVar_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar& AggSpec::var() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggSpec.var)
  return _internal_var();
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* AggSpec::unsafe_arena_release_var() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.AggSpec.var)
  if (type_case() == kVar) {
    clear_has_type();
    auto* temp = _impl_.type_.var_;
    _impl_.type_.var_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void AggSpec::unsafe_arena_set_allocated_var(::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_var();
    _impl_.type_.var_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggSpec.var)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* AggSpec::_internal_mutable_var() {
  if (type_case() != kVar) {
    clear_type();
    set_has_var();
    _impl_.type_.var_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar>(GetArena());
  }
  return _impl_.type_.var_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* AggSpec::mutable_var() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec_AggSpecVar* _msg = _internal_mutable_var();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggSpec.var)
  return _msg;
}

inline bool AggSpec::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void AggSpec::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline AggSpec::TypeCase AggSpec::type_case() const {
  return AggSpec::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AggregateRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool AggregateRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AggregateRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& AggregateRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateRequest.result_id)
  return _internal_result_id();
}
inline void AggregateRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggregateRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggregateRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* AggregateRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateRequest.result_id)
  return _msg;
}
inline void AggregateRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggregateRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool AggregateRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void AggregateRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AggregateRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AggregateRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateRequest.source_id)
  return _internal_source_id();
}
inline void AggregateRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggregateRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggregateRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateRequest.source_id)
  return _msg;
}
inline void AggregateRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggregateRequest.source_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference initial_groups_id = 3;
inline bool AggregateRequest::has_initial_groups_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.initial_groups_id_ != nullptr);
  return value;
}
inline void AggregateRequest::clear_initial_groups_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.initial_groups_id_ != nullptr) _impl_.initial_groups_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AggregateRequest::_internal_initial_groups_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.initial_groups_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& AggregateRequest::initial_groups_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateRequest.initial_groups_id)
  return _internal_initial_groups_id();
}
inline void AggregateRequest::unsafe_arena_set_allocated_initial_groups_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.initial_groups_id_);
  }
  _impl_.initial_groups_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.AggregateRequest.initial_groups_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::release_initial_groups_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.initial_groups_id_;
  _impl_.initial_groups_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::unsafe_arena_release_initial_groups_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.AggregateRequest.initial_groups_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.initial_groups_id_;
  _impl_.initial_groups_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::_internal_mutable_initial_groups_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.initial_groups_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.initial_groups_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.initial_groups_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* AggregateRequest::mutable_initial_groups_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_initial_groups_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateRequest.initial_groups_id)
  return _msg;
}
inline void AggregateRequest::set_allocated_initial_groups_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.initial_groups_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.initial_groups_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.AggregateRequest.initial_groups_id)
}

// bool preserve_empty = 4;
inline void AggregateRequest::clear_preserve_empty() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.preserve_empty_ = false;
}
inline bool AggregateRequest::preserve_empty() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateRequest.preserve_empty)
  return _internal_preserve_empty();
}
inline void AggregateRequest::set_preserve_empty(bool value) {
  _internal_set_preserve_empty(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggregateRequest.preserve_empty)
}
inline bool AggregateRequest::_internal_preserve_empty() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.preserve_empty_;
}
inline void AggregateRequest::_internal_set_preserve_empty(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.preserve_empty_ = value;
}

// repeated .io.deephaven.proto.backplane.grpc.Aggregation aggregations = 5;
inline int AggregateRequest::_internal_aggregations_size() const {
  return _internal_aggregations().size();
}
inline int AggregateRequest::aggregations_size() const {
  return _internal_aggregations_size();
}
inline void AggregateRequest::clear_aggregations() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.aggregations_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation* AggregateRequest::mutable_aggregations(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateRequest.aggregations)
  return _internal_mutable_aggregations()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Aggregation>* AggregateRequest::mutable_aggregations()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AggregateRequest.aggregations)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_aggregations();
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation& AggregateRequest::aggregations(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateRequest.aggregations)
  return _internal_aggregations().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation* AggregateRequest::add_aggregations() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::Aggregation* _add = _internal_mutable_aggregations()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AggregateRequest.aggregations)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Aggregation>& AggregateRequest::aggregations() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AggregateRequest.aggregations)
  return _internal_aggregations();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Aggregation>&
AggregateRequest::_internal_aggregations() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.aggregations_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Aggregation>*
AggregateRequest::_internal_mutable_aggregations() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.aggregations_;
}

// repeated string group_by_columns = 6;
inline int AggregateRequest::_internal_group_by_columns_size() const {
  return _internal_group_by_columns().size();
}
inline int AggregateRequest::group_by_columns_size() const {
  return _internal_group_by_columns_size();
}
inline void AggregateRequest::clear_group_by_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.group_by_columns_.Clear();
}
inline std::string* AggregateRequest::add_group_by_columns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_group_by_columns()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
  return _s;
}
inline const std::string& AggregateRequest::group_by_columns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
  return _internal_group_by_columns().Get(index);
}
inline std::string* AggregateRequest::mutable_group_by_columns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
  return _internal_mutable_group_by_columns()->Mutable(index);
}
inline void AggregateRequest::set_group_by_columns(int index, const std::string& value) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::set_group_by_columns(int index, std::string&& value) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::set_group_by_columns(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_group_by_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::set_group_by_columns(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::set_group_by_columns(int index, absl::string_view value) {
  _internal_mutable_group_by_columns()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::add_group_by_columns(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::add_group_by_columns(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::add_group_by_columns(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::add_group_by_columns(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline void AggregateRequest::add_group_by_columns(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_group_by_columns()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AggregateRequest::group_by_columns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
  return _internal_group_by_columns();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AggregateRequest::mutable_group_by_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AggregateRequest.group_by_columns)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_group_by_columns();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
AggregateRequest::_internal_group_by_columns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.group_by_columns_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
AggregateRequest::_internal_mutable_group_by_columns() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.group_by_columns_;
}

// -------------------------------------------------------------------

// Aggregation_AggregationColumns

// .io.deephaven.proto.backplane.grpc.AggSpec spec = 1;
inline bool Aggregation_AggregationColumns::has_spec() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.spec_ != nullptr);
  return value;
}
inline void Aggregation_AggregationColumns::clear_spec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.spec_ != nullptr) _impl_.spec_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec& Aggregation_AggregationColumns::_internal_spec() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::AggSpec* p = _impl_.spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::AggSpec&>(::io::deephaven::proto::backplane::grpc::_AggSpec_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggSpec& Aggregation_AggregationColumns::spec() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.spec)
  return _internal_spec();
}
inline void Aggregation_AggregationColumns::unsafe_arena_set_allocated_spec(::io::deephaven::proto::backplane::grpc::AggSpec* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.spec_);
  }
  _impl_.spec_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.spec)
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* Aggregation_AggregationColumns::release_spec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::AggSpec* released = _impl_.spec_;
  _impl_.spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* Aggregation_AggregationColumns::unsafe_arena_release_spec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.spec)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::AggSpec* temp = _impl_.spec_;
  _impl_.spec_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* Aggregation_AggregationColumns::_internal_mutable_spec() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggSpec>(GetArena());
    _impl_.spec_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec*>(p);
  }
  return _impl_.spec_;
}
inline ::io::deephaven::proto::backplane::grpc::AggSpec* Aggregation_AggregationColumns::mutable_spec() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggSpec* _msg = _internal_mutable_spec();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.spec)
  return _msg;
}
inline void Aggregation_AggregationColumns::set_allocated_spec(::io::deephaven::proto::backplane::grpc::AggSpec* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec*>(_impl_.spec_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.spec_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggSpec*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.spec)
}

// repeated string match_pairs = 2;
inline int Aggregation_AggregationColumns::_internal_match_pairs_size() const {
  return _internal_match_pairs().size();
}
inline int Aggregation_AggregationColumns::match_pairs_size() const {
  return _internal_match_pairs_size();
}
inline void Aggregation_AggregationColumns::clear_match_pairs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.match_pairs_.Clear();
}
inline std::string* Aggregation_AggregationColumns::add_match_pairs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_match_pairs()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
  return _s;
}
inline const std::string& Aggregation_AggregationColumns::match_pairs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
  return _internal_match_pairs().Get(index);
}
inline std::string* Aggregation_AggregationColumns::mutable_match_pairs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
  return _internal_mutable_match_pairs()->Mutable(index);
}
inline void Aggregation_AggregationColumns::set_match_pairs(int index, const std::string& value) {
  _internal_mutable_match_pairs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::set_match_pairs(int index, std::string&& value) {
  _internal_mutable_match_pairs()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::set_match_pairs(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_match_pairs()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::set_match_pairs(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_match_pairs()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::set_match_pairs(int index, absl::string_view value) {
  _internal_mutable_match_pairs()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::add_match_pairs(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::add_match_pairs(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::add_match_pairs(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::add_match_pairs(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline void Aggregation_AggregationColumns::add_match_pairs(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_match_pairs()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Aggregation_AggregationColumns::match_pairs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
  return _internal_match_pairs();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Aggregation_AggregationColumns::mutable_match_pairs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns.match_pairs)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_match_pairs();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Aggregation_AggregationColumns::_internal_match_pairs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.match_pairs_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Aggregation_AggregationColumns::_internal_mutable_match_pairs() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.match_pairs_;
}

// -------------------------------------------------------------------

// Aggregation_AggregationCount

// string column_name = 1;
inline void Aggregation_AggregationCount::clear_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& Aggregation_AggregationCount::column_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount.column_name)
  return _internal_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Aggregation_AggregationCount::set_column_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount.column_name)
}
inline std::string* Aggregation_AggregationCount::mutable_column_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount.column_name)
  return _s;
}
inline const std::string& Aggregation_AggregationCount::_internal_column_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_name_.Get();
}
inline void Aggregation_AggregationCount::_internal_set_column_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(value, GetArena());
}
inline std::string* Aggregation_AggregationCount::_internal_mutable_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.column_name_.Mutable( GetArena());
}
inline std::string* Aggregation_AggregationCount::release_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount.column_name)
  return _impl_.column_name_.Release();
}
inline void Aggregation_AggregationCount::set_allocated_column_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_name_.IsDefault()) {
          _impl_.column_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount.column_name)
}

// -------------------------------------------------------------------

// Aggregation_AggregationRowKey

// string column_name = 1;
inline void Aggregation_AggregationRowKey::clear_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& Aggregation_AggregationRowKey::column_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey.column_name)
  return _internal_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Aggregation_AggregationRowKey::set_column_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey.column_name)
}
inline std::string* Aggregation_AggregationRowKey::mutable_column_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey.column_name)
  return _s;
}
inline const std::string& Aggregation_AggregationRowKey::_internal_column_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_name_.Get();
}
inline void Aggregation_AggregationRowKey::_internal_set_column_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(value, GetArena());
}
inline std::string* Aggregation_AggregationRowKey::_internal_mutable_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.column_name_.Mutable( GetArena());
}
inline std::string* Aggregation_AggregationRowKey::release_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey.column_name)
  return _impl_.column_name_.Release();
}
inline void Aggregation_AggregationRowKey::set_allocated_column_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_name_.IsDefault()) {
          _impl_.column_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey.column_name)
}

// -------------------------------------------------------------------

// Aggregation_AggregationPartition

// string column_name = 1;
inline void Aggregation_AggregationPartition::clear_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& Aggregation_AggregationPartition::column_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.column_name)
  return _internal_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Aggregation_AggregationPartition::set_column_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.column_name)
}
inline std::string* Aggregation_AggregationPartition::mutable_column_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.column_name)
  return _s;
}
inline const std::string& Aggregation_AggregationPartition::_internal_column_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_name_.Get();
}
inline void Aggregation_AggregationPartition::_internal_set_column_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(value, GetArena());
}
inline std::string* Aggregation_AggregationPartition::_internal_mutable_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.column_name_.Mutable( GetArena());
}
inline std::string* Aggregation_AggregationPartition::release_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.column_name)
  return _impl_.column_name_.Release();
}
inline void Aggregation_AggregationPartition::set_allocated_column_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_name_.IsDefault()) {
          _impl_.column_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.column_name)
}

// bool include_group_by_columns = 2;
inline void Aggregation_AggregationPartition::clear_include_group_by_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.include_group_by_columns_ = false;
}
inline bool Aggregation_AggregationPartition::include_group_by_columns() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.include_group_by_columns)
  return _internal_include_group_by_columns();
}
inline void Aggregation_AggregationPartition::set_include_group_by_columns(bool value) {
  _internal_set_include_group_by_columns(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition.include_group_by_columns)
}
inline bool Aggregation_AggregationPartition::_internal_include_group_by_columns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.include_group_by_columns_;
}
inline void Aggregation_AggregationPartition::_internal_set_include_group_by_columns(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.include_group_by_columns_ = value;
}

// -------------------------------------------------------------------

// Aggregation

// .io.deephaven.proto.backplane.grpc.Aggregation.AggregationColumns columns = 1;
inline bool Aggregation::has_columns() const {
  return type_case() == kColumns;
}
inline bool Aggregation::_internal_has_columns() const {
  return type_case() == kColumns;
}
inline void Aggregation::set_has_columns() {
  _impl_._oneof_case_[0] = kColumns;
}
inline void Aggregation::clear_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kColumns) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.columns_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* Aggregation::release_columns() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.columns)
  if (type_case() == kColumns) {
    clear_has_type();
    auto* temp = _impl_.type_.columns_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns& Aggregation::_internal_columns() const {
  return type_case() == kColumns ? *_impl_.type_.columns_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns&>(::io::deephaven::proto::backplane::grpc::_Aggregation_AggregationColumns_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns& Aggregation::columns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.columns)
  return _internal_columns();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* Aggregation::unsafe_arena_release_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Aggregation.columns)
  if (type_case() == kColumns) {
    clear_has_type();
    auto* temp = _impl_.type_.columns_;
    _impl_.type_.columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Aggregation::unsafe_arena_set_allocated_columns(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_columns();
    _impl_.type_.columns_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.columns)
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* Aggregation::_internal_mutable_columns() {
  if (type_case() != kColumns) {
    clear_type();
    set_has_columns();
    _impl_.type_.columns_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns>(GetArena());
  }
  return _impl_.type_.columns_;
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* Aggregation::mutable_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationColumns* _msg = _internal_mutable_columns();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.columns)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.Aggregation.AggregationCount count = 2;
inline bool Aggregation::has_count() const {
  return type_case() == kCount;
}
inline bool Aggregation::_internal_has_count() const {
  return type_case() == kCount;
}
inline void Aggregation::set_has_count() {
  _impl_._oneof_case_[0] = kCount;
}
inline void Aggregation::clear_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kCount) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.count_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* Aggregation::release_count() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.count)
  if (type_case() == kCount) {
    clear_has_type();
    auto* temp = _impl_.type_.count_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.count_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount& Aggregation::_internal_count() const {
  return type_case() == kCount ? *_impl_.type_.count_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount&>(::io::deephaven::proto::backplane::grpc::_Aggregation_AggregationCount_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount& Aggregation::count() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.count)
  return _internal_count();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* Aggregation::unsafe_arena_release_count() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Aggregation.count)
  if (type_case() == kCount) {
    clear_has_type();
    auto* temp = _impl_.type_.count_;
    _impl_.type_.count_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Aggregation::unsafe_arena_set_allocated_count(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_count();
    _impl_.type_.count_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.count)
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* Aggregation::_internal_mutable_count() {
  if (type_case() != kCount) {
    clear_type();
    set_has_count();
    _impl_.type_.count_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount>(GetArena());
  }
  return _impl_.type_.count_;
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* Aggregation::mutable_count() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationCount* _msg = _internal_mutable_count();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.count)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey first_row_key = 3;
inline bool Aggregation::has_first_row_key() const {
  return type_case() == kFirstRowKey;
}
inline bool Aggregation::_internal_has_first_row_key() const {
  return type_case() == kFirstRowKey;
}
inline void Aggregation::set_has_first_row_key() {
  _impl_._oneof_case_[0] = kFirstRowKey;
}
inline void Aggregation::clear_first_row_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kFirstRowKey) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.first_row_key_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::release_first_row_key() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.first_row_key)
  if (type_case() == kFirstRowKey) {
    clear_has_type();
    auto* temp = _impl_.type_.first_row_key_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.first_row_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& Aggregation::_internal_first_row_key() const {
  return type_case() == kFirstRowKey ? *_impl_.type_.first_row_key_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey&>(::io::deephaven::proto::backplane::grpc::_Aggregation_AggregationRowKey_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& Aggregation::first_row_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.first_row_key)
  return _internal_first_row_key();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::unsafe_arena_release_first_row_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Aggregation.first_row_key)
  if (type_case() == kFirstRowKey) {
    clear_has_type();
    auto* temp = _impl_.type_.first_row_key_;
    _impl_.type_.first_row_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Aggregation::unsafe_arena_set_allocated_first_row_key(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_first_row_key();
    _impl_.type_.first_row_key_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.first_row_key)
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::_internal_mutable_first_row_key() {
  if (type_case() != kFirstRowKey) {
    clear_type();
    set_has_first_row_key();
    _impl_.type_.first_row_key_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey>(GetArena());
  }
  return _impl_.type_.first_row_key_;
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::mutable_first_row_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* _msg = _internal_mutable_first_row_key();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.first_row_key)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.Aggregation.AggregationRowKey last_row_key = 4;
inline bool Aggregation::has_last_row_key() const {
  return type_case() == kLastRowKey;
}
inline bool Aggregation::_internal_has_last_row_key() const {
  return type_case() == kLastRowKey;
}
inline void Aggregation::set_has_last_row_key() {
  _impl_._oneof_case_[0] = kLastRowKey;
}
inline void Aggregation::clear_last_row_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kLastRowKey) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.last_row_key_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::release_last_row_key() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.last_row_key)
  if (type_case() == kLastRowKey) {
    clear_has_type();
    auto* temp = _impl_.type_.last_row_key_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.last_row_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& Aggregation::_internal_last_row_key() const {
  return type_case() == kLastRowKey ? *_impl_.type_.last_row_key_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey&>(::io::deephaven::proto::backplane::grpc::_Aggregation_AggregationRowKey_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey& Aggregation::last_row_key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.last_row_key)
  return _internal_last_row_key();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::unsafe_arena_release_last_row_key() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Aggregation.last_row_key)
  if (type_case() == kLastRowKey) {
    clear_has_type();
    auto* temp = _impl_.type_.last_row_key_;
    _impl_.type_.last_row_key_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Aggregation::unsafe_arena_set_allocated_last_row_key(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_last_row_key();
    _impl_.type_.last_row_key_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.last_row_key)
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::_internal_mutable_last_row_key() {
  if (type_case() != kLastRowKey) {
    clear_type();
    set_has_last_row_key();
    _impl_.type_.last_row_key_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey>(GetArena());
  }
  return _impl_.type_.last_row_key_;
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* Aggregation::mutable_last_row_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationRowKey* _msg = _internal_mutable_last_row_key();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.last_row_key)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.Aggregation.AggregationPartition partition = 5;
inline bool Aggregation::has_partition() const {
  return type_case() == kPartition;
}
inline bool Aggregation::_internal_has_partition() const {
  return type_case() == kPartition;
}
inline void Aggregation::set_has_partition() {
  _impl_._oneof_case_[0] = kPartition;
}
inline void Aggregation::clear_partition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (type_case() == kPartition) {
    if (GetArena() == nullptr) {
      delete _impl_.type_.partition_;
    }
    clear_has_type();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* Aggregation::release_partition() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Aggregation.partition)
  if (type_case() == kPartition) {
    clear_has_type();
    auto* temp = _impl_.type_.partition_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.type_.partition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition& Aggregation::_internal_partition() const {
  return type_case() == kPartition ? *_impl_.type_.partition_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition&>(::io::deephaven::proto::backplane::grpc::_Aggregation_AggregationPartition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition& Aggregation::partition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Aggregation.partition)
  return _internal_partition();
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* Aggregation::unsafe_arena_release_partition() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Aggregation.partition)
  if (type_case() == kPartition) {
    clear_has_type();
    auto* temp = _impl_.type_.partition_;
    _impl_.type_.partition_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Aggregation::unsafe_arena_set_allocated_partition(::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_type();
  if (value) {
    set_has_partition();
    _impl_.type_.partition_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Aggregation.partition)
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* Aggregation::_internal_mutable_partition() {
  if (type_case() != kPartition) {
    clear_type();
    set_has_partition();
    _impl_.type_.partition_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition>(GetArena());
  }
  return _impl_.type_.partition_;
}
inline ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* Aggregation::mutable_partition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Aggregation_AggregationPartition* _msg = _internal_mutable_partition();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Aggregation.partition)
  return _msg;
}

inline bool Aggregation::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Aggregation::clear_has_type() {
  _impl_._oneof_case_[0] = TYPE_NOT_SET;
}
inline Aggregation::TypeCase Aggregation::type_case() const {
  return Aggregation::TypeCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SortDescriptor

// string column_name = 1;
inline void SortDescriptor::clear_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& SortDescriptor::column_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
  return _internal_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SortDescriptor::set_column_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
}
inline std::string* SortDescriptor::mutable_column_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
  return _s;
}
inline const std::string& SortDescriptor::_internal_column_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_name_.Get();
}
inline void SortDescriptor::_internal_set_column_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(value, GetArena());
}
inline std::string* SortDescriptor::_internal_mutable_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.column_name_.Mutable( GetArena());
}
inline std::string* SortDescriptor::release_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
  return _impl_.column_name_.Release();
}
inline void SortDescriptor::set_allocated_column_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_name_.IsDefault()) {
          _impl_.column_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SortDescriptor.column_name)
}

// bool is_absolute = 2;
inline void SortDescriptor::clear_is_absolute() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_absolute_ = false;
}
inline bool SortDescriptor::is_absolute() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortDescriptor.is_absolute)
  return _internal_is_absolute();
}
inline void SortDescriptor::set_is_absolute(bool value) {
  _internal_set_is_absolute(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SortDescriptor.is_absolute)
}
inline bool SortDescriptor::_internal_is_absolute() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_absolute_;
}
inline void SortDescriptor::_internal_set_is_absolute(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_absolute_ = value;
}

// .io.deephaven.proto.backplane.grpc.SortDescriptor.SortDirection direction = 3;
inline void SortDescriptor::clear_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.direction_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection SortDescriptor::direction() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortDescriptor.direction)
  return _internal_direction();
}
inline void SortDescriptor::set_direction(::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SortDescriptor.direction)
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection SortDescriptor::_internal_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection>(_impl_.direction_);
}
inline void SortDescriptor::_internal_set_direction(::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.direction_ = value;
}

// -------------------------------------------------------------------

// SortTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool SortTableRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SortTableRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SortTableRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
  return _internal_result_id();
}
inline void SortTableRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SortTableRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SortTableRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SortTableRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SortTableRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
  return _msg;
}
inline void SortTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SortTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool SortTableRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void SortTableRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SortTableRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& SortTableRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
  return _internal_source_id();
}
inline void SortTableRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SortTableRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SortTableRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SortTableRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* SortTableRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
  return _msg;
}
inline void SortTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SortTableRequest.source_id)
}

// repeated .io.deephaven.proto.backplane.grpc.SortDescriptor sorts = 3;
inline int SortTableRequest::_internal_sorts_size() const {
  return _internal_sorts().size();
}
inline int SortTableRequest::sorts_size() const {
  return _internal_sorts_size();
}
inline void SortTableRequest::clear_sorts() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.sorts_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor* SortTableRequest::mutable_sorts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return _internal_mutable_sorts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::SortDescriptor>* SortTableRequest::mutable_sorts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_sorts();
}
inline const ::io::deephaven::proto::backplane::grpc::SortDescriptor& SortTableRequest::sorts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return _internal_sorts().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::SortDescriptor* SortTableRequest::add_sorts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::SortDescriptor* _add = _internal_mutable_sorts()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::SortDescriptor>& SortTableRequest::sorts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SortTableRequest.sorts)
  return _internal_sorts();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::SortDescriptor>&
SortTableRequest::_internal_sorts() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.sorts_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::SortDescriptor>*
SortTableRequest::_internal_mutable_sorts() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.sorts_;
}

// -------------------------------------------------------------------

// FilterTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool FilterTableRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FilterTableRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FilterTableRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
  return _internal_result_id();
}
inline void FilterTableRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FilterTableRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FilterTableRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FilterTableRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FilterTableRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
  return _msg;
}
inline void FilterTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FilterTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool FilterTableRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void FilterTableRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FilterTableRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FilterTableRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
  return _internal_source_id();
}
inline void FilterTableRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FilterTableRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FilterTableRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FilterTableRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FilterTableRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
  return _msg;
}
inline void FilterTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FilterTableRequest.source_id)
}

// repeated .io.deephaven.proto.backplane.grpc.Condition filters = 3;
inline int FilterTableRequest::_internal_filters_size() const {
  return _internal_filters().size();
}
inline int FilterTableRequest::filters_size() const {
  return _internal_filters_size();
}
inline void FilterTableRequest::clear_filters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filters_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* FilterTableRequest::mutable_filters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return _internal_mutable_filters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>* FilterTableRequest::mutable_filters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_filters();
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& FilterTableRequest::filters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return _internal_filters().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::Condition* FilterTableRequest::add_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::Condition* _add = _internal_mutable_filters()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>& FilterTableRequest::filters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.FilterTableRequest.filters)
  return _internal_filters();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>&
FilterTableRequest::_internal_filters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filters_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>*
FilterTableRequest::_internal_mutable_filters() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.filters_;
}

// -------------------------------------------------------------------

// SeekRowRequest

// .io.deephaven.proto.backplane.grpc.Ticket source_id = 1;
inline bool SeekRowRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SeekRowRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& SeekRowRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.source_id)
  return _internal_source_id();
}
inline void SeekRowRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SeekRowRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SeekRowRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SeekRowRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SeekRowRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SeekRowRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* SeekRowRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SeekRowRequest.source_id)
  return _msg;
}
inline void SeekRowRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SeekRowRequest.source_id)
}

// sint64 starting_row = 2 [jstype = JS_STRING];
inline void SeekRowRequest::clear_starting_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.starting_row_ = ::int64_t{0};
}
inline ::int64_t SeekRowRequest::starting_row() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.starting_row)
  return _internal_starting_row();
}
inline void SeekRowRequest::set_starting_row(::int64_t value) {
  _internal_set_starting_row(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SeekRowRequest.starting_row)
}
inline ::int64_t SeekRowRequest::_internal_starting_row() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.starting_row_;
}
inline void SeekRowRequest::_internal_set_starting_row(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.starting_row_ = value;
}

// string column_name = 3;
inline void SeekRowRequest::clear_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& SeekRowRequest::column_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.column_name)
  return _internal_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SeekRowRequest::set_column_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SeekRowRequest.column_name)
}
inline std::string* SeekRowRequest::mutable_column_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SeekRowRequest.column_name)
  return _s;
}
inline const std::string& SeekRowRequest::_internal_column_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_name_.Get();
}
inline void SeekRowRequest::_internal_set_column_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(value, GetArena());
}
inline std::string* SeekRowRequest::_internal_mutable_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.column_name_.Mutable( GetArena());
}
inline std::string* SeekRowRequest::release_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SeekRowRequest.column_name)
  return _impl_.column_name_.Release();
}
inline void SeekRowRequest::set_allocated_column_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_name_.IsDefault()) {
          _impl_.column_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SeekRowRequest.column_name)
}

// .io.deephaven.proto.backplane.grpc.Literal seek_value = 4;
inline bool SeekRowRequest::has_seek_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.seek_value_ != nullptr);
  return value;
}
inline void SeekRowRequest::clear_seek_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.seek_value_ != nullptr) _impl_.seek_value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::Literal& SeekRowRequest::_internal_seek_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Literal* p = _impl_.seek_value_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Literal&>(::io::deephaven::proto::backplane::grpc::_Literal_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Literal& SeekRowRequest::seek_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.seek_value)
  return _internal_seek_value();
}
inline void SeekRowRequest::unsafe_arena_set_allocated_seek_value(::io::deephaven::proto::backplane::grpc::Literal* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.seek_value_);
  }
  _impl_.seek_value_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Literal*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.SeekRowRequest.seek_value)
}
inline ::io::deephaven::proto::backplane::grpc::Literal* SeekRowRequest::release_seek_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::Literal* released = _impl_.seek_value_;
  _impl_.seek_value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Literal* SeekRowRequest::unsafe_arena_release_seek_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SeekRowRequest.seek_value)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::Literal* temp = _impl_.seek_value_;
  _impl_.seek_value_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Literal* SeekRowRequest::_internal_mutable_seek_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.seek_value_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Literal>(GetArena());
    _impl_.seek_value_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Literal*>(p);
  }
  return _impl_.seek_value_;
}
inline ::io::deephaven::proto::backplane::grpc::Literal* SeekRowRequest::mutable_seek_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Literal* _msg = _internal_mutable_seek_value();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SeekRowRequest.seek_value)
  return _msg;
}
inline void SeekRowRequest::set_allocated_seek_value(::io::deephaven::proto::backplane::grpc::Literal* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::Literal*>(_impl_.seek_value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Literal*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.seek_value_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Literal*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SeekRowRequest.seek_value)
}

// bool insensitive = 5;
inline void SeekRowRequest::clear_insensitive() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.insensitive_ = false;
}
inline bool SeekRowRequest::insensitive() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.insensitive)
  return _internal_insensitive();
}
inline void SeekRowRequest::set_insensitive(bool value) {
  _internal_set_insensitive(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SeekRowRequest.insensitive)
}
inline bool SeekRowRequest::_internal_insensitive() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.insensitive_;
}
inline void SeekRowRequest::_internal_set_insensitive(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.insensitive_ = value;
}

// bool contains = 6;
inline void SeekRowRequest::clear_contains() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.contains_ = false;
}
inline bool SeekRowRequest::contains() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.contains)
  return _internal_contains();
}
inline void SeekRowRequest::set_contains(bool value) {
  _internal_set_contains(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SeekRowRequest.contains)
}
inline bool SeekRowRequest::_internal_contains() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.contains_;
}
inline void SeekRowRequest::_internal_set_contains(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.contains_ = value;
}

// bool is_backward = 7;
inline void SeekRowRequest::clear_is_backward() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.is_backward_ = false;
}
inline bool SeekRowRequest::is_backward() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowRequest.is_backward)
  return _internal_is_backward();
}
inline void SeekRowRequest::set_is_backward(bool value) {
  _internal_set_is_backward(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SeekRowRequest.is_backward)
}
inline bool SeekRowRequest::_internal_is_backward() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.is_backward_;
}
inline void SeekRowRequest::_internal_set_is_backward(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.is_backward_ = value;
}

// -------------------------------------------------------------------

// SeekRowResponse

// sint64 result_row = 1 [jstype = JS_STRING];
inline void SeekRowResponse::clear_result_row() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.result_row_ = ::int64_t{0};
}
inline ::int64_t SeekRowResponse::result_row() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SeekRowResponse.result_row)
  return _internal_result_row();
}
inline void SeekRowResponse::set_result_row(::int64_t value) {
  _internal_set_result_row(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SeekRowResponse.result_row)
}
inline ::int64_t SeekRowResponse::_internal_result_row() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.result_row_;
}
inline void SeekRowResponse::_internal_set_result_row(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.result_row_ = value;
}

// -------------------------------------------------------------------

// Reference

// string column_name = 1;
inline void Reference::clear_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& Reference::column_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Reference.column_name)
  return _internal_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Reference::set_column_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Reference.column_name)
}
inline std::string* Reference::mutable_column_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Reference.column_name)
  return _s;
}
inline const std::string& Reference::_internal_column_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_name_.Get();
}
inline void Reference::_internal_set_column_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(value, GetArena());
}
inline std::string* Reference::_internal_mutable_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.column_name_.Mutable( GetArena());
}
inline std::string* Reference::release_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Reference.column_name)
  return _impl_.column_name_.Release();
}
inline void Reference::set_allocated_column_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_name_.IsDefault()) {
          _impl_.column_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Reference.column_name)
}

// -------------------------------------------------------------------

// Literal

// string string_value = 1;
inline bool Literal::has_string_value() const {
  return value_case() == kStringValue;
}
inline void Literal::set_has_string_value() {
  _impl_._oneof_case_[0] = kStringValue;
}
inline void Literal::clear_string_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kStringValue) {
    _impl_.value_.string_value_.Destroy();
    clear_has_value();
  }
}
inline const std::string& Literal::string_value() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.string_value)
  return _internal_string_value();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Literal::set_string_value(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kStringValue) {
    clear_value();

    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.string_value)
}
inline std::string* Literal::mutable_string_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Literal.string_value)
  return _s;
}
inline const std::string& Literal::_internal_string_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (value_case() != kStringValue) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.value_.string_value_.Get();
}
inline void Literal::_internal_set_string_value(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kStringValue) {
    clear_value();

    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  _impl_.value_.string_value_.Set(value, GetArena());
}
inline std::string* Literal::_internal_mutable_string_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() != kStringValue) {
    clear_value();

    set_has_string_value();
    _impl_.value_.string_value_.InitDefault();
  }
  return _impl_.value_.string_value_.Mutable( GetArena());
}
inline std::string* Literal::release_string_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Literal.string_value)
  if (value_case() != kStringValue) {
    return nullptr;
  }
  clear_has_value();
  return _impl_.value_.string_value_.Release();
}
inline void Literal::set_allocated_string_value(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_value()) {
    clear_value();
  }
  if (value != nullptr) {
    set_has_string_value();
    _impl_.value_.string_value_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.Literal.string_value)
}

// double double_value = 2;
inline bool Literal::has_double_value() const {
  return value_case() == kDoubleValue;
}
inline void Literal::set_has_double_value() {
  _impl_._oneof_case_[0] = kDoubleValue;
}
inline void Literal::clear_double_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kDoubleValue) {
    _impl_.value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double Literal::double_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.double_value)
  return _internal_double_value();
}
inline void Literal::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.double_value)
}
inline double Literal::_internal_double_value() const {
  if (value_case() == kDoubleValue) {
    return _impl_.value_.double_value_;
  }
  return 0;
}
inline void Literal::_internal_set_double_value(double value) {
  if (value_case() != kDoubleValue) {
    clear_value();
    set_has_double_value();
  }
  _impl_.value_.double_value_ = value;
}

// bool bool_value = 3;
inline bool Literal::has_bool_value() const {
  return value_case() == kBoolValue;
}
inline void Literal::set_has_bool_value() {
  _impl_._oneof_case_[0] = kBoolValue;
}
inline void Literal::clear_bool_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kBoolValue) {
    _impl_.value_.bool_value_ = false;
    clear_has_value();
  }
}
inline bool Literal::bool_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.bool_value)
  return _internal_bool_value();
}
inline void Literal::set_bool_value(bool value) {
  _internal_set_bool_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.bool_value)
}
inline bool Literal::_internal_bool_value() const {
  if (value_case() == kBoolValue) {
    return _impl_.value_.bool_value_;
  }
  return false;
}
inline void Literal::_internal_set_bool_value(bool value) {
  if (value_case() != kBoolValue) {
    clear_value();
    set_has_bool_value();
  }
  _impl_.value_.bool_value_ = value;
}

// sint64 long_value = 4 [jstype = JS_STRING];
inline bool Literal::has_long_value() const {
  return value_case() == kLongValue;
}
inline void Literal::set_has_long_value() {
  _impl_._oneof_case_[0] = kLongValue;
}
inline void Literal::clear_long_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kLongValue) {
    _impl_.value_.long_value_ = ::int64_t{0};
    clear_has_value();
  }
}
inline ::int64_t Literal::long_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.long_value)
  return _internal_long_value();
}
inline void Literal::set_long_value(::int64_t value) {
  _internal_set_long_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.long_value)
}
inline ::int64_t Literal::_internal_long_value() const {
  if (value_case() == kLongValue) {
    return _impl_.value_.long_value_;
  }
  return ::int64_t{0};
}
inline void Literal::_internal_set_long_value(::int64_t value) {
  if (value_case() != kLongValue) {
    clear_value();
    set_has_long_value();
  }
  _impl_.value_.long_value_ = value;
}

// sint64 nano_time_value = 5 [jstype = JS_STRING];
inline bool Literal::has_nano_time_value() const {
  return value_case() == kNanoTimeValue;
}
inline void Literal::set_has_nano_time_value() {
  _impl_._oneof_case_[0] = kNanoTimeValue;
}
inline void Literal::clear_nano_time_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (value_case() == kNanoTimeValue) {
    _impl_.value_.nano_time_value_ = ::int64_t{0};
    clear_has_value();
  }
}
inline ::int64_t Literal::nano_time_value() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Literal.nano_time_value)
  return _internal_nano_time_value();
}
inline void Literal::set_nano_time_value(::int64_t value) {
  _internal_set_nano_time_value(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.Literal.nano_time_value)
}
inline ::int64_t Literal::_internal_nano_time_value() const {
  if (value_case() == kNanoTimeValue) {
    return _impl_.value_.nano_time_value_;
  }
  return ::int64_t{0};
}
inline void Literal::_internal_set_nano_time_value(::int64_t value) {
  if (value_case() != kNanoTimeValue) {
    clear_value();
    set_has_nano_time_value();
  }
  _impl_.value_.nano_time_value_ = value;
}

inline bool Literal::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Literal::clear_has_value() {
  _impl_._oneof_case_[0] = VALUE_NOT_SET;
}
inline Literal::ValueCase Literal::value_case() const {
  return Literal::ValueCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Value

// .io.deephaven.proto.backplane.grpc.Reference reference = 1;
inline bool Value::has_reference() const {
  return data_case() == kReference;
}
inline bool Value::_internal_has_reference() const {
  return data_case() == kReference;
}
inline void Value::set_has_reference() {
  _impl_._oneof_case_[0] = kReference;
}
inline void Value::clear_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kReference) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.reference_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Reference* Value::release_reference() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Value.reference)
  if (data_case() == kReference) {
    clear_has_data();
    auto* temp = _impl_.data_.reference_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& Value::_internal_reference() const {
  return data_case() == kReference ? *_impl_.data_.reference_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference&>(::io::deephaven::proto::backplane::grpc::_Reference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& Value::reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Value.reference)
  return _internal_reference();
}
inline ::io::deephaven::proto::backplane::grpc::Reference* Value::unsafe_arena_release_reference() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Value.reference)
  if (data_case() == kReference) {
    clear_has_data();
    auto* temp = _impl_.data_.reference_;
    _impl_.data_.reference_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_reference();
    _impl_.data_.reference_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Value.reference)
}
inline ::io::deephaven::proto::backplane::grpc::Reference* Value::_internal_mutable_reference() {
  if (data_case() != kReference) {
    clear_data();
    set_has_reference();
    _impl_.data_.reference_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Reference>(GetArena());
  }
  return _impl_.data_.reference_;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* Value::mutable_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Value.reference)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.Literal literal = 2;
inline bool Value::has_literal() const {
  return data_case() == kLiteral;
}
inline bool Value::_internal_has_literal() const {
  return data_case() == kLiteral;
}
inline void Value::set_has_literal() {
  _impl_._oneof_case_[0] = kLiteral;
}
inline void Value::clear_literal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kLiteral) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.literal_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::Literal* Value::release_literal() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Value.literal)
  if (data_case() == kLiteral) {
    clear_has_data();
    auto* temp = _impl_.data_.literal_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.literal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::Literal& Value::_internal_literal() const {
  return data_case() == kLiteral ? *_impl_.data_.literal_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::Literal&>(::io::deephaven::proto::backplane::grpc::_Literal_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Literal& Value::literal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Value.literal)
  return _internal_literal();
}
inline ::io::deephaven::proto::backplane::grpc::Literal* Value::unsafe_arena_release_literal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Value.literal)
  if (data_case() == kLiteral) {
    clear_has_data();
    auto* temp = _impl_.data_.literal_;
    _impl_.data_.literal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Value::unsafe_arena_set_allocated_literal(::io::deephaven::proto::backplane::grpc::Literal* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_literal();
    _impl_.data_.literal_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Value.literal)
}
inline ::io::deephaven::proto::backplane::grpc::Literal* Value::_internal_mutable_literal() {
  if (data_case() != kLiteral) {
    clear_data();
    set_has_literal();
    _impl_.data_.literal_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Literal>(GetArena());
  }
  return _impl_.data_.literal_;
}
inline ::io::deephaven::proto::backplane::grpc::Literal* Value::mutable_literal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Literal* _msg = _internal_mutable_literal();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Value.literal)
  return _msg;
}

inline bool Value::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Value::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline Value::DataCase Value::data_case() const {
  return Value::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Condition

// .io.deephaven.proto.backplane.grpc.AndCondition and = 1;
inline bool Condition::has_and_() const {
  return data_case() == kAnd;
}
inline bool Condition::_internal_has_and_() const {
  return data_case() == kAnd;
}
inline void Condition::set_has_and_() {
  _impl_._oneof_case_[0] = kAnd;
}
inline void Condition::clear_and_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kAnd) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.and__;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AndCondition* Condition::release_and_() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.and)
  if (data_case() == kAnd) {
    clear_has_data();
    auto* temp = _impl_.data_.and__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.and__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AndCondition& Condition::_internal_and_() const {
  return data_case() == kAnd ? *_impl_.data_.and__ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AndCondition&>(::io::deephaven::proto::backplane::grpc::_AndCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AndCondition& Condition::and_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.and)
  return _internal_and_();
}
inline ::io::deephaven::proto::backplane::grpc::AndCondition* Condition::unsafe_arena_release_and_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.and)
  if (data_case() == kAnd) {
    clear_has_data();
    auto* temp = _impl_.data_.and__;
    _impl_.data_.and__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_and_(::io::deephaven::proto::backplane::grpc::AndCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_and_();
    _impl_.data_.and__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.and)
}
inline ::io::deephaven::proto::backplane::grpc::AndCondition* Condition::_internal_mutable_and_() {
  if (data_case() != kAnd) {
    clear_data();
    set_has_and_();
    _impl_.data_.and__ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AndCondition>(GetArena());
  }
  return _impl_.data_.and__;
}
inline ::io::deephaven::proto::backplane::grpc::AndCondition* Condition::mutable_and_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AndCondition* _msg = _internal_mutable_and_();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.and)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.OrCondition or = 2;
inline bool Condition::has_or_() const {
  return data_case() == kOr;
}
inline bool Condition::_internal_has_or_() const {
  return data_case() == kOr;
}
inline void Condition::set_has_or_() {
  _impl_._oneof_case_[0] = kOr;
}
inline void Condition::clear_or_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kOr) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.or__;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::OrCondition* Condition::release_or_() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.or)
  if (data_case() == kOr) {
    clear_has_data();
    auto* temp = _impl_.data_.or__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.or__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::OrCondition& Condition::_internal_or_() const {
  return data_case() == kOr ? *_impl_.data_.or__ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::OrCondition&>(::io::deephaven::proto::backplane::grpc::_OrCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::OrCondition& Condition::or_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.or)
  return _internal_or_();
}
inline ::io::deephaven::proto::backplane::grpc::OrCondition* Condition::unsafe_arena_release_or_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.or)
  if (data_case() == kOr) {
    clear_has_data();
    auto* temp = _impl_.data_.or__;
    _impl_.data_.or__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_or_(::io::deephaven::proto::backplane::grpc::OrCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_or_();
    _impl_.data_.or__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.or)
}
inline ::io::deephaven::proto::backplane::grpc::OrCondition* Condition::_internal_mutable_or_() {
  if (data_case() != kOr) {
    clear_data();
    set_has_or_();
    _impl_.data_.or__ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::OrCondition>(GetArena());
  }
  return _impl_.data_.or__;
}
inline ::io::deephaven::proto::backplane::grpc::OrCondition* Condition::mutable_or_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::OrCondition* _msg = _internal_mutable_or_();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.or)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.NotCondition not = 3;
inline bool Condition::has_not_() const {
  return data_case() == kNot;
}
inline bool Condition::_internal_has_not_() const {
  return data_case() == kNot;
}
inline void Condition::set_has_not_() {
  _impl_._oneof_case_[0] = kNot;
}
inline void Condition::clear_not_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kNot) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.not__;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::NotCondition* Condition::release_not_() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.not)
  if (data_case() == kNot) {
    clear_has_data();
    auto* temp = _impl_.data_.not__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.not__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::NotCondition& Condition::_internal_not_() const {
  return data_case() == kNot ? *_impl_.data_.not__ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::NotCondition&>(::io::deephaven::proto::backplane::grpc::_NotCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::NotCondition& Condition::not_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.not)
  return _internal_not_();
}
inline ::io::deephaven::proto::backplane::grpc::NotCondition* Condition::unsafe_arena_release_not_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.not)
  if (data_case() == kNot) {
    clear_has_data();
    auto* temp = _impl_.data_.not__;
    _impl_.data_.not__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_not_(::io::deephaven::proto::backplane::grpc::NotCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_not_();
    _impl_.data_.not__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.not)
}
inline ::io::deephaven::proto::backplane::grpc::NotCondition* Condition::_internal_mutable_not_() {
  if (data_case() != kNot) {
    clear_data();
    set_has_not_();
    _impl_.data_.not__ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::NotCondition>(GetArena());
  }
  return _impl_.data_.not__;
}
inline ::io::deephaven::proto::backplane::grpc::NotCondition* Condition::mutable_not_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::NotCondition* _msg = _internal_mutable_not_();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.not)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.CompareCondition compare = 4;
inline bool Condition::has_compare() const {
  return data_case() == kCompare;
}
inline bool Condition::_internal_has_compare() const {
  return data_case() == kCompare;
}
inline void Condition::set_has_compare() {
  _impl_._oneof_case_[0] = kCompare;
}
inline void Condition::clear_compare() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kCompare) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.compare_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition* Condition::release_compare() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.compare)
  if (data_case() == kCompare) {
    clear_has_data();
    auto* temp = _impl_.data_.compare_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.compare_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CompareCondition& Condition::_internal_compare() const {
  return data_case() == kCompare ? *_impl_.data_.compare_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::CompareCondition&>(::io::deephaven::proto::backplane::grpc::_CompareCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CompareCondition& Condition::compare() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.compare)
  return _internal_compare();
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition* Condition::unsafe_arena_release_compare() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.compare)
  if (data_case() == kCompare) {
    clear_has_data();
    auto* temp = _impl_.data_.compare_;
    _impl_.data_.compare_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_compare(::io::deephaven::proto::backplane::grpc::CompareCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_compare();
    _impl_.data_.compare_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.compare)
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition* Condition::_internal_mutable_compare() {
  if (data_case() != kCompare) {
    clear_data();
    set_has_compare();
    _impl_.data_.compare_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CompareCondition>(GetArena());
  }
  return _impl_.data_.compare_;
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition* Condition::mutable_compare() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::CompareCondition* _msg = _internal_mutable_compare();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.compare)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.InCondition in = 5;
inline bool Condition::has_in() const {
  return data_case() == kIn;
}
inline bool Condition::_internal_has_in() const {
  return data_case() == kIn;
}
inline void Condition::set_has_in() {
  _impl_._oneof_case_[0] = kIn;
}
inline void Condition::clear_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kIn) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.in_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::InCondition* Condition::release_in() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.in)
  if (data_case() == kIn) {
    clear_has_data();
    auto* temp = _impl_.data_.in_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::InCondition& Condition::_internal_in() const {
  return data_case() == kIn ? *_impl_.data_.in_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::InCondition&>(::io::deephaven::proto::backplane::grpc::_InCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::InCondition& Condition::in() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.in)
  return _internal_in();
}
inline ::io::deephaven::proto::backplane::grpc::InCondition* Condition::unsafe_arena_release_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.in)
  if (data_case() == kIn) {
    clear_has_data();
    auto* temp = _impl_.data_.in_;
    _impl_.data_.in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_in(::io::deephaven::proto::backplane::grpc::InCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_in();
    _impl_.data_.in_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.in)
}
inline ::io::deephaven::proto::backplane::grpc::InCondition* Condition::_internal_mutable_in() {
  if (data_case() != kIn) {
    clear_data();
    set_has_in();
    _impl_.data_.in_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::InCondition>(GetArena());
  }
  return _impl_.data_.in_;
}
inline ::io::deephaven::proto::backplane::grpc::InCondition* Condition::mutable_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::InCondition* _msg = _internal_mutable_in();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.in)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.InvokeCondition invoke = 6;
inline bool Condition::has_invoke() const {
  return data_case() == kInvoke;
}
inline bool Condition::_internal_has_invoke() const {
  return data_case() == kInvoke;
}
inline void Condition::set_has_invoke() {
  _impl_._oneof_case_[0] = kInvoke;
}
inline void Condition::clear_invoke() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kInvoke) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.invoke_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::InvokeCondition* Condition::release_invoke() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.invoke)
  if (data_case() == kInvoke) {
    clear_has_data();
    auto* temp = _impl_.data_.invoke_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.invoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::InvokeCondition& Condition::_internal_invoke() const {
  return data_case() == kInvoke ? *_impl_.data_.invoke_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::InvokeCondition&>(::io::deephaven::proto::backplane::grpc::_InvokeCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::InvokeCondition& Condition::invoke() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.invoke)
  return _internal_invoke();
}
inline ::io::deephaven::proto::backplane::grpc::InvokeCondition* Condition::unsafe_arena_release_invoke() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.invoke)
  if (data_case() == kInvoke) {
    clear_has_data();
    auto* temp = _impl_.data_.invoke_;
    _impl_.data_.invoke_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_invoke(::io::deephaven::proto::backplane::grpc::InvokeCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_invoke();
    _impl_.data_.invoke_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.invoke)
}
inline ::io::deephaven::proto::backplane::grpc::InvokeCondition* Condition::_internal_mutable_invoke() {
  if (data_case() != kInvoke) {
    clear_data();
    set_has_invoke();
    _impl_.data_.invoke_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::InvokeCondition>(GetArena());
  }
  return _impl_.data_.invoke_;
}
inline ::io::deephaven::proto::backplane::grpc::InvokeCondition* Condition::mutable_invoke() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::InvokeCondition* _msg = _internal_mutable_invoke();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.invoke)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.IsNullCondition is_null = 7;
inline bool Condition::has_is_null() const {
  return data_case() == kIsNull;
}
inline bool Condition::_internal_has_is_null() const {
  return data_case() == kIsNull;
}
inline void Condition::set_has_is_null() {
  _impl_._oneof_case_[0] = kIsNull;
}
inline void Condition::clear_is_null() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kIsNull) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.is_null_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::IsNullCondition* Condition::release_is_null() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.is_null)
  if (data_case() == kIsNull) {
    clear_has_data();
    auto* temp = _impl_.data_.is_null_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.is_null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::IsNullCondition& Condition::_internal_is_null() const {
  return data_case() == kIsNull ? *_impl_.data_.is_null_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::IsNullCondition&>(::io::deephaven::proto::backplane::grpc::_IsNullCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::IsNullCondition& Condition::is_null() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.is_null)
  return _internal_is_null();
}
inline ::io::deephaven::proto::backplane::grpc::IsNullCondition* Condition::unsafe_arena_release_is_null() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.is_null)
  if (data_case() == kIsNull) {
    clear_has_data();
    auto* temp = _impl_.data_.is_null_;
    _impl_.data_.is_null_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_is_null(::io::deephaven::proto::backplane::grpc::IsNullCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_is_null();
    _impl_.data_.is_null_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.is_null)
}
inline ::io::deephaven::proto::backplane::grpc::IsNullCondition* Condition::_internal_mutable_is_null() {
  if (data_case() != kIsNull) {
    clear_data();
    set_has_is_null();
    _impl_.data_.is_null_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::IsNullCondition>(GetArena());
  }
  return _impl_.data_.is_null_;
}
inline ::io::deephaven::proto::backplane::grpc::IsNullCondition* Condition::mutable_is_null() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::IsNullCondition* _msg = _internal_mutable_is_null();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.is_null)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.MatchesCondition matches = 8;
inline bool Condition::has_matches() const {
  return data_case() == kMatches;
}
inline bool Condition::_internal_has_matches() const {
  return data_case() == kMatches;
}
inline void Condition::set_has_matches() {
  _impl_._oneof_case_[0] = kMatches;
}
inline void Condition::clear_matches() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kMatches) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.matches_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::MatchesCondition* Condition::release_matches() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.matches)
  if (data_case() == kMatches) {
    clear_has_data();
    auto* temp = _impl_.data_.matches_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.matches_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::MatchesCondition& Condition::_internal_matches() const {
  return data_case() == kMatches ? *_impl_.data_.matches_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::MatchesCondition&>(::io::deephaven::proto::backplane::grpc::_MatchesCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MatchesCondition& Condition::matches() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.matches)
  return _internal_matches();
}
inline ::io::deephaven::proto::backplane::grpc::MatchesCondition* Condition::unsafe_arena_release_matches() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.matches)
  if (data_case() == kMatches) {
    clear_has_data();
    auto* temp = _impl_.data_.matches_;
    _impl_.data_.matches_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_matches(::io::deephaven::proto::backplane::grpc::MatchesCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_matches();
    _impl_.data_.matches_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.matches)
}
inline ::io::deephaven::proto::backplane::grpc::MatchesCondition* Condition::_internal_mutable_matches() {
  if (data_case() != kMatches) {
    clear_data();
    set_has_matches();
    _impl_.data_.matches_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MatchesCondition>(GetArena());
  }
  return _impl_.data_.matches_;
}
inline ::io::deephaven::proto::backplane::grpc::MatchesCondition* Condition::mutable_matches() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::MatchesCondition* _msg = _internal_mutable_matches();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.matches)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.ContainsCondition contains = 9;
inline bool Condition::has_contains() const {
  return data_case() == kContains;
}
inline bool Condition::_internal_has_contains() const {
  return data_case() == kContains;
}
inline void Condition::set_has_contains() {
  _impl_._oneof_case_[0] = kContains;
}
inline void Condition::clear_contains() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kContains) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.contains_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::ContainsCondition* Condition::release_contains() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.contains)
  if (data_case() == kContains) {
    clear_has_data();
    auto* temp = _impl_.data_.contains_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.contains_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::ContainsCondition& Condition::_internal_contains() const {
  return data_case() == kContains ? *_impl_.data_.contains_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::ContainsCondition&>(::io::deephaven::proto::backplane::grpc::_ContainsCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::ContainsCondition& Condition::contains() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.contains)
  return _internal_contains();
}
inline ::io::deephaven::proto::backplane::grpc::ContainsCondition* Condition::unsafe_arena_release_contains() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.contains)
  if (data_case() == kContains) {
    clear_has_data();
    auto* temp = _impl_.data_.contains_;
    _impl_.data_.contains_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_contains(::io::deephaven::proto::backplane::grpc::ContainsCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_contains();
    _impl_.data_.contains_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.contains)
}
inline ::io::deephaven::proto::backplane::grpc::ContainsCondition* Condition::_internal_mutable_contains() {
  if (data_case() != kContains) {
    clear_data();
    set_has_contains();
    _impl_.data_.contains_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ContainsCondition>(GetArena());
  }
  return _impl_.data_.contains_;
}
inline ::io::deephaven::proto::backplane::grpc::ContainsCondition* Condition::mutable_contains() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::ContainsCondition* _msg = _internal_mutable_contains();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.contains)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SearchCondition search = 10;
inline bool Condition::has_search() const {
  return data_case() == kSearch;
}
inline bool Condition::_internal_has_search() const {
  return data_case() == kSearch;
}
inline void Condition::set_has_search() {
  _impl_._oneof_case_[0] = kSearch;
}
inline void Condition::clear_search() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (data_case() == kSearch) {
    if (GetArena() == nullptr) {
      delete _impl_.data_.search_;
    }
    clear_has_data();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SearchCondition* Condition::release_search() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.Condition.search)
  if (data_case() == kSearch) {
    clear_has_data();
    auto* temp = _impl_.data_.search_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.search_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SearchCondition& Condition::_internal_search() const {
  return data_case() == kSearch ? *_impl_.data_.search_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::SearchCondition&>(::io::deephaven::proto::backplane::grpc::_SearchCondition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SearchCondition& Condition::search() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.Condition.search)
  return _internal_search();
}
inline ::io::deephaven::proto::backplane::grpc::SearchCondition* Condition::unsafe_arena_release_search() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.Condition.search)
  if (data_case() == kSearch) {
    clear_has_data();
    auto* temp = _impl_.data_.search_;
    _impl_.data_.search_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Condition::unsafe_arena_set_allocated_search(::io::deephaven::proto::backplane::grpc::SearchCondition* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_data();
  if (value) {
    set_has_search();
    _impl_.data_.search_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.Condition.search)
}
inline ::io::deephaven::proto::backplane::grpc::SearchCondition* Condition::_internal_mutable_search() {
  if (data_case() != kSearch) {
    clear_data();
    set_has_search();
    _impl_.data_.search_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SearchCondition>(GetArena());
  }
  return _impl_.data_.search_;
}
inline ::io::deephaven::proto::backplane::grpc::SearchCondition* Condition::mutable_search() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::SearchCondition* _msg = _internal_mutable_search();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.Condition.search)
  return _msg;
}

inline bool Condition::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Condition::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline Condition::DataCase Condition::data_case() const {
  return Condition::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// AndCondition

// repeated .io.deephaven.proto.backplane.grpc.Condition filters = 1;
inline int AndCondition::_internal_filters_size() const {
  return _internal_filters().size();
}
inline int AndCondition::filters_size() const {
  return _internal_filters_size();
}
inline void AndCondition::clear_filters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filters_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* AndCondition::mutable_filters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return _internal_mutable_filters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>* AndCondition::mutable_filters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_filters();
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& AndCondition::filters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return _internal_filters().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::Condition* AndCondition::add_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::Condition* _add = _internal_mutable_filters()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>& AndCondition::filters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.AndCondition.filters)
  return _internal_filters();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>&
AndCondition::_internal_filters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filters_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>*
AndCondition::_internal_mutable_filters() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.filters_;
}

// -------------------------------------------------------------------

// OrCondition

// repeated .io.deephaven.proto.backplane.grpc.Condition filters = 1;
inline int OrCondition::_internal_filters_size() const {
  return _internal_filters().size();
}
inline int OrCondition::filters_size() const {
  return _internal_filters_size();
}
inline void OrCondition::clear_filters() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.filters_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Condition* OrCondition::mutable_filters(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return _internal_mutable_filters()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>* OrCondition::mutable_filters()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_filters();
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& OrCondition::filters(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return _internal_filters().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::Condition* OrCondition::add_filters() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::Condition* _add = _internal_mutable_filters()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>& OrCondition::filters() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.OrCondition.filters)
  return _internal_filters();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>&
OrCondition::_internal_filters() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.filters_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Condition>*
OrCondition::_internal_mutable_filters() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.filters_;
}

// -------------------------------------------------------------------

// NotCondition

// .io.deephaven.proto.backplane.grpc.Condition filter = 1;
inline bool NotCondition::has_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline void NotCondition::clear_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& NotCondition::_internal_filter() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Condition* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Condition&>(::io::deephaven::proto::backplane::grpc::_Condition_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Condition& NotCondition::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.NotCondition.filter)
  return _internal_filter();
}
inline void NotCondition::unsafe_arena_set_allocated_filter(::io::deephaven::proto::backplane::grpc::Condition* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Condition*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.NotCondition.filter)
}
inline ::io::deephaven::proto::backplane::grpc::Condition* NotCondition::release_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Condition* released = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Condition* NotCondition::unsafe_arena_release_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.NotCondition.filter)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Condition* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Condition* NotCondition::_internal_mutable_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Condition>(GetArena());
    _impl_.filter_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Condition*>(p);
  }
  return _impl_.filter_;
}
inline ::io::deephaven::proto::backplane::grpc::Condition* NotCondition::mutable_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Condition* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.NotCondition.filter)
  return _msg;
}
inline void NotCondition::set_allocated_filter(::io::deephaven::proto::backplane::grpc::Condition* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::Condition*>(_impl_.filter_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Condition*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.filter_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Condition*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.NotCondition.filter)
}

// -------------------------------------------------------------------

// CompareCondition

// .io.deephaven.proto.backplane.grpc.CompareCondition.CompareOperation operation = 1;
inline void CompareCondition::clear_operation() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.operation_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation CompareCondition::operation() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CompareCondition.operation)
  return _internal_operation();
}
inline void CompareCondition::set_operation(::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CompareCondition.operation)
}
inline ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation CompareCondition::_internal_operation() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation>(_impl_.operation_);
}
inline void CompareCondition::_internal_set_operation(::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.operation_ = value;
}

// .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 2;
inline void CompareCondition::clear_case_sensitivity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.case_sensitivity_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity CompareCondition::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CompareCondition.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void CompareCondition::set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CompareCondition.case_sensitivity)
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity CompareCondition::_internal_case_sensitivity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::CaseSensitivity>(_impl_.case_sensitivity_);
}
inline void CompareCondition::_internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.case_sensitivity_ = value;
}

// .io.deephaven.proto.backplane.grpc.Value lhs = 3;
inline bool CompareCondition::has_lhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.lhs_ != nullptr);
  return value;
}
inline void CompareCondition::clear_lhs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.lhs_ != nullptr) _impl_.lhs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& CompareCondition::_internal_lhs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Value* p = _impl_.lhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Value&>(::io::deephaven::proto::backplane::grpc::_Value_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& CompareCondition::lhs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
  return _internal_lhs();
}
inline void CompareCondition::unsafe_arena_set_allocated_lhs(::io::deephaven::proto::backplane::grpc::Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.lhs_);
  }
  _impl_.lhs_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::release_lhs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Value* released = _impl_.lhs_;
  _impl_.lhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::unsafe_arena_release_lhs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Value* temp = _impl_.lhs_;
  _impl_.lhs_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::_internal_mutable_lhs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.lhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(GetArena());
    _impl_.lhs_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(p);
  }
  return _impl_.lhs_;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::mutable_lhs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Value* _msg = _internal_mutable_lhs();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
  return _msg;
}
inline void CompareCondition::set_allocated_lhs(::io::deephaven::proto::backplane::grpc::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(_impl_.lhs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.lhs_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CompareCondition.lhs)
}

// .io.deephaven.proto.backplane.grpc.Value rhs = 4;
inline bool CompareCondition::has_rhs() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.rhs_ != nullptr);
  return value;
}
inline void CompareCondition::clear_rhs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.rhs_ != nullptr) _impl_.rhs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& CompareCondition::_internal_rhs() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Value* p = _impl_.rhs_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Value&>(::io::deephaven::proto::backplane::grpc::_Value_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& CompareCondition::rhs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
  return _internal_rhs();
}
inline void CompareCondition::unsafe_arena_set_allocated_rhs(::io::deephaven::proto::backplane::grpc::Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.rhs_);
  }
  _impl_.rhs_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::release_rhs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::Value* released = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::unsafe_arena_release_rhs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::Value* temp = _impl_.rhs_;
  _impl_.rhs_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::_internal_mutable_rhs() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.rhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(GetArena());
    _impl_.rhs_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(p);
  }
  return _impl_.rhs_;
}
inline ::io::deephaven::proto::backplane::grpc::Value* CompareCondition::mutable_rhs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Value* _msg = _internal_mutable_rhs();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
  return _msg;
}
inline void CompareCondition::set_allocated_rhs(::io::deephaven::proto::backplane::grpc::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(_impl_.rhs_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.rhs_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CompareCondition.rhs)
}

// -------------------------------------------------------------------

// InCondition

// .io.deephaven.proto.backplane.grpc.Value target = 1;
inline bool InCondition::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline void InCondition::clear_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InCondition::_internal_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Value* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Value&>(::io::deephaven::proto::backplane::grpc::_Value_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InCondition::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InCondition.target)
  return _internal_target();
}
inline void InCondition::unsafe_arena_set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.InCondition.target)
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Value* released = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::unsafe_arena_release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.InCondition.target)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Value* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::_internal_mutable_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(GetArena());
    _impl_.target_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(p);
  }
  return _impl_.target_;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Value* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InCondition.target)
  return _msg;
}
inline void InCondition::set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.InCondition.target)
}

// repeated .io.deephaven.proto.backplane.grpc.Value candidates = 2;
inline int InCondition::_internal_candidates_size() const {
  return _internal_candidates().size();
}
inline int InCondition::candidates_size() const {
  return _internal_candidates_size();
}
inline void InCondition::clear_candidates() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.candidates_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::mutable_candidates(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return _internal_mutable_candidates()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Value>* InCondition::mutable_candidates()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_candidates();
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InCondition::candidates(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return _internal_candidates().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::Value* InCondition::add_candidates() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::Value* _add = _internal_mutable_candidates()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Value>& InCondition::candidates() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.InCondition.candidates)
  return _internal_candidates();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Value>&
InCondition::_internal_candidates() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.candidates_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Value>*
InCondition::_internal_mutable_candidates() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.candidates_;
}

// .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
inline void InCondition::clear_case_sensitivity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.case_sensitivity_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity InCondition::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InCondition.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void InCondition::set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.InCondition.case_sensitivity)
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity InCondition::_internal_case_sensitivity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::CaseSensitivity>(_impl_.case_sensitivity_);
}
inline void InCondition::_internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.case_sensitivity_ = value;
}

// .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
inline void InCondition::clear_match_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.match_type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::MatchType InCondition::match_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InCondition.match_type)
  return _internal_match_type();
}
inline void InCondition::set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  _internal_set_match_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.InCondition.match_type)
}
inline ::io::deephaven::proto::backplane::grpc::MatchType InCondition::_internal_match_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::MatchType>(_impl_.match_type_);
}
inline void InCondition::_internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.match_type_ = value;
}

// -------------------------------------------------------------------

// InvokeCondition

// string method = 1;
inline void InvokeCondition::clear_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.method_.ClearToEmpty();
}
inline const std::string& InvokeCondition::method() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
  return _internal_method();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InvokeCondition::set_method(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.method_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
}
inline std::string* InvokeCondition::mutable_method() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_method();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
  return _s;
}
inline const std::string& InvokeCondition::_internal_method() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.method_.Get();
}
inline void InvokeCondition::_internal_set_method(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.method_.Set(value, GetArena());
}
inline std::string* InvokeCondition::_internal_mutable_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.method_.Mutable( GetArena());
}
inline std::string* InvokeCondition::release_method() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
  return _impl_.method_.Release();
}
inline void InvokeCondition::set_allocated_method(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.method_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.method_.IsDefault()) {
          _impl_.method_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.InvokeCondition.method)
}

// .io.deephaven.proto.backplane.grpc.Value target = 2;
inline bool InvokeCondition::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline void InvokeCondition::clear_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.target_ != nullptr) _impl_.target_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InvokeCondition::_internal_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Value* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Value&>(::io::deephaven::proto::backplane::grpc::_Value_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InvokeCondition::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
  return _internal_target();
}
inline void InvokeCondition::unsafe_arena_set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Value* released = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::unsafe_arena_release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.InvokeCondition.target)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Value* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::_internal_mutable_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Value>(GetArena());
    _impl_.target_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(p);
  }
  return _impl_.target_;
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Value* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
  return _msg;
}
inline void InvokeCondition::set_allocated_target(::io::deephaven::proto::backplane::grpc::Value* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.target_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Value*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.InvokeCondition.target)
}

// repeated .io.deephaven.proto.backplane.grpc.Value arguments = 3;
inline int InvokeCondition::_internal_arguments_size() const {
  return _internal_arguments().size();
}
inline int InvokeCondition::arguments_size() const {
  return _internal_arguments_size();
}
inline void InvokeCondition::clear_arguments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.arguments_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::mutable_arguments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return _internal_mutable_arguments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Value>* InvokeCondition::mutable_arguments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_arguments();
}
inline const ::io::deephaven::proto::backplane::grpc::Value& InvokeCondition::arguments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return _internal_arguments().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::Value* InvokeCondition::add_arguments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::Value* _add = _internal_mutable_arguments()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Value>& InvokeCondition::arguments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.InvokeCondition.arguments)
  return _internal_arguments();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Value>&
InvokeCondition::_internal_arguments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.arguments_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Value>*
InvokeCondition::_internal_mutable_arguments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.arguments_;
}

// -------------------------------------------------------------------

// IsNullCondition

// .io.deephaven.proto.backplane.grpc.Reference reference = 1;
inline bool IsNullCondition::has_reference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reference_ != nullptr);
  return value;
}
inline void IsNullCondition::clear_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reference_ != nullptr) _impl_.reference_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& IsNullCondition::_internal_reference() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Reference* p = _impl_.reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Reference&>(::io::deephaven::proto::backplane::grpc::_Reference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& IsNullCondition::reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
  return _internal_reference();
}
inline void IsNullCondition::unsafe_arena_set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reference_);
  }
  _impl_.reference_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
}
inline ::io::deephaven::proto::backplane::grpc::Reference* IsNullCondition::release_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Reference* released = _impl_.reference_;
  _impl_.reference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* IsNullCondition::unsafe_arena_release_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Reference* temp = _impl_.reference_;
  _impl_.reference_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* IsNullCondition::_internal_mutable_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Reference>(GetArena());
    _impl_.reference_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(p);
  }
  return _impl_.reference_;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* IsNullCondition::mutable_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
  return _msg;
}
inline void IsNullCondition::set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(_impl_.reference_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reference_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.IsNullCondition.reference)
}

// -------------------------------------------------------------------

// MatchesCondition

// .io.deephaven.proto.backplane.grpc.Reference reference = 1;
inline bool MatchesCondition::has_reference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reference_ != nullptr);
  return value;
}
inline void MatchesCondition::clear_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reference_ != nullptr) _impl_.reference_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& MatchesCondition::_internal_reference() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Reference* p = _impl_.reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Reference&>(::io::deephaven::proto::backplane::grpc::_Reference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& MatchesCondition::reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
  return _internal_reference();
}
inline void MatchesCondition::unsafe_arena_set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reference_);
  }
  _impl_.reference_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
}
inline ::io::deephaven::proto::backplane::grpc::Reference* MatchesCondition::release_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Reference* released = _impl_.reference_;
  _impl_.reference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* MatchesCondition::unsafe_arena_release_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Reference* temp = _impl_.reference_;
  _impl_.reference_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* MatchesCondition::_internal_mutable_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Reference>(GetArena());
    _impl_.reference_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(p);
  }
  return _impl_.reference_;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* MatchesCondition::mutable_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
  return _msg;
}
inline void MatchesCondition::set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(_impl_.reference_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reference_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MatchesCondition.reference)
}

// string regex = 2;
inline void MatchesCondition::clear_regex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.regex_.ClearToEmpty();
}
inline const std::string& MatchesCondition::regex() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
  return _internal_regex();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MatchesCondition::set_regex(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.regex_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
}
inline std::string* MatchesCondition::mutable_regex() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_regex();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
  return _s;
}
inline const std::string& MatchesCondition::_internal_regex() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.regex_.Get();
}
inline void MatchesCondition::_internal_set_regex(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.regex_.Set(value, GetArena());
}
inline std::string* MatchesCondition::_internal_mutable_regex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.regex_.Mutable( GetArena());
}
inline std::string* MatchesCondition::release_regex() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
  return _impl_.regex_.Release();
}
inline void MatchesCondition::set_allocated_regex(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.regex_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.regex_.IsDefault()) {
          _impl_.regex_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MatchesCondition.regex)
}

// .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
inline void MatchesCondition::clear_case_sensitivity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.case_sensitivity_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity MatchesCondition::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MatchesCondition.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void MatchesCondition::set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MatchesCondition.case_sensitivity)
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity MatchesCondition::_internal_case_sensitivity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::CaseSensitivity>(_impl_.case_sensitivity_);
}
inline void MatchesCondition::_internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.case_sensitivity_ = value;
}

// .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
inline void MatchesCondition::clear_match_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.match_type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::MatchType MatchesCondition::match_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MatchesCondition.match_type)
  return _internal_match_type();
}
inline void MatchesCondition::set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  _internal_set_match_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.MatchesCondition.match_type)
}
inline ::io::deephaven::proto::backplane::grpc::MatchType MatchesCondition::_internal_match_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::MatchType>(_impl_.match_type_);
}
inline void MatchesCondition::_internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.match_type_ = value;
}

// -------------------------------------------------------------------

// ContainsCondition

// .io.deephaven.proto.backplane.grpc.Reference reference = 1;
inline bool ContainsCondition::has_reference() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.reference_ != nullptr);
  return value;
}
inline void ContainsCondition::clear_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.reference_ != nullptr) _impl_.reference_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& ContainsCondition::_internal_reference() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Reference* p = _impl_.reference_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Reference&>(::io::deephaven::proto::backplane::grpc::_Reference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& ContainsCondition::reference() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
  return _internal_reference();
}
inline void ContainsCondition::unsafe_arena_set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.reference_);
  }
  _impl_.reference_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
}
inline ::io::deephaven::proto::backplane::grpc::Reference* ContainsCondition::release_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Reference* released = _impl_.reference_;
  _impl_.reference_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* ContainsCondition::unsafe_arena_release_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Reference* temp = _impl_.reference_;
  _impl_.reference_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* ContainsCondition::_internal_mutable_reference() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.reference_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Reference>(GetArena());
    _impl_.reference_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(p);
  }
  return _impl_.reference_;
}
inline ::io::deephaven::proto::backplane::grpc::Reference* ContainsCondition::mutable_reference() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Reference* _msg = _internal_mutable_reference();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
  return _msg;
}
inline void ContainsCondition::set_allocated_reference(::io::deephaven::proto::backplane::grpc::Reference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(_impl_.reference_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.reference_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Reference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ContainsCondition.reference)
}

// string search_string = 2;
inline void ContainsCondition::clear_search_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.search_string_.ClearToEmpty();
}
inline const std::string& ContainsCondition::search_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
  return _internal_search_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ContainsCondition::set_search_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.search_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
}
inline std::string* ContainsCondition::mutable_search_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_search_string();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
  return _s;
}
inline const std::string& ContainsCondition::_internal_search_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.search_string_.Get();
}
inline void ContainsCondition::_internal_set_search_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.search_string_.Set(value, GetArena());
}
inline std::string* ContainsCondition::_internal_mutable_search_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.search_string_.Mutable( GetArena());
}
inline std::string* ContainsCondition::release_search_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
  return _impl_.search_string_.Release();
}
inline void ContainsCondition::set_allocated_search_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.search_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.search_string_.IsDefault()) {
          _impl_.search_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ContainsCondition.search_string)
}

// .io.deephaven.proto.backplane.grpc.CaseSensitivity case_sensitivity = 3;
inline void ContainsCondition::clear_case_sensitivity() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.case_sensitivity_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity ContainsCondition::case_sensitivity() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ContainsCondition.case_sensitivity)
  return _internal_case_sensitivity();
}
inline void ContainsCondition::set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  _internal_set_case_sensitivity(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ContainsCondition.case_sensitivity)
}
inline ::io::deephaven::proto::backplane::grpc::CaseSensitivity ContainsCondition::_internal_case_sensitivity() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::CaseSensitivity>(_impl_.case_sensitivity_);
}
inline void ContainsCondition::_internal_set_case_sensitivity(::io::deephaven::proto::backplane::grpc::CaseSensitivity value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.case_sensitivity_ = value;
}

// .io.deephaven.proto.backplane.grpc.MatchType match_type = 4;
inline void ContainsCondition::clear_match_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.match_type_ = 0;
}
inline ::io::deephaven::proto::backplane::grpc::MatchType ContainsCondition::match_type() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ContainsCondition.match_type)
  return _internal_match_type();
}
inline void ContainsCondition::set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  _internal_set_match_type(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ContainsCondition.match_type)
}
inline ::io::deephaven::proto::backplane::grpc::MatchType ContainsCondition::_internal_match_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::io::deephaven::proto::backplane::grpc::MatchType>(_impl_.match_type_);
}
inline void ContainsCondition::_internal_set_match_type(::io::deephaven::proto::backplane::grpc::MatchType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.match_type_ = value;
}

// -------------------------------------------------------------------

// SearchCondition

// string search_string = 1;
inline void SearchCondition::clear_search_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.search_string_.ClearToEmpty();
}
inline const std::string& SearchCondition::search_string() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
  return _internal_search_string();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SearchCondition::set_search_string(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.search_string_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
}
inline std::string* SearchCondition::mutable_search_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_search_string();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
  return _s;
}
inline const std::string& SearchCondition::_internal_search_string() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.search_string_.Get();
}
inline void SearchCondition::_internal_set_search_string(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.search_string_.Set(value, GetArena());
}
inline std::string* SearchCondition::_internal_mutable_search_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.search_string_.Mutable( GetArena());
}
inline std::string* SearchCondition::release_search_string() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
  return _impl_.search_string_.Release();
}
inline void SearchCondition::set_allocated_search_string(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.search_string_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.search_string_.IsDefault()) {
          _impl_.search_string_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.SearchCondition.search_string)
}

// repeated .io.deephaven.proto.backplane.grpc.Reference optional_references = 2;
inline int SearchCondition::_internal_optional_references_size() const {
  return _internal_optional_references().size();
}
inline int SearchCondition::optional_references_size() const {
  return _internal_optional_references_size();
}
inline void SearchCondition::clear_optional_references() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.optional_references_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::Reference* SearchCondition::mutable_optional_references(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return _internal_mutable_optional_references()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Reference>* SearchCondition::mutable_optional_references()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_optional_references();
}
inline const ::io::deephaven::proto::backplane::grpc::Reference& SearchCondition::optional_references(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return _internal_optional_references().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::Reference* SearchCondition::add_optional_references() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::Reference* _add = _internal_mutable_optional_references()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Reference>& SearchCondition::optional_references() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.SearchCondition.optional_references)
  return _internal_optional_references();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Reference>&
SearchCondition::_internal_optional_references() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.optional_references_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::Reference>*
SearchCondition::_internal_mutable_optional_references() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.optional_references_;
}

// -------------------------------------------------------------------

// FlattenRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool FlattenRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FlattenRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& FlattenRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
  return _internal_result_id();
}
inline void FlattenRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FlattenRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FlattenRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FlattenRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* FlattenRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
  return _msg;
}
inline void FlattenRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FlattenRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool FlattenRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void FlattenRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FlattenRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& FlattenRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
  return _internal_source_id();
}
inline void FlattenRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FlattenRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FlattenRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FlattenRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* FlattenRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
  return _msg;
}
inline void FlattenRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.FlattenRequest.source_id)
}

// -------------------------------------------------------------------

// MetaTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool MetaTableRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& MetaTableRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& MetaTableRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MetaTableRequest.result_id)
  return _internal_result_id();
}
inline void MetaTableRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.MetaTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MetaTableRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MetaTableRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MetaTableRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MetaTableRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* MetaTableRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MetaTableRequest.result_id)
  return _msg;
}
inline void MetaTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MetaTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool MetaTableRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void MetaTableRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& MetaTableRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& MetaTableRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.MetaTableRequest.source_id)
  return _internal_source_id();
}
inline void MetaTableRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.MetaTableRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MetaTableRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MetaTableRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.MetaTableRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MetaTableRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* MetaTableRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.MetaTableRequest.source_id)
  return _msg;
}
inline void MetaTableRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.MetaTableRequest.source_id)
}

// -------------------------------------------------------------------

// RunChartDownsampleRequest_ZoomRange

// optional int64 min_date_nanos = 1 [jstype = JS_STRING];
inline bool RunChartDownsampleRequest_ZoomRange::has_min_date_nanos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void RunChartDownsampleRequest_ZoomRange::clear_min_date_nanos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.min_date_nanos_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::int64_t RunChartDownsampleRequest_ZoomRange::min_date_nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange.min_date_nanos)
  return _internal_min_date_nanos();
}
inline void RunChartDownsampleRequest_ZoomRange::set_min_date_nanos(::int64_t value) {
  _internal_set_min_date_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange.min_date_nanos)
}
inline ::int64_t RunChartDownsampleRequest_ZoomRange::_internal_min_date_nanos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.min_date_nanos_;
}
inline void RunChartDownsampleRequest_ZoomRange::_internal_set_min_date_nanos(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.min_date_nanos_ = value;
}

// optional int64 max_date_nanos = 2 [jstype = JS_STRING];
inline bool RunChartDownsampleRequest_ZoomRange::has_max_date_nanos() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void RunChartDownsampleRequest_ZoomRange::clear_max_date_nanos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.max_date_nanos_ = ::int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::int64_t RunChartDownsampleRequest_ZoomRange::max_date_nanos() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange.max_date_nanos)
  return _internal_max_date_nanos();
}
inline void RunChartDownsampleRequest_ZoomRange::set_max_date_nanos(::int64_t value) {
  _internal_set_max_date_nanos(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange.max_date_nanos)
}
inline ::int64_t RunChartDownsampleRequest_ZoomRange::_internal_max_date_nanos() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.max_date_nanos_;
}
inline void RunChartDownsampleRequest_ZoomRange::_internal_set_max_date_nanos(::int64_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_date_nanos_ = value;
}

// -------------------------------------------------------------------

// RunChartDownsampleRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool RunChartDownsampleRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& RunChartDownsampleRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& RunChartDownsampleRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
  return _internal_result_id();
}
inline void RunChartDownsampleRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RunChartDownsampleRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RunChartDownsampleRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RunChartDownsampleRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* RunChartDownsampleRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
  return _msg;
}
inline void RunChartDownsampleRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool RunChartDownsampleRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void RunChartDownsampleRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RunChartDownsampleRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& RunChartDownsampleRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
  return _internal_source_id();
}
inline void RunChartDownsampleRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RunChartDownsampleRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RunChartDownsampleRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RunChartDownsampleRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* RunChartDownsampleRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
  return _msg;
}
inline void RunChartDownsampleRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.source_id)
}

// int32 pixel_count = 3;
inline void RunChartDownsampleRequest::clear_pixel_count() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.pixel_count_ = 0;
}
inline ::int32_t RunChartDownsampleRequest::pixel_count() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.pixel_count)
  return _internal_pixel_count();
}
inline void RunChartDownsampleRequest::set_pixel_count(::int32_t value) {
  _internal_set_pixel_count(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.pixel_count)
}
inline ::int32_t RunChartDownsampleRequest::_internal_pixel_count() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.pixel_count_;
}
inline void RunChartDownsampleRequest::_internal_set_pixel_count(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.pixel_count_ = value;
}

// .io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.ZoomRange zoom_range = 4;
inline bool RunChartDownsampleRequest::has_zoom_range() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.zoom_range_ != nullptr);
  return value;
}
inline void RunChartDownsampleRequest::clear_zoom_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.zoom_range_ != nullptr) _impl_.zoom_range_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange& RunChartDownsampleRequest::_internal_zoom_range() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* p = _impl_.zoom_range_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange&>(::io::deephaven::proto::backplane::grpc::_RunChartDownsampleRequest_ZoomRange_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange& RunChartDownsampleRequest::zoom_range() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
  return _internal_zoom_range();
}
inline void RunChartDownsampleRequest::unsafe_arena_set_allocated_zoom_range(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.zoom_range_);
  }
  _impl_.zoom_range_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* RunChartDownsampleRequest::release_zoom_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* released = _impl_.zoom_range_;
  _impl_.zoom_range_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* RunChartDownsampleRequest::unsafe_arena_release_zoom_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* temp = _impl_.zoom_range_;
  _impl_.zoom_range_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* RunChartDownsampleRequest::_internal_mutable_zoom_range() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.zoom_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange>(GetArena());
    _impl_.zoom_range_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange*>(p);
  }
  return _impl_.zoom_range_;
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* RunChartDownsampleRequest::mutable_zoom_range() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* _msg = _internal_mutable_zoom_range();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
  return _msg;
}
inline void RunChartDownsampleRequest::set_allocated_zoom_range(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange*>(_impl_.zoom_range_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.zoom_range_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest_ZoomRange*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.zoom_range)
}

// string x_column_name = 5;
inline void RunChartDownsampleRequest::clear_x_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_column_name_.ClearToEmpty();
}
inline const std::string& RunChartDownsampleRequest::x_column_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
  return _internal_x_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RunChartDownsampleRequest::set_x_column_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
}
inline std::string* RunChartDownsampleRequest::mutable_x_column_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_x_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
  return _s;
}
inline const std::string& RunChartDownsampleRequest::_internal_x_column_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_column_name_.Get();
}
inline void RunChartDownsampleRequest::_internal_set_x_column_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.x_column_name_.Set(value, GetArena());
}
inline std::string* RunChartDownsampleRequest::_internal_mutable_x_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.x_column_name_.Mutable( GetArena());
}
inline std::string* RunChartDownsampleRequest::release_x_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
  return _impl_.x_column_name_.Release();
}
inline void RunChartDownsampleRequest::set_allocated_x_column_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.x_column_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.x_column_name_.IsDefault()) {
          _impl_.x_column_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.x_column_name)
}

// repeated string y_column_names = 6;
inline int RunChartDownsampleRequest::_internal_y_column_names_size() const {
  return _internal_y_column_names().size();
}
inline int RunChartDownsampleRequest::y_column_names_size() const {
  return _internal_y_column_names_size();
}
inline void RunChartDownsampleRequest::clear_y_column_names() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.y_column_names_.Clear();
}
inline std::string* RunChartDownsampleRequest::add_y_column_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_y_column_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return _s;
}
inline const std::string& RunChartDownsampleRequest::y_column_names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return _internal_y_column_names().Get(index);
}
inline std::string* RunChartDownsampleRequest::mutable_y_column_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return _internal_mutable_y_column_names()->Mutable(index);
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, const std::string& value) {
  _internal_mutable_y_column_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, std::string&& value) {
  _internal_mutable_y_column_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_y_column_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_y_column_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::set_y_column_names(int index, absl::string_view value) {
  _internal_mutable_y_column_names()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::add_y_column_names(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_y_column_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::add_y_column_names(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_y_column_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::add_y_column_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_y_column_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::add_y_column_names(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_y_column_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline void RunChartDownsampleRequest::add_y_column_names(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_y_column_names()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RunChartDownsampleRequest::y_column_names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  return _internal_y_column_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RunChartDownsampleRequest::mutable_y_column_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest.y_column_names)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_y_column_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
RunChartDownsampleRequest::_internal_y_column_names() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_column_names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
RunChartDownsampleRequest::_internal_mutable_y_column_names() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.y_column_names_;
}

// -------------------------------------------------------------------

// CreateInputTableRequest_InputTableKind_InMemoryAppendOnly

// -------------------------------------------------------------------

// CreateInputTableRequest_InputTableKind_InMemoryKeyBacked

// repeated string key_columns = 1;
inline int CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::_internal_key_columns_size() const {
  return _internal_key_columns().size();
}
inline int CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::key_columns_size() const {
  return _internal_key_columns_size();
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::clear_key_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.key_columns_.Clear();
}
inline std::string* CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::add_key_columns()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_key_columns()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
  return _s;
}
inline const std::string& CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::key_columns(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
  return _internal_key_columns().Get(index);
}
inline std::string* CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::mutable_key_columns(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
  return _internal_mutable_key_columns()->Mutable(index);
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::set_key_columns(int index, const std::string& value) {
  _internal_mutable_key_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::set_key_columns(int index, std::string&& value) {
  _internal_mutable_key_columns()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::set_key_columns(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_key_columns()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::set_key_columns(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_key_columns()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::set_key_columns(int index, absl::string_view value) {
  _internal_mutable_key_columns()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::add_key_columns(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_key_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::add_key_columns(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_key_columns()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::add_key_columns(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_key_columns()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::add_key_columns(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_key_columns()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline void CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::add_key_columns(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_key_columns()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::key_columns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
  return _internal_key_columns();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::mutable_key_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked.key_columns)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_key_columns();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::_internal_key_columns() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.key_columns_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
CreateInputTableRequest_InputTableKind_InMemoryKeyBacked::_internal_mutable_key_columns() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.key_columns_;
}

// -------------------------------------------------------------------

// CreateInputTableRequest_InputTableKind_Blink

// -------------------------------------------------------------------

// CreateInputTableRequest_InputTableKind

// .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryAppendOnly in_memory_append_only = 1;
inline bool CreateInputTableRequest_InputTableKind::has_in_memory_append_only() const {
  return kind_case() == kInMemoryAppendOnly;
}
inline bool CreateInputTableRequest_InputTableKind::_internal_has_in_memory_append_only() const {
  return kind_case() == kInMemoryAppendOnly;
}
inline void CreateInputTableRequest_InputTableKind::set_has_in_memory_append_only() {
  _impl_._oneof_case_[0] = kInMemoryAppendOnly;
}
inline void CreateInputTableRequest_InputTableKind::clear_in_memory_append_only() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kInMemoryAppendOnly) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.in_memory_append_only_;
    }
    clear_has_kind();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* CreateInputTableRequest_InputTableKind::release_in_memory_append_only() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_append_only)
  if (kind_case() == kInMemoryAppendOnly) {
    clear_has_kind();
    auto* temp = _impl_.kind_.in_memory_append_only_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.in_memory_append_only_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& CreateInputTableRequest_InputTableKind::_internal_in_memory_append_only() const {
  return kind_case() == kInMemoryAppendOnly ? *_impl_.kind_.in_memory_append_only_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly&>(::io::deephaven::proto::backplane::grpc::_CreateInputTableRequest_InputTableKind_InMemoryAppendOnly_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly& CreateInputTableRequest_InputTableKind::in_memory_append_only() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_append_only)
  return _internal_in_memory_append_only();
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* CreateInputTableRequest_InputTableKind::unsafe_arena_release_in_memory_append_only() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_append_only)
  if (kind_case() == kInMemoryAppendOnly) {
    clear_has_kind();
    auto* temp = _impl_.kind_.in_memory_append_only_;
    _impl_.kind_.in_memory_append_only_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateInputTableRequest_InputTableKind::unsafe_arena_set_allocated_in_memory_append_only(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_in_memory_append_only();
    _impl_.kind_.in_memory_append_only_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_append_only)
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* CreateInputTableRequest_InputTableKind::_internal_mutable_in_memory_append_only() {
  if (kind_case() != kInMemoryAppendOnly) {
    clear_kind();
    set_has_in_memory_append_only();
    _impl_.kind_.in_memory_append_only_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly>(GetArena());
  }
  return _impl_.kind_.in_memory_append_only_;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* CreateInputTableRequest_InputTableKind::mutable_in_memory_append_only() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryAppendOnly* _msg = _internal_mutable_in_memory_append_only();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_append_only)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.InMemoryKeyBacked in_memory_key_backed = 2;
inline bool CreateInputTableRequest_InputTableKind::has_in_memory_key_backed() const {
  return kind_case() == kInMemoryKeyBacked;
}
inline bool CreateInputTableRequest_InputTableKind::_internal_has_in_memory_key_backed() const {
  return kind_case() == kInMemoryKeyBacked;
}
inline void CreateInputTableRequest_InputTableKind::set_has_in_memory_key_backed() {
  _impl_._oneof_case_[0] = kInMemoryKeyBacked;
}
inline void CreateInputTableRequest_InputTableKind::clear_in_memory_key_backed() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kInMemoryKeyBacked) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.in_memory_key_backed_;
    }
    clear_has_kind();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* CreateInputTableRequest_InputTableKind::release_in_memory_key_backed() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_key_backed)
  if (kind_case() == kInMemoryKeyBacked) {
    clear_has_kind();
    auto* temp = _impl_.kind_.in_memory_key_backed_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.in_memory_key_backed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& CreateInputTableRequest_InputTableKind::_internal_in_memory_key_backed() const {
  return kind_case() == kInMemoryKeyBacked ? *_impl_.kind_.in_memory_key_backed_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked&>(::io::deephaven::proto::backplane::grpc::_CreateInputTableRequest_InputTableKind_InMemoryKeyBacked_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked& CreateInputTableRequest_InputTableKind::in_memory_key_backed() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_key_backed)
  return _internal_in_memory_key_backed();
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* CreateInputTableRequest_InputTableKind::unsafe_arena_release_in_memory_key_backed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_key_backed)
  if (kind_case() == kInMemoryKeyBacked) {
    clear_has_kind();
    auto* temp = _impl_.kind_.in_memory_key_backed_;
    _impl_.kind_.in_memory_key_backed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateInputTableRequest_InputTableKind::unsafe_arena_set_allocated_in_memory_key_backed(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_in_memory_key_backed();
    _impl_.kind_.in_memory_key_backed_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_key_backed)
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* CreateInputTableRequest_InputTableKind::_internal_mutable_in_memory_key_backed() {
  if (kind_case() != kInMemoryKeyBacked) {
    clear_kind();
    set_has_in_memory_key_backed();
    _impl_.kind_.in_memory_key_backed_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked>(GetArena());
  }
  return _impl_.kind_.in_memory_key_backed_;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* CreateInputTableRequest_InputTableKind::mutable_in_memory_key_backed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_InMemoryKeyBacked* _msg = _internal_mutable_in_memory_key_backed();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.in_memory_key_backed)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.Blink blink = 3;
inline bool CreateInputTableRequest_InputTableKind::has_blink() const {
  return kind_case() == kBlink;
}
inline bool CreateInputTableRequest_InputTableKind::_internal_has_blink() const {
  return kind_case() == kBlink;
}
inline void CreateInputTableRequest_InputTableKind::set_has_blink() {
  _impl_._oneof_case_[0] = kBlink;
}
inline void CreateInputTableRequest_InputTableKind::clear_blink() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kBlink) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.blink_;
    }
    clear_has_kind();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* CreateInputTableRequest_InputTableKind::release_blink() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.blink)
  if (kind_case() == kBlink) {
    clear_has_kind();
    auto* temp = _impl_.kind_.blink_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.blink_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink& CreateInputTableRequest_InputTableKind::_internal_blink() const {
  return kind_case() == kBlink ? *_impl_.kind_.blink_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink&>(::io::deephaven::proto::backplane::grpc::_CreateInputTableRequest_InputTableKind_Blink_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink& CreateInputTableRequest_InputTableKind::blink() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.blink)
  return _internal_blink();
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* CreateInputTableRequest_InputTableKind::unsafe_arena_release_blink() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.blink)
  if (kind_case() == kBlink) {
    clear_has_kind();
    auto* temp = _impl_.kind_.blink_;
    _impl_.kind_.blink_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateInputTableRequest_InputTableKind::unsafe_arena_set_allocated_blink(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_blink();
    _impl_.kind_.blink_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.blink)
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* CreateInputTableRequest_InputTableKind::_internal_mutable_blink() {
  if (kind_case() != kBlink) {
    clear_kind();
    set_has_blink();
    _impl_.kind_.blink_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink>(GetArena());
  }
  return _impl_.kind_.blink_;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* CreateInputTableRequest_InputTableKind::mutable_blink() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind_Blink* _msg = _internal_mutable_blink();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind.blink)
  return _msg;
}

inline bool CreateInputTableRequest_InputTableKind::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void CreateInputTableRequest_InputTableKind::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline CreateInputTableRequest_InputTableKind::KindCase CreateInputTableRequest_InputTableKind::kind_case() const {
  return CreateInputTableRequest_InputTableKind::KindCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateInputTableRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool CreateInputTableRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CreateInputTableRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& CreateInputTableRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.result_id)
  return _internal_result_id();
}
inline void CreateInputTableRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CreateInputTableRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CreateInputTableRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CreateInputTableRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* CreateInputTableRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.result_id)
  return _msg;
}
inline void CreateInputTableRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_table_id = 2;
inline bool CreateInputTableRequest::has_source_table_id() const {
  return definition_case() == kSourceTableId;
}
inline bool CreateInputTableRequest::_internal_has_source_table_id() const {
  return definition_case() == kSourceTableId;
}
inline void CreateInputTableRequest::set_has_source_table_id() {
  _impl_._oneof_case_[0] = kSourceTableId;
}
inline void CreateInputTableRequest::clear_source_table_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (definition_case() == kSourceTableId) {
    if (GetArena() == nullptr) {
      delete _impl_.definition_.source_table_id_;
    }
    clear_has_definition();
  }
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CreateInputTableRequest::release_source_table_id() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.source_table_id)
  if (definition_case() == kSourceTableId) {
    clear_has_definition();
    auto* temp = _impl_.definition_.source_table_id_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.definition_.source_table_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CreateInputTableRequest::_internal_source_table_id() const {
  return definition_case() == kSourceTableId ? *_impl_.definition_.source_table_id_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& CreateInputTableRequest::source_table_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.source_table_id)
  return _internal_source_table_id();
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CreateInputTableRequest::unsafe_arena_release_source_table_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.source_table_id)
  if (definition_case() == kSourceTableId) {
    clear_has_definition();
    auto* temp = _impl_.definition_.source_table_id_;
    _impl_.definition_.source_table_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateInputTableRequest::unsafe_arena_set_allocated_source_table_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_definition();
  if (value) {
    set_has_source_table_id();
    _impl_.definition_.source_table_id_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.source_table_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CreateInputTableRequest::_internal_mutable_source_table_id() {
  if (definition_case() != kSourceTableId) {
    clear_definition();
    set_has_source_table_id();
    _impl_.definition_.source_table_id_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
  }
  return _impl_.definition_.source_table_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* CreateInputTableRequest::mutable_source_table_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_table_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.source_table_id)
  return _msg;
}

// bytes schema = 3;
inline bool CreateInputTableRequest::has_schema() const {
  return definition_case() == kSchema;
}
inline void CreateInputTableRequest::set_has_schema() {
  _impl_._oneof_case_[0] = kSchema;
}
inline void CreateInputTableRequest::clear_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (definition_case() == kSchema) {
    _impl_.definition_.schema_.Destroy();
    clear_has_definition();
  }
}
inline const std::string& CreateInputTableRequest::schema() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.schema)
  return _internal_schema();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void CreateInputTableRequest::set_schema(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (definition_case() != kSchema) {
    clear_definition();

    set_has_schema();
    _impl_.definition_.schema_.InitDefault();
  }
  _impl_.definition_.schema_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.schema)
}
inline std::string* CreateInputTableRequest::mutable_schema() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schema();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.schema)
  return _s;
}
inline const std::string& CreateInputTableRequest::_internal_schema() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (definition_case() != kSchema) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.definition_.schema_.Get();
}
inline void CreateInputTableRequest::_internal_set_schema(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (definition_case() != kSchema) {
    clear_definition();

    set_has_schema();
    _impl_.definition_.schema_.InitDefault();
  }
  _impl_.definition_.schema_.Set(value, GetArena());
}
inline std::string* CreateInputTableRequest::_internal_mutable_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (definition_case() != kSchema) {
    clear_definition();

    set_has_schema();
    _impl_.definition_.schema_.InitDefault();
  }
  return _impl_.definition_.schema_.Mutable( GetArena());
}
inline std::string* CreateInputTableRequest::release_schema() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.schema)
  if (definition_case() != kSchema) {
    return nullptr;
  }
  clear_has_definition();
  return _impl_.definition_.schema_.Release();
}
inline void CreateInputTableRequest::set_allocated_schema(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_definition()) {
    clear_definition();
  }
  if (value != nullptr) {
    set_has_schema();
    _impl_.definition_.schema_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.schema)
}

// .io.deephaven.proto.backplane.grpc.CreateInputTableRequest.InputTableKind kind = 4;
inline bool CreateInputTableRequest::has_kind() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.kind_ != nullptr);
  return value;
}
inline void CreateInputTableRequest::clear_kind() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.kind_ != nullptr) _impl_.kind_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind& CreateInputTableRequest::_internal_kind() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* p = _impl_.kind_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind&>(::io::deephaven::proto::backplane::grpc::_CreateInputTableRequest_InputTableKind_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind& CreateInputTableRequest::kind() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.kind)
  return _internal_kind();
}
inline void CreateInputTableRequest::unsafe_arena_set_allocated_kind(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.kind_);
  }
  _impl_.kind_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.kind)
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* CreateInputTableRequest::release_kind() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* released = _impl_.kind_;
  _impl_.kind_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* CreateInputTableRequest::unsafe_arena_release_kind() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.kind)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* temp = _impl_.kind_;
  _impl_.kind_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* CreateInputTableRequest::_internal_mutable_kind() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.kind_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind>(GetArena());
    _impl_.kind_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind*>(p);
  }
  return _impl_.kind_;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* CreateInputTableRequest::mutable_kind() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* _msg = _internal_mutable_kind();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.kind)
  return _msg;
}
inline void CreateInputTableRequest::set_allocated_kind(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind*>(_impl_.kind_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.kind_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest_InputTableKind*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.CreateInputTableRequest.kind)
}

inline bool CreateInputTableRequest::has_definition() const {
  return definition_case() != DEFINITION_NOT_SET;
}
inline void CreateInputTableRequest::clear_has_definition() {
  _impl_._oneof_case_[0] = DEFINITION_NOT_SET;
}
inline CreateInputTableRequest::DefinitionCase CreateInputTableRequest::definition_case() const {
  return CreateInputTableRequest::DefinitionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// WhereInRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool WhereInRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& WhereInRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& WhereInRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.WhereInRequest.result_id)
  return _internal_result_id();
}
inline void WhereInRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.WhereInRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* WhereInRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* WhereInRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.WhereInRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* WhereInRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* WhereInRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.WhereInRequest.result_id)
  return _msg;
}
inline void WhereInRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.WhereInRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference left_id = 2;
inline bool WhereInRequest::has_left_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.left_id_ != nullptr);
  return value;
}
inline void WhereInRequest::clear_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.left_id_ != nullptr) _impl_.left_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& WhereInRequest::_internal_left_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.left_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& WhereInRequest::left_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.WhereInRequest.left_id)
  return _internal_left_id();
}
inline void WhereInRequest::unsafe_arena_set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.left_id_);
  }
  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.WhereInRequest.left_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::unsafe_arena_release_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.WhereInRequest.left_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.left_id_;
  _impl_.left_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::_internal_mutable_left_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.left_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.left_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::mutable_left_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_left_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.WhereInRequest.left_id)
  return _msg;
}
inline void WhereInRequest::set_allocated_left_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.left_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.left_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.WhereInRequest.left_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference right_id = 3;
inline bool WhereInRequest::has_right_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.right_id_ != nullptr);
  return value;
}
inline void WhereInRequest::clear_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.right_id_ != nullptr) _impl_.right_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& WhereInRequest::_internal_right_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.right_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& WhereInRequest::right_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.WhereInRequest.right_id)
  return _internal_right_id();
}
inline void WhereInRequest::unsafe_arena_set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.right_id_);
  }
  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.WhereInRequest.right_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::unsafe_arena_release_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.WhereInRequest.right_id)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.right_id_;
  _impl_.right_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::_internal_mutable_right_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.right_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.right_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* WhereInRequest::mutable_right_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_right_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.WhereInRequest.right_id)
  return _msg;
}
inline void WhereInRequest::set_allocated_right_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.right_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.right_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.WhereInRequest.right_id)
}

// bool inverted = 4;
inline void WhereInRequest::clear_inverted() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.inverted_ = false;
}
inline bool WhereInRequest::inverted() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.WhereInRequest.inverted)
  return _internal_inverted();
}
inline void WhereInRequest::set_inverted(bool value) {
  _internal_set_inverted(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.WhereInRequest.inverted)
}
inline bool WhereInRequest::_internal_inverted() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.inverted_;
}
inline void WhereInRequest::_internal_set_inverted(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.inverted_ = value;
}

// repeated string columns_to_match = 5;
inline int WhereInRequest::_internal_columns_to_match_size() const {
  return _internal_columns_to_match().size();
}
inline int WhereInRequest::columns_to_match_size() const {
  return _internal_columns_to_match_size();
}
inline void WhereInRequest::clear_columns_to_match() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.columns_to_match_.Clear();
}
inline std::string* WhereInRequest::add_columns_to_match()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_columns_to_match()->Add();
  // @@protoc_insertion_point(field_add_mutable:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
  return _s;
}
inline const std::string& WhereInRequest::columns_to_match(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
  return _internal_columns_to_match().Get(index);
}
inline std::string* WhereInRequest::mutable_columns_to_match(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
  return _internal_mutable_columns_to_match()->Mutable(index);
}
inline void WhereInRequest::set_columns_to_match(int index, const std::string& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::set_columns_to_match(int index, std::string&& value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::set_columns_to_match(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::set_columns_to_match(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::set_columns_to_match(int index, absl::string_view value) {
  _internal_mutable_columns_to_match()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::add_columns_to_match(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::add_columns_to_match(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::add_columns_to_match(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::add_columns_to_match(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline void WhereInRequest::add_columns_to_match(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_columns_to_match()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
WhereInRequest::columns_to_match() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
  return _internal_columns_to_match();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
WhereInRequest::mutable_columns_to_match() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.WhereInRequest.columns_to_match)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_columns_to_match();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
WhereInRequest::_internal_columns_to_match() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.columns_to_match_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
WhereInRequest::_internal_mutable_columns_to_match() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.columns_to_match_;
}

// -------------------------------------------------------------------

// ColumnStatisticsRequest

// .io.deephaven.proto.backplane.grpc.Ticket result_id = 1;
inline bool ColumnStatisticsRequest::has_result_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.result_id_ != nullptr);
  return value;
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ColumnStatisticsRequest::_internal_result_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::Ticket* p = _impl_.result_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::Ticket&>(::io::deephaven::proto::backplane::grpc::_Ticket_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::Ticket& ColumnStatisticsRequest::result_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.result_id)
  return _internal_result_id();
}
inline void ColumnStatisticsRequest::unsafe_arena_set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }
  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.result_id)
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ColumnStatisticsRequest::release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* released = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ColumnStatisticsRequest::unsafe_arena_release_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.result_id)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::io::deephaven::proto::backplane::grpc::Ticket* temp = _impl_.result_id_;
  _impl_.result_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ColumnStatisticsRequest::_internal_mutable_result_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.result_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::Ticket>(GetArena());
    _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(p);
  }
  return _impl_.result_id_;
}
inline ::io::deephaven::proto::backplane::grpc::Ticket* ColumnStatisticsRequest::mutable_result_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::Ticket* _msg = _internal_mutable_result_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.result_id)
  return _msg;
}
inline void ColumnStatisticsRequest::set_allocated_result_id(::io::deephaven::proto::backplane::grpc::Ticket* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.result_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.result_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::Ticket*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.result_id)
}

// .io.deephaven.proto.backplane.grpc.TableReference source_id = 2;
inline bool ColumnStatisticsRequest::has_source_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.source_id_ != nullptr);
  return value;
}
inline void ColumnStatisticsRequest::clear_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.source_id_ != nullptr) _impl_.source_id_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ColumnStatisticsRequest::_internal_source_id() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::io::deephaven::proto::backplane::grpc::TableReference* p = _impl_.source_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::io::deephaven::proto::backplane::grpc::TableReference&>(::io::deephaven::proto::backplane::grpc::_TableReference_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TableReference& ColumnStatisticsRequest::source_id() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.source_id)
  return _internal_source_id();
}
inline void ColumnStatisticsRequest::unsafe_arena_set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.source_id_);
  }
  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.source_id)
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ColumnStatisticsRequest::release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* released = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ColumnStatisticsRequest::unsafe_arena_release_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.source_id)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::io::deephaven::proto::backplane::grpc::TableReference* temp = _impl_.source_id_;
  _impl_.source_id_ = nullptr;
  return temp;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ColumnStatisticsRequest::_internal_mutable_source_id() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.source_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TableReference>(GetArena());
    _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(p);
  }
  return _impl_.source_id_;
}
inline ::io::deephaven::proto::backplane::grpc::TableReference* ColumnStatisticsRequest::mutable_source_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TableReference* _msg = _internal_mutable_source_id();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.source_id)
  return _msg;
}
inline void ColumnStatisticsRequest::set_allocated_source_id(::io::deephaven::proto::backplane::grpc::TableReference* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(_impl_.source_id_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.source_id_ = reinterpret_cast<::io::deephaven::proto::backplane::grpc::TableReference*>(value);
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.source_id)
}

// string column_name = 3;
inline void ColumnStatisticsRequest::clear_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.ClearToEmpty();
}
inline const std::string& ColumnStatisticsRequest::column_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.column_name)
  return _internal_column_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ColumnStatisticsRequest::set_column_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.column_name)
}
inline std::string* ColumnStatisticsRequest::mutable_column_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_column_name();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.column_name)
  return _s;
}
inline const std::string& ColumnStatisticsRequest::_internal_column_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.column_name_.Get();
}
inline void ColumnStatisticsRequest::_internal_set_column_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.column_name_.Set(value, GetArena());
}
inline std::string* ColumnStatisticsRequest::_internal_mutable_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.column_name_.Mutable( GetArena());
}
inline std::string* ColumnStatisticsRequest::release_column_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.column_name)
  return _impl_.column_name_.Release();
}
inline void ColumnStatisticsRequest::set_allocated_column_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.column_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.column_name_.IsDefault()) {
          _impl_.column_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.column_name)
}

// optional int32 unique_value_limit = 4;
inline bool ColumnStatisticsRequest::has_unique_value_limit() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void ColumnStatisticsRequest::clear_unique_value_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.unique_value_limit_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline ::int32_t ColumnStatisticsRequest::unique_value_limit() const {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.unique_value_limit)
  return _internal_unique_value_limit();
}
inline void ColumnStatisticsRequest::set_unique_value_limit(::int32_t value) {
  _internal_set_unique_value_limit(value);
  // @@protoc_insertion_point(field_set:io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest.unique_value_limit)
}
inline ::int32_t ColumnStatisticsRequest::_internal_unique_value_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.unique_value_limit_;
}
inline void ColumnStatisticsRequest::_internal_set_unique_value_limit(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.unique_value_limit_ = value;
}

// -------------------------------------------------------------------

// BatchTableRequest_Operation

// .io.deephaven.proto.backplane.grpc.EmptyTableRequest empty_table = 1;
inline bool BatchTableRequest_Operation::has_empty_table() const {
  return op_case() == kEmptyTable;
}
inline bool BatchTableRequest_Operation::_internal_has_empty_table() const {
  return op_case() == kEmptyTable;
}
inline void BatchTableRequest_Operation::set_has_empty_table() {
  _impl_._oneof_case_[0] = kEmptyTable;
}
inline void BatchTableRequest_Operation::clear_empty_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kEmptyTable) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.empty_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* BatchTableRequest_Operation::release_empty_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
  if (op_case() == kEmptyTable) {
    clear_has_op();
    auto* temp = _impl_.op_.empty_table_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.empty_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& BatchTableRequest_Operation::_internal_empty_table() const {
  return op_case() == kEmptyTable ? *_impl_.op_.empty_table_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::EmptyTableRequest&>(::io::deephaven::proto::backplane::grpc::_EmptyTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::EmptyTableRequest& BatchTableRequest_Operation::empty_table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
  return _internal_empty_table();
}
inline ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* BatchTableRequest_Operation::unsafe_arena_release_empty_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
  if (op_case() == kEmptyTable) {
    clear_has_op();
    auto* temp = _impl_.op_.empty_table_;
    _impl_.op_.empty_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_empty_table(::io::deephaven::proto::backplane::grpc::EmptyTableRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_empty_table();
    _impl_.op_.empty_table_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
}
inline ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* BatchTableRequest_Operation::_internal_mutable_empty_table() {
  if (op_case() != kEmptyTable) {
    clear_op();
    set_has_empty_table();
    _impl_.op_.empty_table_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::EmptyTableRequest>(GetArena());
  }
  return _impl_.op_.empty_table_;
}
inline ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* BatchTableRequest_Operation::mutable_empty_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::EmptyTableRequest* _msg = _internal_mutable_empty_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.empty_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.TimeTableRequest time_table = 2;
inline bool BatchTableRequest_Operation::has_time_table() const {
  return op_case() == kTimeTable;
}
inline bool BatchTableRequest_Operation::_internal_has_time_table() const {
  return op_case() == kTimeTable;
}
inline void BatchTableRequest_Operation::set_has_time_table() {
  _impl_._oneof_case_[0] = kTimeTable;
}
inline void BatchTableRequest_Operation::clear_time_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kTimeTable) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.time_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::TimeTableRequest* BatchTableRequest_Operation::release_time_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
  if (op_case() == kTimeTable) {
    clear_has_op();
    auto* temp = _impl_.op_.time_table_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.time_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& BatchTableRequest_Operation::_internal_time_table() const {
  return op_case() == kTimeTable ? *_impl_.op_.time_table_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::TimeTableRequest&>(::io::deephaven::proto::backplane::grpc::_TimeTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::TimeTableRequest& BatchTableRequest_Operation::time_table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
  return _internal_time_table();
}
inline ::io::deephaven::proto::backplane::grpc::TimeTableRequest* BatchTableRequest_Operation::unsafe_arena_release_time_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
  if (op_case() == kTimeTable) {
    clear_has_op();
    auto* temp = _impl_.op_.time_table_;
    _impl_.op_.time_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_time_table(::io::deephaven::proto::backplane::grpc::TimeTableRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_time_table();
    _impl_.op_.time_table_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
}
inline ::io::deephaven::proto::backplane::grpc::TimeTableRequest* BatchTableRequest_Operation::_internal_mutable_time_table() {
  if (op_case() != kTimeTable) {
    clear_op();
    set_has_time_table();
    _impl_.op_.time_table_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::TimeTableRequest>(GetArena());
  }
  return _impl_.op_.time_table_;
}
inline ::io::deephaven::proto::backplane::grpc::TimeTableRequest* BatchTableRequest_Operation::mutable_time_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::TimeTableRequest* _msg = _internal_mutable_time_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.time_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.DropColumnsRequest drop_columns = 3;
inline bool BatchTableRequest_Operation::has_drop_columns() const {
  return op_case() == kDropColumns;
}
inline bool BatchTableRequest_Operation::_internal_has_drop_columns() const {
  return op_case() == kDropColumns;
}
inline void BatchTableRequest_Operation::set_has_drop_columns() {
  _impl_._oneof_case_[0] = kDropColumns;
}
inline void BatchTableRequest_Operation::clear_drop_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kDropColumns) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.drop_columns_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* BatchTableRequest_Operation::release_drop_columns() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
  if (op_case() == kDropColumns) {
    clear_has_op();
    auto* temp = _impl_.op_.drop_columns_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& BatchTableRequest_Operation::_internal_drop_columns() const {
  return op_case() == kDropColumns ? *_impl_.op_.drop_columns_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::DropColumnsRequest&>(::io::deephaven::proto::backplane::grpc::_DropColumnsRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::DropColumnsRequest& BatchTableRequest_Operation::drop_columns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
  return _internal_drop_columns();
}
inline ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* BatchTableRequest_Operation::unsafe_arena_release_drop_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
  if (op_case() == kDropColumns) {
    clear_has_op();
    auto* temp = _impl_.op_.drop_columns_;
    _impl_.op_.drop_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_drop_columns(::io::deephaven::proto::backplane::grpc::DropColumnsRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_drop_columns();
    _impl_.op_.drop_columns_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
}
inline ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* BatchTableRequest_Operation::_internal_mutable_drop_columns() {
  if (op_case() != kDropColumns) {
    clear_op();
    set_has_drop_columns();
    _impl_.op_.drop_columns_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::DropColumnsRequest>(GetArena());
  }
  return _impl_.op_.drop_columns_;
}
inline ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* BatchTableRequest_Operation::mutable_drop_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::DropColumnsRequest* _msg = _internal_mutable_drop_columns();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.drop_columns)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest update = 4;
inline bool BatchTableRequest_Operation::has_update() const {
  return op_case() == kUpdate;
}
inline bool BatchTableRequest_Operation::_internal_has_update() const {
  return op_case() == kUpdate;
}
inline void BatchTableRequest_Operation::set_has_update() {
  _impl_._oneof_case_[0] = kUpdate;
}
inline void BatchTableRequest_Operation::clear_update() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.update_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_update() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
  if (op_case() == kUpdate) {
    clear_has_op();
    auto* temp = _impl_.op_.update_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_update() const {
  return op_case() == kUpdate ? *_impl_.op_.update_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
  return _internal_update();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
  if (op_case() == kUpdate) {
    clear_has_op();
    auto* temp = _impl_.op_.update_;
    _impl_.op_.update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_update();
    _impl_.op_.update_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_update() {
  if (op_case() != kUpdate) {
    clear_op();
    set_has_update();
    _impl_.op_.update_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest>(GetArena());
  }
  return _impl_.op_.update_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_update();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest lazy_update = 5;
inline bool BatchTableRequest_Operation::has_lazy_update() const {
  return op_case() == kLazyUpdate;
}
inline bool BatchTableRequest_Operation::_internal_has_lazy_update() const {
  return op_case() == kLazyUpdate;
}
inline void BatchTableRequest_Operation::set_has_lazy_update() {
  _impl_._oneof_case_[0] = kLazyUpdate;
}
inline void BatchTableRequest_Operation::clear_lazy_update() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kLazyUpdate) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.lazy_update_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_lazy_update() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
  if (op_case() == kLazyUpdate) {
    clear_has_op();
    auto* temp = _impl_.op_.lazy_update_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.lazy_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_lazy_update() const {
  return op_case() == kLazyUpdate ? *_impl_.op_.lazy_update_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::lazy_update() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
  return _internal_lazy_update();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_lazy_update() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
  if (op_case() == kLazyUpdate) {
    clear_has_op();
    auto* temp = _impl_.op_.lazy_update_;
    _impl_.op_.lazy_update_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_lazy_update(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_lazy_update();
    _impl_.op_.lazy_update_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_lazy_update() {
  if (op_case() != kLazyUpdate) {
    clear_op();
    set_has_lazy_update();
    _impl_.op_.lazy_update_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest>(GetArena());
  }
  return _impl_.op_.lazy_update_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_lazy_update() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_lazy_update();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.lazy_update)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest view = 6;
inline bool BatchTableRequest_Operation::has_view() const {
  return op_case() == kView;
}
inline bool BatchTableRequest_Operation::_internal_has_view() const {
  return op_case() == kView;
}
inline void BatchTableRequest_Operation::set_has_view() {
  _impl_._oneof_case_[0] = kView;
}
inline void BatchTableRequest_Operation::clear_view() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kView) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.view_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_view() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
  if (op_case() == kView) {
    clear_has_op();
    auto* temp = _impl_.op_.view_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_view() const {
  return op_case() == kView ? *_impl_.op_.view_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::view() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
  return _internal_view();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
  if (op_case() == kView) {
    clear_has_op();
    auto* temp = _impl_.op_.view_;
    _impl_.op_.view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_view();
    _impl_.op_.view_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_view() {
  if (op_case() != kView) {
    clear_op();
    set_has_view();
    _impl_.op_.view_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest>(GetArena());
  }
  return _impl_.op_.view_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_view() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_view();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.view)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest update_view = 7;
inline bool BatchTableRequest_Operation::has_update_view() const {
  return op_case() == kUpdateView;
}
inline bool BatchTableRequest_Operation::_internal_has_update_view() const {
  return op_case() == kUpdateView;
}
inline void BatchTableRequest_Operation::set_has_update_view() {
  _impl_._oneof_case_[0] = kUpdateView;
}
inline void BatchTableRequest_Operation::clear_update_view() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kUpdateView) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.update_view_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_update_view() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
  if (op_case() == kUpdateView) {
    clear_has_op();
    auto* temp = _impl_.op_.update_view_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.update_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_update_view() const {
  return op_case() == kUpdateView ? *_impl_.op_.update_view_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::update_view() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
  return _internal_update_view();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_update_view() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
  if (op_case() == kUpdateView) {
    clear_has_op();
    auto* temp = _impl_.op_.update_view_;
    _impl_.op_.update_view_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_update_view(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_update_view();
    _impl_.op_.update_view_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_update_view() {
  if (op_case() != kUpdateView) {
    clear_op();
    set_has_update_view();
    _impl_.op_.update_view_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest>(GetArena());
  }
  return _impl_.op_.update_view_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_update_view() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_update_view();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_view)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectOrUpdateRequest select = 8;
inline bool BatchTableRequest_Operation::has_select() const {
  return op_case() == kSelect;
}
inline bool BatchTableRequest_Operation::_internal_has_select() const {
  return op_case() == kSelect;
}
inline void BatchTableRequest_Operation::set_has_select() {
  _impl_._oneof_case_[0] = kSelect;
}
inline void BatchTableRequest_Operation::clear_select() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kSelect) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.select_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::release_select() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
  if (op_case() == kSelect) {
    clear_has_op();
    auto* temp = _impl_.op_.select_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.select_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::_internal_select() const {
  return op_case() == kSelect ? *_impl_.op_.select_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest&>(::io::deephaven::proto::backplane::grpc::_SelectOrUpdateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest& BatchTableRequest_Operation::select() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
  return _internal_select();
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::unsafe_arena_release_select() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
  if (op_case() == kSelect) {
    clear_has_op();
    auto* temp = _impl_.op_.select_;
    _impl_.op_.select_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_select(::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_select();
    _impl_.op_.select_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::_internal_mutable_select() {
  if (op_case() != kSelect) {
    clear_op();
    set_has_select();
    _impl_.op_.select_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest>(GetArena());
  }
  return _impl_.op_.select_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* BatchTableRequest_Operation::mutable_select() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::SelectOrUpdateRequest* _msg = _internal_mutable_select();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SelectDistinctRequest select_distinct = 9;
inline bool BatchTableRequest_Operation::has_select_distinct() const {
  return op_case() == kSelectDistinct;
}
inline bool BatchTableRequest_Operation::_internal_has_select_distinct() const {
  return op_case() == kSelectDistinct;
}
inline void BatchTableRequest_Operation::set_has_select_distinct() {
  _impl_._oneof_case_[0] = kSelectDistinct;
}
inline void BatchTableRequest_Operation::clear_select_distinct() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kSelectDistinct) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.select_distinct_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* BatchTableRequest_Operation::release_select_distinct() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
  if (op_case() == kSelectDistinct) {
    clear_has_op();
    auto* temp = _impl_.op_.select_distinct_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.select_distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& BatchTableRequest_Operation::_internal_select_distinct() const {
  return op_case() == kSelectDistinct ? *_impl_.op_.select_distinct_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::SelectDistinctRequest&>(::io::deephaven::proto::backplane::grpc::_SelectDistinctRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest& BatchTableRequest_Operation::select_distinct() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
  return _internal_select_distinct();
}
inline ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* BatchTableRequest_Operation::unsafe_arena_release_select_distinct() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
  if (op_case() == kSelectDistinct) {
    clear_has_op();
    auto* temp = _impl_.op_.select_distinct_;
    _impl_.op_.select_distinct_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_select_distinct(::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_select_distinct();
    _impl_.op_.select_distinct_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
}
inline ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* BatchTableRequest_Operation::_internal_mutable_select_distinct() {
  if (op_case() != kSelectDistinct) {
    clear_op();
    set_has_select_distinct();
    _impl_.op_.select_distinct_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SelectDistinctRequest>(GetArena());
  }
  return _impl_.op_.select_distinct_;
}
inline ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* BatchTableRequest_Operation::mutable_select_distinct() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::SelectDistinctRequest* _msg = _internal_mutable_select_distinct();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.select_distinct)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.FilterTableRequest filter = 10;
inline bool BatchTableRequest_Operation::has_filter() const {
  return op_case() == kFilter;
}
inline bool BatchTableRequest_Operation::_internal_has_filter() const {
  return op_case() == kFilter;
}
inline void BatchTableRequest_Operation::set_has_filter() {
  _impl_._oneof_case_[0] = kFilter;
}
inline void BatchTableRequest_Operation::clear_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kFilter) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.filter_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::FilterTableRequest* BatchTableRequest_Operation::release_filter() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
  if (op_case() == kFilter) {
    clear_has_op();
    auto* temp = _impl_.op_.filter_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& BatchTableRequest_Operation::_internal_filter() const {
  return op_case() == kFilter ? *_impl_.op_.filter_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::FilterTableRequest&>(::io::deephaven::proto::backplane::grpc::_FilterTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::FilterTableRequest& BatchTableRequest_Operation::filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
  return _internal_filter();
}
inline ::io::deephaven::proto::backplane::grpc::FilterTableRequest* BatchTableRequest_Operation::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
  if (op_case() == kFilter) {
    clear_has_op();
    auto* temp = _impl_.op_.filter_;
    _impl_.op_.filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_filter(::io::deephaven::proto::backplane::grpc::FilterTableRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_filter();
    _impl_.op_.filter_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
}
inline ::io::deephaven::proto::backplane::grpc::FilterTableRequest* BatchTableRequest_Operation::_internal_mutable_filter() {
  if (op_case() != kFilter) {
    clear_op();
    set_has_filter();
    _impl_.op_.filter_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FilterTableRequest>(GetArena());
  }
  return _impl_.op_.filter_;
}
inline ::io::deephaven::proto::backplane::grpc::FilterTableRequest* BatchTableRequest_Operation::mutable_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::FilterTableRequest* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.filter)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UnstructuredFilterTableRequest unstructured_filter = 11;
inline bool BatchTableRequest_Operation::has_unstructured_filter() const {
  return op_case() == kUnstructuredFilter;
}
inline bool BatchTableRequest_Operation::_internal_has_unstructured_filter() const {
  return op_case() == kUnstructuredFilter;
}
inline void BatchTableRequest_Operation::set_has_unstructured_filter() {
  _impl_._oneof_case_[0] = kUnstructuredFilter;
}
inline void BatchTableRequest_Operation::clear_unstructured_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kUnstructuredFilter) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.unstructured_filter_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* BatchTableRequest_Operation::release_unstructured_filter() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
  if (op_case() == kUnstructuredFilter) {
    clear_has_op();
    auto* temp = _impl_.op_.unstructured_filter_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.unstructured_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& BatchTableRequest_Operation::_internal_unstructured_filter() const {
  return op_case() == kUnstructuredFilter ? *_impl_.op_.unstructured_filter_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest&>(::io::deephaven::proto::backplane::grpc::_UnstructuredFilterTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest& BatchTableRequest_Operation::unstructured_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
  return _internal_unstructured_filter();
}
inline ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* BatchTableRequest_Operation::unsafe_arena_release_unstructured_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
  if (op_case() == kUnstructuredFilter) {
    clear_has_op();
    auto* temp = _impl_.op_.unstructured_filter_;
    _impl_.op_.unstructured_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_unstructured_filter(::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_unstructured_filter();
    _impl_.op_.unstructured_filter_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
}
inline ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* BatchTableRequest_Operation::_internal_mutable_unstructured_filter() {
  if (op_case() != kUnstructuredFilter) {
    clear_op();
    set_has_unstructured_filter();
    _impl_.op_.unstructured_filter_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest>(GetArena());
  }
  return _impl_.op_.unstructured_filter_;
}
inline ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* BatchTableRequest_Operation::mutable_unstructured_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UnstructuredFilterTableRequest* _msg = _internal_mutable_unstructured_filter();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.unstructured_filter)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SortTableRequest sort = 12;
inline bool BatchTableRequest_Operation::has_sort() const {
  return op_case() == kSort;
}
inline bool BatchTableRequest_Operation::_internal_has_sort() const {
  return op_case() == kSort;
}
inline void BatchTableRequest_Operation::set_has_sort() {
  _impl_._oneof_case_[0] = kSort;
}
inline void BatchTableRequest_Operation::clear_sort() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kSort) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.sort_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SortTableRequest* BatchTableRequest_Operation::release_sort() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
  if (op_case() == kSort) {
    clear_has_op();
    auto* temp = _impl_.op_.sort_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.sort_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SortTableRequest& BatchTableRequest_Operation::_internal_sort() const {
  return op_case() == kSort ? *_impl_.op_.sort_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::SortTableRequest&>(::io::deephaven::proto::backplane::grpc::_SortTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SortTableRequest& BatchTableRequest_Operation::sort() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
  return _internal_sort();
}
inline ::io::deephaven::proto::backplane::grpc::SortTableRequest* BatchTableRequest_Operation::unsafe_arena_release_sort() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
  if (op_case() == kSort) {
    clear_has_op();
    auto* temp = _impl_.op_.sort_;
    _impl_.op_.sort_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_sort(::io::deephaven::proto::backplane::grpc::SortTableRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_sort();
    _impl_.op_.sort_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
}
inline ::io::deephaven::proto::backplane::grpc::SortTableRequest* BatchTableRequest_Operation::_internal_mutable_sort() {
  if (op_case() != kSort) {
    clear_op();
    set_has_sort();
    _impl_.op_.sort_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SortTableRequest>(GetArena());
  }
  return _impl_.op_.sort_;
}
inline ::io::deephaven::proto::backplane::grpc::SortTableRequest* BatchTableRequest_Operation::mutable_sort() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::SortTableRequest* _msg = _internal_mutable_sort();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.sort)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.HeadOrTailRequest head = 13;
inline bool BatchTableRequest_Operation::has_head() const {
  return op_case() == kHead;
}
inline bool BatchTableRequest_Operation::_internal_has_head() const {
  return op_case() == kHead;
}
inline void BatchTableRequest_Operation::set_has_head() {
  _impl_._oneof_case_[0] = kHead;
}
inline void BatchTableRequest_Operation::clear_head() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kHead) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.head_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::release_head() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
  if (op_case() == kHead) {
    clear_has_op();
    auto* temp = _impl_.op_.head_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.head_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& BatchTableRequest_Operation::_internal_head() const {
  return op_case() == kHead ? *_impl_.op_.head_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::HeadOrTailRequest&>(::io::deephaven::proto::backplane::grpc::_HeadOrTailRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& BatchTableRequest_Operation::head() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
  return _internal_head();
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
  if (op_case() == kHead) {
    clear_has_op();
    auto* temp = _impl_.op_.head_;
    _impl_.op_.head_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_head(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_head();
    _impl_.op_.head_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::_internal_mutable_head() {
  if (op_case() != kHead) {
    clear_op();
    set_has_head();
    _impl_.op_.head_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::HeadOrTailRequest>(GetArena());
  }
  return _impl_.op_.head_;
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::mutable_head() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.HeadOrTailRequest tail = 14;
inline bool BatchTableRequest_Operation::has_tail() const {
  return op_case() == kTail;
}
inline bool BatchTableRequest_Operation::_internal_has_tail() const {
  return op_case() == kTail;
}
inline void BatchTableRequest_Operation::set_has_tail() {
  _impl_._oneof_case_[0] = kTail;
}
inline void BatchTableRequest_Operation::clear_tail() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kTail) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.tail_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::release_tail() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
  if (op_case() == kTail) {
    clear_has_op();
    auto* temp = _impl_.op_.tail_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.tail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& BatchTableRequest_Operation::_internal_tail() const {
  return op_case() == kTail ? *_impl_.op_.tail_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::HeadOrTailRequest&>(::io::deephaven::proto::backplane::grpc::_HeadOrTailRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest& BatchTableRequest_Operation::tail() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
  return _internal_tail();
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::unsafe_arena_release_tail() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
  if (op_case() == kTail) {
    clear_has_op();
    auto* temp = _impl_.op_.tail_;
    _impl_.op_.tail_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_tail(::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_tail();
    _impl_.op_.tail_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::_internal_mutable_tail() {
  if (op_case() != kTail) {
    clear_op();
    set_has_tail();
    _impl_.op_.tail_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::HeadOrTailRequest>(GetArena());
  }
  return _impl_.op_.tail_;
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* BatchTableRequest_Operation::mutable_tail() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::HeadOrTailRequest* _msg = _internal_mutable_tail();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.HeadOrTailByRequest head_by = 15;
inline bool BatchTableRequest_Operation::has_head_by() const {
  return op_case() == kHeadBy;
}
inline bool BatchTableRequest_Operation::_internal_has_head_by() const {
  return op_case() == kHeadBy;
}
inline void BatchTableRequest_Operation::set_has_head_by() {
  _impl_._oneof_case_[0] = kHeadBy;
}
inline void BatchTableRequest_Operation::clear_head_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kHeadBy) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.head_by_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::release_head_by() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
  if (op_case() == kHeadBy) {
    clear_has_op();
    auto* temp = _impl_.op_.head_by_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.head_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& BatchTableRequest_Operation::_internal_head_by() const {
  return op_case() == kHeadBy ? *_impl_.op_.head_by_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest&>(::io::deephaven::proto::backplane::grpc::_HeadOrTailByRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& BatchTableRequest_Operation::head_by() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
  return _internal_head_by();
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::unsafe_arena_release_head_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
  if (op_case() == kHeadBy) {
    clear_has_op();
    auto* temp = _impl_.op_.head_by_;
    _impl_.op_.head_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_head_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_head_by();
    _impl_.op_.head_by_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::_internal_mutable_head_by() {
  if (op_case() != kHeadBy) {
    clear_op();
    set_has_head_by();
    _impl_.op_.head_by_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest>(GetArena());
  }
  return _impl_.op_.head_by_;
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::mutable_head_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* _msg = _internal_mutable_head_by();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.head_by)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.HeadOrTailByRequest tail_by = 16;
inline bool BatchTableRequest_Operation::has_tail_by() const {
  return op_case() == kTailBy;
}
inline bool BatchTableRequest_Operation::_internal_has_tail_by() const {
  return op_case() == kTailBy;
}
inline void BatchTableRequest_Operation::set_has_tail_by() {
  _impl_._oneof_case_[0] = kTailBy;
}
inline void BatchTableRequest_Operation::clear_tail_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kTailBy) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.tail_by_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::release_tail_by() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
  if (op_case() == kTailBy) {
    clear_has_op();
    auto* temp = _impl_.op_.tail_by_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.tail_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& BatchTableRequest_Operation::_internal_tail_by() const {
  return op_case() == kTailBy ? *_impl_.op_.tail_by_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest&>(::io::deephaven::proto::backplane::grpc::_HeadOrTailByRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest& BatchTableRequest_Operation::tail_by() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
  return _internal_tail_by();
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::unsafe_arena_release_tail_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
  if (op_case() == kTailBy) {
    clear_has_op();
    auto* temp = _impl_.op_.tail_by_;
    _impl_.op_.tail_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_tail_by(::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_tail_by();
    _impl_.op_.tail_by_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::_internal_mutable_tail_by() {
  if (op_case() != kTailBy) {
    clear_op();
    set_has_tail_by();
    _impl_.op_.tail_by_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest>(GetArena());
  }
  return _impl_.op_.tail_by_;
}
inline ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* BatchTableRequest_Operation::mutable_tail_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::HeadOrTailByRequest* _msg = _internal_mutable_tail_by();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.tail_by)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UngroupRequest ungroup = 17;
inline bool BatchTableRequest_Operation::has_ungroup() const {
  return op_case() == kUngroup;
}
inline bool BatchTableRequest_Operation::_internal_has_ungroup() const {
  return op_case() == kUngroup;
}
inline void BatchTableRequest_Operation::set_has_ungroup() {
  _impl_._oneof_case_[0] = kUngroup;
}
inline void BatchTableRequest_Operation::clear_ungroup() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kUngroup) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.ungroup_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UngroupRequest* BatchTableRequest_Operation::release_ungroup() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
  if (op_case() == kUngroup) {
    clear_has_op();
    auto* temp = _impl_.op_.ungroup_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.ungroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UngroupRequest& BatchTableRequest_Operation::_internal_ungroup() const {
  return op_case() == kUngroup ? *_impl_.op_.ungroup_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UngroupRequest&>(::io::deephaven::proto::backplane::grpc::_UngroupRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UngroupRequest& BatchTableRequest_Operation::ungroup() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
  return _internal_ungroup();
}
inline ::io::deephaven::proto::backplane::grpc::UngroupRequest* BatchTableRequest_Operation::unsafe_arena_release_ungroup() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
  if (op_case() == kUngroup) {
    clear_has_op();
    auto* temp = _impl_.op_.ungroup_;
    _impl_.op_.ungroup_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_ungroup(::io::deephaven::proto::backplane::grpc::UngroupRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_ungroup();
    _impl_.op_.ungroup_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
}
inline ::io::deephaven::proto::backplane::grpc::UngroupRequest* BatchTableRequest_Operation::_internal_mutable_ungroup() {
  if (op_case() != kUngroup) {
    clear_op();
    set_has_ungroup();
    _impl_.op_.ungroup_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UngroupRequest>(GetArena());
  }
  return _impl_.op_.ungroup_;
}
inline ::io::deephaven::proto::backplane::grpc::UngroupRequest* BatchTableRequest_Operation::mutable_ungroup() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UngroupRequest* _msg = _internal_mutable_ungroup();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.ungroup)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.MergeTablesRequest merge = 18;
inline bool BatchTableRequest_Operation::has_merge() const {
  return op_case() == kMerge;
}
inline bool BatchTableRequest_Operation::_internal_has_merge() const {
  return op_case() == kMerge;
}
inline void BatchTableRequest_Operation::set_has_merge() {
  _impl_._oneof_case_[0] = kMerge;
}
inline void BatchTableRequest_Operation::clear_merge() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kMerge) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.merge_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* BatchTableRequest_Operation::release_merge() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
  if (op_case() == kMerge) {
    clear_has_op();
    auto* temp = _impl_.op_.merge_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.merge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& BatchTableRequest_Operation::_internal_merge() const {
  return op_case() == kMerge ? *_impl_.op_.merge_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::MergeTablesRequest&>(::io::deephaven::proto::backplane::grpc::_MergeTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MergeTablesRequest& BatchTableRequest_Operation::merge() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
  return _internal_merge();
}
inline ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_merge() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
  if (op_case() == kMerge) {
    clear_has_op();
    auto* temp = _impl_.op_.merge_;
    _impl_.op_.merge_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_merge(::io::deephaven::proto::backplane::grpc::MergeTablesRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_merge();
    _impl_.op_.merge_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
}
inline ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* BatchTableRequest_Operation::_internal_mutable_merge() {
  if (op_case() != kMerge) {
    clear_op();
    set_has_merge();
    _impl_.op_.merge_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MergeTablesRequest>(GetArena());
  }
  return _impl_.op_.merge_;
}
inline ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* BatchTableRequest_Operation::mutable_merge() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::MergeTablesRequest* _msg = _internal_mutable_merge();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.merge)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.ComboAggregateRequest combo_aggregate = 19;
inline bool BatchTableRequest_Operation::has_combo_aggregate() const {
  return op_case() == kComboAggregate;
}
inline bool BatchTableRequest_Operation::_internal_has_combo_aggregate() const {
  return op_case() == kComboAggregate;
}
inline void BatchTableRequest_Operation::set_has_combo_aggregate() {
  _impl_._oneof_case_[0] = kComboAggregate;
}
inline void BatchTableRequest_Operation::clear_combo_aggregate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kComboAggregate) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.combo_aggregate_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* BatchTableRequest_Operation::release_combo_aggregate() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
  if (op_case() == kComboAggregate) {
    clear_has_op();
    auto* temp = _impl_.op_.combo_aggregate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.combo_aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& BatchTableRequest_Operation::_internal_combo_aggregate() const {
  return op_case() == kComboAggregate ? *_impl_.op_.combo_aggregate_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest&>(::io::deephaven::proto::backplane::grpc::_ComboAggregateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest& BatchTableRequest_Operation::combo_aggregate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
  return _internal_combo_aggregate();
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* BatchTableRequest_Operation::unsafe_arena_release_combo_aggregate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
  if (op_case() == kComboAggregate) {
    clear_has_op();
    auto* temp = _impl_.op_.combo_aggregate_;
    _impl_.op_.combo_aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_combo_aggregate(::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_combo_aggregate();
    _impl_.op_.combo_aggregate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* BatchTableRequest_Operation::_internal_mutable_combo_aggregate() {
  if (op_case() != kComboAggregate) {
    clear_op();
    set_has_combo_aggregate();
    _impl_.op_.combo_aggregate_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest>(GetArena());
  }
  return _impl_.op_.combo_aggregate_;
}
inline ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* BatchTableRequest_Operation::mutable_combo_aggregate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest* _msg = _internal_mutable_combo_aggregate();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.combo_aggregate)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.FlattenRequest flatten = 21;
inline bool BatchTableRequest_Operation::has_flatten() const {
  return op_case() == kFlatten;
}
inline bool BatchTableRequest_Operation::_internal_has_flatten() const {
  return op_case() == kFlatten;
}
inline void BatchTableRequest_Operation::set_has_flatten() {
  _impl_._oneof_case_[0] = kFlatten;
}
inline void BatchTableRequest_Operation::clear_flatten() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kFlatten) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.flatten_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::FlattenRequest* BatchTableRequest_Operation::release_flatten() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
  if (op_case() == kFlatten) {
    clear_has_op();
    auto* temp = _impl_.op_.flatten_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.flatten_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::FlattenRequest& BatchTableRequest_Operation::_internal_flatten() const {
  return op_case() == kFlatten ? *_impl_.op_.flatten_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::FlattenRequest&>(::io::deephaven::proto::backplane::grpc::_FlattenRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::FlattenRequest& BatchTableRequest_Operation::flatten() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
  return _internal_flatten();
}
inline ::io::deephaven::proto::backplane::grpc::FlattenRequest* BatchTableRequest_Operation::unsafe_arena_release_flatten() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
  if (op_case() == kFlatten) {
    clear_has_op();
    auto* temp = _impl_.op_.flatten_;
    _impl_.op_.flatten_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_flatten(::io::deephaven::proto::backplane::grpc::FlattenRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_flatten();
    _impl_.op_.flatten_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
}
inline ::io::deephaven::proto::backplane::grpc::FlattenRequest* BatchTableRequest_Operation::_internal_mutable_flatten() {
  if (op_case() != kFlatten) {
    clear_op();
    set_has_flatten();
    _impl_.op_.flatten_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FlattenRequest>(GetArena());
  }
  return _impl_.op_.flatten_;
}
inline ::io::deephaven::proto::backplane::grpc::FlattenRequest* BatchTableRequest_Operation::mutable_flatten() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::FlattenRequest* _msg = _internal_mutable_flatten();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.flatten)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.RunChartDownsampleRequest run_chart_downsample = 22;
inline bool BatchTableRequest_Operation::has_run_chart_downsample() const {
  return op_case() == kRunChartDownsample;
}
inline bool BatchTableRequest_Operation::_internal_has_run_chart_downsample() const {
  return op_case() == kRunChartDownsample;
}
inline void BatchTableRequest_Operation::set_has_run_chart_downsample() {
  _impl_._oneof_case_[0] = kRunChartDownsample;
}
inline void BatchTableRequest_Operation::clear_run_chart_downsample() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kRunChartDownsample) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.run_chart_downsample_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* BatchTableRequest_Operation::release_run_chart_downsample() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
  if (op_case() == kRunChartDownsample) {
    clear_has_op();
    auto* temp = _impl_.op_.run_chart_downsample_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.run_chart_downsample_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& BatchTableRequest_Operation::_internal_run_chart_downsample() const {
  return op_case() == kRunChartDownsample ? *_impl_.op_.run_chart_downsample_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest&>(::io::deephaven::proto::backplane::grpc::_RunChartDownsampleRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest& BatchTableRequest_Operation::run_chart_downsample() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
  return _internal_run_chart_downsample();
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* BatchTableRequest_Operation::unsafe_arena_release_run_chart_downsample() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
  if (op_case() == kRunChartDownsample) {
    clear_has_op();
    auto* temp = _impl_.op_.run_chart_downsample_;
    _impl_.op_.run_chart_downsample_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_run_chart_downsample(::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_run_chart_downsample();
    _impl_.op_.run_chart_downsample_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* BatchTableRequest_Operation::_internal_mutable_run_chart_downsample() {
  if (op_case() != kRunChartDownsample) {
    clear_op();
    set_has_run_chart_downsample();
    _impl_.op_.run_chart_downsample_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest>(GetArena());
  }
  return _impl_.op_.run_chart_downsample_;
}
inline ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* BatchTableRequest_Operation::mutable_run_chart_downsample() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::RunChartDownsampleRequest* _msg = _internal_mutable_run_chart_downsample();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.run_chart_downsample)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.CrossJoinTablesRequest cross_join = 23;
inline bool BatchTableRequest_Operation::has_cross_join() const {
  return op_case() == kCrossJoin;
}
inline bool BatchTableRequest_Operation::_internal_has_cross_join() const {
  return op_case() == kCrossJoin;
}
inline void BatchTableRequest_Operation::set_has_cross_join() {
  _impl_._oneof_case_[0] = kCrossJoin;
}
inline void BatchTableRequest_Operation::clear_cross_join() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kCrossJoin) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.cross_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* BatchTableRequest_Operation::release_cross_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
  if (op_case() == kCrossJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.cross_join_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.cross_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& BatchTableRequest_Operation::_internal_cross_join() const {
  return op_case() == kCrossJoin ? *_impl_.op_.cross_join_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_CrossJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest& BatchTableRequest_Operation::cross_join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
  return _internal_cross_join();
}
inline ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_cross_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
  if (op_case() == kCrossJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.cross_join_;
    _impl_.op_.cross_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_cross_join(::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_cross_join();
    _impl_.op_.cross_join_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
}
inline ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_cross_join() {
  if (op_case() != kCrossJoin) {
    clear_op();
    set_has_cross_join();
    _impl_.op_.cross_join_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest>(GetArena());
  }
  return _impl_.op_.cross_join_;
}
inline ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* BatchTableRequest_Operation::mutable_cross_join() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::CrossJoinTablesRequest* _msg = _internal_mutable_cross_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.cross_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.NaturalJoinTablesRequest natural_join = 24;
inline bool BatchTableRequest_Operation::has_natural_join() const {
  return op_case() == kNaturalJoin;
}
inline bool BatchTableRequest_Operation::_internal_has_natural_join() const {
  return op_case() == kNaturalJoin;
}
inline void BatchTableRequest_Operation::set_has_natural_join() {
  _impl_._oneof_case_[0] = kNaturalJoin;
}
inline void BatchTableRequest_Operation::clear_natural_join() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kNaturalJoin) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.natural_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* BatchTableRequest_Operation::release_natural_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
  if (op_case() == kNaturalJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.natural_join_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.natural_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& BatchTableRequest_Operation::_internal_natural_join() const {
  return op_case() == kNaturalJoin ? *_impl_.op_.natural_join_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_NaturalJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest& BatchTableRequest_Operation::natural_join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
  return _internal_natural_join();
}
inline ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_natural_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
  if (op_case() == kNaturalJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.natural_join_;
    _impl_.op_.natural_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_natural_join(::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_natural_join();
    _impl_.op_.natural_join_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
}
inline ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_natural_join() {
  if (op_case() != kNaturalJoin) {
    clear_op();
    set_has_natural_join();
    _impl_.op_.natural_join_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest>(GetArena());
  }
  return _impl_.op_.natural_join_;
}
inline ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* BatchTableRequest_Operation::mutable_natural_join() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::NaturalJoinTablesRequest* _msg = _internal_mutable_natural_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.natural_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.ExactJoinTablesRequest exact_join = 25;
inline bool BatchTableRequest_Operation::has_exact_join() const {
  return op_case() == kExactJoin;
}
inline bool BatchTableRequest_Operation::_internal_has_exact_join() const {
  return op_case() == kExactJoin;
}
inline void BatchTableRequest_Operation::set_has_exact_join() {
  _impl_._oneof_case_[0] = kExactJoin;
}
inline void BatchTableRequest_Operation::clear_exact_join() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kExactJoin) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.exact_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* BatchTableRequest_Operation::release_exact_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
  if (op_case() == kExactJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.exact_join_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.exact_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& BatchTableRequest_Operation::_internal_exact_join() const {
  return op_case() == kExactJoin ? *_impl_.op_.exact_join_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_ExactJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest& BatchTableRequest_Operation::exact_join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
  return _internal_exact_join();
}
inline ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_exact_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
  if (op_case() == kExactJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.exact_join_;
    _impl_.op_.exact_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_exact_join(::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_exact_join();
    _impl_.op_.exact_join_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
}
inline ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_exact_join() {
  if (op_case() != kExactJoin) {
    clear_op();
    set_has_exact_join();
    _impl_.op_.exact_join_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest>(GetArena());
  }
  return _impl_.op_.exact_join_;
}
inline ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* BatchTableRequest_Operation::mutable_exact_join() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::ExactJoinTablesRequest* _msg = _internal_mutable_exact_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.exact_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.LeftJoinTablesRequest left_join = 26;
inline bool BatchTableRequest_Operation::has_left_join() const {
  return op_case() == kLeftJoin;
}
inline bool BatchTableRequest_Operation::_internal_has_left_join() const {
  return op_case() == kLeftJoin;
}
inline void BatchTableRequest_Operation::set_has_left_join() {
  _impl_._oneof_case_[0] = kLeftJoin;
}
inline void BatchTableRequest_Operation::clear_left_join() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kLeftJoin) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.left_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* BatchTableRequest_Operation::release_left_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
  if (op_case() == kLeftJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.left_join_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.left_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& BatchTableRequest_Operation::_internal_left_join() const {
  return op_case() == kLeftJoin ? *_impl_.op_.left_join_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_LeftJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest& BatchTableRequest_Operation::left_join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
  return _internal_left_join();
}
inline ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_left_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
  if (op_case() == kLeftJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.left_join_;
    _impl_.op_.left_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_left_join(::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_left_join();
    _impl_.op_.left_join_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
}
inline ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_left_join() {
  if (op_case() != kLeftJoin) {
    clear_op();
    set_has_left_join();
    _impl_.op_.left_join_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest>(GetArena());
  }
  return _impl_.op_.left_join_;
}
inline ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* BatchTableRequest_Operation::mutable_left_join() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::LeftJoinTablesRequest* _msg = _internal_mutable_left_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.left_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AsOfJoinTablesRequest as_of_join = 27 [deprecated = true];
inline bool BatchTableRequest_Operation::has_as_of_join() const {
  return op_case() == kAsOfJoin;
}
inline bool BatchTableRequest_Operation::_internal_has_as_of_join() const {
  return op_case() == kAsOfJoin;
}
inline void BatchTableRequest_Operation::set_has_as_of_join() {
  _impl_._oneof_case_[0] = kAsOfJoin;
}
inline void BatchTableRequest_Operation::clear_as_of_join() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kAsOfJoin) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.as_of_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* BatchTableRequest_Operation::release_as_of_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
  if (op_case() == kAsOfJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.as_of_join_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.as_of_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& BatchTableRequest_Operation::_internal_as_of_join() const {
  return op_case() == kAsOfJoin ? *_impl_.op_.as_of_join_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_AsOfJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest& BatchTableRequest_Operation::as_of_join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
  return _internal_as_of_join();
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_as_of_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
  if (op_case() == kAsOfJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.as_of_join_;
    _impl_.op_.as_of_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_as_of_join(::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_as_of_join();
    _impl_.op_.as_of_join_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_as_of_join() {
  if (op_case() != kAsOfJoin) {
    clear_op();
    set_has_as_of_join();
    _impl_.op_.as_of_join_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest>(GetArena());
  }
  return _impl_.op_.as_of_join_;
}
inline ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* BatchTableRequest_Operation::mutable_as_of_join() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest* _msg = _internal_mutable_as_of_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.as_of_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.FetchTableRequest fetch_table = 28;
inline bool BatchTableRequest_Operation::has_fetch_table() const {
  return op_case() == kFetchTable;
}
inline bool BatchTableRequest_Operation::_internal_has_fetch_table() const {
  return op_case() == kFetchTable;
}
inline void BatchTableRequest_Operation::set_has_fetch_table() {
  _impl_._oneof_case_[0] = kFetchTable;
}
inline void BatchTableRequest_Operation::clear_fetch_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kFetchTable) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.fetch_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::FetchTableRequest* BatchTableRequest_Operation::release_fetch_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
  if (op_case() == kFetchTable) {
    clear_has_op();
    auto* temp = _impl_.op_.fetch_table_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.fetch_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& BatchTableRequest_Operation::_internal_fetch_table() const {
  return op_case() == kFetchTable ? *_impl_.op_.fetch_table_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::FetchTableRequest&>(::io::deephaven::proto::backplane::grpc::_FetchTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::FetchTableRequest& BatchTableRequest_Operation::fetch_table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
  return _internal_fetch_table();
}
inline ::io::deephaven::proto::backplane::grpc::FetchTableRequest* BatchTableRequest_Operation::unsafe_arena_release_fetch_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
  if (op_case() == kFetchTable) {
    clear_has_op();
    auto* temp = _impl_.op_.fetch_table_;
    _impl_.op_.fetch_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_fetch_table(::io::deephaven::proto::backplane::grpc::FetchTableRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_fetch_table();
    _impl_.op_.fetch_table_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
}
inline ::io::deephaven::proto::backplane::grpc::FetchTableRequest* BatchTableRequest_Operation::_internal_mutable_fetch_table() {
  if (op_case() != kFetchTable) {
    clear_op();
    set_has_fetch_table();
    _impl_.op_.fetch_table_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::FetchTableRequest>(GetArena());
  }
  return _impl_.op_.fetch_table_;
}
inline ::io::deephaven::proto::backplane::grpc::FetchTableRequest* BatchTableRequest_Operation::mutable_fetch_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::FetchTableRequest* _msg = _internal_mutable_fetch_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.fetch_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.ApplyPreviewColumnsRequest apply_preview_columns = 30;
inline bool BatchTableRequest_Operation::has_apply_preview_columns() const {
  return op_case() == kApplyPreviewColumns;
}
inline bool BatchTableRequest_Operation::_internal_has_apply_preview_columns() const {
  return op_case() == kApplyPreviewColumns;
}
inline void BatchTableRequest_Operation::set_has_apply_preview_columns() {
  _impl_._oneof_case_[0] = kApplyPreviewColumns;
}
inline void BatchTableRequest_Operation::clear_apply_preview_columns() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kApplyPreviewColumns) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.apply_preview_columns_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* BatchTableRequest_Operation::release_apply_preview_columns() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.apply_preview_columns)
  if (op_case() == kApplyPreviewColumns) {
    clear_has_op();
    auto* temp = _impl_.op_.apply_preview_columns_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.apply_preview_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest& BatchTableRequest_Operation::_internal_apply_preview_columns() const {
  return op_case() == kApplyPreviewColumns ? *_impl_.op_.apply_preview_columns_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest&>(::io::deephaven::proto::backplane::grpc::_ApplyPreviewColumnsRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest& BatchTableRequest_Operation::apply_preview_columns() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.apply_preview_columns)
  return _internal_apply_preview_columns();
}
inline ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* BatchTableRequest_Operation::unsafe_arena_release_apply_preview_columns() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.apply_preview_columns)
  if (op_case() == kApplyPreviewColumns) {
    clear_has_op();
    auto* temp = _impl_.op_.apply_preview_columns_;
    _impl_.op_.apply_preview_columns_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_apply_preview_columns(::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_apply_preview_columns();
    _impl_.op_.apply_preview_columns_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.apply_preview_columns)
}
inline ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* BatchTableRequest_Operation::_internal_mutable_apply_preview_columns() {
  if (op_case() != kApplyPreviewColumns) {
    clear_op();
    set_has_apply_preview_columns();
    _impl_.op_.apply_preview_columns_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest>(GetArena());
  }
  return _impl_.op_.apply_preview_columns_;
}
inline ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* BatchTableRequest_Operation::mutable_apply_preview_columns() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::ApplyPreviewColumnsRequest* _msg = _internal_mutable_apply_preview_columns();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.apply_preview_columns)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.CreateInputTableRequest create_input_table = 31;
inline bool BatchTableRequest_Operation::has_create_input_table() const {
  return op_case() == kCreateInputTable;
}
inline bool BatchTableRequest_Operation::_internal_has_create_input_table() const {
  return op_case() == kCreateInputTable;
}
inline void BatchTableRequest_Operation::set_has_create_input_table() {
  _impl_._oneof_case_[0] = kCreateInputTable;
}
inline void BatchTableRequest_Operation::clear_create_input_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kCreateInputTable) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.create_input_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* BatchTableRequest_Operation::release_create_input_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.create_input_table)
  if (op_case() == kCreateInputTable) {
    clear_has_op();
    auto* temp = _impl_.op_.create_input_table_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.create_input_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest& BatchTableRequest_Operation::_internal_create_input_table() const {
  return op_case() == kCreateInputTable ? *_impl_.op_.create_input_table_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest&>(::io::deephaven::proto::backplane::grpc::_CreateInputTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest& BatchTableRequest_Operation::create_input_table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.create_input_table)
  return _internal_create_input_table();
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* BatchTableRequest_Operation::unsafe_arena_release_create_input_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.create_input_table)
  if (op_case() == kCreateInputTable) {
    clear_has_op();
    auto* temp = _impl_.op_.create_input_table_;
    _impl_.op_.create_input_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_create_input_table(::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_create_input_table();
    _impl_.op_.create_input_table_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.create_input_table)
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* BatchTableRequest_Operation::_internal_mutable_create_input_table() {
  if (op_case() != kCreateInputTable) {
    clear_op();
    set_has_create_input_table();
    _impl_.op_.create_input_table_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::CreateInputTableRequest>(GetArena());
  }
  return _impl_.op_.create_input_table_;
}
inline ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* BatchTableRequest_Operation::mutable_create_input_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::CreateInputTableRequest* _msg = _internal_mutable_create_input_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.create_input_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.UpdateByRequest update_by = 32;
inline bool BatchTableRequest_Operation::has_update_by() const {
  return op_case() == kUpdateBy;
}
inline bool BatchTableRequest_Operation::_internal_has_update_by() const {
  return op_case() == kUpdateBy;
}
inline void BatchTableRequest_Operation::set_has_update_by() {
  _impl_._oneof_case_[0] = kUpdateBy;
}
inline void BatchTableRequest_Operation::clear_update_by() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kUpdateBy) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.update_by_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest* BatchTableRequest_Operation::release_update_by() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_by)
  if (op_case() == kUpdateBy) {
    clear_has_op();
    auto* temp = _impl_.op_.update_by_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.update_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest& BatchTableRequest_Operation::_internal_update_by() const {
  return op_case() == kUpdateBy ? *_impl_.op_.update_by_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::UpdateByRequest&>(::io::deephaven::proto::backplane::grpc::_UpdateByRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::UpdateByRequest& BatchTableRequest_Operation::update_by() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_by)
  return _internal_update_by();
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest* BatchTableRequest_Operation::unsafe_arena_release_update_by() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_by)
  if (op_case() == kUpdateBy) {
    clear_has_op();
    auto* temp = _impl_.op_.update_by_;
    _impl_.op_.update_by_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_update_by(::io::deephaven::proto::backplane::grpc::UpdateByRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_update_by();
    _impl_.op_.update_by_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_by)
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest* BatchTableRequest_Operation::_internal_mutable_update_by() {
  if (op_case() != kUpdateBy) {
    clear_op();
    set_has_update_by();
    _impl_.op_.update_by_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::UpdateByRequest>(GetArena());
  }
  return _impl_.op_.update_by_;
}
inline ::io::deephaven::proto::backplane::grpc::UpdateByRequest* BatchTableRequest_Operation::mutable_update_by() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::UpdateByRequest* _msg = _internal_mutable_update_by();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.update_by)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.WhereInRequest where_in = 33;
inline bool BatchTableRequest_Operation::has_where_in() const {
  return op_case() == kWhereIn;
}
inline bool BatchTableRequest_Operation::_internal_has_where_in() const {
  return op_case() == kWhereIn;
}
inline void BatchTableRequest_Operation::set_has_where_in() {
  _impl_._oneof_case_[0] = kWhereIn;
}
inline void BatchTableRequest_Operation::clear_where_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kWhereIn) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.where_in_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::WhereInRequest* BatchTableRequest_Operation::release_where_in() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.where_in)
  if (op_case() == kWhereIn) {
    clear_has_op();
    auto* temp = _impl_.op_.where_in_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.where_in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::WhereInRequest& BatchTableRequest_Operation::_internal_where_in() const {
  return op_case() == kWhereIn ? *_impl_.op_.where_in_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::WhereInRequest&>(::io::deephaven::proto::backplane::grpc::_WhereInRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::WhereInRequest& BatchTableRequest_Operation::where_in() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.where_in)
  return _internal_where_in();
}
inline ::io::deephaven::proto::backplane::grpc::WhereInRequest* BatchTableRequest_Operation::unsafe_arena_release_where_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.where_in)
  if (op_case() == kWhereIn) {
    clear_has_op();
    auto* temp = _impl_.op_.where_in_;
    _impl_.op_.where_in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_where_in(::io::deephaven::proto::backplane::grpc::WhereInRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_where_in();
    _impl_.op_.where_in_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.where_in)
}
inline ::io::deephaven::proto::backplane::grpc::WhereInRequest* BatchTableRequest_Operation::_internal_mutable_where_in() {
  if (op_case() != kWhereIn) {
    clear_op();
    set_has_where_in();
    _impl_.op_.where_in_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::WhereInRequest>(GetArena());
  }
  return _impl_.op_.where_in_;
}
inline ::io::deephaven::proto::backplane::grpc::WhereInRequest* BatchTableRequest_Operation::mutable_where_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::WhereInRequest* _msg = _internal_mutable_where_in();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.where_in)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggregateAllRequest aggregate_all = 34;
inline bool BatchTableRequest_Operation::has_aggregate_all() const {
  return op_case() == kAggregateAll;
}
inline bool BatchTableRequest_Operation::_internal_has_aggregate_all() const {
  return op_case() == kAggregateAll;
}
inline void BatchTableRequest_Operation::set_has_aggregate_all() {
  _impl_._oneof_case_[0] = kAggregateAll;
}
inline void BatchTableRequest_Operation::clear_aggregate_all() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kAggregateAll) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.aggregate_all_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* BatchTableRequest_Operation::release_aggregate_all() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate_all)
  if (op_case() == kAggregateAll) {
    clear_has_op();
    auto* temp = _impl_.op_.aggregate_all_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.aggregate_all_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggregateAllRequest& BatchTableRequest_Operation::_internal_aggregate_all() const {
  return op_case() == kAggregateAll ? *_impl_.op_.aggregate_all_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggregateAllRequest&>(::io::deephaven::proto::backplane::grpc::_AggregateAllRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggregateAllRequest& BatchTableRequest_Operation::aggregate_all() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate_all)
  return _internal_aggregate_all();
}
inline ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* BatchTableRequest_Operation::unsafe_arena_release_aggregate_all() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate_all)
  if (op_case() == kAggregateAll) {
    clear_has_op();
    auto* temp = _impl_.op_.aggregate_all_;
    _impl_.op_.aggregate_all_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_aggregate_all(::io::deephaven::proto::backplane::grpc::AggregateAllRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_aggregate_all();
    _impl_.op_.aggregate_all_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate_all)
}
inline ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* BatchTableRequest_Operation::_internal_mutable_aggregate_all() {
  if (op_case() != kAggregateAll) {
    clear_op();
    set_has_aggregate_all();
    _impl_.op_.aggregate_all_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggregateAllRequest>(GetArena());
  }
  return _impl_.op_.aggregate_all_;
}
inline ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* BatchTableRequest_Operation::mutable_aggregate_all() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggregateAllRequest* _msg = _internal_mutable_aggregate_all();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate_all)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AggregateRequest aggregate = 35;
inline bool BatchTableRequest_Operation::has_aggregate() const {
  return op_case() == kAggregate;
}
inline bool BatchTableRequest_Operation::_internal_has_aggregate() const {
  return op_case() == kAggregate;
}
inline void BatchTableRequest_Operation::set_has_aggregate() {
  _impl_._oneof_case_[0] = kAggregate;
}
inline void BatchTableRequest_Operation::clear_aggregate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kAggregate) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.aggregate_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AggregateRequest* BatchTableRequest_Operation::release_aggregate() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate)
  if (op_case() == kAggregate) {
    clear_has_op();
    auto* temp = _impl_.op_.aggregate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AggregateRequest& BatchTableRequest_Operation::_internal_aggregate() const {
  return op_case() == kAggregate ? *_impl_.op_.aggregate_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AggregateRequest&>(::io::deephaven::proto::backplane::grpc::_AggregateRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AggregateRequest& BatchTableRequest_Operation::aggregate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate)
  return _internal_aggregate();
}
inline ::io::deephaven::proto::backplane::grpc::AggregateRequest* BatchTableRequest_Operation::unsafe_arena_release_aggregate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate)
  if (op_case() == kAggregate) {
    clear_has_op();
    auto* temp = _impl_.op_.aggregate_;
    _impl_.op_.aggregate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_aggregate(::io::deephaven::proto::backplane::grpc::AggregateRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_aggregate();
    _impl_.op_.aggregate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate)
}
inline ::io::deephaven::proto::backplane::grpc::AggregateRequest* BatchTableRequest_Operation::_internal_mutable_aggregate() {
  if (op_case() != kAggregate) {
    clear_op();
    set_has_aggregate();
    _impl_.op_.aggregate_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AggregateRequest>(GetArena());
  }
  return _impl_.op_.aggregate_;
}
inline ::io::deephaven::proto::backplane::grpc::AggregateRequest* BatchTableRequest_Operation::mutable_aggregate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AggregateRequest* _msg = _internal_mutable_aggregate();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aggregate)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SnapshotTableRequest snapshot = 36;
inline bool BatchTableRequest_Operation::has_snapshot() const {
  return op_case() == kSnapshot;
}
inline bool BatchTableRequest_Operation::_internal_has_snapshot() const {
  return op_case() == kSnapshot;
}
inline void BatchTableRequest_Operation::set_has_snapshot() {
  _impl_._oneof_case_[0] = kSnapshot;
}
inline void BatchTableRequest_Operation::clear_snapshot() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kSnapshot) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.snapshot_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* BatchTableRequest_Operation::release_snapshot() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
  if (op_case() == kSnapshot) {
    clear_has_op();
    auto* temp = _impl_.op_.snapshot_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& BatchTableRequest_Operation::_internal_snapshot() const {
  return op_case() == kSnapshot ? *_impl_.op_.snapshot_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::SnapshotTableRequest&>(::io::deephaven::proto::backplane::grpc::_SnapshotTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest& BatchTableRequest_Operation::snapshot() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
  return _internal_snapshot();
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* BatchTableRequest_Operation::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
  if (op_case() == kSnapshot) {
    clear_has_op();
    auto* temp = _impl_.op_.snapshot_;
    _impl_.op_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_snapshot(::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_snapshot();
    _impl_.op_.snapshot_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* BatchTableRequest_Operation::_internal_mutable_snapshot() {
  if (op_case() != kSnapshot) {
    clear_op();
    set_has_snapshot();
    _impl_.op_.snapshot_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SnapshotTableRequest>(GetArena());
  }
  return _impl_.op_.snapshot_;
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* BatchTableRequest_Operation::mutable_snapshot() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::SnapshotTableRequest* _msg = _internal_mutable_snapshot();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.SnapshotWhenTableRequest snapshot_when = 37;
inline bool BatchTableRequest_Operation::has_snapshot_when() const {
  return op_case() == kSnapshotWhen;
}
inline bool BatchTableRequest_Operation::_internal_has_snapshot_when() const {
  return op_case() == kSnapshotWhen;
}
inline void BatchTableRequest_Operation::set_has_snapshot_when() {
  _impl_._oneof_case_[0] = kSnapshotWhen;
}
inline void BatchTableRequest_Operation::clear_snapshot_when() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kSnapshotWhen) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.snapshot_when_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* BatchTableRequest_Operation::release_snapshot_when() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot_when)
  if (op_case() == kSnapshotWhen) {
    clear_has_op();
    auto* temp = _impl_.op_.snapshot_when_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.snapshot_when_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest& BatchTableRequest_Operation::_internal_snapshot_when() const {
  return op_case() == kSnapshotWhen ? *_impl_.op_.snapshot_when_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest&>(::io::deephaven::proto::backplane::grpc::_SnapshotWhenTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest& BatchTableRequest_Operation::snapshot_when() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot_when)
  return _internal_snapshot_when();
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* BatchTableRequest_Operation::unsafe_arena_release_snapshot_when() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot_when)
  if (op_case() == kSnapshotWhen) {
    clear_has_op();
    auto* temp = _impl_.op_.snapshot_when_;
    _impl_.op_.snapshot_when_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_snapshot_when(::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_snapshot_when();
    _impl_.op_.snapshot_when_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot_when)
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* BatchTableRequest_Operation::_internal_mutable_snapshot_when() {
  if (op_case() != kSnapshotWhen) {
    clear_op();
    set_has_snapshot_when();
    _impl_.op_.snapshot_when_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest>(GetArena());
  }
  return _impl_.op_.snapshot_when_;
}
inline ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* BatchTableRequest_Operation::mutable_snapshot_when() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::SnapshotWhenTableRequest* _msg = _internal_mutable_snapshot_when();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.snapshot_when)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.MetaTableRequest meta_table = 38;
inline bool BatchTableRequest_Operation::has_meta_table() const {
  return op_case() == kMetaTable;
}
inline bool BatchTableRequest_Operation::_internal_has_meta_table() const {
  return op_case() == kMetaTable;
}
inline void BatchTableRequest_Operation::set_has_meta_table() {
  _impl_._oneof_case_[0] = kMetaTable;
}
inline void BatchTableRequest_Operation::clear_meta_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kMetaTable) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.meta_table_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::MetaTableRequest* BatchTableRequest_Operation::release_meta_table() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.meta_table)
  if (op_case() == kMetaTable) {
    clear_has_op();
    auto* temp = _impl_.op_.meta_table_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.meta_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::MetaTableRequest& BatchTableRequest_Operation::_internal_meta_table() const {
  return op_case() == kMetaTable ? *_impl_.op_.meta_table_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::MetaTableRequest&>(::io::deephaven::proto::backplane::grpc::_MetaTableRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MetaTableRequest& BatchTableRequest_Operation::meta_table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.meta_table)
  return _internal_meta_table();
}
inline ::io::deephaven::proto::backplane::grpc::MetaTableRequest* BatchTableRequest_Operation::unsafe_arena_release_meta_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.meta_table)
  if (op_case() == kMetaTable) {
    clear_has_op();
    auto* temp = _impl_.op_.meta_table_;
    _impl_.op_.meta_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_meta_table(::io::deephaven::proto::backplane::grpc::MetaTableRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_meta_table();
    _impl_.op_.meta_table_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.meta_table)
}
inline ::io::deephaven::proto::backplane::grpc::MetaTableRequest* BatchTableRequest_Operation::_internal_mutable_meta_table() {
  if (op_case() != kMetaTable) {
    clear_op();
    set_has_meta_table();
    _impl_.op_.meta_table_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MetaTableRequest>(GetArena());
  }
  return _impl_.op_.meta_table_;
}
inline ::io::deephaven::proto::backplane::grpc::MetaTableRequest* BatchTableRequest_Operation::mutable_meta_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::MetaTableRequest* _msg = _internal_mutable_meta_table();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.meta_table)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.RangeJoinTablesRequest range_join = 39;
inline bool BatchTableRequest_Operation::has_range_join() const {
  return op_case() == kRangeJoin;
}
inline bool BatchTableRequest_Operation::_internal_has_range_join() const {
  return op_case() == kRangeJoin;
}
inline void BatchTableRequest_Operation::set_has_range_join() {
  _impl_._oneof_case_[0] = kRangeJoin;
}
inline void BatchTableRequest_Operation::clear_range_join() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kRangeJoin) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.range_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* BatchTableRequest_Operation::release_range_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.range_join)
  if (op_case() == kRangeJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.range_join_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.range_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest& BatchTableRequest_Operation::_internal_range_join() const {
  return op_case() == kRangeJoin ? *_impl_.op_.range_join_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_RangeJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest& BatchTableRequest_Operation::range_join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.range_join)
  return _internal_range_join();
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_range_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.range_join)
  if (op_case() == kRangeJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.range_join_;
    _impl_.op_.range_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_range_join(::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_range_join();
    _impl_.op_.range_join_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.range_join)
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_range_join() {
  if (op_case() != kRangeJoin) {
    clear_op();
    set_has_range_join();
    _impl_.op_.range_join_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest>(GetArena());
  }
  return _impl_.op_.range_join_;
}
inline ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* BatchTableRequest_Operation::mutable_range_join() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest* _msg = _internal_mutable_range_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.range_join)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AjRajTablesRequest aj = 40;
inline bool BatchTableRequest_Operation::has_aj() const {
  return op_case() == kAj;
}
inline bool BatchTableRequest_Operation::_internal_has_aj() const {
  return op_case() == kAj;
}
inline void BatchTableRequest_Operation::set_has_aj() {
  _impl_._oneof_case_[0] = kAj;
}
inline void BatchTableRequest_Operation::clear_aj() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kAj) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.aj_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::release_aj() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aj)
  if (op_case() == kAj) {
    clear_has_op();
    auto* temp = _impl_.op_.aj_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.aj_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& BatchTableRequest_Operation::_internal_aj() const {
  return op_case() == kAj ? *_impl_.op_.aj_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AjRajTablesRequest&>(::io::deephaven::proto::backplane::grpc::_AjRajTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& BatchTableRequest_Operation::aj() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aj)
  return _internal_aj();
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_aj() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aj)
  if (op_case() == kAj) {
    clear_has_op();
    auto* temp = _impl_.op_.aj_;
    _impl_.op_.aj_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_aj(::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_aj();
    _impl_.op_.aj_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aj)
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::_internal_mutable_aj() {
  if (op_case() != kAj) {
    clear_op();
    set_has_aj();
    _impl_.op_.aj_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AjRajTablesRequest>(GetArena());
  }
  return _impl_.op_.aj_;
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::mutable_aj() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* _msg = _internal_mutable_aj();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.aj)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.AjRajTablesRequest raj = 41;
inline bool BatchTableRequest_Operation::has_raj() const {
  return op_case() == kRaj;
}
inline bool BatchTableRequest_Operation::_internal_has_raj() const {
  return op_case() == kRaj;
}
inline void BatchTableRequest_Operation::set_has_raj() {
  _impl_._oneof_case_[0] = kRaj;
}
inline void BatchTableRequest_Operation::clear_raj() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kRaj) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.raj_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::release_raj() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.raj)
  if (op_case() == kRaj) {
    clear_has_op();
    auto* temp = _impl_.op_.raj_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.raj_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& BatchTableRequest_Operation::_internal_raj() const {
  return op_case() == kRaj ? *_impl_.op_.raj_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::AjRajTablesRequest&>(::io::deephaven::proto::backplane::grpc::_AjRajTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest& BatchTableRequest_Operation::raj() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.raj)
  return _internal_raj();
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_raj() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.raj)
  if (op_case() == kRaj) {
    clear_has_op();
    auto* temp = _impl_.op_.raj_;
    _impl_.op_.raj_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_raj(::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_raj();
    _impl_.op_.raj_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.raj)
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::_internal_mutable_raj() {
  if (op_case() != kRaj) {
    clear_op();
    set_has_raj();
    _impl_.op_.raj_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::AjRajTablesRequest>(GetArena());
  }
  return _impl_.op_.raj_;
}
inline ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* BatchTableRequest_Operation::mutable_raj() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::AjRajTablesRequest* _msg = _internal_mutable_raj();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.raj)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.ColumnStatisticsRequest column_statistics = 42;
inline bool BatchTableRequest_Operation::has_column_statistics() const {
  return op_case() == kColumnStatistics;
}
inline bool BatchTableRequest_Operation::_internal_has_column_statistics() const {
  return op_case() == kColumnStatistics;
}
inline void BatchTableRequest_Operation::set_has_column_statistics() {
  _impl_._oneof_case_[0] = kColumnStatistics;
}
inline void BatchTableRequest_Operation::clear_column_statistics() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kColumnStatistics) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.column_statistics_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* BatchTableRequest_Operation::release_column_statistics() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.column_statistics)
  if (op_case() == kColumnStatistics) {
    clear_has_op();
    auto* temp = _impl_.op_.column_statistics_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.column_statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest& BatchTableRequest_Operation::_internal_column_statistics() const {
  return op_case() == kColumnStatistics ? *_impl_.op_.column_statistics_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest&>(::io::deephaven::proto::backplane::grpc::_ColumnStatisticsRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest& BatchTableRequest_Operation::column_statistics() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.column_statistics)
  return _internal_column_statistics();
}
inline ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* BatchTableRequest_Operation::unsafe_arena_release_column_statistics() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.column_statistics)
  if (op_case() == kColumnStatistics) {
    clear_has_op();
    auto* temp = _impl_.op_.column_statistics_;
    _impl_.op_.column_statistics_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_column_statistics(::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_column_statistics();
    _impl_.op_.column_statistics_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.column_statistics)
}
inline ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* BatchTableRequest_Operation::_internal_mutable_column_statistics() {
  if (op_case() != kColumnStatistics) {
    clear_op();
    set_has_column_statistics();
    _impl_.op_.column_statistics_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest>(GetArena());
  }
  return _impl_.op_.column_statistics_;
}
inline ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* BatchTableRequest_Operation::mutable_column_statistics() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::ColumnStatisticsRequest* _msg = _internal_mutable_column_statistics();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.column_statistics)
  return _msg;
}

// .io.deephaven.proto.backplane.grpc.MultiJoinTablesRequest multi_join = 43;
inline bool BatchTableRequest_Operation::has_multi_join() const {
  return op_case() == kMultiJoin;
}
inline bool BatchTableRequest_Operation::_internal_has_multi_join() const {
  return op_case() == kMultiJoin;
}
inline void BatchTableRequest_Operation::set_has_multi_join() {
  _impl_._oneof_case_[0] = kMultiJoin;
}
inline void BatchTableRequest_Operation::clear_multi_join() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (op_case() == kMultiJoin) {
    if (GetArena() == nullptr) {
      delete _impl_.op_.multi_join_;
    }
    clear_has_op();
  }
}
inline ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* BatchTableRequest_Operation::release_multi_join() {
  // @@protoc_insertion_point(field_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.multi_join)
  if (op_case() == kMultiJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.multi_join_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.op_.multi_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest& BatchTableRequest_Operation::_internal_multi_join() const {
  return op_case() == kMultiJoin ? *_impl_.op_.multi_join_ : reinterpret_cast<::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest&>(::io::deephaven::proto::backplane::grpc::_MultiJoinTablesRequest_default_instance_);
}
inline const ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest& BatchTableRequest_Operation::multi_join() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.multi_join)
  return _internal_multi_join();
}
inline ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* BatchTableRequest_Operation::unsafe_arena_release_multi_join() {
  // @@protoc_insertion_point(field_unsafe_arena_release:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.multi_join)
  if (op_case() == kMultiJoin) {
    clear_has_op();
    auto* temp = _impl_.op_.multi_join_;
    _impl_.op_.multi_join_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void BatchTableRequest_Operation::unsafe_arena_set_allocated_multi_join(::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_op();
  if (value) {
    set_has_multi_join();
    _impl_.op_.multi_join_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.multi_join)
}
inline ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* BatchTableRequest_Operation::_internal_mutable_multi_join() {
  if (op_case() != kMultiJoin) {
    clear_op();
    set_has_multi_join();
    _impl_.op_.multi_join_ = CreateMaybeMessage<::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest>(GetArena());
  }
  return _impl_.op_.multi_join_;
}
inline ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* BatchTableRequest_Operation::mutable_multi_join() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::io::deephaven::proto::backplane::grpc::MultiJoinTablesRequest* _msg = _internal_mutable_multi_join();
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation.multi_join)
  return _msg;
}

inline bool BatchTableRequest_Operation::has_op() const {
  return op_case() != OP_NOT_SET;
}
inline void BatchTableRequest_Operation::clear_has_op() {
  _impl_._oneof_case_[0] = OP_NOT_SET;
}
inline BatchTableRequest_Operation::OpCase BatchTableRequest_Operation::op_case() const {
  return BatchTableRequest_Operation::OpCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// BatchTableRequest

// repeated .io.deephaven.proto.backplane.grpc.BatchTableRequest.Operation ops = 1;
inline int BatchTableRequest::_internal_ops_size() const {
  return _internal_ops().size();
}
inline int BatchTableRequest::ops_size() const {
  return _internal_ops_size();
}
inline void BatchTableRequest::clear_ops() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.ops_.Clear();
}
inline ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* BatchTableRequest::mutable_ops(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return _internal_mutable_ops()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation>* BatchTableRequest::mutable_ops()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_ops();
}
inline const ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation& BatchTableRequest::ops(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return _internal_ops().Get(index);
}
inline ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* BatchTableRequest::add_ops() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation* _add = _internal_mutable_ops()->Add();
  // @@protoc_insertion_point(field_add:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation>& BatchTableRequest::ops() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:io.deephaven.proto.backplane.grpc.BatchTableRequest.ops)
  return _internal_ops();
}
inline const ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation>&
BatchTableRequest::_internal_ops() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.ops_;
}
inline ::google::protobuf::RepeatedPtrField<::io::deephaven::proto::backplane::grpc::BatchTableRequest_Operation>*
BatchTableRequest::_internal_mutable_ops() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.ops_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace grpc
}  // namespace backplane
}  // namespace proto
}  // namespace deephaven
}  // namespace io


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode>() {
  return ::io::deephaven::proto::backplane::grpc::MathContext_RoundingMode_descriptor();
}
template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule>() {
  return ::io::deephaven::proto::backplane::grpc::AsOfJoinTablesRequest_MatchRule_descriptor();
}
template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule>() {
  return ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeStartRule_descriptor();
}
template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule>() {
  return ::io::deephaven::proto::backplane::grpc::RangeJoinTablesRequest_RangeEndRule_descriptor();
}
template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType>() {
  return ::io::deephaven::proto::backplane::grpc::ComboAggregateRequest_AggType_descriptor();
}
template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection>() {
  return ::io::deephaven::proto::backplane::grpc::SortDescriptor_SortDirection_descriptor();
}
template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation>() {
  return ::io::deephaven::proto::backplane::grpc::CompareCondition_CompareOperation_descriptor();
}
template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::BadDataBehavior> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::BadDataBehavior>() {
  return ::io::deephaven::proto::backplane::grpc::BadDataBehavior_descriptor();
}
template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior>() {
  return ::io::deephaven::proto::backplane::grpc::UpdateByNullBehavior_descriptor();
}
template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::NullValue> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::NullValue>() {
  return ::io::deephaven::proto::backplane::grpc::NullValue_descriptor();
}
template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::CaseSensitivity> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::CaseSensitivity>() {
  return ::io::deephaven::proto::backplane::grpc::CaseSensitivity_descriptor();
}
template <>
struct is_proto_enum<::io::deephaven::proto::backplane::grpc::MatchType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::io::deephaven::proto::backplane::grpc::MatchType>() {
  return ::io::deephaven::proto::backplane::grpc::MatchType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_deephaven_2fproto_2ftable_2eproto_2epb_2eh
