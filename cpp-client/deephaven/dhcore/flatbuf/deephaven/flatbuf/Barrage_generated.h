// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BARRAGE_IO_DEEPHAVEN_BARRAGE_FLATBUF_H_
#define FLATBUFFERS_GENERATED_BARRAGE_IO_DEEPHAVEN_BARRAGE_FLATBUF_H_

#include "flatbuffers/flatbuffers.h"

namespace io {
namespace deephaven {
namespace barrage {
namespace flatbuf {

struct BarrageMessageWrapper;
struct BarrageMessageWrapperBuilder;

struct NewSessionRequest;
struct NewSessionRequestBuilder;

struct RefreshSessionRequest;
struct RefreshSessionRequestBuilder;

struct SessionInfoResponse;
struct SessionInfoResponseBuilder;

struct BarrageSubscriptionOptions;
struct BarrageSubscriptionOptionsBuilder;

struct BarrageSubscriptionRequest;
struct BarrageSubscriptionRequestBuilder;

struct BarrageSnapshotOptions;
struct BarrageSnapshotOptionsBuilder;

struct BarrageSnapshotRequest;
struct BarrageSnapshotRequestBuilder;

struct BarragePublicationOptions;
struct BarragePublicationOptionsBuilder;

struct BarragePublicationRequest;
struct BarragePublicationRequestBuilder;

struct BarrageModColumnMetadata;
struct BarrageModColumnMetadataBuilder;

struct BarrageUpdateMetadata;
struct BarrageUpdateMetadataBuilder;

enum BarrageMessageType : int8_t {
  /// A barrage message wrapper might send a None message type
  /// if the msg_payload is empty.
  BarrageMessageType_None = 0,
  /// for session management (not-yet-used)
  BarrageMessageType_NewSessionRequest = 1,
  BarrageMessageType_RefreshSessionRequest = 2,
  BarrageMessageType_SessionInfoResponse = 3,
  /// for subscription parsing/management (aka DoPut, DoExchange)
  BarrageMessageType_BarrageSerializationOptions = 4,
  BarrageMessageType_BarrageSubscriptionRequest = 5,
  BarrageMessageType_BarrageUpdateMetadata = 6,
  BarrageMessageType_BarrageSnapshotRequest = 7,
  BarrageMessageType_BarragePublicationRequest = 8,
  BarrageMessageType_MIN = BarrageMessageType_None,
  BarrageMessageType_MAX = BarrageMessageType_BarragePublicationRequest
};

inline const BarrageMessageType (&EnumValuesBarrageMessageType())[9] {
  static const BarrageMessageType values[] = {
    BarrageMessageType_None,
    BarrageMessageType_NewSessionRequest,
    BarrageMessageType_RefreshSessionRequest,
    BarrageMessageType_SessionInfoResponse,
    BarrageMessageType_BarrageSerializationOptions,
    BarrageMessageType_BarrageSubscriptionRequest,
    BarrageMessageType_BarrageUpdateMetadata,
    BarrageMessageType_BarrageSnapshotRequest,
    BarrageMessageType_BarragePublicationRequest
  };
  return values;
}

inline const char * const *EnumNamesBarrageMessageType() {
  static const char * const names[10] = {
    "None",
    "NewSessionRequest",
    "RefreshSessionRequest",
    "SessionInfoResponse",
    "BarrageSerializationOptions",
    "BarrageSubscriptionRequest",
    "BarrageUpdateMetadata",
    "BarrageSnapshotRequest",
    "BarragePublicationRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameBarrageMessageType(BarrageMessageType e) {
  if (flatbuffers::IsOutRange(e, BarrageMessageType_None, BarrageMessageType_BarragePublicationRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBarrageMessageType()[index];
}

/// There will always be types that cannot be easily supported over IPC. These are the options:
///   Stringify (default) - Pretend the column is a string when sending over Arrow Flight (default)
///   JavaSerialization   - Use java serialization; the client is responsible for the deserialization
///   ThrowError          - Refuse to send the column and throw an internal error sharing as much detail as possible
enum ColumnConversionMode : int8_t {
  ColumnConversionMode_Stringify = 1,
  ColumnConversionMode_JavaSerialization = 2,
  ColumnConversionMode_ThrowError = 3,
  ColumnConversionMode_MIN = ColumnConversionMode_Stringify,
  ColumnConversionMode_MAX = ColumnConversionMode_ThrowError
};

inline const ColumnConversionMode (&EnumValuesColumnConversionMode())[3] {
  static const ColumnConversionMode values[] = {
    ColumnConversionMode_Stringify,
    ColumnConversionMode_JavaSerialization,
    ColumnConversionMode_ThrowError
  };
  return values;
}

inline const char * const *EnumNamesColumnConversionMode() {
  static const char * const names[4] = {
    "Stringify",
    "JavaSerialization",
    "ThrowError",
    nullptr
  };
  return names;
}

inline const char *EnumNameColumnConversionMode(ColumnConversionMode e) {
  if (flatbuffers::IsOutRange(e, ColumnConversionMode_Stringify, ColumnConversionMode_ThrowError)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ColumnConversionMode_Stringify);
  return EnumNamesColumnConversionMode()[index];
}

/// The message wrapper used for all barrage app_metadata fields.
struct BarrageMessageWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrageMessageWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAGIC = 4,
    VT_MSG_TYPE = 6,
    VT_MSG_PAYLOAD = 8
  };
  /// Used to identify this type of app_metadata vs other applications.
  /// The magic value is '0x6E687064'. It is the numerical representation of the ASCII "dphn".
  uint32_t magic() const {
    return GetField<uint32_t>(VT_MAGIC, 0);
  }
  /// The msg type being sent.
  io::deephaven::barrage::flatbuf::BarrageMessageType msg_type() const {
    return static_cast<io::deephaven::barrage::flatbuf::BarrageMessageType>(GetField<int8_t>(VT_MSG_TYPE, 0));
  }
  /// The msg payload.
  const flatbuffers::Vector<int8_t> *msg_payload() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_MSG_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MAGIC, 4) &&
           VerifyField<int8_t>(verifier, VT_MSG_TYPE, 1) &&
           VerifyOffset(verifier, VT_MSG_PAYLOAD) &&
           verifier.VerifyVector(msg_payload()) &&
           verifier.EndTable();
  }
};

struct BarrageMessageWrapperBuilder {
  typedef BarrageMessageWrapper Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_magic(uint32_t magic) {
    fbb_.AddElement<uint32_t>(BarrageMessageWrapper::VT_MAGIC, magic, 0);
  }
  void add_msg_type(io::deephaven::barrage::flatbuf::BarrageMessageType msg_type) {
    fbb_.AddElement<int8_t>(BarrageMessageWrapper::VT_MSG_TYPE, static_cast<int8_t>(msg_type), 0);
  }
  void add_msg_payload(flatbuffers::Offset<flatbuffers::Vector<int8_t>> msg_payload) {
    fbb_.AddOffset(BarrageMessageWrapper::VT_MSG_PAYLOAD, msg_payload);
  }
  explicit BarrageMessageWrapperBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarrageMessageWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrageMessageWrapper>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrageMessageWrapper> CreateBarrageMessageWrapper(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t magic = 0,
    io::deephaven::barrage::flatbuf::BarrageMessageType msg_type = io::deephaven::barrage::flatbuf::BarrageMessageType_None,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> msg_payload = 0) {
  BarrageMessageWrapperBuilder builder_(_fbb);
  builder_.add_msg_payload(msg_payload);
  builder_.add_magic(magic);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<BarrageMessageWrapper> CreateBarrageMessageWrapperDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t magic = 0,
    io::deephaven::barrage::flatbuf::BarrageMessageType msg_type = io::deephaven::barrage::flatbuf::BarrageMessageType_None,
    const std::vector<int8_t> *msg_payload = nullptr) {
  auto msg_payload__ = msg_payload ? _fbb.CreateVector<int8_t>(*msg_payload) : 0;
  return io::deephaven::barrage::flatbuf::CreateBarrageMessageWrapper(
      _fbb,
      magic,
      msg_type,
      msg_payload__);
}

/// Establish a new session.
struct NewSessionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NewSessionRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROTOCOL_VERSION = 4,
    VT_PAYLOAD = 6
  };
  /// A nested protocol version (gets delegated to handshake)
  uint32_t protocol_version() const {
    return GetField<uint32_t>(VT_PROTOCOL_VERSION, 0);
  }
  /// Arbitrary auth/handshake info.
  const flatbuffers::Vector<int8_t> *payload() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_PAYLOAD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_PROTOCOL_VERSION, 4) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.VerifyVector(payload()) &&
           verifier.EndTable();
  }
};

struct NewSessionRequestBuilder {
  typedef NewSessionRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_protocol_version(uint32_t protocol_version) {
    fbb_.AddElement<uint32_t>(NewSessionRequest::VT_PROTOCOL_VERSION, protocol_version, 0);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::Vector<int8_t>> payload) {
    fbb_.AddOffset(NewSessionRequest::VT_PAYLOAD, payload);
  }
  explicit NewSessionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NewSessionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NewSessionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<NewSessionRequest> CreateNewSessionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t protocol_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> payload = 0) {
  NewSessionRequestBuilder builder_(_fbb);
  builder_.add_payload(payload);
  builder_.add_protocol_version(protocol_version);
  return builder_.Finish();
}

inline flatbuffers::Offset<NewSessionRequest> CreateNewSessionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t protocol_version = 0,
    const std::vector<int8_t> *payload = nullptr) {
  auto payload__ = payload ? _fbb.CreateVector<int8_t>(*payload) : 0;
  return io::deephaven::barrage::flatbuf::CreateNewSessionRequest(
      _fbb,
      protocol_version,
      payload__);
}

/// Refresh the provided session.
struct RefreshSessionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RefreshSessionRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION = 4
  };
  /// this session token is only required if it is the first request of a handshake rpc stream
  const flatbuffers::Vector<int8_t> *session() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SESSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSION) &&
           verifier.VerifyVector(session()) &&
           verifier.EndTable();
  }
};

struct RefreshSessionRequestBuilder {
  typedef RefreshSessionRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_session(flatbuffers::Offset<flatbuffers::Vector<int8_t>> session) {
    fbb_.AddOffset(RefreshSessionRequest::VT_SESSION, session);
  }
  explicit RefreshSessionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RefreshSessionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RefreshSessionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<RefreshSessionRequest> CreateRefreshSessionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> session = 0) {
  RefreshSessionRequestBuilder builder_(_fbb);
  builder_.add_session(session);
  return builder_.Finish();
}

inline flatbuffers::Offset<RefreshSessionRequest> CreateRefreshSessionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *session = nullptr) {
  auto session__ = session ? _fbb.CreateVector<int8_t>(*session) : 0;
  return io::deephaven::barrage::flatbuf::CreateRefreshSessionRequest(
      _fbb,
      session__);
}

/// Information about the current session state.
struct SessionInfoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SessionInfoResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METADATA_HEADER = 4,
    VT_SESSION_TOKEN = 6,
    VT_TOKEN_REFRESH_DEADLINE_MS = 8
  };
  /// this is the metadata header to identify this session with future requests; it must be lower-case and remain static for the life of the session
  const flatbuffers::Vector<int8_t> *metadata_header() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_METADATA_HEADER);
  }
  /// this is the session_token; note that it may rotate
  const flatbuffers::Vector<int8_t> *session_token() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SESSION_TOKEN);
  }
  /// a suggested time for the user to refresh the session if they do not do so earlier; value is denoted in milliseconds since epoch
  int64_t token_refresh_deadline_ms() const {
    return GetField<int64_t>(VT_TOKEN_REFRESH_DEADLINE_MS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METADATA_HEADER) &&
           verifier.VerifyVector(metadata_header()) &&
           VerifyOffset(verifier, VT_SESSION_TOKEN) &&
           verifier.VerifyVector(session_token()) &&
           VerifyField<int64_t>(verifier, VT_TOKEN_REFRESH_DEADLINE_MS, 8) &&
           verifier.EndTable();
  }
};

struct SessionInfoResponseBuilder {
  typedef SessionInfoResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_metadata_header(flatbuffers::Offset<flatbuffers::Vector<int8_t>> metadata_header) {
    fbb_.AddOffset(SessionInfoResponse::VT_METADATA_HEADER, metadata_header);
  }
  void add_session_token(flatbuffers::Offset<flatbuffers::Vector<int8_t>> session_token) {
    fbb_.AddOffset(SessionInfoResponse::VT_SESSION_TOKEN, session_token);
  }
  void add_token_refresh_deadline_ms(int64_t token_refresh_deadline_ms) {
    fbb_.AddElement<int64_t>(SessionInfoResponse::VT_TOKEN_REFRESH_DEADLINE_MS, token_refresh_deadline_ms, 0);
  }
  explicit SessionInfoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SessionInfoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SessionInfoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<SessionInfoResponse> CreateSessionInfoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> metadata_header = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> session_token = 0,
    int64_t token_refresh_deadline_ms = 0) {
  SessionInfoResponseBuilder builder_(_fbb);
  builder_.add_token_refresh_deadline_ms(token_refresh_deadline_ms);
  builder_.add_session_token(session_token);
  builder_.add_metadata_header(metadata_header);
  return builder_.Finish();
}

inline flatbuffers::Offset<SessionInfoResponse> CreateSessionInfoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *metadata_header = nullptr,
    const std::vector<int8_t> *session_token = nullptr,
    int64_t token_refresh_deadline_ms = 0) {
  auto metadata_header__ = metadata_header ? _fbb.CreateVector<int8_t>(*metadata_header) : 0;
  auto session_token__ = session_token ? _fbb.CreateVector<int8_t>(*session_token) : 0;
  return io::deephaven::barrage::flatbuf::CreateSessionInfoResponse(
      _fbb,
      metadata_header__,
      session_token__,
      token_refresh_deadline_ms);
}

struct BarrageSubscriptionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrageSubscriptionOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMN_CONVERSION_MODE = 4,
    VT_USE_DEEPHAVEN_NULLS = 6,
    VT_MIN_UPDATE_INTERVAL_MS = 8,
    VT_BATCH_SIZE = 10,
    VT_MAX_MESSAGE_SIZE = 12,
    VT_COLUMNS_AS_LIST = 14
  };
  /// see enum for details
  io::deephaven::barrage::flatbuf::ColumnConversionMode column_conversion_mode() const {
    return static_cast<io::deephaven::barrage::flatbuf::ColumnConversionMode>(GetField<int8_t>(VT_COLUMN_CONVERSION_MODE, 1));
  }
  /// Deephaven reserves a value in the range of primitives as a custom NULL value. This enables more efficient transmission
  /// by eliminating the additional complexity of the validity buffer.
  bool use_deephaven_nulls() const {
    return GetField<uint8_t>(VT_USE_DEEPHAVEN_NULLS, 0) != 0;
  }
  /// Explicitly set the Update interval for this subscription. Note that subscriptions with different update intervals
  /// cannot share intermediary state with other subscriptions and greatly increases the footprint of the non-conforming subscription.
  ///
  /// Note: if not supplied (default of zero) then the server uses a consistent value to be efficient and fair to all clients
  int32_t min_update_interval_ms() const {
    return GetField<int32_t>(VT_MIN_UPDATE_INTERVAL_MS, 0);
  }
  /// Specify a preferred batch size. Server is allowed to be configured to restrict possible values. Too small of a
  /// batch size may be dominated with header costs as each batch is wrapped into a separate RecordBatch. Too large of
  /// a payload and it may not fit within the maximum payload size. A good default might be 4096.
  ///
  /// a batch_size of -1 indicates that the server should avoid batching a single logical message
  int32_t batch_size() const {
    return GetField<int32_t>(VT_BATCH_SIZE, 0);
  }
  /// Specify a maximum allowed message size. Server will enforce this limit by reducing batch size (to a lower limit
  /// of one row per batch). If the message size limit cannot be met due to large row sizes, the server will throw a
  /// `Status.RESOURCE_EXHAUSTED` exception
  int32_t max_message_size() const {
    return GetField<int32_t>(VT_MAX_MESSAGE_SIZE, 0);
  }
  /// If true, the server will wrap columns with a list. This is useful for clients that do not support modified batches
  /// with columns of differing lengths.
  bool columns_as_list() const {
    return GetField<uint8_t>(VT_COLUMNS_AS_LIST, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COLUMN_CONVERSION_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_USE_DEEPHAVEN_NULLS, 1) &&
           VerifyField<int32_t>(verifier, VT_MIN_UPDATE_INTERVAL_MS, 4) &&
           VerifyField<int32_t>(verifier, VT_BATCH_SIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_MAX_MESSAGE_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_COLUMNS_AS_LIST, 1) &&
           verifier.EndTable();
  }
};

struct BarrageSubscriptionOptionsBuilder {
  typedef BarrageSubscriptionOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_column_conversion_mode(io::deephaven::barrage::flatbuf::ColumnConversionMode column_conversion_mode) {
    fbb_.AddElement<int8_t>(BarrageSubscriptionOptions::VT_COLUMN_CONVERSION_MODE, static_cast<int8_t>(column_conversion_mode), 1);
  }
  void add_use_deephaven_nulls(bool use_deephaven_nulls) {
    fbb_.AddElement<uint8_t>(BarrageSubscriptionOptions::VT_USE_DEEPHAVEN_NULLS, static_cast<uint8_t>(use_deephaven_nulls), 0);
  }
  void add_min_update_interval_ms(int32_t min_update_interval_ms) {
    fbb_.AddElement<int32_t>(BarrageSubscriptionOptions::VT_MIN_UPDATE_INTERVAL_MS, min_update_interval_ms, 0);
  }
  void add_batch_size(int32_t batch_size) {
    fbb_.AddElement<int32_t>(BarrageSubscriptionOptions::VT_BATCH_SIZE, batch_size, 0);
  }
  void add_max_message_size(int32_t max_message_size) {
    fbb_.AddElement<int32_t>(BarrageSubscriptionOptions::VT_MAX_MESSAGE_SIZE, max_message_size, 0);
  }
  void add_columns_as_list(bool columns_as_list) {
    fbb_.AddElement<uint8_t>(BarrageSubscriptionOptions::VT_COLUMNS_AS_LIST, static_cast<uint8_t>(columns_as_list), 0);
  }
  explicit BarrageSubscriptionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarrageSubscriptionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrageSubscriptionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrageSubscriptionOptions> CreateBarrageSubscriptionOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    io::deephaven::barrage::flatbuf::ColumnConversionMode column_conversion_mode = io::deephaven::barrage::flatbuf::ColumnConversionMode_Stringify,
    bool use_deephaven_nulls = false,
    int32_t min_update_interval_ms = 0,
    int32_t batch_size = 0,
    int32_t max_message_size = 0,
    bool columns_as_list = false) {
  BarrageSubscriptionOptionsBuilder builder_(_fbb);
  builder_.add_max_message_size(max_message_size);
  builder_.add_batch_size(batch_size);
  builder_.add_min_update_interval_ms(min_update_interval_ms);
  builder_.add_columns_as_list(columns_as_list);
  builder_.add_use_deephaven_nulls(use_deephaven_nulls);
  builder_.add_column_conversion_mode(column_conversion_mode);
  return builder_.Finish();
}

/// Describes the subscription the client would like to acquire.
struct BarrageSubscriptionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrageSubscriptionRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICKET = 4,
    VT_COLUMNS = 6,
    VT_VIEWPORT = 8,
    VT_SUBSCRIPTION_OPTIONS = 10,
    VT_REVERSE_VIEWPORT = 12
  };
  /// Ticket for the source data set.
  const flatbuffers::Vector<int8_t> *ticket() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_TICKET);
  }
  /// The bitset of columns to Subscribe. If not provided then all columns are subscribed.
  const flatbuffers::Vector<int8_t> *columns() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_COLUMNS);
  }
  /// This is an encoded and compressed RowSet in position-space to Subscribe to. If not provided then the entire
  /// table is requested.
  const flatbuffers::Vector<int8_t> *viewport() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VIEWPORT);
  }
  /// Options to configure your subscription.
  const io::deephaven::barrage::flatbuf::BarrageSubscriptionOptions *subscription_options() const {
    return GetPointer<const io::deephaven::barrage::flatbuf::BarrageSubscriptionOptions *>(VT_SUBSCRIPTION_OPTIONS);
  }
  /// When this is set the viewport RowSet will be inverted against the length of the table. That is to say
  /// every position value is converted from `i` to `n - i - 1` if the table has `n` rows.
  bool reverse_viewport() const {
    return GetField<uint8_t>(VT_REVERSE_VIEWPORT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TICKET) &&
           verifier.VerifyVector(ticket()) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           VerifyOffset(verifier, VT_VIEWPORT) &&
           verifier.VerifyVector(viewport()) &&
           VerifyOffset(verifier, VT_SUBSCRIPTION_OPTIONS) &&
           verifier.VerifyTable(subscription_options()) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE_VIEWPORT, 1) &&
           verifier.EndTable();
  }
};

struct BarrageSubscriptionRequestBuilder {
  typedef BarrageSubscriptionRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ticket(flatbuffers::Offset<flatbuffers::Vector<int8_t>> ticket) {
    fbb_.AddOffset(BarrageSubscriptionRequest::VT_TICKET, ticket);
  }
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<int8_t>> columns) {
    fbb_.AddOffset(BarrageSubscriptionRequest::VT_COLUMNS, columns);
  }
  void add_viewport(flatbuffers::Offset<flatbuffers::Vector<int8_t>> viewport) {
    fbb_.AddOffset(BarrageSubscriptionRequest::VT_VIEWPORT, viewport);
  }
  void add_subscription_options(flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageSubscriptionOptions> subscription_options) {
    fbb_.AddOffset(BarrageSubscriptionRequest::VT_SUBSCRIPTION_OPTIONS, subscription_options);
  }
  void add_reverse_viewport(bool reverse_viewport) {
    fbb_.AddElement<uint8_t>(BarrageSubscriptionRequest::VT_REVERSE_VIEWPORT, static_cast<uint8_t>(reverse_viewport), 0);
  }
  explicit BarrageSubscriptionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarrageSubscriptionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrageSubscriptionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrageSubscriptionRequest> CreateBarrageSubscriptionRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> ticket = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> columns = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> viewport = 0,
    flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageSubscriptionOptions> subscription_options = 0,
    bool reverse_viewport = false) {
  BarrageSubscriptionRequestBuilder builder_(_fbb);
  builder_.add_subscription_options(subscription_options);
  builder_.add_viewport(viewport);
  builder_.add_columns(columns);
  builder_.add_ticket(ticket);
  builder_.add_reverse_viewport(reverse_viewport);
  return builder_.Finish();
}

inline flatbuffers::Offset<BarrageSubscriptionRequest> CreateBarrageSubscriptionRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *ticket = nullptr,
    const std::vector<int8_t> *columns = nullptr,
    const std::vector<int8_t> *viewport = nullptr,
    flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageSubscriptionOptions> subscription_options = 0,
    bool reverse_viewport = false) {
  auto ticket__ = ticket ? _fbb.CreateVector<int8_t>(*ticket) : 0;
  auto columns__ = columns ? _fbb.CreateVector<int8_t>(*columns) : 0;
  auto viewport__ = viewport ? _fbb.CreateVector<int8_t>(*viewport) : 0;
  return io::deephaven::barrage::flatbuf::CreateBarrageSubscriptionRequest(
      _fbb,
      ticket__,
      columns__,
      viewport__,
      subscription_options,
      reverse_viewport);
}

struct BarrageSnapshotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrageSnapshotOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLUMN_CONVERSION_MODE = 4,
    VT_USE_DEEPHAVEN_NULLS = 6,
    VT_BATCH_SIZE = 8,
    VT_MAX_MESSAGE_SIZE = 10
  };
  /// see enum for details
  io::deephaven::barrage::flatbuf::ColumnConversionMode column_conversion_mode() const {
    return static_cast<io::deephaven::barrage::flatbuf::ColumnConversionMode>(GetField<int8_t>(VT_COLUMN_CONVERSION_MODE, 1));
  }
  /// Deephaven reserves a value in the range of primitives as a custom NULL value. This enables more efficient transmission
  /// by eliminating the additional complexity of the validity buffer.
  bool use_deephaven_nulls() const {
    return GetField<uint8_t>(VT_USE_DEEPHAVEN_NULLS, 0) != 0;
  }
  /// Specify a preferred batch size. Server is allowed to be configured to restrict possible values. Too small of a
  /// batch size may be dominated with header costs as each batch is wrapped into a separate RecordBatch. Too large of
  /// a payload and it may not fit within the maximum payload size. A good default might be 4096.
  int32_t batch_size() const {
    return GetField<int32_t>(VT_BATCH_SIZE, 0);
  }
  /// Specify a maximum allowed message size. Server will enforce this limit by reducing batch size (to a lower limit
  /// of one row per batch). If the message size limit cannot be met due to large row sizes, the server will throw a
  /// `Status.RESOURCE_EXHAUSTED` exception
  int32_t max_message_size() const {
    return GetField<int32_t>(VT_MAX_MESSAGE_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COLUMN_CONVERSION_MODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_USE_DEEPHAVEN_NULLS, 1) &&
           VerifyField<int32_t>(verifier, VT_BATCH_SIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_MAX_MESSAGE_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct BarrageSnapshotOptionsBuilder {
  typedef BarrageSnapshotOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_column_conversion_mode(io::deephaven::barrage::flatbuf::ColumnConversionMode column_conversion_mode) {
    fbb_.AddElement<int8_t>(BarrageSnapshotOptions::VT_COLUMN_CONVERSION_MODE, static_cast<int8_t>(column_conversion_mode), 1);
  }
  void add_use_deephaven_nulls(bool use_deephaven_nulls) {
    fbb_.AddElement<uint8_t>(BarrageSnapshotOptions::VT_USE_DEEPHAVEN_NULLS, static_cast<uint8_t>(use_deephaven_nulls), 0);
  }
  void add_batch_size(int32_t batch_size) {
    fbb_.AddElement<int32_t>(BarrageSnapshotOptions::VT_BATCH_SIZE, batch_size, 0);
  }
  void add_max_message_size(int32_t max_message_size) {
    fbb_.AddElement<int32_t>(BarrageSnapshotOptions::VT_MAX_MESSAGE_SIZE, max_message_size, 0);
  }
  explicit BarrageSnapshotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarrageSnapshotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrageSnapshotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrageSnapshotOptions> CreateBarrageSnapshotOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    io::deephaven::barrage::flatbuf::ColumnConversionMode column_conversion_mode = io::deephaven::barrage::flatbuf::ColumnConversionMode_Stringify,
    bool use_deephaven_nulls = false,
    int32_t batch_size = 0,
    int32_t max_message_size = 0) {
  BarrageSnapshotOptionsBuilder builder_(_fbb);
  builder_.add_max_message_size(max_message_size);
  builder_.add_batch_size(batch_size);
  builder_.add_use_deephaven_nulls(use_deephaven_nulls);
  builder_.add_column_conversion_mode(column_conversion_mode);
  return builder_.Finish();
}

/// Describes the snapshot the client would like to acquire.
struct BarrageSnapshotRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrageSnapshotRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICKET = 4,
    VT_COLUMNS = 6,
    VT_VIEWPORT = 8,
    VT_SNAPSHOT_OPTIONS = 10,
    VT_REVERSE_VIEWPORT = 12
  };
  /// Ticket for the source data set.
  const flatbuffers::Vector<int8_t> *ticket() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_TICKET);
  }
  /// The bitset of columns to request. If not provided then all columns are requested.
  const flatbuffers::Vector<int8_t> *columns() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_COLUMNS);
  }
  /// This is an encoded and compressed RowSet in position-space to Subscribe to. If not provided then the entire
  /// table is requested.
  const flatbuffers::Vector<int8_t> *viewport() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_VIEWPORT);
  }
  /// Options to configure your subscription.
  const io::deephaven::barrage::flatbuf::BarrageSnapshotOptions *snapshot_options() const {
    return GetPointer<const io::deephaven::barrage::flatbuf::BarrageSnapshotOptions *>(VT_SNAPSHOT_OPTIONS);
  }
  /// When this is set the viewport RowSet will be inverted against the length of the table. That is to say
  /// every position value is converted from `i` to `n - i - 1` if the table has `n` rows.
  bool reverse_viewport() const {
    return GetField<uint8_t>(VT_REVERSE_VIEWPORT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TICKET) &&
           verifier.VerifyVector(ticket()) &&
           VerifyOffset(verifier, VT_COLUMNS) &&
           verifier.VerifyVector(columns()) &&
           VerifyOffset(verifier, VT_VIEWPORT) &&
           verifier.VerifyVector(viewport()) &&
           VerifyOffset(verifier, VT_SNAPSHOT_OPTIONS) &&
           verifier.VerifyTable(snapshot_options()) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE_VIEWPORT, 1) &&
           verifier.EndTable();
  }
};

struct BarrageSnapshotRequestBuilder {
  typedef BarrageSnapshotRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ticket(flatbuffers::Offset<flatbuffers::Vector<int8_t>> ticket) {
    fbb_.AddOffset(BarrageSnapshotRequest::VT_TICKET, ticket);
  }
  void add_columns(flatbuffers::Offset<flatbuffers::Vector<int8_t>> columns) {
    fbb_.AddOffset(BarrageSnapshotRequest::VT_COLUMNS, columns);
  }
  void add_viewport(flatbuffers::Offset<flatbuffers::Vector<int8_t>> viewport) {
    fbb_.AddOffset(BarrageSnapshotRequest::VT_VIEWPORT, viewport);
  }
  void add_snapshot_options(flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageSnapshotOptions> snapshot_options) {
    fbb_.AddOffset(BarrageSnapshotRequest::VT_SNAPSHOT_OPTIONS, snapshot_options);
  }
  void add_reverse_viewport(bool reverse_viewport) {
    fbb_.AddElement<uint8_t>(BarrageSnapshotRequest::VT_REVERSE_VIEWPORT, static_cast<uint8_t>(reverse_viewport), 0);
  }
  explicit BarrageSnapshotRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarrageSnapshotRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrageSnapshotRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrageSnapshotRequest> CreateBarrageSnapshotRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> ticket = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> columns = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> viewport = 0,
    flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageSnapshotOptions> snapshot_options = 0,
    bool reverse_viewport = false) {
  BarrageSnapshotRequestBuilder builder_(_fbb);
  builder_.add_snapshot_options(snapshot_options);
  builder_.add_viewport(viewport);
  builder_.add_columns(columns);
  builder_.add_ticket(ticket);
  builder_.add_reverse_viewport(reverse_viewport);
  return builder_.Finish();
}

inline flatbuffers::Offset<BarrageSnapshotRequest> CreateBarrageSnapshotRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *ticket = nullptr,
    const std::vector<int8_t> *columns = nullptr,
    const std::vector<int8_t> *viewport = nullptr,
    flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageSnapshotOptions> snapshot_options = 0,
    bool reverse_viewport = false) {
  auto ticket__ = ticket ? _fbb.CreateVector<int8_t>(*ticket) : 0;
  auto columns__ = columns ? _fbb.CreateVector<int8_t>(*columns) : 0;
  auto viewport__ = viewport ? _fbb.CreateVector<int8_t>(*viewport) : 0;
  return io::deephaven::barrage::flatbuf::CreateBarrageSnapshotRequest(
      _fbb,
      ticket__,
      columns__,
      viewport__,
      snapshot_options,
      reverse_viewport);
}

struct BarragePublicationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarragePublicationOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USE_DEEPHAVEN_NULLS = 4
  };
  /// Deephaven reserves a value in the range of primitives as a custom NULL value. This enables more efficient transmission
  /// by eliminating the additional complexity of the validity buffer.
  bool use_deephaven_nulls() const {
    return GetField<uint8_t>(VT_USE_DEEPHAVEN_NULLS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USE_DEEPHAVEN_NULLS, 1) &&
           verifier.EndTable();
  }
};

struct BarragePublicationOptionsBuilder {
  typedef BarragePublicationOptions Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_use_deephaven_nulls(bool use_deephaven_nulls) {
    fbb_.AddElement<uint8_t>(BarragePublicationOptions::VT_USE_DEEPHAVEN_NULLS, static_cast<uint8_t>(use_deephaven_nulls), 0);
  }
  explicit BarragePublicationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarragePublicationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarragePublicationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarragePublicationOptions> CreateBarragePublicationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool use_deephaven_nulls = false) {
  BarragePublicationOptionsBuilder builder_(_fbb);
  builder_.add_use_deephaven_nulls(use_deephaven_nulls);
  return builder_.Finish();
}

/// Describes the table Update stream the client would like to push to. This is similar to a DoPut but the client
/// will send BarrageUpdateMetadata to explicitly describe the row key space. The updates sent adhere to the table
/// Update model semantics; thus BarragePublication enables the client to upload a ticking table.
struct BarragePublicationRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarragePublicationRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TICKET = 4,
    VT_PUBLISH_OPTIONS = 6
  };
  /// The destination Ticket.
  const flatbuffers::Vector<int8_t> *ticket() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_TICKET);
  }
  /// Options to configure your request.
  const io::deephaven::barrage::flatbuf::BarragePublicationOptions *publish_options() const {
    return GetPointer<const io::deephaven::barrage::flatbuf::BarragePublicationOptions *>(VT_PUBLISH_OPTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TICKET) &&
           verifier.VerifyVector(ticket()) &&
           VerifyOffset(verifier, VT_PUBLISH_OPTIONS) &&
           verifier.VerifyTable(publish_options()) &&
           verifier.EndTable();
  }
};

struct BarragePublicationRequestBuilder {
  typedef BarragePublicationRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ticket(flatbuffers::Offset<flatbuffers::Vector<int8_t>> ticket) {
    fbb_.AddOffset(BarragePublicationRequest::VT_TICKET, ticket);
  }
  void add_publish_options(flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarragePublicationOptions> publish_options) {
    fbb_.AddOffset(BarragePublicationRequest::VT_PUBLISH_OPTIONS, publish_options);
  }
  explicit BarragePublicationRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarragePublicationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarragePublicationRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarragePublicationRequest> CreateBarragePublicationRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> ticket = 0,
    flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarragePublicationOptions> publish_options = 0) {
  BarragePublicationRequestBuilder builder_(_fbb);
  builder_.add_publish_options(publish_options);
  builder_.add_ticket(ticket);
  return builder_.Finish();
}

inline flatbuffers::Offset<BarragePublicationRequest> CreateBarragePublicationRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *ticket = nullptr,
    flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarragePublicationOptions> publish_options = 0) {
  auto ticket__ = ticket ? _fbb.CreateVector<int8_t>(*ticket) : 0;
  return io::deephaven::barrage::flatbuf::CreateBarragePublicationRequest(
      _fbb,
      ticket__,
      publish_options);
}

/// Holds all of the rowset data structures for the column being modified.
struct BarrageModColumnMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrageModColumnMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODIFIED_ROWS = 4
  };
  /// This is an encoded and compressed RowSet for this column (within the viewport) that were modified.
  /// There is no notification for modifications outside of the viewport.
  const flatbuffers::Vector<int8_t> *modified_rows() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_MODIFIED_ROWS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODIFIED_ROWS) &&
           verifier.VerifyVector(modified_rows()) &&
           verifier.EndTable();
  }
};

struct BarrageModColumnMetadataBuilder {
  typedef BarrageModColumnMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modified_rows(flatbuffers::Offset<flatbuffers::Vector<int8_t>> modified_rows) {
    fbb_.AddOffset(BarrageModColumnMetadata::VT_MODIFIED_ROWS, modified_rows);
  }
  explicit BarrageModColumnMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarrageModColumnMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrageModColumnMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrageModColumnMetadata> CreateBarrageModColumnMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> modified_rows = 0) {
  BarrageModColumnMetadataBuilder builder_(_fbb);
  builder_.add_modified_rows(modified_rows);
  return builder_.Finish();
}

inline flatbuffers::Offset<BarrageModColumnMetadata> CreateBarrageModColumnMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *modified_rows = nullptr) {
  auto modified_rows__ = modified_rows ? _fbb.CreateVector<int8_t>(*modified_rows) : 0;
  return io::deephaven::barrage::flatbuf::CreateBarrageModColumnMetadata(
      _fbb,
      modified_rows__);
}

/// A data header describing the shared memory layout of a "record" or "row"
/// batch for a ticking barrage table.
struct BarrageUpdateMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BarrageUpdateMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIRST_SEQ = 4,
    VT_LAST_SEQ = 6,
    VT_IS_SNAPSHOT = 8,
    VT_EFFECTIVE_VIEWPORT = 10,
    VT_EFFECTIVE_REVERSE_VIEWPORT = 12,
    VT_EFFECTIVE_COLUMN_SET = 14,
    VT_ADDED_ROWS = 16,
    VT_REMOVED_ROWS = 18,
    VT_SHIFT_DATA = 20,
    VT_ADDED_ROWS_INCLUDED = 22,
    VT_MOD_COLUMN_NODES = 24
  };
  /// This batch is generated from an upstream table that ticks independently of the stream. If
  /// multiple events are coalesced into one Update, the server may communicate that here for
  /// informational purposes.
  int64_t first_seq() const {
    return GetField<int64_t>(VT_FIRST_SEQ, 0);
  }
  int64_t last_seq() const {
    return GetField<int64_t>(VT_LAST_SEQ, 0);
  }
  /// Indicates if this message was sent due to upstream ticks or due to a subscription change.
  bool is_snapshot() const {
    return GetField<uint8_t>(VT_IS_SNAPSHOT, 0) != 0;
  }
  /// If this is a snapshot and the subscription is a viewport, then the effectively subscribed viewport
  /// will be included in the payload. It is an encoded and compressed RowSet.
  const flatbuffers::Vector<int8_t> *effective_viewport() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_EFFECTIVE_VIEWPORT);
  }
  /// When this is set the viewport RowSet will be inverted against the length of the table. That is to say
  /// every position value is converted from `i` to `n - i - 1` if the table has `n` rows.
  bool effective_reverse_viewport() const {
    return GetField<uint8_t>(VT_EFFECTIVE_REVERSE_VIEWPORT, 0) != 0;
  }
  /// If this is a snapshot, then the effectively subscribed column set will be included in the payload.
  const flatbuffers::Vector<int8_t> *effective_column_set() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_EFFECTIVE_COLUMN_SET);
  }
  /// This is an encoded and compressed RowSet that was added in this Update.
  const flatbuffers::Vector<int8_t> *added_rows() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ADDED_ROWS);
  }
  /// This is an encoded and compressed RowSet that was removed in this Update.
  const flatbuffers::Vector<int8_t> *removed_rows() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_REMOVED_ROWS);
  }
  /// This is an encoded and compressed RowSetShiftData describing how the keyspace of unmodified rows changed.
  const flatbuffers::Vector<int8_t> *shift_data() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_SHIFT_DATA);
  }
  /// This is an encoded and compressed RowSet that was included with this Update.
  /// (the server may include rows not in addedRows if this is a viewport subscription to refresh
  ///  unmodified rows that were scoped into View)
  const flatbuffers::Vector<int8_t> *added_rows_included() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_ADDED_ROWS_INCLUDED);
  }
  /// The list of modified column data are in the same order as the field nodes on the schema.
  const flatbuffers::Vector<flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageModColumnMetadata>> *mod_column_nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageModColumnMetadata>> *>(VT_MOD_COLUMN_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_FIRST_SEQ, 8) &&
           VerifyField<int64_t>(verifier, VT_LAST_SEQ, 8) &&
           VerifyField<uint8_t>(verifier, VT_IS_SNAPSHOT, 1) &&
           VerifyOffset(verifier, VT_EFFECTIVE_VIEWPORT) &&
           verifier.VerifyVector(effective_viewport()) &&
           VerifyField<uint8_t>(verifier, VT_EFFECTIVE_REVERSE_VIEWPORT, 1) &&
           VerifyOffset(verifier, VT_EFFECTIVE_COLUMN_SET) &&
           verifier.VerifyVector(effective_column_set()) &&
           VerifyOffset(verifier, VT_ADDED_ROWS) &&
           verifier.VerifyVector(added_rows()) &&
           VerifyOffset(verifier, VT_REMOVED_ROWS) &&
           verifier.VerifyVector(removed_rows()) &&
           VerifyOffset(verifier, VT_SHIFT_DATA) &&
           verifier.VerifyVector(shift_data()) &&
           VerifyOffset(verifier, VT_ADDED_ROWS_INCLUDED) &&
           verifier.VerifyVector(added_rows_included()) &&
           VerifyOffset(verifier, VT_MOD_COLUMN_NODES) &&
           verifier.VerifyVector(mod_column_nodes()) &&
           verifier.VerifyVectorOfTables(mod_column_nodes()) &&
           verifier.EndTable();
  }
};

struct BarrageUpdateMetadataBuilder {
  typedef BarrageUpdateMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_first_seq(int64_t first_seq) {
    fbb_.AddElement<int64_t>(BarrageUpdateMetadata::VT_FIRST_SEQ, first_seq, 0);
  }
  void add_last_seq(int64_t last_seq) {
    fbb_.AddElement<int64_t>(BarrageUpdateMetadata::VT_LAST_SEQ, last_seq, 0);
  }
  void add_is_snapshot(bool is_snapshot) {
    fbb_.AddElement<uint8_t>(BarrageUpdateMetadata::VT_IS_SNAPSHOT, static_cast<uint8_t>(is_snapshot), 0);
  }
  void add_effective_viewport(flatbuffers::Offset<flatbuffers::Vector<int8_t>> effective_viewport) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_EFFECTIVE_VIEWPORT, effective_viewport);
  }
  void add_effective_reverse_viewport(bool effective_reverse_viewport) {
    fbb_.AddElement<uint8_t>(BarrageUpdateMetadata::VT_EFFECTIVE_REVERSE_VIEWPORT, static_cast<uint8_t>(effective_reverse_viewport), 0);
  }
  void add_effective_column_set(flatbuffers::Offset<flatbuffers::Vector<int8_t>> effective_column_set) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_EFFECTIVE_COLUMN_SET, effective_column_set);
  }
  void add_added_rows(flatbuffers::Offset<flatbuffers::Vector<int8_t>> added_rows) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_ADDED_ROWS, added_rows);
  }
  void add_removed_rows(flatbuffers::Offset<flatbuffers::Vector<int8_t>> removed_rows) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_REMOVED_ROWS, removed_rows);
  }
  void add_shift_data(flatbuffers::Offset<flatbuffers::Vector<int8_t>> shift_data) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_SHIFT_DATA, shift_data);
  }
  void add_added_rows_included(flatbuffers::Offset<flatbuffers::Vector<int8_t>> added_rows_included) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_ADDED_ROWS_INCLUDED, added_rows_included);
  }
  void add_mod_column_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageModColumnMetadata>>> mod_column_nodes) {
    fbb_.AddOffset(BarrageUpdateMetadata::VT_MOD_COLUMN_NODES, mod_column_nodes);
  }
  explicit BarrageUpdateMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BarrageUpdateMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BarrageUpdateMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<BarrageUpdateMetadata> CreateBarrageUpdateMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t first_seq = 0,
    int64_t last_seq = 0,
    bool is_snapshot = false,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> effective_viewport = 0,
    bool effective_reverse_viewport = false,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> effective_column_set = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> added_rows = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> removed_rows = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> shift_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> added_rows_included = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageModColumnMetadata>>> mod_column_nodes = 0) {
  BarrageUpdateMetadataBuilder builder_(_fbb);
  builder_.add_last_seq(last_seq);
  builder_.add_first_seq(first_seq);
  builder_.add_mod_column_nodes(mod_column_nodes);
  builder_.add_added_rows_included(added_rows_included);
  builder_.add_shift_data(shift_data);
  builder_.add_removed_rows(removed_rows);
  builder_.add_added_rows(added_rows);
  builder_.add_effective_column_set(effective_column_set);
  builder_.add_effective_viewport(effective_viewport);
  builder_.add_effective_reverse_viewport(effective_reverse_viewport);
  builder_.add_is_snapshot(is_snapshot);
  return builder_.Finish();
}

inline flatbuffers::Offset<BarrageUpdateMetadata> CreateBarrageUpdateMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t first_seq = 0,
    int64_t last_seq = 0,
    bool is_snapshot = false,
    const std::vector<int8_t> *effective_viewport = nullptr,
    bool effective_reverse_viewport = false,
    const std::vector<int8_t> *effective_column_set = nullptr,
    const std::vector<int8_t> *added_rows = nullptr,
    const std::vector<int8_t> *removed_rows = nullptr,
    const std::vector<int8_t> *shift_data = nullptr,
    const std::vector<int8_t> *added_rows_included = nullptr,
    const std::vector<flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageModColumnMetadata>> *mod_column_nodes = nullptr) {
  auto effective_viewport__ = effective_viewport ? _fbb.CreateVector<int8_t>(*effective_viewport) : 0;
  auto effective_column_set__ = effective_column_set ? _fbb.CreateVector<int8_t>(*effective_column_set) : 0;
  auto added_rows__ = added_rows ? _fbb.CreateVector<int8_t>(*added_rows) : 0;
  auto removed_rows__ = removed_rows ? _fbb.CreateVector<int8_t>(*removed_rows) : 0;
  auto shift_data__ = shift_data ? _fbb.CreateVector<int8_t>(*shift_data) : 0;
  auto added_rows_included__ = added_rows_included ? _fbb.CreateVector<int8_t>(*added_rows_included) : 0;
  auto mod_column_nodes__ = mod_column_nodes ? _fbb.CreateVector<flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageModColumnMetadata>>(*mod_column_nodes) : 0;
  return io::deephaven::barrage::flatbuf::CreateBarrageUpdateMetadata(
      _fbb,
      first_seq,
      last_seq,
      is_snapshot,
      effective_viewport__,
      effective_reverse_viewport,
      effective_column_set__,
      added_rows__,
      removed_rows__,
      shift_data__,
      added_rows_included__,
      mod_column_nodes__);
}

inline const io::deephaven::barrage::flatbuf::BarrageMessageWrapper *GetBarrageMessageWrapper(const void *buf) {
  return flatbuffers::GetRoot<io::deephaven::barrage::flatbuf::BarrageMessageWrapper>(buf);
}

inline const io::deephaven::barrage::flatbuf::BarrageMessageWrapper *GetSizePrefixedBarrageMessageWrapper(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<io::deephaven::barrage::flatbuf::BarrageMessageWrapper>(buf);
}

inline bool VerifyBarrageMessageWrapperBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<io::deephaven::barrage::flatbuf::BarrageMessageWrapper>(nullptr);
}

inline bool VerifySizePrefixedBarrageMessageWrapperBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<io::deephaven::barrage::flatbuf::BarrageMessageWrapper>(nullptr);
}

inline void FinishBarrageMessageWrapperBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageMessageWrapper> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedBarrageMessageWrapperBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<io::deephaven::barrage::flatbuf::BarrageMessageWrapper> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace flatbuf
}  // namespace barrage
}  // namespace deephaven
}  // namespace io

#endif  // FLATBUFFERS_GENERATED_BARRAGE_IO_DEEPHAVEN_BARRAGE_FLATBUF_H_
